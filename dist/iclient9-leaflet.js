/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(10);
	__webpack_require__(14);
	__webpack_require__(29);
	__webpack_require__(33);
	__webpack_require__(35);
	__webpack_require__(37);
	__webpack_require__(39);
	__webpack_require__(45);
	__webpack_require__(48);
	__webpack_require__(51);
	__webpack_require__(65);
	__webpack_require__(67);
	__webpack_require__(70);
	__webpack_require__(73);
	__webpack_require__(110);
	__webpack_require__(137);
	__webpack_require__(149);
	__webpack_require__(193);
	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(203);
	module.exports = __webpack_require__(204);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: TiledMapLayer
	 * SuperMap iServer 的 REST 地图服务的图层(SuperMap iServer Java 6R 及以上分块动态 REST 图层)
	 * 用法：
	 *      L.superMap.tiledMapLayer(url,{CRS:L.CRS.EPSG4326}).addTo(map);
	 */
	__webpack_require__(2);
	__webpack_require__(4);

	TiledMapLayer = L.TileLayer.extend({

	    options: {
	        url: null,
	        token: null,
	        transparent: null,
	        cacheEnabled: null,
	        layersID: null, //如果有layersID，则是在使用专题图
	        crs: null,
	        attribution: ' with <a href="http://icltest.supermapol.com/">SuperMap iClient</a>'
	    },

	    initialize: function (url, options) {
	        this.options.url = url;
	        L.setOptions(this, options);
	        this._initParams();
	        L.stamp(this);
	    },

	    onAdd: function (map) {
	        this._crs = this.options.crs || map.options.crs;
	        L.TileLayer.prototype.onAdd.call(this, map);
	    },

	    getTileUrl: function (coords) {
	        var x = coords.x, y = coords.y, zoom = coords.z;
	        //使用ViewBounds出图
	        var tileBounds = this._tileCoordsToBounds(coords),
	            nw = this._crs.project(tileBounds.getNorthWest()),
	            se = this._crs.project(tileBounds.getSouthEast());
	        var tileUrl = this._layerUrl + "&viewBounds=" + "{\"leftBottom\" : {\"x\":" + nw.x + ",\"y\":" + se.y + "},\"rightTop\" : {\"x\":" + se.x + ",\"y\":" + nw.y + "}}";

	        var crs = this._crs, scale = crs.scale(zoom);
	        tileUrl += "&scale=" + scale;
	        return tileUrl;
	    },

	    _initParams: function () {
	        var options = this.options;
	        if (!options.url) {
	            return;
	        }
	        this._layerUrl = this._initLayerUrl(options);
	    },

	    _initLayerUrl: function (options) {

	        var layerUrl = options.url + "/image.png?redirect=false";

	        //为url添加安全认证信息片段
	        if (options.token) {
	            layerUrl += "&token=" + options.token;
	        }

	        if (options.layersID) {
	            layerUrl += "&layersID=" + options.layersID;
	        }

	        var transparent = (options.transparent) ? options.transparent : false;
	        layerUrl += "&transparent=" + transparent;

	        var cacheEnabled = (options.cacheEnabled) ? options.cacheEnabled : true;
	        layerUrl += "&cacheEnabled=" + cacheEnabled;

	        var tileSize = this.options.tileSize;
	        layerUrl += "&width=" + tileSize + "&height=" + tileSize;

	        return layerUrl;
	    }
	});

	L.supermap.tiledMapLayer = function (url, options) {
	    return new TiledMapLayer(url, options);
	};

	module.exports = L.supermap.tiledMapLayer;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *SuperMapLeaflet基础模块
	 * 1、定义命名空间
	 * 2、提供必要的转换工具
	 */
	L.supermap = L.supermap || {};
	__webpack_require__(3);
	__webpack_require__(9);

	L.Util.toGeoJSON = function (feature) {
	    if (!feature) {
	        return feature;
	    }
	    var result, format = new SuperMap.Format.GeoJSON();
	    if (feature.geometry) {
	        result = JSON.parse(format.write(feature.geometry));
	    } else {
	        result = JSON.parse(format.write(feature));
	    }
	    return result;
	};

	L.Util.toSuperMapGeometry = function (geometry) {
	    if (!geometry) {
	        return geometry;
	    }
	    var result, format = new SuperMap.Format.GeoJSON();
	    if (["FeatureCollection", "Feature", "Geometry"].indexOf(geometry.type) != -1) {
	        result = format.read(geometry, geometry.type);
	    } else if (typeof geometry.toGeoJSON === "function") {
	        var geojson = geometry.toGeoJSON();
	        result = (geojson) ? format.read(geojson, geojson.type) : geometry;
	    }

	    var serverResult = result;
	    if (L.Util.isArray(result)) {
	        if (result.length === 1) {
	            serverResult = result[0];
	        } else if (result.length > 1) {
	            serverResult = [];
	            result.map(function (item) {
	                serverResult.push(item.geometry);
	            });
	        }
	    }

	    return (serverResult && serverResult.geometry) ? serverResult.geometry : serverResult;

	};

	L.Util.Csv2GeoJSON = function (csv, options) {
	    var defaultOptions = {
	        titles: ['lon', 'lat'],
	        latitudeTitle: 'lat',
	        longitudeTitle: 'lon',
	        fieldSeparator: ',',
	        lineSeparator: '\n',
	        deleteDoubleQuotes: true,
	        firstLineTitles: false
	    };
	    options = options || defaultOptions;
	    var _propertiesNames = []
	    if (typeof csv === 'string') {
	        var titulos = options.titles;
	        if (options.firstLineTitles) {
	            csv = csv.split(options.lineSeparator);
	            if (csv.length < 2) return;
	            titulos = csv[0];
	            csv.splice(0, 1);
	            csv = csv.join(options.lineSeparator);
	            titulos = titulos.trim().split(options.fieldSeparator);
	            for (var i = 0; i < titulos.length; i++) {
	                titulos[i] = _deleteDoubleQuotes(titulos[i]);
	            }
	            options.titles = titulos;
	        }
	        for (var i = 0; i < titulos.length; i++) {
	            var prop = titulos[i].toLowerCase().replace(/[^\w ]+/g, '').replace(/ +/g, '_');
	            if (prop == '' || prop == '_') prop = 'prop-' + i;
	            _propertiesNames[i] = prop;
	        }
	        csv = _csv2json(csv);
	    }
	    return csv;

	    function _deleteDoubleQuotes(cadena) {
	        if (options.deleteDoubleQuotes) cadena = cadena.trim().replace(/^"/, "").replace(/"$/, "");
	        return cadena;
	    };

	    function _csv2json(csv) {
	        var json = {};
	        json["type"] = "FeatureCollection";
	        json["features"] = [];
	        var titulos = options.titles;
	        csv = csv.split(options.lineSeparator);
	        for (var num_linea = 0; num_linea < csv.length; num_linea++) {
	            var campos = csv[num_linea].trim().split(options.fieldSeparator)
	                , lng = parseFloat(campos[titulos.indexOf(options.longitudeTitle)])
	                , lat = parseFloat(campos[titulos.indexOf(options.latitudeTitle)]);
	            if (campos.length == titulos.length && lng < 180 && lng > -180 && lat < 90 && lat > -90) {
	                var feature = {};
	                feature["type"] = "Feature";
	                feature["geometry"] = {};
	                feature["properties"] = {};
	                feature["geometry"]["type"] = "Point";
	                feature["geometry"]["coordinates"] = [lng, lat];
	                for (var i = 0; i < titulos.length; i++) {
	                    if (titulos[i] != options.latitudeTitle && titulos[i] != options.longitudeTitle) {
	                        feature["properties"][_propertiesNames[i]] = _deleteDoubleQuotes(campos[i]);
	                    }
	                }
	                json["features"].push(feature);
	            }
	        }
	        return json;
	    };
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.Format.GeoJSON
	 * GeoJSON 的读和写。使用 <SuperMap.Format.GeoJSON> 构造器创建一个GeoJSON解析器.
	 *
	 * Inherits from:
	 *  - <SuperMap.Format.JSON>
	 */
	__webpack_require__(4);
	__webpack_require__(7);

	SuperMap.Format.GeoJSON = SuperMap.Class(SuperMap.Format.JSON, {

	    /**
	     * APIProperty: ignoreExtraDims
	     * {Boolean} 忽略维度超过2的几何要素
	     */
	    ignoreExtraDims: false,


	    /**
	     * APIMethod: read
	     * 反序列化一个 GeoJSON 字符串.
	     *
	     * Parameters:
	     * json - {String}  GeoJSON 字符串
	     * type - {String} 可选的字符串，它决定了输出的格式。
	     *     支持的值有："Geometry","Feature",和"FeatureCollection",
	     *     如果此值为null，则会使用默认值"FeaureCollection"。
	     * filter - {Function} 对象中每个层次每个键值对都会调用此函数得出一个结果。
	     *     每个值都会被filter函数的结果所替换掉。这个函数可被用来将某些对象转化成
	     *     某个类相应的对象，或者将日期字符串转化成Date对象。
	     *
	     * Returns:
	     * {Object} 返回值依赖于type参数的值。如果type等于"FeatureCollection"（默认值），
	     *     返回值将会是 <SuperMap.Feature.Vector> 数组。如果type为"Geometry",
	     *     输入的json对象必须表示一个唯一的几何体，然后返回值就会是 <SuperMap.Feature.Geometry>
	     *     如果type为"Feature"，输入的json对象也必须表示的一个要素，这样返回值才会是
	     *      <SuperMap.Feature.Vector> 。
	     */
	    read: function (json, type, filter) {
	        type = (type) ? type : "FeatureCollection";
	        var results = null;
	        var obj = null;
	        if (typeof json == "string") {
	            obj = SuperMap.Format.JSON.prototype.read.apply(this,
	                [json, filter]);
	        } else {
	            obj = json;
	        }
	        if (!obj) {
	            //SuperMap.Console.error("Bad JSON: " + json);
	        } else if (typeof(obj.type) != "string") {
	            //SuperMap.Console.error("Bad GeoJSON - no type: " + json);
	        } else if (this.isValidType(obj, type)) {
	            switch (type) {
	                case "Geometry":
	                    try {
	                        results = this.parseGeometry(obj);
	                    } catch (err) {
	                        //SuperMap.Console.error(err);
	                    }
	                    break;
	                case "Feature":
	                    try {
	                        results = this.parseFeature(obj);
	                        results.type = "Feature";
	                    } catch (err) {
	                        //SuperMap.Console.error(err);
	                    }
	                    break;
	                case "FeatureCollection":
	                    // for type FeatureCollection, we allow input to be any type
	                    results = [];
	                    switch (obj.type) {
	                        case "Feature":
	                            try {
	                                results.push(this.parseFeature(obj));
	                            } catch (err) {
	                                results = null;
	                                //SuperMap.Console.error(err);
	                            }
	                            break;
	                        case "FeatureCollection":
	                            for (var i = 0, len = obj.features.length; i < len; ++i) {
	                                try {
	                                    results.push(this.parseFeature(obj.features[i]));
	                                } catch (err) {
	                                    results = null;
	                                    // SuperMap.Console.error(err);
	                                }
	                            }
	                            break;
	                        default:
	                            try {
	                                var geom = this.parseGeometry(obj);
	                                results.push(new SuperMap.Feature.Vector(geom));
	                            } catch (err) {
	                                results = null;
	                                //SuperMap.Console.error(err);
	                            }
	                    }
	                    break;
	            }
	        }
	        return results;
	    },

	    /**
	     * Method: isValidType
	     * 检查一个GeoJSON对象是否和给定的类型相符的合法的对象。
	     *
	     * Returns:
	     * {Boolean} GeoJSON是否是给定类型的合法对象。
	     */
	    isValidType: function (obj, type) {
	        var valid = false;
	        switch (type) {
	            case "Geometry":
	                if (SuperMap.Util.indexOf(
	                        ["Point", "MultiPoint", "LineString", "MultiLineString",
	                            "Polygon", "MultiPolygon", "Box", "GeometryCollection"],
	                        obj.type) == -1) {
	                    // unsupported geometry type
	                    //SuperMap.Console.error("Unsupported geometry type: " +
	                    // obj.type);
	                } else {
	                    valid = true;
	                }
	                break;
	            case "FeatureCollection":
	                // allow for any type to be converted to a feature collection
	                valid = true;
	                break;
	            default:
	                // for Feature types must match
	                if (obj.type == type) {
	                    valid = true;
	                } else {
	                    //SuperMap.Console.error("Cannot convert types from " +
	                    //obj.type + " to " + type);
	                }
	        }
	        return valid;
	    },

	    /**
	     * Method: parseFeature
	     * 将一个GeoJSON中的feature转化成<SuperMap.Feature.Vector>对象。
	     *
	     * Parameters:
	     * obj - {Object} 从GeoJSON对象中创建一个对象。
	     *
	     * Returns:
	     * {<SuperMap.Feature.Vector>} 一个要素。
	     */
	    parseFeature: function (obj) {
	        var feature, geometry, attributes, bbox;
	        attributes = (obj.properties) ? obj.properties : {};
	        bbox = (obj.geometry && obj.geometry.bbox) || obj.bbox;
	        try {
	            geometry = this.parseGeometry(obj.geometry);
	        } catch (err) {
	            // deal with bad geometries
	            throw err;
	        }
	        feature = new SuperMap.Feature.Vector(geometry, attributes);
	        if (bbox) {
	            feature.bounds = SuperMap.Bounds.fromArray(bbox);
	        }
	        if (obj.id) {
	            feature.fid = obj.id;
	        }
	        return feature;
	    },

	    /**
	     * Method: parseGeometry
	     * 将一个GeoJSON中的几何要素转化成<SuperMap.Geometry>对象。
	     *
	     * Parameters:
	     * obj - {Object} 从GeoJSON对象中创建一个对象。
	     *
	     * Returns:
	     * {<SuperMap.Geometry>} 一个几何要素。
	     */
	    parseGeometry: function (obj) {
	        if (obj == null) {
	            return null;
	        }
	        var geometry, collection = false;
	        if (obj.type == "GeometryCollection") {
	            if (!(SuperMap.Util.isArray(obj.geometries))) {
	                throw "GeometryCollection must have geometries array: " + obj;
	            }
	            var numGeom = obj.geometries.length;
	            var components = new Array(numGeom);
	            for (var i = 0; i < numGeom; ++i) {
	                components[i] = this.parseGeometry.apply(
	                    this, [obj.geometries[i]]
	                );
	            }
	            geometry = new SuperMap.Geometry.Collection(components);
	            collection = true;
	        } else {
	            if (!(SuperMap.Util.isArray(obj.coordinates))) {
	                throw "Geometry must have coordinates array: " + obj;
	            }
	            if (!this.parseCoords[obj.type.toLowerCase()]) {
	                throw "Unsupported geometry type: " + obj.type;
	            }
	            try {
	                geometry = this.parseCoords[obj.type.toLowerCase()].apply(
	                    this, [obj.coordinates]
	                );
	            } catch (err) {
	                // deal with bad coordinates
	                throw err;
	            }
	        }
	        // We don't reproject collections because the children are reprojected
	        // for us when they are created.
	        if (this.internalProjection && this.externalProjection && !collection) {
	            geometry.transform(this.externalProjection,
	                this.internalProjection);
	        }
	        return geometry;
	    },

	    /**
	     * Property: parseCoords
	     * 一个属性名对应着GeoJSON对象的几何类型的对象。每个属性其实都是一个实际上做解析用的方法。
	     */
	    parseCoords: {
	        /**
	         * Method: parseCoords.point
	         * 将一组坐标成一个<SuperMap.Geometry>对象。
	         *
	         * Parameters:
	         * array - {Object} GeoJSON片段中的一组坐标。
	         *
	         * Returns:
	         * {<SuperMap.Geometry>} 一个几何对象。
	         */
	        "point": function (array) {
	            if (this.ignoreExtraDims == false &&
	                array.length != 2) {
	                throw "Only 2D points are supported: " + array;
	            }
	            return new SuperMap.Geometry.Point(array[0], array[1]);
	        },

	        /**
	         * Method: parseCoords.multipoint
	         * 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
	         *
	         * Parameters:
	         * array - {Object} GeoJSON片段中的坐标组数组。
	         *
	         * Returns:
	         * {<SuperMap.Geometry>} 一个几何对象。
	         */
	        "multipoint": function (array) {
	            var points = [];
	            var p = null;
	            for (var i = 0, len = array.length; i < len; ++i) {
	                try {
	                    p = this.parseCoords["point"].apply(this, [array[i]]);
	                } catch (err) {
	                    throw err;
	                }
	                points.push(p);
	            }
	            return new SuperMap.Geometry.MultiPoint(points);
	        },

	        /**
	         * Method: parseCoords.linestring
	         * 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
	         *
	         * Parameters:
	         * array - {Object} GeoJSON片段中的坐标组数组。
	         *
	         * Returns:
	         * {<SuperMap.Geometry>} 一个几何对象。
	         */
	        "linestring": function (array) {
	            var points = [];
	            var p = null;
	            for (var i = 0, len = array.length; i < len; ++i) {
	                try {
	                    p = this.parseCoords["point"].apply(this, [array[i]]);
	                } catch (err) {
	                    throw err;
	                }
	                points.push(p);
	            }
	            return new SuperMap.Geometry.LineString(points);
	        },

	        /**
	         * Method: parseCoords.multilinestring
	         * 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
	         *
	         * Parameters:
	         * array - {Object} GeoJSON片段中的坐标组数组。
	         *
	         * Returns:
	         * {<SuperMap.Geometry>} 一个几何对象。
	         */
	        "multilinestring": function (array) {
	            var lines = [];
	            var l = null;
	            for (var i = 0, len = array.length; i < len; ++i) {
	                try {
	                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
	                } catch (err) {
	                    throw err;
	                }
	                lines.push(l);
	            }
	            return new SuperMap.Geometry.MultiLineString(lines);
	        },

	        /**
	         * Method: parseCoords.polygon
	         * 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
	         *
	         * Returns:
	         * {<SuperMap.Geometry>} 一个几何对象。
	         */
	        "polygon": function (array) {
	            var rings = [];
	            var r, l;
	            for (var i = 0, len = array.length; i < len; ++i) {
	                try {
	                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
	                } catch (err) {
	                    throw err;
	                }
	                r = new SuperMap.Geometry.LinearRing(l.components);
	                rings.push(r);
	            }
	            return new SuperMap.Geometry.Polygon(rings);
	        },

	        /**
	         * Method: parseCoords.multipolygon
	         * 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
	         *
	         * Parameters:
	         * array - {Object} GeoJSON片段中的坐标组数组。
	         *
	         * Returns:
	         * {<SuperMap.Geometry>} 一个几何对象。
	         */
	        "multipolygon": function (array) {
	            var polys = [];
	            var p = null;
	            for (var i = 0, len = array.length; i < len; ++i) {
	                try {
	                    p = this.parseCoords["polygon"].apply(this, [array[i]]);
	                } catch (err) {
	                    throw err;
	                }
	                polys.push(p);
	            }
	            return new SuperMap.Geometry.MultiPolygon(polys);
	        },

	        /**
	         * Method: parseCoords.box
	         * 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
	         *
	         * Parameters:
	         * array - {Object} GeoJSON片段中的坐标组数组。
	         *
	         * Returns:
	         * {<SuperMap.Geometry>} 一个几何对象。
	         */
	        "box": function (array) {
	            if (array.length != 2) {
	                throw "GeoJSON box coordinates must have 2 elements";
	            }
	            return new SuperMap.Geometry.Polygon([
	                new SuperMap.Geometry.LinearRing([
	                    new SuperMap.Geometry.Point(array[0][0], array[0][1]),
	                    new SuperMap.Geometry.Point(array[1][0], array[0][1]),
	                    new SuperMap.Geometry.Point(array[1][0], array[1][1]),
	                    new SuperMap.Geometry.Point(array[0][0], array[1][1]),
	                    new SuperMap.Geometry.Point(array[0][0], array[0][1])
	                ])
	            ]);
	        }

	    },

	    /**
	     * APIMethod: write
	     * 序列化一个要素对象，几何对象，要素对象数组为一个GeoJSON字符串。
	     *
	     * Parameters:
	     * obj - {Object} 一个 <SuperMap.Feature.Vector> 对象，一个 <SuperMap.Geometry> 对象，
	     *     或者一个要素对象数组。
	     * pretty - {Boolean} 是否使用换行和缩进来控制输出。默认值为false。
	     *
	     * Returns:
	     * {String} 一个GeoJSON字符串，它表示了输入的几何对象，要素对象，或者要素对象数组。
	     */
	    write: function (obj, pretty) {
	        var geojson = {
	            "type": null
	        };
	        if (SuperMap.Util.isArray(obj)) {
	            geojson.type = "FeatureCollection";
	            var numFeatures = obj.length;
	            geojson.features = new Array(numFeatures);
	            for (var i = 0; i < numFeatures; ++i) {
	                var element = obj[i];
	                if (isGeometry(element)) {
	                    geojson.features[i] = this.extract.geometry.apply(this, [element]);
	                } else {
	                    geojson.features[i] = this.extract.feature.apply(this, [element]);
	                }
	            }
	        } else if (isGeometry(obj)) {
	            geojson = this.extract.geometry.apply(this, [obj]);
	        }

	        function isGeometry(input) {
	            return input.hasOwnProperty("parts") && input.hasOwnProperty("points");
	        }

	        return SuperMap.Format.JSON.prototype.write.apply(this, [geojson, pretty]);
	    },

	    /**
	     * Method: createCRSObject
	     * 从一个要素对象中创建一个坐标参考系对象。
	     *
	     * Parameters:
	     * object - {<SuperMap.Feature.Vector>} 要素对象
	     *
	     * Returns:
	     * {Object} 一个可作为GeoJSON对象的crs属性使用的对象。
	     */
	    createCRSObject: function (object) {
	        var proj = object.layer.projection.toString();
	        var crs = {};
	        if (proj.match(/epsg:/i)) {
	            var code = parseInt(proj.substring(proj.indexOf(":") + 1));
	            if (code == 4326) {
	                crs = {
	                    "type": "name",
	                    "properties": {
	                        "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
	                    }
	                };
	            } else {
	                crs = {
	                    "type": "name",
	                    "properties": {
	                        "name": "EPSG:" + code
	                    }
	                };
	            }
	        }
	        return crs;
	    },

	    /**
	     * Property: extract
	     * 一个属性名对应着GeoJSON类型的对象。其值为相应的实际的解析方法。
	     */
	    extract: {
	        /**
	         * Method: extract.feature
	         * 返回一个表示单个要素对象的GeoJSON的一部分。
	         *
	         * Parameters:
	         * feature - iServer要素对象
	         *
	         * Returns:
	         * {Object} 一个表示点的对象。
	         */
	        'feature': function (feature) {
	            var geom = this.extract.geometry.apply(this, [feature.geometry]);
	            var json = {
	                "type": "Feature",
	                // "properties": feature.attributes,
	                "properties": this.createAttributes(feature),
	                "geometry": geom
	            };
	            if (feature.fid != null) {
	                json.id = feature.fid;
	            }
	            return json;
	        },

	        /**
	         * Method: extract.geometry
	         * 返回一个表示单个几何对象的GeoJSON的一部分。
	         *
	         * Parameters:
	         * geometry -iServer 几何对象
	         *
	         * Returns:
	         * {Object} 一个表示几何体的对象。
	         */
	        'geometry': function (geometry) {
	            if (geometry == null) {
	                return null;
	            }
	            var geo = this.toGeometry(geometry);
	            var geometryType = geo.type;
	            var data = this.extract[geometryType.toLowerCase()].apply(this, [geo]);
	            var json;
	            if (geometryType === "Collection") {
	                json = {
	                    "type": "GeometryCollection",
	                    "geometries": data
	                };
	            } else {
	                json = {
	                    "type": geometryType,
	                    "coordinates": data
	                };
	            }

	            return json;
	        },


	        /**
	         * Method: extract.point
	         * 从一个点对象中返回一个坐标组。
	         *
	         * Parameters:
	         * point - {<SuperMap.Geometry.Point>} 一个点对象。
	         *
	         * Returns:
	         * {Array} 一个表示一个点的坐标组。
	         */
	        'point': function (point) {
	            return [point.x, point.y];
	        },

	        /**
	         * Method: extract.multipoint
	         * 从一个多点对象中返一个坐标组数组。
	         *
	         * Parameters:
	         * multipoint - {<SuperMap.Geometry.MultiPoint>} 多点对象。
	         *
	         * Returns:
	         * {Array} 一个表示多点的坐标组数组。
	         */
	        'multipoint': function (multipoint) {
	            var array = [];
	            for (var i = 0, len = multipoint.components.length; i < len; ++i) {
	                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
	            }
	            return array;
	        },

	        /**
	         * Method: extract.linestring
	         * 从一个线对象中返回一个坐标组数组。
	         *
	         * Parameters:
	         * linestring - {<SuperMap.Geometry.LineString>} 线对象。
	         *
	         * Returns:
	         * {Array} 一个表示线对象的坐标组数组。
	         */
	        'linestring': function (linestring) {
	            var array = [];
	            for (var i = 0, len = linestring.components.length; i < len; ++i) {
	                array.push(this.extract.point.apply(this, [linestring.components[i]]));
	            }
	            return array;
	        },

	        /**
	         * Method: extract.multilinestring
	         * 从一个多线对象中返回一个线数组。
	         *
	         * Parameters:
	         * multilinestring - {<SuperMap.Geometry.MultiLineString>} 多线对象
	         *
	         * Returns:
	         * {Array} 一个表示多线的线数组。
	         */
	        'multilinestring': function (multilinestring) {
	            var array = [];
	            for (var i = 0, len = multilinestring.components.length; i < len; ++i) {
	                array.push(this.extract.linestring.apply(this, [{components: multilinestring.components[i]}]));
	            }
	            return array;
	        },

	        /**
	         * Method: extract.polygon
	         * 从一个面对象中返回一组线环。
	         *
	         * Parameters:
	         * polygon - {<SuperMap.Geometry.Polygon> 面对象。
	         *
	         * Returns:
	         * {Array} 一组表示面的线环。
	         */
	        'polygon': function (polygon) {
	            var array = [];
	            for (var i = 0, len = polygon.components.length; i < len; ++i) {
	                array.push(this.extract.linestring.apply(this, [{components: polygon.components[i]}]));
	            }
	            return array;
	        },

	        /**
	         * Method: extract.multipolygon
	         * 从一个多面对象中返回一组面。
	         *
	         * Parameters:
	         * multipolygon - {<SuperMap.Geometry.MultiPolygon>} 多面对象。
	         *
	         * Returns:
	         * {Array} 一组表示多面的面。
	         */
	        'multipolygon': function (multipolygon) {
	            var array = [];
	            for (var i = 0, len = multipolygon.components.length; i < len; ++i) {
	                array.push(this.extract.polygon.apply(this, [{components: multipolygon.components[i]}]));
	            }
	            return array;
	        },

	        /**
	         * Method: extract.collection
	         * 从一个几何要素集合中一组几何要素数组。
	         *
	         * Parameters:
	         * collection - {<SuperMap.Geometry.Collection>} 几何要素集合。
	         *
	         * Returns:
	         * {Array} 一组表示几何要素集合的几何要素数组。
	         */
	        'collection': function (collection) {
	            var len = collection.components.length;
	            var array = new Array(len);
	            for (var i = 0; i < len; ++i) {
	                array[i] = this.extract.geometry.apply(this, [{
	                    type: "Collection",
	                    components: collection.components[i]
	                }]);
	            }
	            return array;
	        }
	    },

	    createAttributes: function (feature) {
	        if (!feature) {
	            return null;
	        }
	        var attr = {};
	        processFieldsAttributes(feature, attr);
	        var exceptKeys = ["fieldNames", "fieldValues", "geometry"];
	        for (var key in feature) {
	            if (exceptKeys.indexOf(key) > -1) {
	                continue;
	            }
	            attr[key] = feature[key];
	        }

	        function processFieldsAttributes(feature, attributes) {
	            if (!(feature.hasOwnProperty("fieldNames") && feature.hasOwnProperty("fieldValues"))) {
	                return;
	            }
	            var names = feature.fieldNames,
	                values = feature.fieldValues;
	            for (var i in names) {
	                attributes[names[i]] = values[i];
	            }
	        }


	        return attr;
	    },


	    toGeometry: function (geometry) {
	        var me = this,
	            geoType = geometry.type;
	        switch (geoType) {
	            case SuperMap.REST.GeometryType.POINT:
	                return me.toGeoPoint(geometry);
	            case SuperMap.REST.GeometryType.LINE:
	                return me.toGeoLine(geometry);
	            case SuperMap.REST.GeometryType.LINEM:
	                return me.toGeoLinem(geometry);
	            case SuperMap.REST.GeometryType.REGION:
	                return me.toGeoRegion(geometry);
	            case SuperMap.REST.GeometryType.POINTEPS:
	                return me.toGeoPoint(geometry);
	            // case SuperMap.REST.GeometryType.LINEEPS:
	            //     return me.toGeoLineEPS();
	            // case SuperMap.REST.GeometryType.REGIONEPS:
	            //     return me.toGeoRegionEPS();
	            default:
	                return geometry;
	        }
	    },
	    /**
	     * Method: toGeoPoint
	     * 将服务端的点几何对象转换为几何对象
	     */
	    toGeoPoint: function (geometry) {
	        var me = this,
	            geoParts = geometry.parts || [],
	            geoPoints = geometry.points || [],
	            len = geoParts.length;
	        if (len < 1) {
	            return null;
	        }
	        if (len === 1) {
	            return {type: "Point", x: geoPoints[0].x, y: geoPoints[0].y};
	        } else {
	            for (var i = 0, pointList = []; i < len; i++) {
	                pointList.push({x: geoPoints[i].x, y: geoPoints[i].y});
	            }
	            return {type: "MultiPoint", components: pointList};
	        }

	    },

	    /**
	     * Method: toGeoLine
	     * 将服务端的线几何对象转换为几何对象。
	     */
	    toGeoLine: function (geometry) {
	        var me = this,
	            geoParts = geometry.parts || [],
	            geoPoints = geometry.points || [],
	            len = geoParts.length;
	        if (len < 1) {
	            return null;
	        }
	        if (len === 1) {
	            for (var i = 0, pointList = []; i < geoParts[0]; i++) {
	                pointList.push({x: geoPoints[i].x, y: geoPoints[i].y});
	            }
	            //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
	            if (me.isPointsEquals(pointList[0], pointList[geoParts[0] - 1])) {
	                pointList.pop();
	                pointList.push(pointList[0]);
	            }
	            return {type: "LineString", components: pointList};
	        } else {
	            for (var i = 0, lineList = []; i < len; i++) {
	                for (var j = 0, pointList = []; j < geoParts[i]; j++) {
	                    pointList.push({x: geoPoints[j].x, y: geoPoints[j].y});
	                }
	                lineList.push(pointList);
	                geoPoints.splice(0, geoParts[i]);
	            }
	            return {type: "LineString", components: lineList};
	        }

	    },

	    /**
	     * Method: toGeoLinem
	     * 将服务端的路由线几何对象转换为几何对象。
	     */
	    toGeoLinem: function (geometry) {
	        var me = this,
	            geoParts = geometry.parts || [],
	            geoPoints = geometry.points || [],
	            len = geoParts.length,
	            lineList = [],
	            type;
	        if (len < 1) {
	            return null;
	        }
	        for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {
	            for (var j = 0; j < geoParts[i]; j++) {
	                pointList.push({x: geoPoints[pointIndex + j].x, y: geoPoints[pointIndex + j].y});
	            }
	            pointIndex += geoParts[i];
	            //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
	            if (me.isPointsEquals(pointList[0], pointList[geoParts[0] - 1])) {
	                pointList.pop();
	                pointList.push(pointList[0]);
	            }
	            lineList.push(pointList);
	            pointList = [];
	        }
	        return {type: "MultiLineString", components: lineList};
	    },

	    /**
	     * Method: toGeoRegion
	     * 将服务端的面几何对象转换为几何对象。
	     */
	    toGeoRegion: function (geometry) {
	        var CCWArray = [],
	            geoParts = geometry.parts || [],
	            geoPoints = geometry.points || [],
	            len = geoParts.length;
	        if (len < 1) {
	            return null;
	        }
	        var polygonArray = new Array();
	        for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {
	            for (var j = 0; j < geoParts[i]; j++) {
	                pointList.push({x: geoPoints[pointIndex + j].x, y: geoPoints[pointIndex + j].y});
	            }

	            pointIndex += geoParts[i];
	            var linearRing = pointList.concat();
	            linearRing.pop();
	            linearRing.push(linearRing[0]);

	            if (this.isClockWise(linearRing) > 0) {
	                CCWArray.push(linearRing);
	            } else {
	                polygonArray.push([linearRing]);
	            }

	            if (i === len - 1) {
	                var polyLength = polygonArray.length;
	                if (!!polyLength) {
	                    polygonArray[polyLength - 1] = polygonArray[polyLength - 1].concat(CCWArray);
	                } else {
	                    for (var k = 0, length = CCWArray.length; k < length; k++) {
	                        polygonArray.push([CCWArray[k]].concat());
	                    }
	                }
	            }
	            pointList = [];
	        }
	        return {type: "MultiPolygon", components: polygonArray};
	    },

	    isClockWise: function (points) {
	        var length = points.length;
	        if (length < 3) {
	            return 0.0;
	        }
	        var s = points[0].y * (points[length - 1].x - points[1].x);
	        points.push(points[0]);
	        for (var i = 1; i < length; i++) {
	            s += points[i].y * (points[i - 1].x - points[i + 1].x);
	        }
	        return s * 0.5;
	    },
	    isPointsEquals: function (point1, point2) {
	        return (point1.x === point2.x && point1.y === point2.y);
	    },
	    CLASS_NAME: "SuperMap.Format.GeoJSON"
	});

	module.exports = function (options) {
	    return new SuperMap.Format.GeoJSON(options);
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	__webpack_require__(6);

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('1G.A={aU:"aT 7.1.0",5H:(U(){B f=18 aS("(^|(.*?\\\\/))(A.aR.aQ)(\\\\?|$)"),e=1d.aP("4D"),g,b,c="";13(B d=0,a=e.V;d<a;d++){g=e[d].aO("1F");C(g){B b=g.1V(f);C(b){c=b[1];1r}}}T(U(){T c})})()};A.68=A.68||{};A.L=A.L||{};A.67=A.67||{};A.65=A.65||{};A.64=A.64||{};A.63=A.63||{};A.62=A.62||{};A.61=A.61||{};A.aN=U(){B a=1x.V;B d=1x[0];B c=1x[a-1];B e=1h c.4j==="U"?c.4j:U(){d.1O.4j.5Z(1b,1x)};C(a>1){B b=[e,d].4q(1A.1O.3H.5X(1x).3H(1,a-1),c);A.5Y.5Z(Z,b)}X{e.1O=c}T e};A.5Y=U(f,d){B c=U(){};c.1O=d.1O;f.1O=18 c;B b,a,e;13(b=2,a=1x.V;b<a;b++){e=1x[b];C(1h e==="U"){e=e.1O}A.L.3w(f.1O,e)}};A.L=A.L||{};A.L.3w=U(a,e){a=a||{};C(e){13(B d 1i e){B c=e[d];C(c!==1j){a[d]=c}}B b=1h 1G.2t==="U"&&e 1K 1G.2t;C(!b&&e.1E&&e.1E("1B")){a.1B=e.1B}}T a};A.L.4u=U(c,b){c=c||{};B a;C(b){13(B d 1i c){a=b[d];C(1h a!=="1j"){c[d]=a}}}};A.L.aM=U(c){c=c||{};13(B b 1i c){C(c.1E(b)){C(1h c[b]==="21"&&c[b]1K 1A){13(B a 1i c[b]){C(c[b][a].3z){c[b][a].3z()}}c[b].V=0}X{C(1h c[b]==="21"&&c[b]1K 3G){C(c[b].3z){c[b].3z()}}}c[b]=Z}}};A.L.aL=U(){B d=[];13(B c=0,a=1x.V;c<a;c++){B b=1x[c];C(1h b==="3L"){b=1d.aK(b)}C(1x.V===1){T b}d.1a(b)}T d};A.L.aJ=U(a){T!!(a&&a.aI===1)};A.L.5Q=U(b){T(3G.1O.1B.5X(b)==="[21 1A]")};A.L.aH=U(c,b){13(B a=c.V-1;a>=0;a--){C(c[a]===b){c.aG(a,1)}}T c};A.L.1c=U(d,c){C(d==Z){T-1}X{C(1h d.1c==="U"){T d.1c(c)}X{13(B b=0,a=d.V;b<a;b++){C(d[b]===c){T b}}T-1}}};A.L.2V=U(e,h,d,f,a,c,g,b){C(h){e.1o=h}C(d){e.15.1n=d.x+"2a";e.15.1m=d.y+"2a"}C(f){e.15.2K=f.w+"2a";e.15.3q=f.h+"2a"}C(a){e.15.2q=a}C(c){e.15.aF=c}C(g){e.15.2J=g}C(1z(b)>=0&&1z(b)<1){e.15.2U="4h(1Y="+(b*2o)+")";e.15.1Y=b}X{C(1z(b)===1){e.15.2U="";e.15.1Y=""}}};A.L.5M=U(a,i,h,f,e,c,b,g){B d=1d.1N("2L");C(f){d.15.aE="1l("+f+")"}C(!a){a=A.L.4b("5W")}C(!e){e="2p"}A.L.2V(d,a,i,h,e,c,b,g);T d};A.L.5L=U(a,h,g,e,d,c,f,i){B b=1d.1N("aD");C(!a){a=A.L.4b("5W")}C(!d){d="aC"}A.L.2V(b,a,h,g,d,c,Z,f);C(i){b.15.2u="5N";A.2t.5V(b,"aB",A.2k.2j(A.L.5U,b));A.2t.5V(b,"aA",A.2k.2j(A.L.5S,b))}b.15.az=a;b.ay="ax";C(e){b.1F=e}T b};A.L.5U=U(){C(!1b.4i||(1b.5T&&1b.4i===1b.5T.4i)){1b.15.2u=""}A.2N.aw(1b,"5P")};A.5R=0;A.L.5S=U(){1b.3y=(1b.3y)?(1b.3y+1):1;C(1b.3y<=A.5R){B d=1b.av;C(d&&A.L.5Q(d)&&d.V>1){B e=1b.1F.1B();B c,a;13(a=0;c=d[a];a++){C(e.1c(c)!==-1){1r}}B f=11.2B(d.V*11.3O());B b=d[f];a=0;1L(b===c&&a++<4){f=11.2B(d.V*11.3O());b=d[f]}1b.1F=e.1H(c,b)}X{1b.1F=1b.1F}}X{A.2N.au(1b,"5P")}1b.15.2u=""};A.L.3x=Z;A.L.5O=U(){C(A.L.3x==Z){B d=31.at.1W("as");B a=1z(d[1]);B b=1f;2z{b=!!(1d.1y.ar)}2y(c){}A.L.3x=(b&&(a>=5.5)&&(a<7))}T A.L.3x};A.L.5K=U(a,b,k,j,g,f,c,d,h,i){A.L.2V(a,b,k,j,f,Z,Z,h);B e=a.2M[0];C(g){e.1F=g}C(!!i){e.15.2u=i}A.L.2V(e,a.1o+"aq",Z,j,f,c);C(A.L.5O()){C(a.15.2u!=="5N"){a.15.2u="ap-5J"}C(d==Z){d="ao"}a.15.2U="an:am.al.ak(1F=\'"+e.1F+"\', aj=\'"+d+"\')";C(1z(a.15.1Y)>=0&&1z(a.15.1Y)<1){a.15.2U+=" 4h(1Y="+a.15.1Y*2o+")"}e.15.2U="4h(1Y=0)"}};A.L.ai=U(b,j,i,g,f,c,d,h,k){B a=A.L.5M();B e=A.L.5L(Z,Z,Z,Z,f,Z,Z,k);e.4S="ah";a.24(e);A.L.5K(a,b,j,i,g,f,c,d,h,"5J");T a};A.L.ag=U(b){B a={};13(B c 1i b){a[c.af()]=b[c]}T a};A.L.57=U(d,c){d=d||{};B b=1h 1G.2t==="U"&&c 1K 1G.2t;13(B a 1i c){C(d[a]===1j||(!b&&c.1E&&c.1E(a)&&!d.1E(a))){d[a]=c[a]}}C(!b&&c&&c.1E&&c.1E("1B")&&!d.1E("1B")){d.1B=c.1B}T d};A.L.4I=U(c){B b=[];13(B h 1i c){B g=c[h];C((g!=Z)&&(1h g!=="U")){B d;C(1h g==="21"&&g.4J===1A){B e=[];B i;13(B a=0,f=g.V;a<f;a++){i=g[a];e.1a(2E((i===Z||i===1j)?"":i))}d=e.2n(",")}X{d=2E(g)}b.1a(2E(h)+"="+d)}}T b.2n("&")};A.L.ae=U(a,b){B d=a;C(b){B c=(a+" ").1W(/[?&]/);d+=(c.56()===" "?b:c.V?"&"+b:"?"+b)}T d};A.5I="";A.L.ad=U(){T A.5I||(A.5H()+"../ac/ab/")};A.L.5G=U(){B d=Z;13(B c=0,a=1x.V;c<a;c++){B b=1x[c];2z{d=b();1r}2y(f){}}T d};A.L.aa=U(a){B b=Z;A.L.5G(U(){b=a.4B;C(!b){b=a.5F}C(!b){b=a.a9.a8}},U(){b=a.5F});T b};A.L.a7=U(a,c){B b=(a.5E)?a.5E:a.a6;1L(b!==c&&b!=Z){b=b.30}T(b!==c)};A.L.5D=14;A.L.a5=U(b,a){C(a==Z){a=A.L.5D}C(1h b!=="a4"){b=1z(b)}T a===0?b:1z(b.a3(a))};A.L.2s=U(a){T a*11.28/3X};A.L.4c=U(a){T a*3X/11.28};A.L.4g={a:3j,b:a2.a1,f:1/a0.9Z};A.L.9Y=U(g,e){B k=A.L.4g;B M=k.a,K=k.b,G=k.f;B n=A.L.2s(e.3p-g.3p);B J=11.5C((1-G)*11.4e(A.L.2s(g.4f)));B I=11.5C((1-G)*11.4e(A.L.2s(e.4f)));B m=11.2r(J),i=11.1X(J);B l=11.2r(I),h=11.1X(I);B r=n,o=2*11.28;B q=20;1L(11.3W(r-o)>1e-12&&--q>0){B z=11.2r(r),c=11.1X(r);B N=11.4d((h*z)*(h*z)+(i*l-m*h*c)*(i*l-m*h*c));C(N==0){T 0}B E=m*l+i*h*c;B y=11.2T(N,E);B j=11.9X(i*h*z/N);B F=11.1X(j)*11.1X(j);B p=E-2*m*l/F;B v=G/16*F*(4+G*(4-3*F));o=r;r=n+(1-v)*G*11.2r(j)*(y+v*N*(p+v*E*(-1+2*p*p)))}C(q==0){T 9W}B u=F*(M*M-K*K)/(K*K);B x=1+u/5B*(5A+u*(-5z+u*(5y-5x*u)));B w=u/5w*(5v+u*(-3R+u*(74-47*u)));B D=w*N*(p+w/4*(E*(-1+2*p*p)-w/6*p*(-3+4*N*N)*(-3+4*p*p)));B t=K*x*(y-D);B H=t.9V(3)/2A;T H};A.L.9U=U(l,P,E){B o=A.L;B i=o.4g;B Q=i.a,O=i.b,J=i.f;B N=l.3p;B g=l.4f;B q=E;B D=o.2s(P);B G=11.2r(D);B h=11.1X(D);B F=(1-J)*11.4e(o.2s(g));B c=1/11.4d((1+F*F)),j=F*c;B p=11.2T(F,h);B y=c*G;B I=1-y*y;B t=I*(Q*Q-O*O)/(O*O);B x=1+t/5B*(5A+t*(-5z+t*(5y-5x*t)));B v=t/5w*(5v+t*(-3R+t*(74-47*t)));B w=q/(O*x),K=2*11.28;1L(11.3W(w-K)>1e-12){B m=11.1X(2*p+w);B R=11.2r(w);B H=11.1X(w);B z=v*R*(m+v/4*(H*(-1+2*m*m)-v/6*m*(-3+4*R*R)*(-3+4*m*m)));K=w;w=q/(O*x)+z}B M=j*R-c*H*h;B d=11.2T(j*H+c*R*h,(1-J)*11.4d(y*y+M*M));B n=11.2T(R*G,c*H-j*R*h);B r=J/16*I*(4+J*(4-3*I));B k=n-(1-r)*J*y*(w+r*R*(m+r*H*(-1+2*m*m)));B e=11.2T(y,-M);T 18 A.9T(N+o.4c(k),o.4c(d))};A.L.50=U(b){b=(b===Z||b===1j)?1G.3l.54:b;B a="";C(A.2H.2d(b,"?")){B c=b.1c("?")+1;B f=A.2H.2d(b,"#")?b.1c("#"):b.V;a=b.1v(c,f)}B m={};B d=a.1W(/[&;]/);13(B h=0,j=d.V;h<j;++h){B g=d[h].1W("=");C(g[0]){B l=g[0];2z{l=5u(l)}2y(e){l=5t(l)}B k=(g[1]||"").1H(/\\+/g," ");2z{k=5u(k)}2y(e){k=5t(k)}k=k.1W(",");C(k.V==1){k=k[0]}m[l]=k}}T m};A.L.4a=0;A.L.4b=U(a){C(a==Z){a="9S"}A.L.4a+=1;T a+A.L.4a};A.17={2I:1,3n:12,3V:9R,m:39.9Q,3U:9P.1,2m:9O,3m:36};A.17["1i"]=A.17.2I;A.17.29=A.17.2m;A.17.5o=5r*A.17.m;A.Y=0.9N;A.L.3w(A.17,{9M:A.17.2I,2S:1/A.Y,5k:0.9L/A.Y,9K:0.9J/A.Y,9I:0.9H/A.Y,9G:0.9F/A.Y,9E:0.9D/A.Y,9C:0.27/A.Y,9B:0.9A/A.Y,9z:2.9y-8/A.Y,9x:0.9w/A.Y,9v:2A/A.Y,5j:0.9u/A.Y,9t:0.9s/A.Y,9r:0.9q/A.Y,5g:0.9p/A.Y,9o:0.9n/A.Y,9m:0.9l/A.Y,9k:0.9j/A.Y,5f:0.9i/A.Y,9h:0.9g/A.Y,9f:0.9e/A.Y,5h:5s.9d/A.Y,9c:0.9b/A.Y,9a:5s.99/A.Y,5p:5r/A.Y,"5q-66":98.97/A.Y,"5q-83":95.94/A.Y,93:0.1/A.Y,92:0.91/A.Y,90:10/A.Y,8Z:10/A.Y,8Y:2o/A.Y,8X:1.8W/A.Y,8V:0.8U/A.Y,8T:20.8S/A.Y,5i:20.8R/A.Y,8Q:20.8P/A.Y,8O:20.8N/A.Y,8M:0.8L/A.Y,8K:0.8J/A.Y,8I:0.8H/A.Y,8G:0.8F/A.Y,8E:5.49/A.Y,5m:20.8D/A.Y,5l:0.8C/A.Y,8B:5.49/A.Y,8A:5.49/A.Y,8z:8y.8x/A.Y,8w:3.8v/A.Y,8u:0.8t/A.Y,8s:8r/A.Y,8q:0.8p/A.Y,5n:1.8o/A.Y,"5p-8n":8m.8l/A.Y,"8k":8j/A.Y,"8i":8h/A.Y});A.L.3w(A.17,{8g:A.17.2S/2A,8f:A.17.2S/2o,4L:A.17.2S*2o,3U:A.17.2S*2A,8e:A.17.5o,8d:A.17.5n,46:A.17.5m,8c:A.17.5l,"2R-1i":A.17.2I,"2R-3n":A.17.5k,"2R-3m":A.17.5j,"2R-46":A.17.5i,"2R-3V":A.17.5h,"48-3m":A.17.5g,"48-3n":A.17.5f,"48-46":20.8b/A.Y});A.45=96;A.L.3T=U(b){B a=(b>1)?(1/b):b;T a};A.L.8a=U(d,a){B b;C(d){C(a==Z){a="29"}B c=A.L.3T(d);b=1/(c*A.17[a]*A.45)}T b};A.L.89=U(b,a){C(a==Z){a="29"}B c=b*A.17[a]*A.45;T c};A.L.88=U(d){B i=[0,0];B h=A.L.58();C(!d||d===1G||d===h){T i}B f=A.4Z&&1d.3v&&A.2N.3Z(d,"2q")==="2p"&&(d.15.1m==""||d.15.1n=="");B j=Z;B g;C(d.5e){g=d.5e();B b=h.59;B c=h.5a;i[0]=g.1n+c;i[1]=g.1m+b}X{C(1d.3v&&!f){g=1d.3v(d);B a=1d.3v(h);i[0]=g.5d-a.5d;i[1]=g.5c-a.5c}X{i[0]=d.5b;i[1]=d.44;j=d.3u;C(j!==d){1L(j){i[0]+=j.5b;i[1]+=j.44;j=j.3u}}B e=A.3t.2b;C(e==="2P"||(e==="3r"&&A.2N.3Z(d,"2q")==="2p")){i[1]-=1d.1y.44}j=d.3u;1L(j&&j!==1d.1y){i[0]-=j.5a;C(e!=="2P"||j.4T!=="87"){i[1]-=j.59}j=j.3u}}}T i};A.L.58=U(){B a=1x.86.85;C(a==1j){a=(A.3t.2b==="2O"&&1d.84!=="82")?1d.1y:1d.81}T a};A.L.7Z=U(f,e,c){c=c||{};A.L.57(c,{55:1g,52:1g,51:1g});B b=A.L.43(f,c);B a=A.L.43(e,c);13(B d 1i b){C(d!=="2c"){C(b[d]!==a[d]){T 1f}}}13(B d 1i b.2c){C(b.2c[d]!==a.2c[d]){T 1f}2Z a.2c[d]}13(B d 1i a.2c){T 1f}T 1g};A.L.43=U(c,k){k=k||{};C(!(/^\\w+:\\/\\//).7Y(c)){B g=1G.3l;B e=g.1I?":"+g.1I:"";B h=g.3k+"//"+g.42.1W(":").53()+e;C(c.1c("/")===0){c=h+c}X{B f=g.2Q.1W("/");f.56();c=h+f.2n("/")+"/"+c}}C(k.55){c=c.1q()}B i=1d.1N("a");i.54=c;B d={};d.42=i.42.1W(":").53();d.3k=i.3k;C(k.52){d.1I=(i.1I==="80"||i.1I=="0")?"":i.1I}X{d.1I=(i.1I==""||i.1I=="0")?"80":i.1I}d.41=(k.51||i.41==="#")?"":i.41;B b=i.7X;C(!b){B j=c.1c("?");b=(j!==-1)?c.2G(j):""}d.2c=A.L.50(b);d.2Q=(i.2Q.7W(0)==="/")?i.2Q:"/"+i.2Q;T d};A.L.7V=U(b){B c=Z;B a=b.1c("?");B d=b.1c("#");C(a==-1){c=(d!==-1)?b.2G(0,d):b}X{c=(d!==-1)?b.2G(0,11.3E(a,d)):b.2G(0,a)}T c};A.4Z=(U(){B a=31.3N.1q();T a.1c("7U")===-1&&a.1c("7T")!==-1})();A.3t=(U(){B c="",a="",e="7S",b;B d=31.3N.1q();C(d.1c("2O")>-1||(d.1c("7R")>-1&&d.1c("4Y")>-1)){c="2O";b=d.1V(/2O ([\\d.]+)/)||d.1V(/4Y:([\\d.]+)/)}X{C(d.1c("40")>-1){c="40";b=d.1V(/40\\/([\\d.]+)/)}X{C(d.1c("3s")>-1){c="3s";b=d.1V(/3s\\/([\\d.]+)/)}X{C(d.1c("2P")>-1){c="2P";b=d.1V(/1U\\/([\\d.]+)/)}X{C(d.1c("3r")>-1){c="3r";b=d.1V(/1U\\/([\\d.]+)/)}}}}}a=b?b[1]:"";C(d.1c("7Q")>-1||d.1c("7P")>-1||d.1c("7O")>-1){e="7N"}X{C(d.1c("4X")>-1){b=d.1V(/1U\\/([\\d.]+)/);a=b?b[1]:"";e="4X"}}T{2b:c,1U:a,7M:e}})();A.L.4W=U(){T A.3t};A.L.4V=(U(){B a=1g,b=A.L.4W();C(1d.1N("7L").7K){C(b.2b==="3s"&&1z(b.1U)<5){a=1f}C(b.2b==="3r"&&1z(b.1U)<4){a=1f}C(b.2b==="2P"&&1z(b.1U)<10){a=1f}C(b.2b==="2O"&&1z(b.1U)<9){a=1f}}X{a=1f}T a})();A.L.7J=U(){T A.L.4V};A.L.7I=U(b,o,p){B m,e;B a=1d.1N("2L");a.15.7H="4N";B n=(p&&p.4U)?p.4U:1d.1y;B q=1f;B g=Z;B k=n;1L(k&&k.4T.1q()!=="1y"){B j=A.2N.3Z(k,"2q");C(j==="2p"){q=1g;1r}X{C(j&&j!=="7G"){1r}}k=k.30}C(!q){a.15.2q="2p"}C(o){C(o.w){m=o.w;a.15.2K=m+"2a"}X{C(o.h){e=o.h;a.15.3q=e+"2a"}}}C(p&&p.4R){a.4S=p.4R}B f=1d.1N("2L");f.7F=b;f.15.2J="4Q";C(f.2M){13(B d=0,c=f.2M.V;d<c;d++){C(!f.2M[d].15){2X}f.2M[d].15.2J="4Q"}}a.24(f);n.24(a);n.24(a);C(!m){m=4P(f.7E);a.15.2K=m+"2a"}C(!e){e=4P(f.7D)}a.2h(f);n.2h(a);T 18 A.7C(m,e)};A.L.7B=U(){B c=A.L.3Y;C(c==Z){B e=Z;B d=Z;B a=0;B b=0;e=1d.1N("2L");e.15.2q="2p";e.15.1m="-4O";e.15.1n="-4O";e.15.2K="7A";e.15.3q="7z";e.15.2J="4N";d=1d.1N("2L");d.15.2K="2o%";d.15.3q="7y";e.24(d);1d.1y.24(e);a=d.4M;e.15.2J="7x";b=d.4M;1d.1y.2h(1d.1y.7w);A.L.3Y=(a-b);c=A.L.3Y}T c};A.L.7v=U(h,b,e){C(!e){e="4K"}h=(h+7u)%3h-3X;B d=11.3W(h);B i=11.2B(d);B a=(d-i)/(1/60);B c=a;a=11.2B(a);B g=(c-a)/(1/60);g=11.7t(g*10);g/=10;C(g>=60){g-=60;a+=1;C(a>=60){a-=60;i+=1}}C(i<10){i="0"+i}B f=i+"\\7s";C(e.1c("4L")>=0){C(a<10){a="0"+a}f+=a+"\'";C(e.1c("4K")>=0){C(g<10){g="0"+g}f+=g+\'"\'}}C(b==="3p"){f+=h<0?A.3o("W"):A.3o("E")}X{f+=h<0?A.3o("S"):A.3o("N")}T f};A.17.3i=A.17.2m;A.17.7r=A.17.m;A.17.7q=A.17.3n;A.17.7p=A.17.2I;A.17.7o=A.17.3V;A.17.7n=A.17.3U;A.17.7m=A.17.3m;A.L.2F=U(a){C(!a){T 1g}B g=a.1c("//");B j=1d.3l.1B();B b=j.1c("//");C(g===-1){T 1g}X{B f=a.1v(0,g);B h=j.1v(b+2);b=h.1c("/");B k=h.1v(0,b);B l=1d.3l.3k;C(l.1q()!==f.1q()){T 1f}f=a.1v(g+2);B c=f.1c(":");g=f.1c("/");B d=f.1v(0,c);B i=f.1v(0,g);B e=1d.7l;C(d===e&&i===k){T 1g}}T 1f};A.L.7k=U(e,f,c,k,n){C(!e||!f||!c){T}B j=3S,g=e.7j(),d=e.7i(),m=f.w,i=f.h;n=n||3j;k=k||"29";C(k.1q()==="3i"||k.1q()==="29"||k.1q()==="2m"){B l=g/m,h=d/i,b=l>h?l:h,a=0.27*j/b/c/((11.28*2*n)/3h)/j;T a}X{B b=g/m,a=0.27*j/b/c/j;T a}};A.L.1T=U(g){B d=g;C(d==Z){T Z}3Q(d.4J){1w 2H:d=\'"\'+d.1H(/(["\\\\])/g,"\\\\$1")+\'"\';d=d.1H(/\\n/g,"\\\\n");d=d.1H(/\\r/g,"\\\\r");d=d.1H("<","&7h;");d=d.1H(">","&7g;");d=d.1H(/%/g,"%25");d=d.1H(/&/g,"%26");T d;1w 1A:B c=[];13(B f=0,b=d.V;f<b;f++){c.1a(A.L.1T(d[f]))}T"["+c.2n(",")+"]";1w 7f:T 7e(d)?2H(d):Z;1w 7d:T 2H(d);1w 2w:B e="{\'7c\':\\"7b.7a\\",\'79\':"+d.78()+",\'77\':"+(d.76()+1)+",\'75\':"+d.73()+",\'72\':"+d.71()+",\'70\':"+d.6Z()+",\'6Y\':"+d.6X()+",\'6W\':"+d.6V()+",\'6U\':"+d.6T()+"}";T e;6S:C(d.1T!=Z&&1h d.1T==="U"){T d.1T()}C(1h d==="21"){C(d.V){B c=[];13(B f=0,b=d.V;f<b;f++){c.1a(A.L.1T(d[f]))}T"["+c.2n(",")+"]"}B c=[];13(B a 1i d){C(1h d[a]!=="U"&&a!=="1J"&&a!=="6R"){c.1a("\'"+a+"\':"+A.L.1T(d[a]))}}C(c.V>0){T"{"+c.2n(",")+"}"}X{T"{}"}}T d.1B()}};A.L.6Q=U(f,c,b,e){B a=Z,d=3S;e=e||3j;b=b||"";C(f>0&&c>0){f=A.L.3T(f);C(b.1q()==="3i"||b.1q()==="29"||b.1q()==="2m"){a=0.27*d/c/f/((11.28*2*e)/3h)/d;T a}X{a=0.27*d/c/f/d;T a}}T-1};A.L.6P=U(b,c,a,e){B f=Z,d=3S;e=e||3j;a=a||"";C(b>0&&c>0){C(a.1q()==="3i"||a.1q()==="29"||a.1q()==="2m"){f=0.27*d/c/b/((11.28*2*e)/3h)/d;T f}X{f=0.27*d/c/b/d;T f}}T-1};A.L.4H=U(c){B e=0,b=Z;13(B d=0,a=c.V;d<a;d++){b=c.6O(d);C(b<6N){e++}X{C((3R<=b)&&(b<=6M)){e+=2}X{C((6L<=b)&&(b<=6K)){e+=3}}}}T(e<6J)?1f:1g};A.L.6I=U(k){C(!k){T}B a=k.1l,h=a.1c("?")>-1?"&":"?",f=a.2G(a.V-1,1);C(1h 6H==="1j"){k.1l=1G.4G(k.1l);k.2F=k.2F||A.L.2F(k.1l);C(k.2F){C(k.2l==="1R"&&k.1Q){B e=k.1Q,d=A.L.4I(e);C(A.L.4H(d)){B g=k.22;k.2l="23";k.1l+=h+"3f=1R";g="{";13(B i 1i e){g+="\'"+i+"\':"+2E(e[i])+","}g+="}";k.22=g}X{C(d.V>0){a+=h+d}k.1l=a}2Z k.1Q}B c=k.3P||{};k.3P=c;3Q(k.2l){1w"1R":A.3g.1R(k);1r;1w"23":c["3e-3d"]="3c/x-3b-3a-38;37=35-8";A.3g.23(k);1r;1w"2g":c["3e-3d"]="3c/x-3b-3a-38;37=35-8";A.3g.2g(k);1r;1w"2f":c["3e-3d"]="3c/x-3b-3a-38;37=35-8";A.3g.2f(k);1r}}X{3Q(k.2l){1w"1R":A.L.2i.1R(k);1r;1w"23":k.1l+=h+"3f=23";A.L.2i.23(k);1r;1w"2g":k.1l+=h+"3f=2g";A.L.2i.2g(k);1r;1w"2f":k.1l+=h+"3f=2f";A.L.2i.2f(k);1r}}}X{B b="",j=1g;C(k.1Q&&k.2l==="1R"){13(B i 1i k.1Q){C(!j){b+="&"+i+"="+k.1Q[i]}X{j=1f;b+=i+"="+k.1Q[i]}}}k.1l=k.1l.1H(/6G/,"6F");C(b){k.1l+=h+b}k.1l=1G.4G(k.1l);6E.6D({1l:k.1l,3F:k.2l,22:k.22,3P:{"3e-3d":"3c/x-3b-3a-38;37=35-8"}}).6C(U(l){B m=(k.1S)?A.2k.2j(k.2D,k.1S):k.2D;m(l)},U(m){B l=(k.1S)?A.2k.2j(k.2C,k.1S):k.2C;l(m)})}};A.L.2i={32:6B,1s:[],1M:[],33:{},2e:U(a){B d=1b;13(B b 1i a){d.1s.1a(b);C(1h a[b]!=="3L"){a[b]=A.L.1T(a[b])}B c=2E(a[b]);d.1M.1a(c)}},2x:U(e){B m=1b,k=m.4F(),b=e.1l,p=Z,d=Z,n=[];C(e.2D){p=(e.1S)?A.2k.2j(e.2D,e.1S):e.2D}C(e.2C){d=(e.1S)?A.2k.2j(e.2C,e.1S):e.2C}m.33[k]=U(q){B i=A.L.4x(q);i.34=i.34==1j?1g:i.34;C(i.34&&p){p(q)}X{C(d){d(q)}}2Z m.33[k]};m.2e({6A:"A.L.2i.33["+k+"]"});B j=m.1s,l=b,g=0;B c=m.1s?m.1s.V:0;13(B f=0;f<c;f++){C(l.V+m.1s[f].V+2>=m.32){C(g==0){T 1f}C(n==Z){n=18 1A()}n.1a(l);l=b;g=0;f--}X{C(l.V+m.1s[f].V+2+m.1M[f].V>m.32){B a=m.1M[f];1L(a.V>0){B o=m.32-l.V-m.1s[f].V-2;C(l.1c("?")>-1){l+="&"}X{l+="?"}B h=a.1v(0,o);C(h.1v(o-1,o)==="%"){o-=1;h=a.1v(0,o)}X{C(h.1v(o-2,o-1)==="%"){o-=2;h=a.1v(0,o)}}l+=m.1s[f]+"="+h;a=a.1v(o);C(h.V>0){C(n==Z){n=18 1A()}n.1a(l);l=b;g=0}}}X{g++;C(l.1c("?")>-1){l+="&"}X{l+="?"}B h=m.1M[f];l+=m.1s[f]+"="+h}}}C(n==Z){n=18 1A()}l!==b&&n.1a(l);m.4E(n)},4F:U(){B a=18 2w().3I(),b=11.2B(11.3O()*6z);T a*2A+b},4E:U(e){B a=e.V;C(a>0){B f=18 2w().3I();13(B d=0;d<a;d++){B b=1d.1N("4D");B c=e[d];C(c.1c("?")>-1){c+="&"}X{c+="?"}c+="6y="+a;c+="&6x="+d;c+="&6w="+f;b.4C("1F",c);b.4C("3F","4B/6v");C(31.3N.1c("6u")>=0){b.4z=U(){C(1b&&("6t"===1b.4A||"6s"===1b.4A)){1b.4z=Z;2z{1d.1y.2h(1b)}2y(g){C(1b.30){1b.30.2h(1b)}2Z 1b}}}}X{b.4y=U(){1b.4y=Z;1d.1y.2h(1b)}}1d.1y.24(b)}}},1R:U(a){B b=1b;b.1s.V=0;b.1M.V=0;b.2e(a.1Q);b.2x(a)},23:U(a){B b=1b;b.1s.V=0;b.1M.V=0;b.2e({3M:a.22});b.2x(a)},2g:U(a){B b=1b;b.1s.V=0;b.1M.V=0;b.2e({3M:a.22});b.2x(a)},2f:U(a){B b=1b;b.1s.V=0;b.1M.V=0;b.2e({3M:a.22});b.2x(a)}};A.L.4x=U(1P){C(1P.2Y&&1h 1P.2Y==="3L"){C(1h 3K!="1j"&&3K.4w){1P=3K.4w(1P.2Y)}X{1P=6r("("+1P.2Y+")")}}T 1P};A.L.6q=U(a,d){a=a||{};C(d){13(B c 1i d){B b=d[c];C(b!==1j&&c!=="1J"&&1h b!=="U"){a[c]=b}}}T a};A.L.6p=U(b,h,d){b=b||{};C(h){13(B g 1i h){B f=1f;C(d&&d.V){13(B c=0,a=d.V;c<a;c++){C(g===d[c]){f=1g;1r}}}C(f===1g){2X}B e=h[g];C(e!==1j&&g!=="1J"&&1h e!=="U"){b[g]=e}}}T b};A.L.3J=U(b,h){b=b||{};C(h){C(h 1K 1A){b=[];13(B e=0,a=h.V;e<a;e++){B d=h[e];b.1a(A.L.3J({},d))}}X{13(B g 1i h){B f=h[g];C(1h f==="21"){B c={};b[g]=A.L.3J(c,f)}b[g]=f}}}T b};A.L.6o=U(a){A.6n=!!a};A.L.4v=U(b){C(Z===b||"21"!==1h b){T b}C(b 1K 2w){B c=18 2w();c.6m(b.3I());T c}C(b 1K 1A){B c=b.3H(0);T c}C(b 1K 3G){B c={};13(B a 1i b){C(b.1E(a)){c[a]=A.L.4v(b[a])}}T c}6l 18 6k("6j 6i 4u 6h! 6g 3F 6f\'t 6e.")};A.L.1Z=U(d,c,l,i){B o=Z;B g;B e;B j=(i.x-l.x)*(d.y-l.y)-(i.y-l.y)*(d.x-l.x);B k=(c.x-d.x)*(d.y-l.y)-(c.y-d.y)*(d.x-l.x);B p=(i.y-l.y)*(c.x-d.x)-(i.x-l.x)*(c.y-d.y);C(p!=0){g=j/p;e=k/p;C(g>=0&&e<=1&&g<=1&&e>=0){o=18 A.19.1p(d.x+g*(c.x-d.x),d.y+g*(c.y-d.y))}X{o="6d 6c"}}X{C(j==0&&k==0){B f=11.4t(d.y,c.y);B m=11.3E(d.y,c.y);B h=11.4t(d.x,c.x);B n=11.3E(d.x,c.x);C(((l.y>=m&&l.y<=f)||(i.y>=m&&i.y<=f))&&(l.x>=n&&l.x<=h)||(i.x>=n&&i.x<=h)){o="6b"}X{o="4s"}}X{o="4s"}}T o};A.L.4r=U(d,e,h){B c=[];B b=18 A.19.1p(h.1n,h.1t);B k=18 A.19.1p(h.1u,h.1m);B g=18 A.19.1p(h.1u,h.1t);B j=18 A.19.1p(h.1n,h.1m);B a=[];a.1a(A.L.1Z(b,g,d,e));a.1a(A.L.1Z(g,k,d,e));a.1a(A.L.1Z(k,j,d,e));a.1a(A.L.1Z(j,b,d,e));B f=0;1L(f<a.V){C(a[f].1J==="A.19.1p"){c.1a(a[f])}f++}T c};A.L.3C=U(l,j,b,c){b=b!=1j?b:1g;c=c!=1j?c:1f;C(!j.2W(l.1D())){T Z}C(j.2v(l.1D())){T[l]}B n=l.1k;B g=[];13(B e=0;e<n.V-1;e++){B k=18 A.19.1p(n[e].x,n[e].y);B h=18 A.19.1p(n[e+1].x,n[e+1].y);B f=A.L.4r(k,h,j);B o;C(f.V===2){C(((f[0].x-k.x)*(f[0].x-k.x)+(f[0].y-k.y)*(f[0].y-k.y))>((f[1].x-k.x)*(f[1].x-k.x)+(f[1].y-k.y)*(f[1].y-k.y))){B m=f[0];f[0]=f[1];f[1]=m}C(b){o=18 A.19.1C(f);g.1a(o)}X{g.1a(f[0],f[1])}}X{C(f.V===1){C(j.2d(k.x,k.y,1f)){C(b){o=18 A.19.1C([k,f[0]]);g.1a(o)}X{g.1a(k,f[0])}}X{C(j.2d(h.x,h.y,1f)){C(b){o=18 A.19.1C([f[0],h]);g.1a(o)}X{g.1a(f[0],h)}}X{}}}X{C(f.V==0){C(j.2d(k.x,k.y)&&j.2d(h.x,h.y)){C(b){o=18 A.19.1C([k,h]);g.1a(o)}X{g.1a(k,h)}}X{}}}}}C(g.V>0){C(!b){B d=18 A.19.1C(g);C(c){d.1o=l.1o}T d}X{C(c){g[0].1o=l.1o;C(g.V>1){13(B e=1;e<g.V;e++){g[e].1o=l.1o+"6a"+e}}}}T g}};A.L.4n=U(g,f,a,b){a=a!=1j?a:1g;b=b!=1j?b:1f;C(!f.2W(g.1D())){T Z}C(f.2v(g.1D())){T g}B c=g.1k;B j=[];13(B d=0;d<c.V;d++){B e=A.L.3C(c[d],f,a,b);C(!e){2X}C(e 1K 1A){j=j.4q(e)}X{j.1a(e)}}C(j.V>0){B h=18 A.19.3B(j);C(b){h.1o=g.1o;T h}T h}};A.L.4p=U(k,i){B f=18 A.19.1p(k.1n,k.1t<i.1t?k.1t:i.1t);B b=18 A.19.1p(k.1n,k.1m>i.1m?k.1m:i.1m);B l=18 A.19.1C([f,b]);B m=18 A.19.1p(k.1n<i.1n?k.1n:i.1n,k.1m);B a=18 A.19.1p(k.1u>i.1u?k.1u:i.1u,k.1m);B g=18 A.19.1C([m,a]);B n=18 A.19.1p(k.1u,k.1m>i.1m?k.1m:i.1m);B j=18 A.19.1p(k.1u,k.1t<i.1t?k.1t:i.1t);B e=18 A.19.1C([n,j]);B c=18 A.19.1p(k.1u>i.1u?k.1u:i.1u,k.1t);B h=18 A.19.1p(k.1n<i.1n?k.1n:i.1n,k.1t);B d=18 A.19.1C([c,h]);T[l,g,e,d]};A.L.3D=U(a,c,b){C((b==0)&&a.x>=c.1n){T 1g}X{C((b===1)&&a.y<=c.1m){T 1g}X{C((b===2)&&a.x<=c.1u){T 1g}X{C((b===3)&&a.y>=c.1t){T 1g}}}}T 1f};A.L.3A=U(m,a,t){C(!a.2W(m.1D())){T Z}C(a.2v(m.1D())){T m}t=t!=1j?t:1f;B y=[];B z=m.1k;13(B s=0;s<z.V;s++){C(a.2v(z[s].1D())){y.1a(z[s]);2X}B b=A.L.4p(a,z[s].1D());B w=z[s].1k;B c=[],h=[],g=[];B x=4,f=w.V;B d=w[f-1];13(B q=0;q<f;q++){h.1a(w[q])}B r;13(B q=0;q<x;q++){C(A.L.3D(d,a,q)){r=1f}X{r=1g}B p=h.V;13(B o=0;o<p;o++){C(A.L.3D(h[o],a,q)){C(r){r=1f;c.1a(A.L.1Z(d,h[o],b[q].1k[0],b[q].1k[1]))}c.1a(h[o])}X{C(!r){r=1g;c.1a(A.L.1Z(d,h[o],b[q].1k[0],b[q].1k[1]))}}d=h[o]}B u=c.V;h.V=0;13(B n=0;n<u;n++){h.1a(c[n])}c.V=0}13(B q=0;q<h.V;q++){g.1a(h[q])}C(g.V>2){B v=18 A.19.4o(g);C(t){v.1o=z[s].1o}y.1a(v)}}C(y.V>0){B e=18 A.19.4m(y);C(t){e.1o=m.1o;T e}T e}};A.L.4k=U(g,f,a){C(!f.2W(g.1D())){T Z}C(f.2v(g.1D())){T g}a=a!=1j?a:1f;B d=[];13(B c=0;c<g.1k.V;c++){B b=A.L.3A(g.1k[c],f,a);C(b){d.1a(b)}}C(d.V>0){B e=18 A.19.4l(d);C(a){e.1o=g.1o}T e}};A.L.69=U(e,c,d,b){C(e){d=d!=1j?d:1g;b=b!=1j?b:1f;C(((e.1J==="A.19.1C")||(e.1J==="A.19.4o"))&&(e.1k.V>1)){B a=A.L.3C(e,c,d,b);C(a){C(a.V===1){T a[0]}X{T 18 A.19.3B(a)}}}X{C((e.1J==="A.19.3B")&&(e.1k.V>0)&&(e.1k[0].1k.V>1)){T A.L.4n(e,c,d,b)}X{C((e.1J==="A.19.4m")&&(e.1k.V>0)&&(e.1k[0].1k.V>2)){T A.L.3A(e,c,b)}X{C((e.1J==="A.19.4l")&&(e.1k.V>0)){T A.L.4k(e,c,1g)}X{T e}}}}}};',62,677,'||||||||||||||||||||||||||||||||||||SuperMap|var|if|||||||||Util||||||||return|function|length||else|METERS_PER_INCH|null||Math||for||style||INCHES_PER_UNIT|new|Geometry|push|this|indexOf|document||false|true|typeof|in|undefined|components|url|top|left|id|Point|toLowerCase|break|queryKeys|bottom|right|substring|case|arguments|body|parseFloat|Array|toString|LineString|getBounds|hasOwnProperty|src|window|replace|port|CLASS_NAME|instanceof|while|queryValues|createElement|prototype|result|params|GET|scope|toJSON|version|match|split|cos|opacity|lineIntersection||object|data|POST|appendChild|||0254|PI|degrees|px|name|args|contains|addQueryStrings|DELETE|PUT|removeChild|RequestJSONP|bind|Function|method|dd|join|100|absolute|position|sin|rad|Event|display|containsBounds|Date|issue|catch|try|1000|floor|failure|success|encodeURIComponent|isInTheSameDomain|substr|String|inches|overflow|width|div|childNodes|Element|msie|opera|pathname|us|Meter|atan2|filter|modifyDOMElement|intersectsBounds|continue|responseText|delete|parentNode|navigator|limitLength|supermap_callbacks|succeed|UTF||charset|urlencoded||form|www|application|Type|Content|_method|Request|360|degree|6378137|protocol|location|yd|ft|i18n|lon|height|safari|firefox|Browser|offsetParent|getBoxObjectFor|extend|alphaHackNeeded|_attempts|destroy|clipPolygonRect|MultiLineString|clipLineStringRect|isInside|min|type|Object|slice|getTime|JSONClone|JSON|string|requestEntity|userAgent|random|headers|switch|128|10000|normalizeScale|km|mi|abs|180|_scrollbarWidth|getStyle|chrome|hash|host|createUrlObject|offsetTop|DOTS_PER_INCH|ch||ind|02921005842012|lastSeqID|createUniqueID|deg|sqrt|tan|lat|VincentyConstants|alpha|viewRequestID|initialize|clipMultiPolygonRect|MultiPolygon|Polygon|clipMultiLineStringRect|LinearRing|getIntersectLineArray|concat|clipLineRect|Parallel|max|copy|cloneObject|parse|transformResult|onload|onreadystatechange|readyState|text|setAttribute|script|send|getUid|encodeURI|urlIsLong|getParameterString|constructor|dms|dm|offsetWidth|hidden|1000px|parseInt|visible|displayClass|className|tagName|containerElement|isSupportCanvas|getBrowser|android|rv|IS_GECKO|getParameters|ignoreHash|ignorePort80|shift|href|ignoreCase|pop|applyDefaults|getViewportElement|scrollTop|scrollLeft|offsetLeft|screenY|screenX|getBoundingClientRect|IndianFt37|IndianYd37|Mile|GunterChain|Yard|Foot|IntnlLink|IntnlChain|Fathom|nmi|NautM|Lat|1852|1609|unescape|decodeURIComponent|256|1024|175|320|768|4096|16384|atan|DEFAULT_PRECISION|relatedTarget|textContent|Try|_getScriptLocation|ImgPath|block|modifyAlphaImageDiv|createImage|createDiv|none|alphaHack|smImageLoadError|isArray|IMAGE_RELOAD_ATTEMPTS|onImageLoadError|map|onImageLoad|observe|SuperMapDiv|call|inherit|apply||Plot|Tool|Scheme|Tile|Layer||REST|Control|clipGeometryRect|_clip_|Coincident|Intersection|No|supported|isn|Its|obj|to|Unable|Error|throw|setTime|isApp|setApp|copyAttributesWithClip|copyAttributes|eval|complete|loaded|IE|javascript|jsonpUserID|sectionIndex|sectionCount|100000000000000000|callback|1500|then|xhr|WinJS|json|jsonp|Windows|committer|2000|65535|2048|2047|127|charCodeAt|getScaleFromResolutionDpi|getResolutionFromScaleDpi|parent|default|getTimezoneOffset|TimezoneOffset|getMilliseconds|Millisecond|getSeconds|Second|getMinutes|Minute|getHours|Hour|getDate||Day|getMonth|Month|getFullYear|Year|DateTime|System|__type|Boolean|isFinite|Number|gt|lt|getHeight|getWidth|calculateDpi|domain|yard|kilometer|mile|inch|foot|meter|u00B0|round|540|getFormattedLonLat|lastChild|scroll|200px|50px|100px|getScrollbarWidth|Size|scrollHeight|scrollWidth|innerHTML|static|visibility|getRenderedDimensions|supportCanvas|getContext|canvas|device|apple|iphone|ipod|ipad|trident|pc|gecko|webkit|removeTail|charAt|search|test|isEquivalentUrl||documentElement|CSS1Compat||compatMode|viewportElement|callee|TR|pagePosition|getScaleFromResolution|getResolutionFromScale|11669506|link|fath|kmi|cm|mm|150000|150kilometers|50000|50kilometers|184|1853|UK|8288|304812252984506|ModAmFt|375|Brealey|3047972615|CapeFoot|778266898|Rood|1684023368046|201|Furlong|Pole|Perch|201168|1168|Rod|2011676512155|SearsLink|20116782494375873|BenoitLink|2011684023368047|GunterLink|201166194976|ClarkeLink|11676512155|SearsChain|116782494375872|BenoitChain|11684023368047|1166194976|ClarkeChain|999738|CaGrid|0000135965|GermanMeter|Hectometer|Decameter|Dekameter|001|Millimeter|Decimeter|25736872235|110946||31648893273|110943|344|IMile|9144|IYard|3472186944373|3047995|IndianFt75|3047996|IndianFt62|30479841|30479951|IndianFoot|9143985|IndianYd75|9143988|IndianYd62|91439523|9143985307444408|IndianYard|914398414616029|SearsYard|9144018288036576|Kilometer|01|Centimeter|54e|Mil|0000254|MicroInch|IInch|3047997101815088|GoldCoastFoot|30479947153867626|SearsFoot|3047972651151|ClarkeFoot|3048|IFoot|3048006096012192|Inch|0254000508001016|4374754|39370|3701|63360|id_|LonLat|destinationVincenty|toFixed|NaN|asin|distVincenty|257223563|298|3142|6356752|toPrecision|number|toFloat|toElement|mouseLeft|nodeValue|firstChild|getXmlNodeValue|images|theme|getImagesLocation|urlAppend|toUpperCase|upperCaseObject|olAlphaImg|createAlphaImageDiv|sizingMethod|AlphaImageLoader|Microsoft|DXImageTransform|progid|scale|inline|_innerImage|filters|MSIE|appVersion|addClass|urls|removeClass|no|galleryImg|alt|error|load|relative|img|backgroundImage|border|splice|removeItem|nodeType|isElement|getElementById|getElement|reset|Class|getAttribute|getElementsByTagName|js|Include|RegExp|Release|VERSION_NUMBER'.split('|'),0,{}))

	eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('N.6K={Y7:Q(b,a){R(b.2S(a)==0)},c1:Q(b,a){R(b.2S(a)!=-1)},kJ:Q(a){R a.4D(/^\\s\\s*/,"").4D(/\\s\\s*$/,"")},yY:Q(f){O d=f.4U("-");O b=d[0];1h(O c=1,a=d.1a;c<a;c++){O e=d[c];b+=e.dU(0).hy()+e.aU(1)}R b},5L:Q(d,c,a){if(!c){c=2k}O b=Q(j,e){O h;O g=e.4U(/\\.+/);1h(O f=0;f<g.1a;f++){if(f==0){h=c}h=h[g[f]]}if(2t h==="Q"){h=a?h.1j(P,a):h()}if(2t h=="2q"){R"2q"}V{R h}};R d.4D(N.6K.Lm,b)},Lm:/\\$\\{([\\w.]+?)\\}/g,Ll:/^([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?\\d+))?$/,Lk:Q(a){R N.6K.Ll.d1(a)},Y6:Q(a){R N.6K.Lk(a)?3t(a):a}};N.6r={Li:".",Lj:",",l7:Q(a,c){O b=0;if(c>0){b=3t(a.Y5(c))}R b},5L:Q(c,a,g,i){a=(2t a!="2q")?a:0;g=(2t g!="2q")?g:N.6r.Lj;i=(2t i!="2q")?i:N.6r.Li;if(a!=P){c=3t(c.l1(a))}O b=c.7r().4U(".");if(b.1a===1&&a==P){a=0}O d=b[0];if(g){O e=/(-?[0-9]+)([0-9]{3})/;4W(e.d1(d)){d=d.4D(e,"$1"+g+"$2")}}O f;if(a==0){f=d}V{O h=b.1a>1?b[1]:"0";if(a!=P){h=h+S 3Q(a-h.1a+1).6b("0")}f=d+i+h}R f}};if(!6r.1g.l7){6r.1g.l7=Q(a){R N.6r.l7(K,a)}}N.2u={3E:Q(c,b){O a=3Q.1g.9D.1j(1r,[2]);R Q(){O d=a.b1(3Q.1g.9D.1j(1r,[0]));R c.1j(b,d)}},59:Q(b,a){R Q(c){R b.4g(a,c||2k.b7)}},i3:Q(){R 1b},qk:Q(){R 1d},Y4:Q(){}};N.3Q={4V:Q(g,f,b){O d=[];if(3Q.1g.4V){d=g.4V(f,b)}V{O a=g.1a;if(2t f!="Q"){7z S hS()}1h(O c=0;c<a;c++){if(c in g){O e=g[c];if(f.4g(b,e,c,g)){d.1w(e)}}}}R d}};N.1U=N.1z({1s:P,1L:P,1I:P,1t:P,hd:P,1o:Q(d,a,b,c){if(N.1c.4f(d)){c=d[3];b=d[2];a=d[1];d=d[0]}K.1s=d!=P?N.1c.cQ(d):K.1s;K.1L=a!=P?N.1c.cQ(a):K.1L;K.1I=b!=P?N.1c.cQ(b):K.1I;K.1t=c!=P?N.1c.cQ(c):K.1t},1T:Q(){R S N.1U(K.1s,K.1L,K.1I,K.1t)},3w:Q(b){O a=1b;if(b!=P){a=((K.1s===b.1s)&&(K.1I===b.1I)&&(K.1t===b.1t)&&(K.1L===b.1L))}R a},7r:Q(){R[K.1s,K.1L,K.1I,K.1t].6b(",")},Y3:Q(a){if(a===1d){R[K.1L,K.1s,K.1t,K.1I]}V{R[K.1s,K.1L,K.1I,K.1t]}},Y2:Q(b,e){if(b==P){b=6}O g=1k.2Y(10,b);O f=1k.2w(K.1s*g)/g;O d=1k.2w(K.1L*g)/g;O c=1k.2w(K.1I*g)/g;O a=1k.2w(K.1t*g)/g;if(e===1d){R d+","+f+","+a+","+c}V{R f+","+d+","+c+","+a}},fA:Q(){R S N.1f.3T([S N.1f.4s([S N.1f.1D(K.1s,K.1L),S N.1f.1D(K.1I,K.1L),S N.1f.1D(K.1I,K.1t),S N.1f.1D(K.1s,K.1t)])])},3L:Q(){R(K.1I-K.1s)},4y:Q(){R(K.1t-K.1L)},5c:Q(){R S N.2M(K.3L(),K.4y())},vI:Q(){R S N.2B((K.1s+K.1I)/2,(K.1L+K.1t)/2)},5P:Q(){if(!K.hd){K.hd=S N.3i((K.1s+K.1I)/2,(K.1L+K.1t)/2)}R K.hd},3D:Q(e,c){e=e?e:1;if(c==P){c=K.5P()}O a,h;if(c.1p==="N.3i"){a=c.1P;h=c.1R}V{a=c.x;h=c.y}O g=(K.1s-a)*e+a;O b=(K.1L-h)*e+h;O d=(K.1I-a)*e+a;O f=(K.1t-h)*e+h;R S N.1U(g,b,d,f)},3p:Q(a,b){if((a==P)||(b==P)){7z S hS("1U.3p yW yV P yU")}R S N.1U(K.1s+a,K.1L+b,K.1I+a,K.1t+b)},1K:Q(a){O b=P;if(a){5U(a.1p){1N"N.3i":b=S N.1U(a.1P,a.1R,a.1P,a.1R);1F;1N"N.1f.1D":b=S N.1U(a.x,a.y,a.x,a.y);1F;1N"N.1U":b=a;1F}if(b){K.hd=P;if((K.1s==P)||(b.1s<K.1s)){K.1s=b.1s}if((K.1L==P)||(b.1L<K.1L)){K.1L=b.1L}if((K.1I==P)||(b.1I>K.1I)){K.1I=b.1I}if((K.1t==P)||(b.1t>K.1t)){K.1t=b.1t}}}},eI:Q(f,c){if(2t c==="yK"){c={aS:c}}c=c||{};O d=K.c1(f.1P,f.1R,c.aS),e=c.dm;if(e&&!d){O g=e.3L();O a=(e.1s+e.1I)/2;O b=1k.2w((f.1P-a)/g);d=K.eI({1P:f.1P-b*g,1R:f.1R},{aS:c.aS})}R d},Y1:Q(b,a){R K.c1(b.x,b.y,a)},c1:Q(b,d,a){if(a==P){a=1d}if(b==P||d==P){R 1b}b=N.1c.cQ(b);d=N.1c.cQ(d);O c=1b;if(a){c=((b>=K.1s)&&(b<=K.1I)&&(d>=K.1L)&&(d<=K.1t))}V{c=((b>K.1s)&&(b<K.1I)&&(d>K.1L)&&(d<K.1t))}R c},9R:Q(a,m){if(2t m==="yK"){m={aS:m}}m=m||{};if(m.dm){O l=K.5C(m.dm);a=a.5C(m.dm)}V{l=K}if(m.aS==P){m.aS=1d}O h=1b;O i=(l.1s===a.1I||l.1I===a.1s||l.1t===a.1L||l.1L===a.1t);if(m.aS||!i){O j=(((a.1L>=l.1L)&&(a.1L<=l.1t))||((l.1L>=a.1L)&&(l.1L<=a.1t)));O k=(((a.1t>=l.1L)&&(a.1t<=l.1t))||((l.1t>a.1L)&&(l.1t<a.1t)));O d=(((a.1s>=l.1s)&&(a.1s<=l.1I))||((l.1s>=a.1s)&&(l.1s<=a.1I)));O c=(((a.1I>=l.1s)&&(a.1I<=l.1I))||((l.1I>=a.1s)&&(l.1I<=a.1I)));h=((j||k)&&(d||c))}if(m.dm&&!h){O g=m.dm;O b=g.3L();O f=!g.bg(l);O e=!g.bg(a);if(f&&!e){a=a.3p(-b,0);h=l.9R(a,{aS:m.aS})}V{if(e&&!f){l=l.3p(-b,0);h=a.9R(l,{aS:m.aS})}}}R h},bg:Q(g,b,a){if(b==P){b=1b}if(a==P){a=1d}O c=K.c1(g.1s,g.1L,a);O d=K.c1(g.1I,g.1L,a);O f=K.c1(g.1s,g.1t,a);O e=K.c1(g.1I,g.1t,a);R(b)?(c||d||f||e):(c&&d&&f&&e)},BJ:Q(c){O b="";O a=K.5P();b+=(c.1R<a.1R)?"b":"t";b+=(c.1P<a.1P)?"l":"r";R b},3K:Q(d,b){K.hd=P;O e=N.3g.3K({x:K.1s,y:K.1L},d,b);O a=N.3g.3K({x:K.1I,y:K.1L},d,b);O c=N.3g.3K({x:K.1s,y:K.1t},d,b);O f=N.3g.3K({x:K.1I,y:K.1t},d,b);K.1s=1k.4v(e.x,c.x);K.1L=1k.4v(e.y,a.y);K.1I=1k.3f(a.x,f.x);K.1t=1k.3f(c.y,f.y);R K},5C:Q(a,c){c=c||{};O e=c.Kk||0;O b=c.Kl||0;O g=K.1T();if(a){O d=a.3L();4W(g.1s<a.1s&&g.1I-b<=a.1s){g=g.3p(d,0)}4W(g.1s+e>=a.1I&&g.1I>a.1I){g=g.3p(-d,0)}O f=g.1s+e;if(f<a.1I&&f>a.1s&&g.1I-b>a.1I){g=g.3p(-d,0)}}R g},3P:Q(){O a={aW:{x:K.1I,y:K.1t},9B:{x:K.1s,y:K.1L},1s:K.1s,1I:K.1I,1t:K.1t,1L:K.1L};R a},1m:Q(){K.1s=P;K.1I=P;K.1t=P;K.1L=P;K.hd=P},1p:"N.1U"});N.1U.Lg=Q(c,b){O a=c.4U(",");R N.1U.yX(a,b)};N.1U.yX=Q(b,a){R a===1d?S N.1U(b[1],b[0],b[3],b[2]):S N.1U(b[0],b[1],b[2],b[3])};N.1U.Y0=Q(a){R S N.1U(0,a.h,a.w,0)};N.1U.BI=Q(a){O b="";b+=(a.dU(0)==="t")?"b":"t";b+=(a.dU(1)==="l")?"r":"l";R b};N.8j={yZ:(Q(){if("yZ"in 8j.1g){R Q(b){R b.yZ()}}V{Q a(c,b){O d=c+"";4W(d.1a<b){d="0"+d}R d}R Q(b){O c;if(2x(b.dO())){c="XZ 8j"}V{c=b.XY()+"-"+a(b.XX()+1,2)+"-"+a(b.XW(),2)+"T"+a(b.XV(),2)+":"+a(b.XU(),2)+":"+a(b.XT(),2)+"."+a(b.XS(),3)+"Z"}R c}}})(),XR:Q(j){O b;O h=j.es(/^(?:(\\d{4})(?:-(\\d{2})(?:-(\\d{2}))?)?)?(?:(?:T(\\d{1,2}):(\\d{2}):(\\d{2}(?:\\.\\d+)?)(Z|(?:[+-]\\d{1,2}(?::(\\d{2}))?)))|Z)?$/);if(h&&(h[1]||h[7])){O k=2g(h[1],10)||0;O i=(2g(h[2],10)-1)||0;O m=2g(h[3],10)||1;b=S 8j(8j.XQ(k,i,m));O l=h[7];if(l){O n=2g(h[4],10);O d=2g(h[5],10);O a=3t(h[6]);O o=a|0;O c=1k.2w(ib*(a-o));b.XP(n,d,o,c);if(l!=="Z"){O g=2g(l,10);O f=2g(h[8],10)||0;O e=-ib*(60*(g*60)+f*60);b=S 8j(b.dO()+e)}}}V{b=S 8j("Ld")}R b}};N.2I={6I:Q(a){R N.1c.6l(a).W.23!=="2L"},bY:Q(){1h(O c=0,a=1r.1a;c<a;c++){O b=N.1c.6l(1r[c]);O d=N.2I.6I(b)?"2L":"";b.W.23=d}},i7:Q(a){a=N.1c.6l(a);a.2V.2T(a)},4y:Q(a){a=N.1c.6l(a);R a.Kx},ii:Q(b,a){if(!b||!b.3M){R 1b}O c=b.3M;R(!!c&&S Lh("(^|\\\\s)"+a+"(\\\\s|$)").d1(c))},54:Q(b,a){if(!b){R}if(!N.2I.ii(b,a)){b.3M+=(b.3M?" ":"")+a}R b},9Y:Q(b,a){if(!N.2I.ii(b,a)){R}O c=b.3M;if(c){b.3M=N.6K.kJ(c.4D(S Lh("(^|\\\\s+)"+a+"(\\\\s+|$)")," "))}R b},XO:Q(b,a){if(N.2I.ii(b,a)){N.2I.9Y(b,a)}V{N.2I.54(b,a)}R b},9r:Q(c,d){c=N.1c.6l(c);O e=P;if(c&&c.W){e=c.W[N.6K.yY(d)];if(!e){if(1Q.iM&&1Q.iM.iL){O b=1Q.iM.iL(c,P);e=b?b.w8(d):P}V{if(c.iN){e=c.iN[N.6K.yY(d)]}}}O a=["1s","1t","1I","1L"];if(2k.qf&&(N.1c.2S(a,d)!==-1)&&(N.2I.9r(c,"2v")==="XN")){e="4i"}}R e==="4i"?P:e},oT:Q(b){O d=1Q.ff.ca||1Q.7n.ca,a=1Q.ff.rI||1Q.7n.rI;O c=b.XM();R{1t:c.1t+a,1I:c.1I+d,1L:c.1L+a,1s:c.1s+d}}};N.3i=N.1z({1P:0,1R:0,1o:Q(b,a){if(N.1c.4f(b)){a=b[1];b=b[0]}K.1P=b?N.1c.cQ(b):K.1P;K.1R=a?N.1c.cQ(a):K.1R},7r:Q(){R("1P="+K.1P+",1R="+K.1R)},uJ:Q(){R(K.1P+","+K.1R)},1T:Q(){R S N.3i(K.1P,K.1R)},3p:Q(b,a){if((b==P)||(a==P)){7z S hS("3i.3p yW yV P yU")}R S N.3i(K.1P+N.1c.cQ(b),K.1R+N.1c.cQ(a))},3w:Q(b){O a=1b;if(b!=P){a=((K.1P===b.1P&&K.1R===b.1R)||(2x(K.1P)&&2x(K.1R)&&2x(b.1P)&&2x(b.1R)))}R a},3K:Q(c,b){O a=N.3g.3K({x:K.1P,y:K.1R},c,b);K.1P=a.x;K.1R=a.y;R K},5C:Q(a){O b=K.1T();if(a){4W(b.1P<a.1s){b.1P+=a.3L()}4W(b.1P>a.1I){b.1P-=a.3L()}}R b},1m:Q(){K.1P=P;K.1R=P},1p:"N.3i"});N.3i.Lg=Q(b){O a=b.4U(",");R S N.3i(a[0],a[1])};N.3i.yX=Q(a){O b=N.1c.4f(a),d=b&&a[0],c=b&&a[1];R S N.3i(d,c)};N.2B=N.1z({x:0,y:0,8N:P,1o:Q(a,c,b){K.x=a?3t(a):K.x;K.y=c?3t(c):K.y;K.8N=b},7r:Q(){R("x="+K.x+",y="+K.y)},1T:Q(){R S N.2B(K.x,K.y,K.8N)},3w:Q(a){O b=1b;if(a!=P){b=((K.x==a.x&&K.y==a.y)||(2x(K.x)&&2x(K.y)&&2x(a.x)&&2x(a.y)))}R b},74:Q(a){R 1k.5r(1k.2Y(K.x-a.x,2)+1k.2Y(K.y-a.y,2))},3p:Q(a,b){if((a==P)||(b==P)){7z S hS("2B.3p yW yV P yU")}R S N.2B(K.x+a,K.y+b)},3e:Q(a){O b=K.1T();if(a){b=K.3p(a.x,a.y)}R b},1m:Q(){K.x=P;K.y=P;K.8N=P},1p:"N.2B"});N.2B.Fq={Fp:"h4",Fo:"XL",Fn:"XK",Fm:"XJ"};N.2M=N.1z({w:0,h:0,1o:Q(a,b){K.w=a?3t(a):K.w;K.h=a?3t(b):K.h},7r:Q(){R("w="+K.w+",h="+K.h)},1T:Q(){R S N.2M(K.w,K.h)},3w:Q(b){O a=1b;if(b!=P){a=((K.w===b.w&&K.h===b.h)||(2x(K.w)&&2x(K.h)&&2x(b.w)&&2x(b.h)))}R a},1m:Q(){K.w=P;K.h=P},1p:"N.2M"});N.8u=N.1z({d7:"",2l:"XI",1o:Q(b,a){K.d7=b?b:K.d7;K.2l=a?a:K.2l},jU:Q(){R K.2l+"="+K.d7},xt:Q(){R K.d7},1m:Q(){K.d7=P;K.2l=P},1p:"N.8u"});N.8u.9C=P;N.rx=N.1z({Lf:10,yT:P,aC:P,rN:P,rM:P,3F:P,mJ:P,6Y:P,rO:1b,1o:Q(a){K.yT=(a)?a:N.cO.rz.mz},3X:Q(c,b,d,a){K.rO=1d;K.aC=c;K.rN=b;K.rM=d;K.3F=a.3F;K.mJ=0;if(K.6Y){2k.rL(K.6Y);K.6Y=P}if(K.3F&&K.3F.3X){K.3F.3X.4g(K,K.aC)}K.6Y=2k.L7(N.2u.3E(K.Le,K),K.Lf)},2K:Q(){if(!K.rO){R}if(K.3F&&K.3F.7c){K.3F.7c.4g(K,K.rN)}2k.rL(K.6Y);K.6Y=P;K.rO=1b},Le:Q(){O g={};1h(O d in K.aC){if(!K.aC.dX(d)){5y}O a=K.aC[d];O e=K.rN[d];if(a==P||e==P||2x(a)||2x(e)){7z S hS("Ld d7 1h rx")}O h=e-a;g[d]=K.yT.1j(K,[K.mJ,a,h,K.rM])}K.mJ++;if(K.3F&&K.3F.yg){K.3F.yg.4g(K,g)}if(K.mJ>K.rM){K.2K()}},1p:"N.rx"});N.cO={1p:"N.cO"};N.cO.Lc={yS:Q(e,a,g,f){R g*e/f+a},mz:Q(e,a,g,f){R g*e/f+a},yR:Q(e,a,g,f){R g*e/f+a},1p:"N.cO.Lc"};N.cO.rz={yS:Q(e,a,g,f){R(e==0)?a:g*1k.2Y(2,10*(e/f-1))+a},mz:Q(e,a,g,f){R(e==f)?a+g:g*(-1k.2Y(2,-10*e/f)+1)+a},yR:Q(e,a,g,f){if(e==0){R a}if(e==f){R a+g}if((e/=f/2)<1){R g/2*1k.2Y(2,10*(e-1))+a}R g/2*(-1k.2Y(2,-10*--e)+2)+a},1p:"N.cO.rz"};N.cO.Lb={yS:Q(e,a,g,f){R g*(e/=f)*e+a},mz:Q(e,a,g,f){R-g*(e/=f)*(e-2)+a},yR:Q(e,a,g,f){if((e/=f/2)<1){R g/2*e*e+a}R-g/2*((--e)*(e-2)-1)+a},1p:"N.cO.Lb"};N.w1=N.1z({L9:0,6Y:10,yO:0.XH,La:4b,gR:cW,5K:2q,3O:2q,1o:Q(a){N.1c.1K(K,a)},aC:Q(){rL(K.3O);K.3O=2q;K.5K=[]},6P:Q(a){K.5K.i9({xy:a,yQ:S 8j().dO()});if(K.5K.1a>K.La){K.5K.9h()}},fP:Q(k){O j,a=S 8j().dO();1h(O f=0,e=K.5K.1a,h;f<e;f++){h=K.5K[f];if(a-h.yQ>K.gR){1F}j=h}if(!j){R}O d=S 8j().dO()-j.yQ;O g=1k.5r(1k.2Y(k.x-j.xy.x,2)+1k.2Y(k.y-j.xy.y,2));O c=g/d;if(c==0||c<K.L9){R}O b=1k.XG((k.y-j.xy.y)/g);if(j.xy.x<=k.x){b=1k.PI-b}R{L8:c,yP:b}},3x:Q(c,j){O i=c.L8;O g=1k.8y(c.yP);O f=-1k.7P(c.yP);O e=0;O d=S 8j().dO();O b=0;O a=0;O h=Q(){if(K.3O==P){R}e+=K.6Y;O q=S 8j().dO()-d;O n=(e+q)/2;O o=(-K.yO*1k.2Y(n,2))/2+i*n;O k=o*g;O r=o*f;O m={};m.fP=1b;O l=-K.yO*n+i;if(l<=0){rL(K.3O);K.3O=P;m.fP=1d}m.x=k-b;m.y=r-a;b=k;a=r;j(m.x,m.y,m.fP)};K.3O=2k.L7(N.2u.3E(h,K),K.6Y)},1p:"N.w1"});N.1H={af:1b,XF:32,XE:8,XD:9,XC:13,XB:27,EI:37,EG:38,EH:39,EF:40,XA:46,2h:Q(a){R a.bw||a.oW},pQ:Q(a){R a.6E&&a.6E.1a===1},qm:Q(a){R a.6E&&a.6E.1a>1},aE:Q(a){R(((a.hR)&&(a.hR===1))||((a.ln)&&(a.ln===1)))},G4:Q(a){R(((a.hR)&&(a.hR===3))||((a.ln)&&(a.ln===2)))},2K:Q(b,a){if(!a){if(b.bv){b.bv()}V{b.FT=1b}}if(b.yw){b.yw()}V{b.Xz=1d}},Xy:Q(c,b){O a=N.1H.2h(c);4W(a.2V&&(!a.yq||(a.yq.hy()!=b.hy()))){a=a.2V}R a},3m:Q(b,d,c,a){O e=N.1c.6l(b);a=a||1b;if(d==="L6"&&(b4.L5.es(/L4|L3|L2/)||e.iT)){d="fh"}if(!K.af){K.af={}}if(!e.mI){O f="Xx";if(e.id){f=e.id+"4n"+f}e.mI=N.1c.7x(f)}O g=e.mI;if(!K.af[g]){K.af[g]=[]}K.af[g].1w({2h:e,2l:d,yN:c,yM:a});if(e.yz){e.yz(d,c,a)}V{if(e.iT){e.iT("on"+d,c)}}},9F:Q(a){O b=N.1c.6l(a);O c=b.mI;K.yL(N.1H.af[c])},yL:Q(e){if(e){1h(O b=e.1a-1;b>=0;b--){O c=e[b];O a=S 3Q(c.2h,c.2l,c.yN,c.yM);O d=N.1H.a3.1j(K,a)}}},a3:Q(h,a,g,b){b=b||1b;O f=N.1c.6l(h);O d=f.mI;if(a==="L6"){if(b4.L5.es(/L4|L3|L2/)||f.rH){a="fh"}}O k=1b;O c=N.1H.af[d];if(c){O e=0;4W(!k&&e<c.1a){O j=c[e];if((j.2l===a)&&(j.yN===g)&&(j.yM===b)){c.6c(e,1);if(c.1a==0){2s N.1H.af[d]}k=1d;1F}e++}}if(k){if(f.yy){f.yy(a,g,b)}V{if(f&&f.rH){f.rH("on"+a,g)}}}R k},L1:Q(){if(N.1H&&N.1H.af){1h(O a in N.1H.af){O b=N.1H.af[a];N.1H.yL.1j(K,[b])}N.1H.af=1b}},1p:"N.1H"};N.1H.3m(2k,"a2",N.1H.L1,1b);N.4l=N.1z({lX:["dx","aL","48","4o","4p","2U","4F","eV","vY","7C","Cp","Xw","8R","9q","eU","fh","we","wd","FL","FK","FJ","FI","vN","j0"],92:P,6q:P,2h:P,mH:P,rK:P,gH:P,dB:1b,fg:P,mG:P,rJ:P,1o:Q(c,e,g,f,b){N.1c.1K(K,b);K.6q=c;K.gH=f;K.92={};K.fg={};K.mG={};K.mH=[];if(g!=P){1h(O d=0,a=g.1a;d<a;d++){K.f9(g[d])}}if(e!=P){K.L0(e)}},1m:Q(){1h(O a in K.fg){if(2t K.fg[a]!=="yK"){K.fg[a].1m()}}K.fg=P;if(K.2h){N.1H.9F(K.2h);if(K.2h.yI){N.1H.a3(2k,"w7",K.rJ)}}K.2h=P;K.92=P;K.6q=P;K.mH=P;K.gH=P;K.rK=P},f9:Q(a){if(!K.92[a]){K.mH.1w(a);K.92[a]=[]}},L0:Q(d){if(K.2h){N.1H.9F(K.2h)}V{K.rK=N.2u.59(K.pe,K);K.rJ=N.2u.3E(K.ry,K)}K.2h=d;1h(O c=0,a=K.lX.1a;c<a;c++){O b=K.lX[c];K.f9(b);N.1H.3m(d,b,K.rK)}N.1H.3m(d,"iA",N.1H.2K)},on:Q(a){1h(O b in a){if(b!=="2y"&&a.dX(b)){K.4N(b,a.2y,a[b])}}},4N:Q(c,f,d,a){if(c in N.4l&&!K.fg[c]){K.fg[c]=S N.4l[c](K)}if((d!=P)&&(N.1c.2S(K.mH,c)!==-1)){if(f==P){f=K.6q}O b=K.92[c];if(!b){b=[];K.92[c]=b;K.mG[c]=0}O e={ea:f,yJ:d};if(a){b.6c(K.mG[c],0,e);if(2t a==="6q"&&a.Xv){K.mG[c]++}}V{b.1w(e)}}},lU:Q(a,c,b){K.4N(a,c,b,1d)},un:Q(a){1h(O b in a){if(b!=="2y"&&a.dX(b)){K.6S(b,a.2y,a[b])}}},6S:Q(d,f,e){if(f==P){f=K.6q}O c=K.92[d];if(c!=P){1h(O b=0,a=c.1a;b<a;b++){if(c[b].ea===f&&c[b].yJ===e){c.6c(b,1);1F}}}},i7:Q(a){if(K.92[a]!=P){K.92[a]=[]}},1M:Q(e,b){O d=K.92[e];if(!d||d.1a==0){R 2q}if(b==P){b={}}b.6q=K.6q;b.2h=K.2h;if(!b.2E){b.2E=e}d=d.9D();O f;1h(O c=0,a=d.1a;c<a;c++){O g=d[c];f=g.yJ.1j(g.ea,[b]);if((f!=2q)&&(f==1b)){1F}}if(!K.gH){N.1H.2K(b,1d)}R f},pe:Q(j){O e=j.2E,f=K.92[e];if(!f||f.1a==0){R}O c=j.6E;if(c&&c[0]){O h=0;O g=0;O d=c.1a;O b;1h(O a=0;a<d;++a){b=c[a];h+=b.aF;g+=b.9Z}j.aF=h/d;j.9Z=g/d}if(K.dB){j.xy=K.KZ(j)}K.1M(e,j)},ry:Q(){K.2h.mF=P;K.2h.h4=P;O a=1Q.7n;if(a&&!((a.rI!=0||a.ca!=0)&&b4.i1.es(/Xu/i))){K.2h.iP=P}},KZ:Q(a){if(!K.dB){K.ry()}V{if(!K.2h.yI){N.1H.3m(2k,"w7",K.rJ);K.2h.yI=1d}}if(!K.2h.mF){O b=N.1c.Xt();K.2h.mF=[b.ca,b.rI]}if(!K.2h.h4){K.2h.h4=[(1Q.ff.Xs||0),(1Q.ff.Xr||0)]}if(!K.2h.iP){K.2h.iP=N.1c.vv(K.2h)}R S N.2B((a.aF+K.2h.mF[0])-K.2h.iP[0]-K.2h.h4[0],(a.9Z+K.2h.mF[1])-K.2h.iP[1]-K.2h.h4[1])},1p:"N.4l"});N.cP={KY:{6p:"bO",1B:2k.ir.9l,rC:1d,nw:2q,nx:2q,3J:P,jx:N.KX,ae:{},57:P,3n:Q(){},6H:P,5W:P,2y:P},KW:/([^:]*:)\\/\\/([^:]*:?[^@]*@)?([^:\\/\\?]*):?([^\\/\\?]*)/,1n:S N.4l(K,P,["bq","6H","5W"]),hc:Q(d){O g=N.1c.1K(K.KY,{jx:N.KX});d=N.1c.4I(d,g);O f=S N.cP.jv();O a=N.1c.xr(d.1B,N.1c.iu(d.3J||{}));O i=!(a.2S("6s")==0);O b=!i&&a.es(K.KW);if(b){O j=2k.ir;i=b[1]===j.c4&&b[3]===j.Xq;O e=b[4],c=j.Xp;if(e!==80&&e!=""||c!=="80"&&c!=""){i=i&&e===c}}if(!i){if(d.jx){if(2t d.jx==="Q"){a=d.jx(a)}V{a=d.jx+Xo(a)}}}f.mE(d.6p,a,d.rC,d.nw,d.nx);1h(O h in d.ae){f.rG(h,d.ae[h])}if(d.rF!=P){f.KM(d.rF)}O l=K.1n;O k=K;f.bs=Q(){if(f.7a===N.cP.jv.ha){O m=l.1M("bq",{8m:f,yH:d,KV:a});if(m!==1b){k.KU({8m:f,yH:d,KV:a})}}};if(d.rC===1b){f.rE(d.57)}V{2k.6u(Q(){if(f.7a!==0){f.rE(d.57)}},0)}R f},KU:Q(d){O e=d.8m;O c=d.yH;O a=(c.2y)?N.2u.3E(c.3n,c.2y):c.3n;O f;if(c.6H){f=(c.2y)?N.2u.3E(c.6H,c.2y):c.6H}O b;if(c.5W){b=(c.2y)?N.2u.3E(c.5W,c.2y):c.5W}if(N.1c.Xn(c.1B).c4==="Hs:"&&e.hw){e.b2=cW}a(e);if(!e.b2||(e.b2>=cW&&e.b2<e8)){K.1n.1M("6H",d);if(f){f(e)}}if(e.b2&&(e.b2<cW||e.b2>=e8)){K.1n.1M("5W",d);if(b){b(e)}}},bO:Q(a){a=N.1c.1K(a,{6p:"bO"});R N.cP.hc(a)},hj:Q(a){a=N.1c.1K(a,{6p:"hj"});a.ae=a.ae?a.ae:{};if(!("KT-KS"in N.1c.qS(a.ae))){a.ae["mB-fC"]="yB/mA"}R N.cP.hc(a)},jB:Q(a){a=N.1c.1K(a,{6p:"jB"});a.ae=a.ae?a.ae:{};if(!("KT-KS"in N.1c.qS(a.ae))){a.ae["mB-fC"]="yB/mA"}R N.cP.hc(a)},bK:Q(a){a=N.1c.1K(a,{6p:"bK"});R N.cP.hc(a)},KR:Q(a){a=N.1c.1K(a,{6p:"KR"});R N.cP.hc(a)},KQ:Q(a){a=N.1c.1K(a,{6p:"KQ"});R N.cP.hc(a)}};(Q(){O g=2k.jv;O a=!!2k.Xm;O j=!!2k.1Q.oQ;O k=j&&2k.b4.i1.es(/Xl 7.0/);Q d(){K.7p=g&&!k?S g:S 2k.KH("kT.Xk");K.jw=[]}Q c(){R S d}c.1g=d.1g;if(a&&g.yG){c.yG=g.yG}c.hb=0;c.mC=1;c.yF=2;c.yE=3;c.ha=4;c.1g.hb=c.hb;c.1g.mC=c.mC;c.1g.yF=c.yF;c.1g.yE=c.yE;c.1g.ha=c.ha;c.1g.7a=c.hb;c.1g.hw="";c.1g.yp=P;c.1g.b2=0;c.1g.yo="";c.1g.Xj="Ji";c.1g.bs=P;c.bs=P;c.yD=P;c.yC=P;c.yA=P;c.1g.mE=Q(q,m,o,s,p){O l=q.eb();if(l==="su"||l==="Xi"||l==="Xh"){7z S g3(18)}2s K.mD;if(1r.1a<3){o=1d}K.KK=o;O n=K;O r=K.7a;O t=P;if(j&&o){t=Q(){if(r!==c.ha){e(n);n.o4()}};2k.iT("KP",t)}if(c.yD){c.yD.1j(K,1r)}if(1r.1a>4){K.7p.mE(q,m,o,s,p)}V{if(1r.1a>3){K.7p.mE(q,m,o,s)}V{K.7p.mE(q,m,o)}}K.7a=c.mC;b(K);K.7p.bs=Q(){if(a&&!o){R}n.7a=n.7p.7a;h(n);if(n.yv){n.7a=c.hb;R}if(n.7a===c.ha){2s n.rD;e(n);if(j&&o){2k.rH("KP",t)}if(r!==n.7a){b(n)}r=n.7a}}};c.1g.rE=Q(l){if(c.yC){c.yC.1j(K,1r)}if(!1r.1a){l=P}if(l&&l.Ic){l=2k.KO?S 2k.KO().Xg(l):l.mA;if(!K.mD["mB-fC"]){K.7p.rG("mB-fC","yB/mA")}}K.rD=l;f(K)};c.1g.o4=Q(){if(c.yA){c.yA.1j(K,1r)}if(K.7a>c.hb){K.yv=1d}K.7p.o4();e(K);K.7a=c.hb;2s K.rD};c.1g.KN=Q(){R K.7p.KN()};c.1g.yr=Q(l){R K.7p.yr(l)};c.1g.rG=Q(l,m){if(!K.mD){K.mD={}}K.mD[l]=m;R K.7p.rG(l,m)};c.1g.KM=Q(l){if("rF"in K.7p){K.7p.rF=!!l;R 1d}R 1b};c.1g.yz=Q(o,n,m){1h(O l=0,p;p=K.jw[l];l++){if(p[0]===o&&p[1]===n&&p[2]===m){R}}K.jw.1w([o,n,m])};c.1g.yy=Q(o,n,m){1h(O l=0,p;p=K.jw[l];l++){if(p[0]===o&&p[1]===n&&p[2]===m){1F}}if(p){K.jw.6c(l,1)}};c.1g.KJ=Q(m){O n={2E:m.2E,bw:K,Xf:K,Xe:2,yu:m.yu,yt:m.yt,ys:m.ys,yw:Q(){},bv:Q(){},Xd:Q(){}};if(n.2E==="KI"&&K.bs){(K.bs.KL||K.bs).1j(K,[n])}1h(O l=0,o;o=K.jw[l];l++){if(o[0]===n.2E&&!o[2]){(o[1].KL||o[1]).1j(K,[n])}}};c.1g.7r=Q(){R"[6q jv]"};c.7r=Q(){R"[jv]"};Q f(l){l.7p.rE(l.rD);if(a&&!l.KK){l.7a=c.mC;h(l);4W(l.7a<c.ha){l.7a++;b(l);if(l.yv){R}}}}Q b(l){if(c.bs){c.bs.1j(l)}l.KJ({2E:"KI",yu:1b,yt:1b,ys:S 8j+0})}Q i(n){O m=n.yp;O l=n.hw;if(j&&l&&m&&!m.ff&&n.yr("mB-fC").es(/[^\\/]+\\/[^\\+]+\\+mA/)){m=S 2k.KH("kT.Xc");m.rC=1b;m.Xb=1b;m.Xa(l)}if(m){if((j&&m.X9!==0)||!m.ff||(m.ff&&m.ff.yq==="X8")){R P}}R m}Q h(l){bu{l.hw=l.7p.hw}bt(m){}bu{l.yp=i(l.7p)}bt(m){}bu{l.b2=l.7p.b2}bt(m){}bu{l.yo=l.7p.yo}bt(m){}}Q e(l){l.7p.bs=S 2k.2u}if(!2k.2u.1g.1j){2k.2u.1g.1j=Q(l,m){if(!m){m=[]}l.yn=K;l.yn(m[0],m[1],m[2],m[3],m[4]);2s l.yn}}N.cP.jv=c})();N.3g=N.1z({81:P,hv:P,ym:/\\+8x=[^\\+]*/,1o:Q(b,a){N.1c.1K(K,a);K.hv=b;if(2k.rA){K.81=S rA.X7(b)}},7K:Q(){R K.81?K.81.X6:K.hv},bU:Q(){R K.81?K.81.2N:P},7r:Q(){R K.7K()},3w:Q(a){O e=a,b=1b;if(e){if(!(e 1W N.3g)){e=S N.3g(e)}if(2k.rA&&K.81.rB&&e.81.rB){b=K.81.rB.4D(K.ym,"")===e.81.rB.4D(K.ym,"")}V{if(e.7K){O c=K.7K(),d=e.7K();b=c===d||!!N.3g.h9[c]&&N.3g.h9[c][d]===N.3g.m5}}}R b},1m:Q(){2s K.81;2s K.hv},1p:"N.3g"});N.3g.h9={};N.3g.js={"4E:9E":{2N:"yl",3b:[-2R,-90,2R,90],yx:1d},"KG:84":{2N:"yl",3b:[-2R,-90,2R,90]},"4E:m0":{2N:"m",3b:[-6F.34,-6F.34,6F.34,6F.34]},"4E:gV":{2N:"m",3b:[-6F.34,-6F.34,6F.34,6F.34]}};N.3g.xl=Q(d,c,b){if(b===N.3g.m5){O a=N.3g.js[d];if(a&&!N.3g.js[c]){N.3g.js[c]=a}}if(!N.3g.h9[d]){N.3g.h9[d]={}}N.3g.h9[d][c]=b};N.3g.3K=Q(a,e,b){if(e&&b){if(!(e 1W N.3g)){e=S N.3g(e)}if(!(b 1W N.3g)){b=S N.3g(b)}if(e.81&&b.81){a=rA.3K(e.81,b.81,a)}V{O d=e.7K();O f=b.7K();O c=N.3g.h9;if(c[d]&&c[d][f]){c[d][f](a)}}}R a};N.3g.m5=Q(a){R a};(Q(){O e=6F.34;Q g(h){h.x=2R*h.x/e;h.y=2R/1k.PI*(2*1k.p7(1k.GV((h.y/e)*1k.PI))-1k.PI/2);R h}Q b(h){h.x=h.x*e/2R;h.y=1k.eR(1k.GW((90+h.y)*1k.PI/ks))/1k.PI*e;R h}Q f(k,h){O r=N.3g.xl;O q=N.3g.m5;O n,o,l,p,m;1h(n=0,o=h.1a;n<o;++n){l=h[n];r(k,l,b);r(l,k,g);1h(m=n+1;m<o;++m){p=h[m];r(l,p,q);r(p,l,q)}}}O a=["4E:m0","4E:gV","4E:GU","4E:GT"],d=["KG:84","Cr:X5:X4:X3:4E:6.6:9E","4E:9E"],c;1h(c=a.1a-1;c>=0;--c){f(a[c],d)}1h(c=d.1a-1;c>=0;--c){f(d[c],a)}})();N.dE=N.1z({bC:{KD:4b,qr:X2,3k:X1,gU:X0,3Y:ib,1v:WZ},2P:["KC","eJ","KB","du","7B","h6","3x","7w","pS","WY","WX","WW","WV","WU","dx","aL","4p","iA","5s","qn","8L"],id:P,iZ:1d,WT:1b,iO:1b,1n:P,fe:1b,1q:P,3S:1b,1G:P,3z:P,lD:P,3o:P,1O:P,3R:P,bJ:P,2b:P,3U:P,7v:P,5d:0,Kv:1.5,bH:0,3c:P,2Q:"4E:9E",2N:"yl",1S:P,4j:P,4k:P,4Q:P,4R:P,3b:P,71:P,5w:P,5G:16,85:P,5E:P,gH:1d,dS:P,2F:P,yh:N.cO.rz.mz,Ku:50,8V:P,82:P,bI:P,q9:S N.2B(0,0),ju:P,jt:P,1o:Q(b,l){if(1r.1a===1&&2t b==="6q"){l=b;b=l&&l.1q}K.3c=S N.2M(N.dE.Kr,N.dE.Kq);K.8V=S N.1U(15,15,15,15);N.1c.1K(K,l);O a=K.2Q 1W N.3g?K.2Q.hv:K.2Q;N.1c.4I(K,N.3g.js[a]);if(K.3b&&!(K.3b 1W N.1U)){K.3b=S N.1U(K.3b)}if(K.71&&!(K.71 1W N.1U)){K.71=S N.1U(K.71)}if(K.5w&&!(K.5w 1W N.1U)){K.5w=S N.1U(K.5w)}if(K.3U&&!(K.3U 1W N.3i)){K.3U=S N.3i(K.3U)}K.1O=[];K.id=N.1c.7x("N.WS");K.1q=N.1c.6l(b);if(!K.1q){K.1q=1Q.2G("1q");K.1q.W.1E="oI";K.1q.W.1A="oI"}K.1q.W.WR="2L";N.2I.54(K.1q,"KE");O k=N.1c.4M();K.1q.W.3G="1B(\'"+k+"wk/FO.wj\'),49";O d=K.id+"WQ";K.3z=N.1c.7m(d,P,P,P,"fW",P,"8C");K.3z.W.1A="4b%";K.3z.W.1E="4b%";K.3z.3M="WP";K.1q.1V(K.3z);O f=1Q.2G("1q");f.id=K.id+"WO";f.W.2v="3d";f.W.1A="4b%";f.W.1E="4b%";f.W.5j=K.bC.1v-1;K.3z.1V(f);K.6v=f;K.1n=S N.4l(K,K.6v,K.2P,K.gH,{dB:1d});d=K.id+"WN";K.3o=N.1c.7m(d);K.3o.W.5j=K.bC.3Y-1;K.kw=N.1c.7m("WM");K.kw.W.5j=K.bC.3k-1;K.3o.1V(K.kw);K.6v.1V(K.3o);K.dR();if(K.2F 1W 78){K.1n.on(K.2F)}K.1n.4N("h6",K,K.dR);K.my=N.2u.3E(K.dR,K);N.1H.3m(2k,"7C",K.my);if(K.85){O e=1d;O c=1Q.kV("KF");1h(O g=0,h=c.1a;g<h;++g){if(N.1c.HQ(c.WL(g).9l,K.85)){e=1b;1F}}if(e){O j=1Q.2G("KF");j.c2("WK","WJ");j.c2("2E","99/WI");j.c2("9l",K.85);1Q.kV("WH")[0].1V(j)}}if(K.3R==P){if(N.1v!=P){K.3R=[S N.1v.vU(),S N.1v.iF(),S N.1v.uW()]}V{K.3R=[]}}1h(O g=0,h=K.3R.1a;g<h;g++){K.yi(K.3R[g])}K.bJ=[];K.gG=N.2u.3E(K.1m,K);N.1H.3m(2k,"a2",K.gG);if(l&&l.1O){2s K.3U;K.pX(l.1O);if(l.3U&&!K.aG()){K.5X(l.3U,l.5d)}}},d9:Q(a){K.1q=N.1c.6l(a);N.2I.54(K.1q,"KE");K.3z.2V.2T(K.3z);K.1q.1V(K.3z);K.dR()},gG:P,my:P,1m:Q(){if(!K.gG){R 1b}if(K.dS){K.dS.2K();K.dS=P}N.1H.a3(2k,"a2",K.gG);K.gG=P;if(K.my){N.1H.a3(2k,"7C",K.my)}V{K.1n.6S("7C",K,K.dR)}K.8V=P;if(K.3R!=P){1h(O a=K.3R.1a-1;a>=0;--a){K.3R[a].1m()}K.3R=P}if(K.1O!=P){1h(O a=K.1O.1a-1;a>=0;--a){K.1O[a].1m(1b)}K.1O=P}if(K.3z){K.1q.2T(K.3z)}K.3z=P;if(K.2F){K.1n.un(K.2F);K.2F=P}K.1n.1m();K.1n=P},jA:Q(a){O b=K.82&&a.5w!==K.5w;N.1c.1K(K,a);b&&K.2O(K.a9(),K.5d,{yf:1d})},qW:Q(){R K.3c},yj:Q(e,c,a){O d=(2t a.d1==="Q");O b=N.3Q.4V(K[e],Q(f){R f[c]===a||(d&&a.d1(f[c]))});R b},yk:Q(b,a){R K.yj("1O",b,a)},WG:Q(a){R K.yk("2l",a)},WF:Q(a){R K.yk("1p",a)},ka:Q(b,a){R K.yj("3R",b,a)},AU:Q(a){R K.ka("1p",a)},tX:Q(e){O b=P;1h(O d=0,a=K.1O.1a;d<a;d++){O c=K.1O[d];if(c.id===e){b=c;1F}}R b},lP:Q(b,a){if(b 1W N.1C.xo){b.gN(K.bC.gU+a*5)}V{b.gN(K.bC[b.5S?"KD":"qr"]+a*5)}},KA:Q(){1h(O c=0,a=K.1O.1a;c<a;c++){O b=K.1O[c];K.lP(b,c)}},fL:Q(c){1h(O b=0,a=K.1O.1a;b<a;b++){if(K.1O[b]===c){O d=N.bT("WE",{8Y:c.2l});R 1b}}if(K.1n.1M("KC",{1i:c})===1b){R 1b}if(K.fe){c.5S=1b}c.1q.3M="WD";c.1q.W.9M="";K.lP(c,K.1O.1a);K.3o.1V(c.1q);K.1O.1w(c);c.3a(K);if(c.5S||(K.fe&&!K.2b)){if(K.2b==P){K.eL(c)}V{c.eK(1b)}}V{c.3y()}K.1n.1M("eJ",{1i:c});c.1n.1M("Kp",{U:K,1i:c});c.tL();R 1d},pX:Q(c){1h(O b=0,a=c.1a;b<a;b++){K.fL(c[b])}},b6:Q(c,e){if(K.1n.1M("KB",{1i:c})===1b){R}if(e==P){e=1d}K.3o.2T(c.1q);N.1c.am(K.1O,c);c.9O(K);c.U=P;if(K.2b===c){K.2b=P;if(e){1h(O b=0,a=K.1O.1a;b<a;b++){O d=K.1O[b];if(d.5S||K.fe){K.eL(d);1F}}}}K.KA();K.1n.1M("du",{1i:c});c.1n.1M("Ko",{U:K,1i:c})},WC:Q(){R K.1O.1a},qq:Q(a){R N.1c.2S(K.1O,a)},Kz:Q(d,b){O e=K.qq(d);if(b<0){b=0}V{if(b>K.1O.1a){b=K.1O.1a}}if(e!==b){K.1O.6c(e,1);K.1O.6c(b,0,d);1h(O c=0,a=K.1O.1a;c<a;c++){K.lP(K.1O[c],c)}K.1n.1M("7B",{1i:d,bh:"88"});if(K.fe){if(b===0){K.eL(d)}V{if(K.2b!==K.1O[0]){K.eL(K.1O[0])}}}}},WB:Q(b,c){O a=K.qq(b)+c;K.Kz(b,a)},eL:Q(e){if(e!==K.2b){if(N.1c.2S(K.1O,e)!==-1){O b=K.a9();O f=N.1c.h8(K.ti(),e.2N);if(K.2b!=P&&!K.fe){K.2b.eK(1b)}K.2b=e;if(K.1O.1a>1){1h(O d=0,a=K.1O.1a;d<a;d++){if(K.1O[d]!==e){K.1O[d].Kn();K.1O[d].f3&&K.1O[d].f3()}}}K.bH++;if(!K.fe||K.2b.3j){K.2b.eK(1d);if(K.2b.7X===1b){K.2b.3y()}}if(b!=P){O c=K.a5(f||K.7v,1d);K.5X(b,c,1b,1d)}K.1n.1M("8L",{1i:K.2b})}}},kb:Q(b,a){K.3R.1w(b);K.yi(b,a)},AZ:Q(b,g){O e=(1r.1a===1)?[]:g;1h(O d=0,a=b.1a;d<a;d++){O f=b[d];O c=(e[d])?e[d]:P;K.kb(f,c)}},yi:Q(b,a){b.pI=(b.1q!=P);if(K.5E&&!b.5E){b.5E=K.5E}b.3a(K);O c=b.2H(a);if(c){if(!b.pI){c.W.5j=K.bC.1v+K.3R.1a;K.3z.1V(c)}}if(b.98){b.2p()}},nN:Q(e){O b=P;1h(O c=0,a=K.3R.1a;c<a;c++){O d=K.3R[c];if(d.id===e){b=d;1F}}R b},Fs:Q(a){if((a)&&(a===K.nN(a.id))){if(a.1q&&(a.1q.2V===K.3z)){K.3z.2T(a.1q)}N.1c.am(K.3R,a)}},WA:Q(a,d){if(d){1h(O b=K.bJ.1a-1;b>=0;--b){K.lY(K.bJ[b])}}a.U=K;K.bJ.1w(a);O c=a.2H();if(c){c.W.5j=K.bC.3Y+K.bJ.1a;K.3o.1V(c)}},lY:Q(a){N.1c.am(K.bJ,a);if(a.1q){bu{K.3o.2T(a.1q)}bt(b){}}if(a.c8){bu{K.kw.2T(a.c8)}bt(b){}}a.U=P},Wz:Q(){1h(O a=K.bJ.1a-1;a>=0;--a){K.lY(K.bJ[a])}},5c:Q(){O a=P;if(K.1G!=P){a=K.1G.1T()}R a},dR:Q(){O c=K.Ky();if(c&&!2x(c.h)&&!2x(c.w)){K.1n.ry();O f=K.5c();if(f==P){K.1G=f=c}if(!c.3w(f)){K.1G=c;1h(O d=0,b=K.1O.1a;d<b;d++){K.1O[d].de()}O a=K.a9();if(K.2b!=P&&a!=P){O e=K.4G();K.5d=P;K.5X(a,e)}}}},Ky:Q(){O a=S N.2M(K.1q.i2,K.1q.oH);if(a.w==0&&a.h==0||2x(a.w)&&2x(a.h)){a.w=K.1q.Wy;a.h=K.1q.Kx}if(a.w==0&&a.h==0||2x(a.w)&&2x(a.h)){a.w=2g(K.1q.W.1A);a.h=2g(K.1q.W.1E)}R a},9J:Q(a,b){O c=P;if(a==P){a=K.a9()}if(b==P){b=K.2r()}if((a!=P)&&(b!=P)){O d=(K.1G.w*b)/2;O e=(K.1G.h*b)/2;c=S N.1U(a.1P-d,a.1R-e,a.1P+d,a.1R+e)}R c},aG:Q(){O a=P;O b=K.a9();if(b){a=b.1T()}R a},a9:Q(){if(!K.3U&&K.1G){K.3U=K.5n({x:K.1G.w/2,y:K.1G.h/2})}R K.3U},4G:Q(){R K.5d},Kw:Q(){if(K.1O===P){R 1d}O d=1d;1h(O c=0,e=K.1O,a=e.1a;c<a;c++){O b=e[c];if(b.mg){d=1b;1F}}R d},6X:Q(d,c,e){e=N.1c.4I(e,{lJ:1d,3S:1b});if(e.3S){if((d!=0||c!=0)&&K.Kw()){K.aB(d,c)}}V{O f=K.8c(K.a9());O b=f.3p(d,c);if(K.3S||!b.3w(f)){O a=K.5n(b);if(e.lJ){K.vB(a)}V{K.2O(a);if(K.3S){K.3S=1b}K.1n.1M("7w",{})}}}},vB:Q(d){if(K.yh&&K.42().3D(K.Kv).eI(d)){if(!K.dS){K.dS=S N.rx(K.yh)}O a=K.a9();if(d.3w(a)){R}O f=K.dg(a);O e=K.dg(d);O b={x:e.x-f.x,y:e.y-f.y};O c={x:0,y:0};K.dS.3X({x:0,y:0},b,K.Ku,{3F:{yg:N.2u.3E(Q(h){O g=h.x-c.x,i=h.y-c.y;K.aB(g,i);c.x=1k.2w(h.x);c.y=1k.2w(h.y)},K),7c:N.2u.3E(Q(g){K.2O(d);K.3S=1b;K.1n.1M("7w",{})},K)}})}V{K.5X(d)}},5X:Q(c,a,b,d){K.dS&&K.dS.2K();K.2O(c,a,{3S:b,yf:d})},aB:Q(o,n){O h=K.1G.w/2;O c=K.1G.h/2;O l=h+o;O k=c+n;O d=K.2b.5C;O m=0;O j=0;if(K.5w){m=h;j=c;d=1b}o=d||l<=K.bI.x-m&&l>=K.82.x+m?1k.2w(o):0;n=k<=K.bI.y-j&&k>=K.82.y+j?1k.2w(n):0;O b=K.82.x,a=K.bI.x;if(o||n){if(!K.3S){K.3S=1d;K.1n.1M("h6",{})}K.3U=P;if(o){K.3o.W.1s=2g(K.3o.W.1s)-o+"px";K.82.x-=o;K.bI.x-=o;if(d){if(K.bI.x>a){K.bI.x-=(a-b)}if(K.82.x<b){K.82.x+=(a-b)}}}if(n){K.3o.W.1t=2g(K.3o.W.1t)-n+"px";K.82.y-=n;K.bI.y-=n}O f,e,g;1h(e=0,g=K.1O.1a;e<g;++e){f=K.1O[e];if(f.3j&&(f===K.2b||f.7X)){f.aB(o,n);f.1n.1M("3x",{x:o,y:n})}}K.1n.1M("3x",{x:o,y:n})}},Wx:Q(f){O c,a=K.2b.1S,b=K.9i().3L()/K.1G.w;if(K.a6(f)>b){1h(O d=f|0,e=a.1a;d<e;++d){if(a[d]<=b){f=d;1F}}}R f},2O:Q(h,a,e){if(a!=P){a=3t(a);if(!K.iO){a=1k.2w(a)}}if(a!==K.4G()){O b=1d;O u=K.2b.a6(a);if(K.4k!==P&&K.4j!==P){b=((u>=K.4k)&&(u<=K.4j))}V{if(K.4k!==P&&K.4j===P){b=(u>=K.4k)}V{if(K.4k===P&&K.4j!==P){b=(u<=K.4j)}}}if(K.ju!==P&&K.jt!==P){b=((a>=K.ju)&&(a<=K.jt))}V{if(K.ju!==P&&K.jt===P){b=a>=K.ju}V{if(K.ju===P&&K.jt!==P){b=a<=K.jt}}}if(!b){R}}if(h!=P&&!(h 1W N.3i)){h=S N.3i(h)}if(!e){e={}}if(K.2b.5C){O m=a;if(a!==m){h=K.aG()}}O p=e.3S||K.3S;O k=e.yf;if(!K.a9()&&!K.ye(h)){h=K.3b.5P();K.3U=h.1T()}if(K.5w!=P){if(h==P){h=K.3U}if(a==P){a=K.4G()}if(a<K.gY(K.5w,1d)){a=K.gY(K.5w,1d)}O q=K.a6(a);O n=K.9J(h,q);if(!K.5w.bg(n)){O x=K.5w.5P();if(n.3L()>K.5w.3L()){h=S N.3i(x.1P,h.1R)}V{if(n.1s<K.5w.1s){h=h.3p(K.5w.1s-n.1s,0)}V{if(n.1I>K.5w.1I){h=h.3p(K.5w.1I-n.1I,0)}}}if(n.4y()>K.5w.4y()){h=S N.3i(h.1P,x.1R)}V{if(n.1L<K.5w.1L){h=h.3p(0,K.5w.1L-n.1L)}V{if(n.1t>K.5w.1t){h=h.3p(0,K.5w.1t-n.1t)}}}}}O l=k||((K.yd(a))&&(a!==K.4G()));O g=(K.ye(h))&&(!h.3w(K.3U));if(l||g||p){p||K.1n.1M("h6",{aA:l});if(g){if(!l&&K.3U){K.Kt(h)}K.3U=h.1T()}O y=l?K.a6(a):K.2r();if(l||K.lD==P){K.lD=K.a9();K.3o.W.1s="bk";K.3o.W.1t="bk";O o=K.9i();O d=o.5P();O j=K.3U.1P-d.1P;O c=d.1R-K.3U.1R;O v=1k.2w(o.3L()/y);O t=1k.2w(o.4y()/y);K.82={x:(K.1G.w-v)/2-j/y,y:(K.1G.h-t)/2-c/y};K.bI={x:K.82.x+1k.2w(o.3L()/y),y:K.82.y+1k.2w(o.4y()/y)}}if(l){K.5d=a;K.7v=y;K.bH++}O f=K.42();if(K.2b.3j){K.2b.2O(f,l,e.3S);e.3S||K.2b.1n.1M("7w",{aA:l})}f=K.2b.42();1h(O r=K.1O.1a-1;r>=0;--r){O w=K.1O[r];if(w!==K.2b&&!w.5S){O b=w.c6();if(w.7X!==b){w.7X=b;if(!b){w.23(1b)}K.1n.1M("7B",{1i:w,bh:"3j"})}if(b&&w.3j){w.2O(f,l,e.3S);e.3S||w.1n.1M("7w",{aA:l})}}}K.1n.1M("3x",{aA:l});p||K.1n.1M("7w",{aA:l});if(l){1h(O r=0,s=K.bJ.1a;r<s;r++){K.bJ[r].ty()}K.1n.1M("pS",{})}}},Kt:Q(c){O d=K.8c(K.lD);O g=K.8c(c);if((d!=P)&&(g!=P)){O a=2g(K.3o.W.1s);O b=2g(K.3o.W.1t);O f=1k.2w(d.x-g.x);O e=1k.2w(d.y-g.y);K.3o.W.1s=f+"px";K.3o.W.1t=e+"px";O i=a-f;O h=b-e;K.82.x-=i;K.bI.x-=i;K.82.y-=h;K.bI.y-=h}},yd:Q(a){R((a!=P)&&(a>=0)&&(a<K.9p()))},ye:Q(d){O c=1b;if(d!=P){O a=K.9i();O b=K.2b.5C&&a;c=a.eI(d,{dm:b})}R c},bA:Q(){O a=K.5Y();R a?a.7K():P},5Y:Q(){O a=P;if(K.2b!=P){a=K.2b.2Q}R a},Ww:Q(){O a=P;if(K.2b!=P){a=K.2b.4j}R a},9i:Q(b){O a=P;if(b&&b.yc&&K.5w){a=K.5w}V{if(K.2b!=P){a=K.2b.3b}}R a},9p:Q(){O a=P;if(K.2b!=P){a=K.2b.5G}R a},42:Q(){O a=P;if(K.2b!=P){a=K.2b.42()}R a},2r:Q(){O a=P;if(K.2b!=P){a=K.2b.2r()}V{if(K.fe===1d&&K.1O.1a>0){a=K.1O[0].2r()}}R a},bU:Q(){O a=P;if(K.2b!=P){a=K.2b.2N}R a},ti:Q(){O c=P;if(K.2b!=P){O b=K.2r();O a=K.2b.2N;if(K.2b.4r){c=N.1c.f5(b,K.2b.4r,a,K.2b.58)}V{c=N.1c.mx(b,a);if(c){c=1/c}}}R c},gY:Q(c,b){O a=P;if(K.2b!=P){a=K.2b.gY(c,b)}R a},a6:Q(b){O a=P;if(K.2b){a=K.2b.a6(b)}R a},a5:Q(a,c){O b=P;if(K.2b!=P){b=K.2b.a5(a,c)}R b},gz:Q(a){if(K.yd(a)){K.5X(P,a)}},eS:Q(){K.gz(K.4G()+1)},cD:Q(){K.gz(K.4G()-1)},qc:Q(d,c){if(!(d 1W N.1U)){d=S N.1U(d)}O b=d.5P();if(K.2b.5C){O a=K.9i();d=d.1T();4W(d.1I<d.1s){d.1I+=a.3L()}b=d.5P().5C(a)}K.5X(b,K.gY(d,c))},pK:Q(c){O b=(c)?c.yc:1d;O a=K.9i({yc:b});K.qc(a)},Wv:Q(g,d){O b=N.1c.h8(g,K.2b.2N);O e=(K.1G.w*b)/2;O f=(K.1G.h*b)/2;O a=K.a9();O c=S N.1U(a.1P-e,a.1R-f,a.1P+e,a.1R+f);K.qc(c,d)},5n:Q(a){O b=P;if(K.2b!=P){b=K.2b.5n(a)}R b},8c:Q(b){O a=P;if(K.2b!=P){a=K.2b.8c(b)}R a},6M:Q(a){R K.5n(a)},dg:Q(b){O a=K.8c(b);a.x=1k.2w(a.x);a.y=1k.2w(a.y);R a},Eh:Q(g){O d=g?K.6M(g):(K.a9()||S N.3i(0,0));O e=K.2r();O c=d.3p(-e/2,0);O i=d.3p(e/2,0);O b=d.3p(0,-e/2);O f=d.3p(0,e/2);O h=S N.3g("4E:9E");O a=K.5Y()||h;if(!a.3w(h)){c.3K(a,h);i.3K(a,h);b.3K(a,h);f.3K(a,h)}R S N.2M(N.1c.uH(c,i),N.1c.uH(b,f))},hZ:Q(d){O c=P;if(d!=P){O b=2g(K.3o.W.1s);O a=2g(K.3o.W.1t);c=d.3p(b,a)}R c},Ks:Q(c){O d=P;if(c!=P){O b=-2g(K.3o.W.1s);O a=-2g(K.3o.W.1t);d=c.3p(b,a);if(2x(d.x)||2x(d.y)){d=P}}R d},g1:Q(a){a=K.hZ(a);R K.5n(a)},bm:Q(b){O a=K.dg(b);R K.Ks(a)},1p:"N.dE"});N.dE.Kr=ex;N.dE.Kq=ex;N.1C=N.1z({id:P,2l:P,1q:P,2J:P,f8:P,r4:1d,2P:["av","7k","Wu","fQ","3x","7w","Kp","Ko","xY"],9s:["3B","1S","4Q","4R","4j","4k","5G","bd"],1n:P,U:P,5S:1b,kR:1b,kA:1d,3j:1d,7X:1b,fX:P,y7:P,2C:P,2F:P,fd:0,2Q:P,2N:P,3B:P,1S:P,3b:P,71:P,4j:P,4k:P,5G:P,4R:P,4Q:P,y8:1b,5C:1b,Wt:{},1o:Q(b,a){K.Km(a);K.2l=b;if(K.id==P){K.id=N.1c.7x(K.1p+"4n");K.1q=N.1c.7m(K.id);K.1q.W.1A="4b%";K.1q.W.1E="4b%";K.1q.Ws="Wr";K.1n=S N.4l(K,K.1q,K.2P);if(K.2F 1W 78){K.1n.on(K.2F)}}if(K.5C){K.y8=1d}},1m:Q(a){if(a==P){a=1d}if(K.U!=P){K.U.b6(K,a)}K.2Q=P;K.U=P;K.2l=P;K.1q=P;K.2C=P;if(K.1n){if(K.2F){K.1n.un(K.2F)}K.1n.1m()}K.2F=P;K.1n=P},Kn:Q(){K.1S=P;K.3B=P},1T:Q(a){if(a==P){a=S N.1C(K.2l,K.8H())}N.1c.4I(a,K);a.U=P;R a},8H:Q(){O a={};1h(O b in K.2C){a[b]=K[b]}R a},Wq:Q(a){if(a!==K.2l){K.2l=a;if(K.U!=P){K.U.1n.1M("7B",{1i:K,bh:"2l"})}}},Km:Q(e,a){if(K.2C==P){K.2C={}}if(e){if(2t e.2Q==="aY"){e.2Q=S N.3g(e.2Q)}if(e.2Q){N.1c.4I(e,N.3g.js[e.2Q.7K()])}if(e.3b&&!(e.3b 1W N.1U)){e.3b=S N.1U(e.3b)}if(e.71&&!(e.71 1W N.1U)){e.71=S N.1U(e.71)}}N.1c.1K(K.2C,e);N.1c.1K(K,e);if(K.2Q&&K.2Q.bU()){K.2N=K.2Q.bU()}if(K.U){O b=K.U.2r();O c=K.9s.b1(["2Q","2N","71","3b"]);1h(O d in e){if(e.dX(d)&&N.1c.2S(c,d)>=0){K.f3();if(a&&K.U.2b===K){K.U.5X(K.U.aG(),K.U.a5(b),1b,1d);K.U.1n.1M("8L",{1i:K})}1F}}}},de:Q(){},3y:Q(){O b=1b;if(K.U){K.7X=K.c6();O c=K.42();if(c&&K.7X&&K.3j){O a=1d;K.2O(c,a,1b);K.1n.1M("7w",{aA:a});b=1d}}R b},2O:Q(b,a,c){O d=K.3j;if(!K.5S){d=d&&K.7X}K.23(d)},aB:Q(b,a){},3a:Q(b){if(K.U==P){K.U=b;K.3b=K.3b||K.U.3b;K.71=K.71||K.U.71;K.2Q=K.2Q||K.U.2Q;if(2t K.2Q==="aY"){K.2Q=S N.3g(K.2Q)}if(!K.2N){K.2N=K.2Q.bU()||K.U.2N}K.f3();if(!K.5S){K.7X=K.c6();O a=((K.3j)&&(K.7X));K.1q.W.23=a?"":"2L"}K.h0()}},tL:Q(){},9O:Q(a){},y6:Q(a){R(K.fX||K.3c)},h0:Q(a){O b=(a)?a:((K.3c)?K.3c:K.U.qW());K.3c=b;if(K.fd){K.y7=S N.2B(-K.fd,-K.fd);K.fX=S N.2M(b.w+(2*K.fd),b.h+(2*K.fd))}},cY:Q(){R K.3j},eK:Q(a){if(a!==K.3j){K.3j=a;if(a){K.r4=1b}K.23(a);K.3y();if(K.U!=P){K.U.1n.1M("7B",{1i:K,bh:"3j"})}K.1n.1M("fQ");K.r4=1d}},23:Q(a){if(a!==(K.1q.W.23!=="2L")){K.1q.W.23=(a&&K.c6())?"i5":"2L"}},c6:Q(){O c=1b;O b=1e-14;if(K.f8){c=1d}V{if(K.U){O a=K.U.2r();c=((a-K.4k>=-b)&&(a-K.4j<=b))}}R c},Wp:Q(a){if(a!==K.5S){K.5S=a;if(K.U!=P){K.U.1n.1M("8L",{1i:K})}}},f3:Q(){O e,a,h;O f={},d=1d;1h(e=0,a=K.9s.1a;e<a;e++){h=K.9s[e];f[h]=K.2C[h];if(d&&K.2C[h]){d=1b}}if(K.f8==P){K.f8=d}if(f.1S==P){f.1S=K.f7(f.3B)}if(f.1S==P){f.1S=K.f6(f)}if(f.1S==P){1h(e=0,a=K.9s.1a;e<a;e++){h=K.9s[e];f[h]=K.2C[h]!=P?K.2C[h]:K.U[h]}if(f.1S==P){f.1S=K.f7(f.3B)}if(f.1S==P){f.1S=K.f6(f)}}O c;if(K.2C.4j&&K.2C.4j!=="4i"){c=K.2C.4j}if(K.2C.4R){c=N.1c.h8(K.2C.4R,K.2N)}O b;if(K.2C.4k&&K.2C.4k!=="4i"){b=K.2C.4k}if(K.2C.4Q){b=N.1c.h8(K.2C.4Q,K.2N)}if(f.1S){f.1S.8J(Q(j,i){R(i-j)});if(!c){c=f.1S[0]}if(!b){O g=f.1S.1a-1;b=f.1S[g]}}K.1S=f.1S;if(K.1S){a=K.1S.1a;K.3B=S 3Q(a);1h(e=0;e<a;e++){K.3B[e]=N.1c.mx(K.1S[e],K.2N)}K.5G=a}K.4k=b;if(b){K.4Q=N.1c.mx(b,K.2N)}K.4j=c;if(c){K.4R=N.1c.mx(c,K.2N)}},f7:Q(d){if(d==P){R}O b,c,a;a=d.1a;b=S 3Q(a);1h(c=0;c<a;c++){b[c]=N.1c.h8(d[c],K.2N)}R b},f6:Q(k){O l,j,g;O m=k.4j;if(k.4R!=P){m=N.1c.h8(k.4R,K.2N)}V{if(m==="4i"&&K.3b!=P){l=K.U.5c();j=K.3b.3L()/l.w;g=K.3b.4y()/l.h;m=1k.3f(j,g)}}O f=k.4k;if(k.4Q!=P){f=N.1c.h8(k.4Q,K.2N)}V{if(k.4k==="4i"&&K.71!=P){l=K.U.5c();j=K.71.3L()/l.w;g=K.71.4y()/l.h;f=1k.3f(j,g)}}if(2t m!=="6n"&&2t f!=="6n"&&K.3b!=P){O n=K.U.qW();m=1k.3f(K.3b.3L()/n.w,K.3b.4y()/n.h)}O a=k.bd;O b=k.5G;if(2t f==="6n"&&2t m==="6n"&&b===2q){O h=m/f;b=1k.a0(1k.eR(h)/1k.eR(2))+1}V{if(b===2q&&a!=P){b=a+1}}if(2t b!=="6n"||b<=0||(2t m!=="6n"&&2t f!=="6n")){R}O d=S 3Q(b);O c=2;if(2t f==="6n"&&2t m==="6n"){c=1k.2Y((m/f),(1/(b-1)))}O e;if(2t m==="6n"){1h(e=0;e<b;e++){d[e]=m/1k.2Y(c,e)}}V{1h(e=0;e<b;e++){d[b-1-e]=f*1k.2Y(c,e)}}R d},2r:Q(){O a=K.U.4G();R K.a6(a)},42:Q(){R K.U.9J()},gY:Q(b,c){O d=K.U.5c();O a;if(K.U&&K.U.5w){a=1k.4v(b.3L()/d.w,b.4y()/d.h)}V{a=1k.3f(b.3L()/d.w,b.4y()/d.h)}R K.a5(a,c)},tE:Q(){},a6:Q(c){c=1k.3f(0,1k.4v(c,K.1S.1a-1));O b;if(K.U.iO){O a=1k.a0(c);O d=1k.mt(c);b=K.1S[a]-((c-a)*(K.1S[a]-K.1S[d]))}V{b=K.1S[1k.2w(c)]}R b},mf:Q(d){O c,b,a;c=K.a6(d);a=K.2N;if(K.4r){b=N.1c.f5(c,K.4r,a,K.58)}V{b=N.1c.mx(c,a)}R b},a5:Q(e,b){if(!e){R 0}O n,f,g;if(K.U.iO){O k=0;O c=K.1S.1a-1;O d=K.1S[k];O a=K.1S[c];O j;1h(f=0,g=K.1S.1a;f<g;++f){j=K.1S[f];if(j>=e){d=j;k=f}if(j<=e){a=j;c=f;1F}}O h=d-a;if(h>0){n=k+((d-e)/h)}V{n=k}}V{O l;O m=6r.uF;1h(f=0,g=K.1S.1a;f<g;f++){if(b){l=1k.3N(K.1S[f]-e);if(l>m){1F}m=l}V{if(K.1S[f]<e){1F}}}n=1k.3f(0,f-1)}R n},5n:Q(b){O d=P;O f=K.U;if(b!=P&&f.82){O c=f.2r();O a=f.9i();O g=(b.x-f.82.x)*c+a.1s;O e=(f.82.y-b.y)*c+a.1t;d=S N.3i(g,e);if(K.5C){d=d.5C(K.3b)}}R d},8c:Q(d){O b=P;if(d!=P){O a=K.U.2r();O c=K.U.42();b=S N.2B((1/a*(d.1P-c.1s)),(1/a*(c.1t-d.1R)))}R b},9N:Q(b){if(b!==K.2J){K.2J=b;if(K.47){K.3y()}V{1h(O d=0,a=K.1q.b8.1a;d<a;++d){O c=K.1q.b8[d].9U||K.1q.b8[d];N.1c.j6(c,P,P,P,P,P,P,b)}}if(K.U!=P){K.U.1n.1M("7B",{1i:K,bh:"2J"})}}},gk:Q(){R K.1q.W.5j},gN:Q(a){K.1q.W.5j=a},Ho:Q(b){if(K.fd){O a=K.fd*K.U.2r();b=S N.1U(b.1s-a,b.1L-a,b.1I+a,b.1t+a)}if(K.5C){O c={Kl:K.2r(),Kk:K.2r()};b=b.5C(K.3b,c)}R b},1p:"N.1C"});N.1l.8t={e6:"e6",sy:"sy",cX:"cX",k0:"k0",rr:"rr",Kj:"Kj",Ki:"Ki",gT:"gT"};N.1l.zS={Kh:"Kh",sj:"sj",Kg:"Kg"};N.1l.Wo={Kf:"Kf",Ke:"Ke"};N.1l.zI={rw:"rw",rn:"rn",Kd:"Kd",ro:"ro",fv:"fv",6B:"6B",Kc:"Kc",Kb:"Kb",rv:"rv"};N.1l.Wn={rw:"rw",fv:"fv",rv:"rv"};N.1l.sq={ss:"ss",jW:"jW"};N.1l.A3={st:"st",Ka:"Ka",K9:"K9",K8:"K8",K7:"K7",K6:"K6",K5:"K5",K4:"K4",K3:"K3",K2:"K2",K1:"K1",K0:"K0",JZ:"JZ"};N.1l.Wm={JY:"JY",JX:"JX",JW:"JW",JV:"JV",JU:"JU",JT:"JT"};N.1l.Wl={JS:"JS",JR:"JR",JQ:"JQ",JP:"JP",JO:"JO"};N.1l.Wk={jW:"jW",JN:"JN",JM:"JM",e6:"e6",JL:"JL",JK:"JK",cX:"cX",JJ:"JJ",JI:"JI",JH:"JH",JG:"JG",JF:"JF",JE:"JE"};N.1l.Wj={JD:"JD",6B:"6B",JC:"JC"};N.1l.Wi={JB:"JB",ru:"ru",rs:"rs"};N.1l.Wh={JA:"JA",Jz:"Jz",ru:"ru",Jy:"Jy",rs:"rs",rl:"rl"};N.1l.Wg={s4:"s4",s3:"s3",s5:"s5",s7:"s7",s2:"s2",s6:"s6"};N.1l.Wf={We:"Wd",Wc:"Wb",Wa:"W9",W8:"W7",W6:"W5",W4:"W3",W2:"W1",W0:"VZ",VY:"VX",VW:"VV",VU:"VT",VS:"VR",VQ:"VP",VO:"VN",VM:"VL",VK:"VJ",VI:"VH",VG:"VF",VD:"VC",VB:"VA",Jx:"Jx",Jw:"Jw",Vz:"Vy",Vx:"Vw",Vv:"Vu",Vt:"Vs",Vr:"Vq"};N.1l.zB={Jv:"Jv",Ju:"Ju",Jt:"Jt",Js:"Js",sf:"sf",Jr:"Jr",Jq:"Jq",Jp:"Jp",Jo:"Jo",Jn:"Jn",Jm:"Jm",Jl:"Jl"};N.1l.Vp={6B:"6B",oO:"oO",oN:"oN",Jk:"Jk",Jj:"Jj"};N.1l.Vo={Ji:"Vn",Vm:"Vl",Vk:"Vj",Vi:"Vh",Vg:"Vf"};N.1l.Ve={Jh:"Jh",rr:"rr",Jg:"Jg",6B:"6B",Jf:"Jf",Je:"Je",Jd:"Jd"};N.1l.Vd={Jc:"Jc",6B:"6B",Jb:"Jb"};N.1l.Vc={Ja:"Ja",6B:"6B",J9:"J9",J8:"J8",J7:"J7"};N.1l.Vb={rq:"rq",J6:"J6",6B:"6B",rp:"rp"};N.1l.Va={J5:"J5",J4:"J4",J3:"J3"};N.1l.V9={J2:"J2",J1:"J1",J0:"J0",rq:"rq",6B:"6B",rp:"rp"};N.1l.V8={IZ:"IZ",IY:"IY"};N.1l.V7={IX:"IX",IW:"IW",ro:"ro",fv:"fv",IV:"IV",dw:"dw",IU:"IU"};N.1l.V6={IT:"IT",IS:"IS"};N.1l.V5={IR:"IR",IQ:"IQ"};N.1l.V4={IP:"IP",IO:"IO",IN:"IN"};N.1l.V3={V2:"3p",dw:"6P",bK:"2s"};N.1l.V1={IM:"IM",IL:"IL",IK:"IK",IJ:"IJ"};N.1l.V0={II:"II",IH:"IH",IG:"IG",6B:"6B"};N.1l.UZ={rn:"rn",mU:"mU",cX:"cX"};N.1l.UY={IF:"IF",IE:"IE"};N.1l.UX={mQ:"mQ",sb:"sb",sc:"sc",ID:"ID"};N.1l.UW={IC:"IC",IB:"IB",IA:"IA",rl:"rl",Iz:"Iz",Iy:"Iy"};N.1l.UV={Ix:"Ix",Iw:"Iw",Iv:"Iv",Iu:"Iu",It:"It",Is:"Is",Ir:"Ir",Iq:"Iq",Ip:"Ip",Io:"Io"};N.1l.UU={In:"In",Im:"Im",6B:"6B",Il:"Il"};N.1l.UT={Ik:"Ik",Ij:"Ij",Ii:"Ii"};N.1l.US={Ih:"Ih",Ig:"Ig",If:"If"};N.1l.UR={Ie:"Ie",Id:"Id"};N.rk=N.1z({1B:P,1G:P,3e:P,h7:P,73:P,px:P,1o:Q(a,b,d,c){K.1B=a;K.1G=(b)?b:S N.2M(20,20);K.3e=d?d:S N.2B(-(K.1G.w/2),-(K.1G.h/2));K.h7=c;O e=N.1c.7x("UQ");K.73=N.1c.8F(e)},1m:Q(){K.jh();N.1H.9F(K.73.9U);K.73.5N="";K.73=P},1T:Q(){R S N.rk(K.1B,K.1G,K.3e,K.h7)},6A:Q(a){if(a!=P){K.1G=a}K.2H()},rg:Q(a){if(a!=P){K.1B=a}K.2H()},2H:Q(a){N.1c.ri(K.73,P,P,K.1G,K.1B,"3d");K.73.W.3G="4m";K.2O(a);R K.73},jh:Q(){if(K.73!=P&&K.73.2V!=P){N.2I.i7(K.73)}},9N:Q(a){N.1c.ri(K.73,P,P,P,P,P,P,P,a)},2O:Q(a){if(a!=P){K.px=a}if(K.73!=P){if(K.px==P){K.23(1b)}V{if(K.h7){K.3e=K.h7(K.1G)}O b=K.px.3e(K.3e);N.1c.ri(K.73,P,b)}}},23:Q(a){K.73.W.23=(a)?"":"2L"},qQ:Q(){O a=(K.73&&K.73.2V&&(K.73.2V.Ic!==11));R a},1p:"N.rk"});N.gU=N.1z({4O:P,5q:P,1n:P,U:P,1o:Q(e,d){O c=K;K.5q=e;O a=(d)?d.1T():N.gU.Ib();if(K.4O==P){K.4O=a}V{K.4O.1B=a.1B;K.4O.1G=a.1G;K.4O.3e=a.3e;K.4O.h7=a.h7}K.1n=S N.4l(K,K.4O.73,["eV"]);O b=N.2u.59(Q(f){if(f.bv){f.bv()}c.1n.1M("eV",f);R 1b},K.1n);N.1H.3m(K.4O.73,"j0",b)},UP:Q(){R K.5q},1m:Q(){K.jh();K.U=P;K.1n.1m();K.1n=P;if(K.4O!=P){K.4O.1m();K.4O=P}},2H:Q(a){R K.4O.2H(a)},jh:Q(){if(K.4O!=P){K.4O.jh()}},2O:Q(a){if((a!=P)&&(K.4O!=P)){K.4O.2O(a)}K.5q=K.U.g1(a)},qQ:Q(){O a=(K.4O&&K.4O.qQ());R a},wK:Q(){O b=1b;if(K.U){O a=K.U.42();b=a.eI(K.5q)}R b},UO:Q(b){if(K.4O){O a=S N.2M(K.4O.1G.w*b,K.4O.1G.h*b);K.4O.6A(a)}},9N:Q(a){K.4O.9N(a)},rg:Q(a){K.4O.rg(a)},23:Q(a){K.4O.23(a)},1p:"N.gU"});N.gU.Ib=Q(){O a=N.1c.4M()+"aP.2Z";O b=S N.2M(21,25);O c=Q(d){R S N.2B(-(d.w/2),-d.h)};R S N.rk(a,b,P,c)};N.3Y=N.1z({1n:P,id:"",5q:P,1q:P,g0:P,1G:P,h5:P,dD:"",2J:"",8S:"",4Z:P,8E:P,6R:P,hP:1b,hO:P,hN:P,5M:"UN",kx:"UM",4A:0,Ia:1b,y9:Q(){if(2t K.4A==="6n"){K.4A=S N.1U(K.4A,K.4A,K.4A,K.4A)}},fY:1b,tz:1b,yb:1b,U:P,1o:Q(g,c,f,b,e,d){if(g==P){g=N.1c.7x(K.1p+"4n")}K.id=g;K.5q=c;K.g0=(f!=P)?f:S N.2M(N.3Y.HY,N.3Y.HX);if(b!=P){K.h5=b}K.dD=N.3Y.HW;K.2J=N.3Y.HV;K.8S=N.3Y.HU;K.1q=N.1c.7m(K.id,P,P,P,P,P,"6I");K.1q.3M=K.5M;O a=K.id+"UL";K.8E=N.1c.7m(a,P,P,P,"fW",P,"6I");O g=K.1q.id+"UK";K.4Z=N.1c.7m(g,P,K.g0.1T(),P,"fW");K.4Z.3M=K.kx;K.8E.1V(K.4Z);K.1q.1V(K.8E);if(e){K.I5(d)}K.I4()},1m:Q(){K.id=P;K.5q=P;K.1G=P;K.h5=P;K.dD=P;K.2J=P;K.8S=P;if(K.yb&&K.U){K.U.1n.6S("h6",K,K.ay)}K.1n.1m();K.1n=P;if(K.6R){N.1H.9F(K.6R);K.8E.2T(K.6R)}K.6R=P;K.1q.2T(K.8E);K.8E=P;if(K.U!=P){K.U.lY(K)}K.U=P;K.1q=P;K.hP=P;K.hO=P;K.hN=P;K.4A=P;K.fY=P},2H:Q(a){if(a==P){if((K.5q!=P)&&(K.U!=P)){a=K.U.bm(K.5q)}}if(K.yb){K.U.1n.4N("h6",K,K.ay)}if(!K.Ia&&N.93.2l==="Cx"){K.U.1n.4N("h6",K,Q(){O b=1Q.iM.iL(K.4Z,P);O c=b.w8("9M");if(c!=="8C"){K.4Z.ya=c;K.4Z.W.9M="8C"}});K.U.1n.4N("7w",K,Q(){O b=K.4Z.ya;if(b){K.4Z.W.9M=b;K.4Z.ya=P}})}K.2O(a);if(!K.hP&&!K.1G){K.6A(K.g0)}K.tw();K.9N();K.tv();K.I9();if(K.fY){K.rj()}R K.1q},ty:Q(){if((K.5q)&&(K.U)){O a=K.U.bm(K.5q);if(a){K.2O(a)}}},2O:Q(a){if((a!=P)&&(K.1q!=P)){K.1q.W.1s=a.x+"px";K.1q.W.1t=a.y+"px"}if((a!=P)&&(K.c8!=P)){K.c8.W.1s=a.x+"px";K.c8.W.1t=a.y+2g(K.1q.W.1E)/3+15+"px"}},6I:Q(){R N.2I.6I(K.1q)},bY:Q(){if(K.6I()){K.ay()}V{K.ev()}},ev:Q(){K.1q.W.23="";if(K.fY){K.rj()}},ay:Q(){if(K.1q){K.1q.W.23="2L"}},6A:Q(c){K.1G=c.1T();O b=K.ky();O a=b.1s+b.1I;O e=b.1t+b.1L;K.y9();a+=K.4A.1s+K.4A.1I;e+=K.4A.1t+K.4A.1L;if(K.6R){O d=2g(K.6R.W.1A);a+=d+b.1I}K.1G.w+=a;K.1G.h+=e;if(N.93.2l==="hz"){K.g0.w+=b.1s+b.1I;K.g0.h+=b.1L+b.1t}if(K.1q!=P){K.1q.W.1A=K.1G.w+"px";K.1q.W.1E=K.1G.h+"px"}if(K.4Z!=P){if(K.hP){K.4Z.W.1A=c.w+7+"px"}V{K.4Z.W.1A=c.w+"px"}K.4Z.W.1E=c.h+"px"}},dR:Q(){O b="<1q UJ=\'"+K.kx+"\'>"+K.4Z.5N+"</1q>";O c=(K.U)?K.U.3o:1Q.7n;O a=N.1c.UI(b,P,{5M:K.5M,UH:c});K.6A(a)},tw:Q(a){if(a!=2q){K.dD=a}if(K.1q!=P){K.1q.W.dD=K.dD}},9N:Q(a){if(a!=2q){K.2J=a}if(K.1q!=P){K.1q.W.2J=K.2J;K.1q.W.4V="kR(2J="+K.2J*4b+")"}},tv:Q(a){if(a!=2q){K.8S=a}if(K.1q!=P){K.1q.W.8S=K.8S}},I9:Q(a){if(a!=P){K.h5=a}if((K.4Z!=P)&&(K.h5!=P)&&(K.h5!=K.4Z.5N)){K.4Z.5N=K.h5;if(K.hP){K.I8();K.dR()}}},I8:Q(){O f=Q(){K.5R.dR();if(K.5R.6I()&&K.5R.fY){K.5R.rj()}N.1H.a3(K.5b,"au",K.5b.UG)};O b=K.4Z.kV("5b");1h(O e=0,a=b.1a;e<a;e++){O c=b[e];if(c.1A==0||c.1E==0){O d={5R:K,5b:c};c.I7=N.2u.3E(f,d);N.1H.3m(c,"au",c.I7)}}},UF:Q(k){O d=k.1T();O i=K.ky();O j=i.1s+i.1I;O g=i.1t+i.1L;K.y9();j+=K.4A.1s+K.4A.1I;g+=K.4A.1t+K.4A.1L;if(K.6R){O c=2g(K.6R.W.1A);j+=c+i.1I}if(K.hO){d.w=1k.3f(d.w,(K.hO.w-j));d.h=1k.3f(d.h,(K.hO.h-g))}if(K.hN){d.w=1k.4v(d.w,(K.hN.w-j));d.h=1k.4v(d.h,(K.hN.h-g))}if(K.U&&K.U.1G){O f=0,e=0;if(K.tz&&!K.fY){O h=K.U.dg(K.5q);5U(K.9d){1N"tr":f=h.x;e=K.U.1G.h-h.y;1F;1N"tl":f=K.U.1G.w-h.x;e=K.U.1G.h-h.y;1F;1N"bl":f=K.U.1G.w-h.x;e=h.y;1F;1N"br":f=h.x;e=h.y;1F;49:f=h.x;e=K.U.1G.h-h.y;1F}}O a=K.U.1G.h-K.U.8V.1t-K.U.8V.1L-g-e;O b=K.U.1G.w-K.U.8V.1s-K.U.8V.1I-j-f;d.w=1k.4v(d.w,b);d.h=1k.4v(d.h,a)}R d},ky:Q(){O a=K.I6;if(!a){if(K.1q.2V==P){K.1q.W.23="2L";1Q.7n.1V(K.1q)}a=S N.1U(N.2I.9r(K.4Z,"4A-1s"),N.2I.9r(K.4Z,"4A-1L"),N.2I.9r(K.4Z,"4A-1I"),N.2I.9r(K.4Z,"4A-1t"));K.I6=a;if(K.1q.2V===1Q.7n){1Q.7n.2T(K.1q);K.1q.W.23=""}}R a},I5:Q(c){K.6R=N.1c.7m(K.id+"UE",P,S N.2M(17,17));K.6R.3M="UD";O b=K.ky();K.6R.W.1I=b.1I+"px";K.6R.W.1t=b.1t+"px";K.8E.1V(K.6R);O a=c||Q(d){K.ay();N.1H.2K(d)};N.1H.3m(K.6R,"eU",N.2u.59(a,K));N.1H.3m(K.6R,"2U",N.2u.59(a,K))},rj:Q(){O e=K.U.5c();O d=K.U.hZ(S N.2B(2g(K.1q.W.1s),2g(K.1q.W.1t)));O c=d.1T();if(d.x<K.U.8V.1s){c.x=K.U.8V.1s}V{if((d.x+K.1G.w)>(e.w-K.U.8V.1I)){c.x=e.w-K.U.8V.1I-K.1G.w}}if(d.y<K.U.8V.1t){c.y=K.U.8V.1t}V{if((d.y+K.1G.h)>(e.h-K.U.8V.1L)){c.y=e.h-K.U.8V.1L-K.1G.h}}O b=d.x-c.x;O a=d.y-c.y;K.U.6X(b,a)},I4:Q(){K.1n=S N.4l(K,K.1q,P,1d);Q a(b){N.1H.2K(b,1d)}K.1n.on({48:K.I3,4p:K.I2,4o:K.I1,2U:K.uj,aL:K.I0,4F:K.HZ,8R:a,2y:K})},I3:Q(a){K.48=1d;N.1H.2K(a,1d)},I2:Q(a){if(K.48){N.1H.2K(a,1d)}},I1:Q(a){if(K.48){K.48=1b;N.1H.2K(a,1d)}},uj:Q(a){N.1H.2K(a,1d)},I0:Q(a){K.48=1b},HZ:Q(a){N.1H.2K(a,1d)},1p:"N.3Y"});N.3Y.HY=cW;N.3Y.HX=cW;N.3Y.HW="bE";N.3Y.HV=1;N.3Y.HU="bk";N.df=N.1z({id:P,1x:P,6O:P,W:P,1o:Q(c,a,b){K.id=N.1c.7x(K.1p+"4n");K.1x=c?c:P;K.6O={};if(a){K.6O=N.1c.1K(K.6O,a)}K.W=b?b:P},1m:Q(){K.id=P;K.1x=P;K.6O=P;K.W=P},1T:Q(){R S N.df(K.1x?K.1x.1T():P,K.6O,K.W)},1p:"N.df"});N.5v=N.1z({2P:["av","7k","xS","a2"],1n:P,id:P,1i:P,1B:P,2c:P,1G:P,2v:P,ad:1b,1o:Q(e,a,f,c,d,b){K.1i=e;K.2v=a.1T();K.2c=f.1T();K.1B=c;if(d){K.1G=d.1T()}K.id=N.1c.7x("UC");K.1n=S N.4l(K,P,K.2P);N.1c.1K(K,b)},a2:Q(){if(K.ad){K.ad=1b;K.1n.1M("a2")}},1m:Q(){K.1i=P;K.2c=P;K.1G=P;K.2v=P;K.1n.1m();K.1n=P},1T:Q(a){if(a==P){a=S N.5v(K.1i,K.2v,K.2c,K.1B,K.1G)}N.1c.4I(a,K);R a},2H:Q(){O a=K.1i.3b;O b=(a&&K.2c.9R(a,1b));K.mh=(b||K.1i.y8);K.5z();R K.mh},2O:Q(b,a,c){if(c==P){c=1d}K.2c=b.1T();K.2v=a.1T();if(c){K.2H()}},5z:Q(){},xT:Q(a){O d=K.1i.U.g1(a);O c=a.1T();c.x+=K.1G.w;c.y+=K.1G.h;O b=K.1i.U.g1(c);if(d.1P>b.1P){if(d.1P<0){d.1P=-2R-(d.1P+2R)}V{b.1P=2R+b.1P+2R}}O e=S N.1U(d.1P,b.1R,b.1P,d.1R);R e},mw:Q(){if(K.mh){K.ev()}},ev:Q(){},ay:Q(){},UB:Q(){O a=K.3C||K.7G;if(N.1c.qP()&&a&&!K.ad){if(!K.6G){O b=1Q.2G("1u");b.1A=K.1G.w;b.1E=K.1G.h;K.6G=b.5Q("2d");K.6G.8I(a,0,0)}R K.6G}},1p:"N.5v"});N.5v.4w=N.1z(N.5v,{1B:P,3C:P,67:P,jr:P,cc:1d,8i:P,HT:P,1o:Q(e,a,f,c,d,b){N.5v.1g.1o.1j(K,1r);if(K.HT!=P){N.1c.1K(K,N.5v.4w.UA)}K.1B=c;K.67=1Q.2G("1q");K.67.W.9M="8C";K.67.W.2v="3d";K.jr=K.1i.kR&&N.1c.gA()},1m:Q(){if(K.3C!=P){K.HR()}K.3C=P;if((K.67!=P)&&(K.67.2V===K.1i.1q)){K.1i.1q.2T(K.67)}K.67=P;K.1i.1n.6S("7k",K,K.mw);K.8i&&2k.6t(K.8i);N.5v.1g.1m.1j(K,1r)},1T:Q(a){if(a==P){a=S N.5v.4w(K.1i,K.2v,K.2c,K.1B,K.1G)}a=N.5v.1g.1T.1j(K,[a]);a.3C=P;R a},2H:Q(){if(K.1i!==K.1i.U.2b&&K.1i.xU){K.2c=K.xT(K.2v)}O a=N.5v.1g.2H.1j(K,1r);if((N.1c.2S(K.1i.y3,K.1i.jo)!==-1)||K.1i.ab){if(a&&K.cc){K.1n.4N("7k",K,K.mw);K.1i.1n.4N("7k",K,K.mw);K.cc=1b}V{}}V{if(a&&K.cc){K.1n.4N("7k",K,K.mw);K.cc=1b}}if(!a){R 1b}if(K.ad){K.1n.1M("xS")}V{K.ad=1d;K.1n.1M("av")}R K.r9()},r9:Q(){K.1B=K.1i.qN(K.2c);K.1n.1M(K.Uz);K.HS();K.r8();R 1d},r8:Q(){if(K.1i===P){R}N.1c.j6(K.67,P,K.2v,K.1G);K.3C.W.2J=0;O a=K.1i.y6(K.2c);if(K.jr){N.1c.ri(K.3C,P,P,a,K.1B)}V{N.1c.j6(K.3C,P,P,a);if(K.3C.5o===K.1B){K.y5()}V{if(K.1i.xP&&!N.1c.4B(K.1B)&&(K.1B.2S("dP=1d")<0)&&((N.1C.h1&&K.1i 1W N.1C.h1)||(N.1C.h2&&K.1i 1W N.1C.h2))){K.3C.Hy="Hx"}K.3C.5o=K.1B}}},y5:Q(){O a=K.3C;K.6G=P;a.W.3j="oJ";a.W.2J=0;K.1n.1M("7k");K.8i=2k.6u(Q(b){R Q(){O c=b.1i.2J;a.W.2J=(c||c==0)?c:1}}(K),10)},5z:Q(){if(K.3C){K.ay();if(N.5v.4w.HP){K.3C.5o=N.1c.4M()+"pU.ly"}}K.6G=P},HS:Q(){if(K.3C==P){O d=K.1i.y7;O b=K.1i.y6(K.2c);if(K.jr){K.3C=N.1c.8F(P,d,b,P,"fW",P,P,P,1d)}V{K.3C=N.1c.ol(P,d,b,P,"fW",P,P,1d)}if(N.1c.4f(K.1i.1B)){K.3C.bR=K.1i.1B.9D()}K.3C.3M="Uy";K.67.W.5j=K.HC?0:1;K.67.1V(K.3C);K.1i.1q.1V(K.67);if(K.1i.2J!=P){N.1c.j6(K.3C,P,P,P,P,P,P,K.1i.2J)}K.3C.U=K.1i.U;O c=Q(){if(K.ad){K.ad=1b;K.y5()}};if(K.jr){N.1H.3m(K.3C.b8[0],"au",N.2u.3E(c,K))}V{N.1H.3m(K.3C,"au",N.2u.3E(c,K))}O a=Q(){if(K.3C.aR>N.Hu){c.4g(K)}};N.1H.3m(K.3C,"77",N.2u.3E(a,K))}K.3C.bH=K.1i.U.bH},xG:Q(a){K.3C.Ux("Uw");K.3C.5o=a},HR:Q(){N.1H.9F(K.3C);if(K.3C.2V===K.67){K.67.2T(K.3C);K.3C.U=P}K.3C.bR=P;O a=K.3C.9U;if(a){N.1H.9F(a);K.3C.2T(a);2s a}V{K.3C.5o=N.1c.4M()+"pU.ly"}},Uv:Q(){if(K.1i){O a=K.jr?K.3C.9U.5o:K.3C.5o;if(!N.1c.HQ(a,K.1B)){K.ay()}}},ev:Q(){K.67.W.23="";if(N.1c.2S(K.1i.y3,K.1i.jo)!==-1){if(N.fO===1d){K.67.ca=K.67.ca}}},ay:Q(){K.67.W.23="2L"},mo:Q(){if(!K.3C||K.ad){R}O b;if(K.67){O a=K.67.Cv(1b);b=K.3C;b.W.2v="3d";b.W.1s=a.W.1s.4D(/px/,"%");b.W.1I=a.W.1I.4D(/px/,"%");b.W.1A=a.W.1A.4D(/px/,"%");b.W.1E=a.W.1E.4D(/px/,"%")}V{b=K.3C}K.3C=P;R b},1p:"N.5v.4w"});N.5v.4w.HP=(N.93.2l==="Uu"||N.93.2l==="qf");N.xN=N.1z({6y:6,4X:0,h4:P,9w:P,jq:P,9x:P,mv:P,1A:0,1E:0,3n:P,fb:P,1i:P,cN:P,jp:P,rh:1d,fc:0,1o:Q(a){K.1i=a;K.9w=1Q.2G("1u");K.9w.W.23="2L";K.jq=K.9w.5Q("2d");if(K.1i.jn&&N.93.iS==="pc"){K.9x=1Q.2G("1u");K.mv=K.9x.5Q("2d");K.9x.W.2v="3d"}},aC:Q(a,b,d){K.4X=K.1i.ew/K.1i.U.2r();K.7A=b;K.cN=a;K.jp=a.5Q("2d");K.1A=a.1A;K.1E=a.1E;K.9w.1A=K.1A;K.9w.1E=K.1E;bu{K.jq.8I(K.cN,0,0)}bt(c){R}K.1i.ge();K.jp.8I(K.9w,K.7A.x,K.7A.y,K.1A*K.4X,K.1E*K.4X);if(N.93.iS==="pc"){K.y4(d)}},y4:Q(a){if(!K.rh){R}K.1i.1q.1V(K.9x);K.9x.1A=K.1A;K.9x.1E=K.1E;K.9x.W.1s=K.cN.W.1s;K.9x.W.1t=K.cN.W.1t;K.rh=1b;K.fc=0;K.cN.W.23="2L";K.HO(a)},HN:Q(){K.rh=1d;K.1i.1q.2T(K.9x);K.cN.W.23=""},HO:Q(g){O d=K;O f=(K.7A.x)/K.6y,c=(K.7A.y)/K.6y;O a=(K.4X-1)*K.1A/K.6y,e=(K.4X-1)*K.1E/K.6y;d.fc++;d.mv.4Y(0,0,K.1A,K.1E);d.mv.8I(d.9w,f*d.fc,c*d.fc,a*d.fc+K.1A,e*d.fc+K.1E);d.fb&&2k.6t(d.fb);if(d.fc===d.6y){K.HN();g&&g()}V{O b=N.2u.3E(1r.Ut,K,g);d.fb=2k.6u(b,30)}},1m:Q(){O a=K;a.7A=P;a.9w=P;a.jq=P;a.Us=P;a.Ur=P;a.3n=P;a.cN=P;a.jp=P;a.1i=P;a.fb&&2k.6t(a.fb);a.fb=P}});N.Ci=N.1z(N.xN,{1o:Q(a){K.1i=a;K.9w=1Q.2G("1u");K.9w.W.23="2L";K.jq=K.9w.5Q("2d");K.9x=1Q.2G("1u");K.mv=K.9x.5Q("2d");K.9x.W.2v="3d";K.1i.1q.1V(K.9x)},aC:Q(a,b,c){K.4X=K.1i.ew/K.1i.U.2r();if(1===K.4X){c&&c();R}K.7A=b;K.cN=a;K.jp=a.5Q("2d");K.1A=a.1A;K.1E=a.1E;K.9w.1A=K.1A;K.9w.1E=K.1E;K.jq.8I(K.cN,0,0);K.jp.4Y(0,0,K.1A,K.1E);K.y4(c)}});N.1C.bG=N.1z(N.1C,{HM:(1k.5r(5)-1)/2,1B:P,3J:P,xU:1b,1o:Q(c,b,d,a){N.1C.1g.1o.1j(K,[c,a]);K.1B=b;K.3J=N.1c.1K({},d)},1m:Q(){K.1B=P;K.3J=P;N.1C.1g.1m.1j(K,1r)},1T:Q(a){if(a==P){a=S N.1C.bG(K.2l,K.1B,K.3J,K.8H())}a=N.1C.1g.1T.1j(K,[a]);R a},rg:Q(a){K.1B=a},md:Q(b){K.3J=N.1c.1K(K.3J,b);O a=K.3y();if(K.U!=P){K.U.1n.1M("7B",{1i:K,bh:"3J"})}R a},3y:Q(a){if(a){R K.md({Uq:1k.nD()})}V{R N.1C.1g.3y.1j(K,[])}},eZ:Q(e,d){O c=1;1h(O b=0,a=e.1a;b<a;b++){c*=e.D2(b)*K.HM;c-=1k.a0(c)}K.aR=(K.aR)?(K.aR):0;R d[(1k.a0(c*d.1a)+K.aR)%d.1a]},qT:Q(g,d){O b=d||K.1B;O f=N.1c.1K({},K.3J);f=N.1c.1K(f,g);O e=N.1c.iu(f);if(N.1c.4f(b)){b=K.eZ(e,b)}O a=N.1c.qS(N.1c.gt(b));1h(O c in f){if(c.hy()in a){2s f[c]}}e=N.1c.iu(f);R N.1c.xr(b,e)},1p:"N.1C.bG"});N.1C.ah=N.1z(N.1C.bG,{3c:P,r5:"bl",f4:P,xH:P,xI:N.5v.4w,3v:P,ab:1b,4X:1.5,aQ:0,jo:P,y3:["7C"],h3:P,mu:P,mr:P,rf:P,xZ:P,cM:P,rc:P,rd:0,mq:0,xJ:4b,3O:P,1o:Q(c,b,d,a){N.1C.bG.1g.1o.1j(K,1r);if(K.rc===P){K.rc=K.ab?0:Up}if(!!a&&!!a.aQ){K.aQ=a.aQ}K.1n.f9("xY");K.3v=[];K.mj=N.2u.3E(K.mk,K)},9O:Q(a){if(K.3O!=P){2k.6t(K.3O);K.3O=P}if(K.cM!==P){2k.6t(K.cM);K.cM=P}},1m:Q(){K.xW();K.3v=P;K.3c=P;N.1C.bG.1g.1m.1j(K,1r)},xW:Q(){if(K.3v){1h(O f=0,b=K.3v.1a;f<b;f++){O e=K.3v[f];1h(O c=0,a=e.1a;c<a;c++){O d=e[c];K.jd(d);d.1m()}}K.3v=[];K.mr=P}},1T:Q(a){if(a==P){a=S N.1C.ah(K.2l,K.1B,K.3J,K.8H())}a=N.1C.bG.1g.1T.1j(K,[a]);if(K.3c!=P){a.3c=K.3c.1T()}a.3v=[];a.mr=P;a.h3=P;a.mu=P;a.cM=P;R a},2O:Q(d,a,e){N.1C.bG.1g.2O.1j(K,1r);d=d||K.U.42();if(d!=P){O c=!K.3v.1a||a;O b=K.xM();if(K.ab){if(c||(!e&&!b.bg(d))){K.xL(d)}}V{if(c||!b.bg(d,1d)){K.fa(d)}V{K.jm()}}}},Uo:Q(m){O q=P,n=m.1P,l=m.1R,d=K.3v.1a;if(K.U&&d){O r=K.U.2r(),a=K.3c.w,k=K.3c.h,j=K.3v[0][0].2c,e=j.1s,o=j.1t;if(n<e){if(K.U.2b.5C){O b=K.U.9i().3L();O c=1k.mt((e-n)/b);n+=b*c}}O h=(n-e)/(r*a);O f=(o-l)/(r*k);O g=1k.a0(h);O i=1k.a0(f);if(i>=0&&i<d){O p=K.3v[i][g];if(p){q={41:p,i:1k.a0((h-g)*a),j:1k.a0((f-i)*k)}}}}R q},xK:Q(c){if(K.cM!==P){K.r3()}O j=K.h3;if(!j){O d=K.mo();j=d[1];O g=K.mu=d[0];if(!j){R}K.1q.ui(g,K.1q.9U);K.h3=j;O e=K.3v[0][0].2c;K.xZ={1P:e.1s,1R:e.1t};K.rf=K.mr}O a=j.W;O i=K.rf/c;a.1A=4b*i+"%";a.1E=4b*i+"%";O h=K.8c(K.xZ,c);O b=2g(K.U.3o.W.1s,10);O f=2g(K.U.3o.W.1t,10);j.W.1s=1k.2w(h.x-b)+"%";j.W.1t=1k.2w(h.y-f)+"%"},mo:Q(){O d;if(K.3v.1a>0){O c=1Q.2G("1q");c.id=K.1q.id+"Un";c.3M="Um";c.W.2v="3d";c.W.1A="HL";c.W.1E="HL";d=1Q.2G("1q");d.id=K.1q.id+"Ul";d.3M="Uk";d.W.2v="3d";d.W.1A="4b%";d.W.1E="4b%";c.1V(d);1h(O f=0,b=K.3v.1a;f<b;f++){1h(O e=0,a=K.3v[f].1a;e<a;e++){O g=K.3v[f][e].mo();if(!g){5y}g.W.1t=(f*K.3c.h)+"%";g.W.1s=(e*K.3c.w)+"%";d.1V(g)}}}R[c,d]},r3:Q(){if(K.h3){K.1q.2T(K.mu);K.h3=P;K.mu=P;K.rf=P;if(K.cM!==P){2k.6t(K.cM);K.cM=P}}},aB:Q(b,a){if(!K.ab){K.jm()}},jm:Q(){if(K.3O!=P){2k.6t(K.3O)}K.3O=2k.6u(K.mj,K.xJ)},h0:Q(a){if(K.ab){a=K.U.5c();a.h=2g(a.h*K.4X);a.w=2g(a.w*K.4X)}N.1C.bG.1g.h0.1j(K,[a])},xM:Q(){O e=P;if(K.3v.1a){O a=K.3v.1a-1;O d=K.3v[a][0];O b=K.3v[0].1a-1;O c=K.3v[0][b];e=S N.1U(d.2c.1s,d.2c.1L,c.2c.1I,c.2c.1t)}R e},xL:Q(f){O a=f.5P();O h=f.3L()*K.4X;O b=f.4y()*K.4X;O g=S N.1U(a.1P-(h/2),a.1R-(b/2),a.1P+(h/2),a.1R+(b/2));O d=S N.3i(g.1s,g.1t);O c=K.U.bm(d);if(!K.3v.1a){K.3v[0]=[]}O e=K.3v[0][0];if(!e){e=K.r0(g,c);K.je(e);e.2H();K.3v[0][0]=e}V{e.2O(g,c)}K.xX(1,1)},HK:Q(a,n,e){O k=e*K.3c.w;O c=e*K.3c.h;O i=a.1s-n.1P;O l=1k.a0(i/k)-K.aQ;O j=i/k-l;O f=-j*K.3c.w;O m=n.1P+l*k;O b=a.1t-(n.1R+c);O h=1k.mt(b/c)+K.aQ;O o=h-b/c;O d=-o*K.3c.h;O g=n.1R+h*c;R{HF:k,HE:c,HH:m,HG:g,HJ:f,HI:d}},xC:Q(){O b=K.f4;if(!b){O c=K.9i();O a=({tl:["1s","1t"],tr:["1I","1t"],bl:["1s","1L"],br:["1I","1L"]})[K.r5];b=S N.3i(c[a[0]],c[a[1]])}R b},fa:Q(j){O g=K.U.5c();O A=1k.mt(g.h/K.3c.h)+1k.3f(1,2*K.aQ);O D=1k.mt(g.w/K.3c.w)+1k.3f(1,2*K.aQ);O G=K.xC();O s=K.U.2r();O r=K.HK(j,G,s);O f=1k.2w(r.HJ);O c=1k.2w(r.HI);O l=r.HH;O o=r.HG;O e=r.HF;O k=r.HE;K.6z=S N.2B(f,c);O z=f;O C=l;O w=0;O a=2g(K.U.3o.W.1s);O u=2g(K.U.3o.W.1t);O B=[],E=K.U.aG();do{O h=K.3v[w++];if(!h){h=[];K.3v.1w(h)}l=C;f=z;O d=0;do{O b=S N.1U(l,o,l+e,o+k);O n=f;n-=a;O m=c;m-=u;O q=S N.2B(n,m);O F=h[d++];if(!F){F=K.r0(b,q);K.je(F);h.1w(F)}V{F.2O(b,q,1b)}O t=b.5P();B.1w({41:F,3H:1k.2Y(t.1P-E.1P,2)+1k.2Y(t.1R-E.1R,2)});l+=e;f+=K.3c.w}4W((l<=j.1I+e*K.aQ)||d<D||!((l=C)==0?1d:1d));o-=k;c+=K.3c.h}4W((o>=j.1L-k*K.aQ)||w<A);K.mr=K.U.2r();K.xX(w,d);B.8J(Q(x,i){R x.3H-i.3H});1h(O v=0,p=B.1a;v<p;++v){B[v].41.2H()}},9i:Q(){R K.3b},r0:Q(c,a){O b=S K.xI(K,a,c,P,K.3c,K.xH);K.1n.1M("Hq",{41:b});R b},je:Q(a){a.jc=Q(){if(K.rd==0){K.mq=0;K.1n.1M("av")}K.rd++;K.mq++};a.1n.4N("av",K,a.jc);a.cK=Q(b){K.mq--;K.1n.1M("xY",{41:a,r7:b.r7});if(K.mq===0){K.rd=0;K.1n.1M("7k");if(K.h3){K.cM=2k.6u(N.2u.3E(K.r3,K),K.rc)}}};a.1n.4N("7k",K,a.cK);a.1n.4N("a2",K,a.cK)},jd:Q(a){a.a2();a.1n.un({av:a.jc,7k:a.cK,a2:a.cK,2y:K})},mk:Q(){O d=1d;O c=K.aQ||1;O b=K.3v[0][0].2v;O a=2g(K.U.3o.W.1s);O f=2g(K.U.3o.W.1t);O e=b.3p(a,f);if(e.x>-K.3c.w*(c-1)){K.mm(1d)}V{if(e.x<-K.3c.w*c){K.mm(1b)}V{if(e.y>-K.3c.h*(c-1)){K.ml(1d)}V{if(e.y<-K.3c.h*c){K.ml(1b)}V{d=1b}}}}if(d){K.3O=2k.6u(K.mj,0)}},ml:Q(n){O c=(n)?0:(K.3v.1a-1);O b=K.3v;O f=b[c];O e=K.U.2r();O h=(n)?-K.3c.h:K.3c.h;O g=e*-h;O m=(n)?b.9h():b.hI();1h(O j=0,l=f.1a;j<l;j++){O d=f[j];O a=d.2c.1T();O k=d.2v.1T();a.1L=a.1L+g;a.1t=a.1t+g;k.y=k.y+h;m[j].2O(a,k)}if(n){b.i9(m)}V{b.1w(m)}},mm:Q(m){O d=(m)?-K.3c.w:K.3c.w;O c=K.U.2r();O k=c*d;1h(O e=0,g=K.3v.1a;e<g;e++){O l=K.3v[e];O j=(m)?0:(l.1a-1);O b=l[j];O a=b.2c.1T();O f=b.2v.1T();a.1s=a.1s+k;a.1I=a.1I+k;f.x=f.x+d;O h=m?K.3v[e].9h():K.3v[e].hI();h.2O(a,f);if(m){l.i9(h)}V{l.1w(h)}}},xX:Q(e,c){4W(K.3v.1a>e){O f=K.3v.9h();1h(O b=0,a=f.1a;b<a;b++){O d=f[b];K.jd(d);d.1m()}}4W(K.3v[0].1a>c){1h(O b=0,a=K.3v.1a;b<a;b++){O f=K.3v[b];if(f.1a<=c){5y}O d=f.9h();K.jd(d);d.1m()}}},de:Q(){if(K.ab){K.xW();K.h0()}},Uj:Q(d){O c=K.3b;O f=K.2r();O e=f*K.3c.w;O b=f*K.3c.h;O h=K.5n(d);O a=c.1s+(e*1k.a0((h.1P-c.1s)/e));O g=c.1L+(b*1k.a0((h.1R-c.1L)/b));R S N.1U(a,g,a+e,g+b)},HD:Q(b){b=b||K.U.2r();if(K.dM&&N.1c.2S(K.dM,b)===-1){O c,a;1h(c=K.dM.1a-1;c>=0;c--){a=K.dM[c];if(a>b){b=a;1F}}if(c===-1){7z"no Ui 7v in dM"}}R b},Uh:Q(){O a=K.HD();R K.dM?N.1c.2S(K.dM,a):K.U.a5(a)+(K.Ug||0)},1p:"N.1C.ah"});N.5v.ma=N.1z(N.5v,{1B:P,ac:P,xV:P,67:P,ad:1b,1u:P,7G:P,g9:P,HC:1b,ra:P,mp:P,1o:Q(e,a,g,c,d,b){O f=K;N.5v.1g.1o.1j(f,1r);f.1B=c;f.xV=b;f.1n.f9("Uf");f.1n.f9("Ue")},1m:Q(){N.5v.1g.1m.1j(K,1r);O a=K;a.7G=P;a.1u=P;a.6G=P;if(a.ra){a.ra.1m();a.ra=P;a.1i.1n.6S("7k",a,a.Ud)}},1T:Q(b){O a=K;if(b==P){b=S N.5v.ma(a.1i,a.2v,a.2c,a.1B,a.1G,a.xV)}b=N.5v.1g.1T.1j(a,[b]);b.1u=P;R b},2H:Q(){O b=K;if(b.1i!==b.1i.U.2b&&b.1i.xU){b.2c=b.xT(b.2v)}O a=N.5v.1g.2H.1j(b,1r);b.HB(a);if(!a){R}if(b.ad){b.1n.1M("xS")}V{b.ad=1d;b.1n.1M("av")}R b.r9()},HB:Q(a){},r9:Q(){O a=K;a.1B=a.1i.qN(a.2c);a.r8();R 1d},ol:Q(){if(K.7G!==P&&!K.7G.bq){K.7G.5o=""}O e=K,b=e.1i.xn(e.2c);e.g9=e.2c.1T();if(b){e.ac="";e.7G=b;e.1i.jf(b,e.2v);if(e.dQ){e.r1()}}V{O i=e.1i.m9(e.2c);if(!N.dJ){e.ac=i.x+"4n"+i.y+"4n"+i.z;e.xR()}V{O g=i.x,f=i.y,d;if(e.1i 1W N.1C.mb||e.1i.xB==="db"){d=i.z}V{d=e.1i.3B[i.z].Uc()}O c={41:e,X:g,Y:f,Z:d,bH:e.1i.U.bH};e.ac=g+"4n"+f+"4n"+d;e.7G=S 4w();O h=e.HA();O a=Q(j,k){R Q(l){2k[k]=P;j.41.Hz(j,l)}}(c,h);2k[h]=a;qV.fB(Q(){},Q(j){},"qU","Ub",[e.1B,e.1i.2l,g,f,d,h])}}},HA:Q(){O h=S 8j();O e=h.Ua();O f=h.U9()+1;O g=h.U8();O c=h.U7();O d=h.U6();O i=h.U5();O b=h.U4();O a="U3"+e+f+g+c+d+i+b+(1k.2w(1k.nD()*U2));R a},Hz:Q(a,d){O c=K;O b=d.x+"4n"+d.y+"4n"+d.z;if(c.ac!==b){R}if(d.57){if(d.57=="P"){R 1b}O e="57:5p/U1;U0,"+d.57}V{O e=c.1i.xO+"N/"+c.1i.2l+"/"+a.Z+"/"+a.X+"4n"+a.Y+".2Z"}c.1B=e;c.xR()},xR:Q(){O d=K,e=S 4w();e.dQ=1d;d.7G=e;O c={5p:e,41:d,bH:d.1i.U.bH,ac:d.ac};O a=Q(){if(K.41.ac===K.ac){K.41.Hw(K)}};O b=Q(){K.41.Hv(K)};e.gd=N.2u.3E(a,c);e.TZ=N.2u.3E(b,c);if(K.1i.xP&&!N.1c.4B(d.1B)&&(d.1B.2S("dP=1d")<0)&&((N.1C.h1&&d.1i 1W N.1C.h1)||(N.1C.h2&&d.1i 1W N.1C.h2))){e.Hy="Hx"}e.5o=d.1B},r8:Q(){O a=K;if(!a.1i){R}a.ol()},Hw:Q(a){if((K.1i===P)||K.1i.U==P||(a.bH!==K.1i.U.bH)||(a.5p!==K.7G)){R}K.6G=P;O b=a.5p;if(a.41.mh){K.xQ(b,a.ac)}},xG:Q(d,c){O b,a=c.r7;b=S 4w();b.gd=Q(g,f,e){R Q(){if(e===g.ac){g.7G=f;g.1i.jf(f,g.2v)}}}(K,b,a);if(a===K.ac){b.5o=d}},xQ:Q(d,a){O c=K,b=c.1i;if(b.TY&&!d.TX){c.4V(d);R}b.jf(d,c.2v);c.ad=1b;if(d.dQ){c.r1()}c.1n.1M("7k",{r7:a})},Hv:Q(a){O b=K;if(a.5p!==b.7G){R}b.aR=(b.aR)?(b.aR+1):1;if(b.aR<=N.Hu){if(b.1i.1B&&N.1c.4f(b.1i.1B)&&b.1i.1B.1a>1){b.1i.aR=b.aR;b.2H();R}}V{b.aR=0}b.1n.1M("7k")},r1:Q(){O b=K;if(!b.mp){O a={r6:b,5p:b.7G};b.mp=2k.6u(N.2u.3E(b.Ht,a),4b)}},Ht:Q(){O a=K;a.5p.dQ=1b;2k.6t(a.r6.mp);a.r6.mp=P;a.r6.xQ(a.5p)},ev:Q(){},ay:Q(){},TW:Q(a){R a.w>TV},2O:Q(b,a,c){if(c==P){c=1d}K.2c=b.1T();K.2v=a.1T();K.1i.jl=1b;if(c){K.2H()}},mo:Q(){},1p:"N.5v.ma"});N.4P=N.1z(N.1C.ah,{47:1d,1u:P,xP:1b,6G:P,ew:P,jl:1b,5L:"2Z",4r:P,5S:1d,r5:"tl",58:P,fb:P,aa:P,jk:[],qX:ib,mn:1d,ql:e8,mg:P,jn:1d,9u:P,9t:P,xD:P,xE:P,xO:P,xB:"TU",c9:P,qZ:1b,r2:P,1o:Q(c,b,f,a){O d=K,e=N.93;if(!!N.dJ){d.qX=rP}N.1C.ah.1g.1o.1j(d,1r);if(!!a&&!!a.47){d.47=a.47;if(d.47){d.47=N.1c.qP()}}V{if(d.47){d.47=N.1c.qP()}}if(e.iS==="oD"){d.47=1b}if(N.dJ){qV.fB(Q(g){d.xO="Hs://"+g.TT+"/"},Q(g){},"qU","TS",[]);d.47=1d}if(d.47){d.1u=1Q.2G("1u");d.1u.id="H3"+d.id;d.1u.W.2v="3d";d.1q.1V(d.1u);d.6G=d.1u.5Q("2d");d.c9=S N.xN(d);d.aa={}}d.jn=d.47?1d:1b;d.mn=1d},9O:Q(a){N.1C.ah.1g.9O.1j(K,[a]);K.8i&&2k.6t(K.8i);K.8i=P},1m:Q(){O a=K;N.1C.ah.1g.1m.1j(a,1r);a.5L=P;a.4r=P;a.58=P;a.5S=P;a.r5=P;a.3c=P;a.TQ=P;if(a.c9){a.c9.1m();a.TP=P}if(a.47){a.1u=P;a.aa=P}},1T:Q(b){O a=K;if(b==P){b=S N.4P(a.2l,a.1B,a.3J,a.8H())}b=N.1C.ah.1g.1T.1j(a,[b]);R b},2O:Q(a,b,l){O h=K,g=K.ew/K.U.2r(),c=K.U.3o.W,d=2g(c.1s),j=2g(c.1t);if(h.ab&&h.47){b=1d}K.qZ=b?1d:1b;K.9u=-d;K.9t=-j;if(!b&&!h.mg&&h.47&&!K.mn){K.jg()}N.1C.bG.1g.2O.1j(h,1r);a=a||h.U.42();h.jl=b;h.3S=l;O e=K.U.2r();if(h.47&&g!==1&&h.r4){if(!b||l||(K.ew===P)||(K.r2===P)||(K.g7===P)){}V{if(!K.U.vM){K.c9.aC(K.1u,K.Hr())}}}if(a!=P){O f=!h.3v.1a||b;O k=h.xM();if(K.ab){if(f||(!l&&!k.bg(a))){if(b&&K.jo!=="7C"){K.r3()}if(!b||K.jo==="7C"){K.xK(e)}K.xL(a)}}V{if(f||!k.bg(a,1d)){if(K.47){if(K.mn){K.jl=1d;K.ge();K.qZ=1d;K.mn=1b;K.fa(a)}V{if(K.ql){K.ge();K.mg=1d;2k.6t(K.8i);K.8i=2k.6u(N.2u.3E(Q(){K.fa(a)},K),K.ql)}V{K.fa(a)}}}V{if(b&&K.jo==="7C"){K.xK(e)}K.fa(a)}}V{K.jm()}}}if(h.47){if(h.ab){O m=U.5c();h.6G.4Y(0,0,m.w,m.h)}K.1q.W.1s=K.9u+"px";K.1q.W.1t=K.9t+"px";O i=S N.2B(K.9u,K.9t);K.g7=K.U.g1(i);K.r2=K.U.4G()}},Hr:Q(){O b;O d=K.U.4G();if(!K.5C||d>4){b=K.bm(K.g7)}V{O f=K.r2-d;O c=K.1u.1A/2;O a=K.1u.1E/2;O e=K.U.q9;if(f>0){b=S N.2B((c-e.x)*(1-1k.2Y(0.5,f)),(a+e.y)*(1-1k.2Y(0.5,f)))}V{b=S N.2B(-c*(1k.2Y(2,-f)-1)+e.x,-a*(1k.2Y(2,-f)-1)-e.y)}}R b},jm:Q(){if(K.jn){K.mk()}V{K.3O&&2k.6t(K.3O);K.3O=2k.6u(K.mj,K.xJ)}},mk:Q(){O d=1d;O c=K.aQ||1;O b=K.3v[0][0].2v;O a=-K.9u;O f=-K.9t;O e=b.3p(a,f);if(e.x>-K.3c.w*(c-1)){K.mm(1d)}V{if(e.x<-K.3c.w*c){K.mm(1b)}V{if(e.y>-K.3c.h*(c-1)){K.ml(1d)}V{if(e.y<-K.3c.h*c){K.ml(1b)}V{d=1b}}}}if(d){if(K.jn){K.mk()}V{K.3O=2k.6u(K.mj,0)}}V{}},aB:Q(b,a){K.8i&&2k.6t(K.8i);K.9u+=b;K.9t+=a;if(!K.ab){if(K.47){K.1q.W.1s=K.9u+"px";K.1q.W.1t=K.9t+"px"}if(K.jn){K.jg();K.jm()}}},jg:Q(){O f,g,b,a,e=K;e.6G.4Y(0,0,e.1u.1A,e.1u.1E);1h(b=0;b<K.xE;b++){1h(a=0;a<K.xD;a++){f=e.3v[b][a];g=f.7G;if((g!=P)&&(f.mh===1d)&&(g.1A>0&&g.1E>0)&&g.bq){O d=f.2v.x-e.9u;O c=f.2v.y-e.9t;if(f.7G.dQ){if(e.42().eI(f.2c.5P())){f.7G.dQ=1b}V{if(e.42().9R(f.2c)){f.r1()}}}e.qY(f.7G,d,c,1b)}}}},r0:Q(c,a){if(K.47){R S N.5v.ma(K,a,c,P,K.3c,K.47)}V{O b=S K.xI(K,a,c,P,K.3c,K.xH);K.1n.1M("Hq",{41:b});R b}},jf:Q(g,a){if(K.3S||!K.U){R}if(K.qZ){g.dQ=1b}K.ge();O b=K.U.3o.W;O f=2g(b.1s),e=2g(b.1t);if(N.93.2l==="hz"){O c={1i:K,2v:a,5p:g,xF:b};O d=N.2u.3E(K.Hp,c);2k.6u(d,4b)}V{K.qY(g,a.x+f,a.y+e)}},xG:Q(e,d){O a=K.U.3o.W;O c=2g(a.1s),b=2g(a.1t);K.6G.TO(e,d.x+c,d.y+b)},Hp:Q(){K.1i.qY(K.5p,K.2v.x+2g(K.xF.1s),K.2v.y+2g(K.xF.1t))},qY:Q(e,d,c,a){a=a||1d;if(e){a&&K.6G.4Y(d,c,e.1A,e.1E);if(2t K.2J==="6n"){O b=K.2J>0.3?K.2J-0.3:0.1;K.6G.5l=e.dQ?b:K.2J}V{K.6G.5l=e.dQ?0.6:1}K.6G.8I(e,d,c)}},ge:Q(){if(K.jl){K.jl=1b;K.1u.1A=K.U.3z.i2;K.1u.1E=K.U.3z.oH;K.6G.4Y(0,0,K.1u.1A,K.1u.1E);if(K.47){K.ew=K.U.2r()}R 1d}R 1b},fa:Q(a){K.mg=1b;N.1C.ah.1g.fa.1j(K,1r);K.xE=K.3v.1a;K.xD=K.3v[0].1a},bm:Q(a){R K.TN?K.U.dg(a):K.U.bm(a)},hZ:Q(a){R K.47?a:K.U.hZ(a)},qN:Q(c){O b=K,a;c=b.Ho(c);if(b.ab){R b.Hj(c)}a=b.m9(c);R b.f0(a)},m9:Q(b){O f=K,h,g,e,c=f.U,d=c.2r(),a=f.xC(),i=f.3c;h=1k.2w((b.1s-a.1P)/(d*i.w));g=1k.2w((a.1R-b.1t)/(d*i.h));e=c.4G();R{x:h,y:g,z:e}},xn:Q(c){O b=K,a=b.m9(c);a="x"+a.x+"y"+a.y+"z"+a.z;R b.aa[a]},H2:Q(f,h,c){O e=K;if(e.qX==0){R}O g=c.ac;if(g&&g!=""){if(e.jk.1a>=e.qX){O a=e.jk.hI();e.aa[a]=P;2s e.aa[a]}O d=g.4U("4n");O b="x"+d[0]+"y"+d[1]+"z"+d[2];e.aa[b]=h;e.jk.1w(b)}},H7:Q(){O c=K;1h(O b=0;b<c.jk.1a;b++){O a=c.jk.hI();c.aa[a]=P;2s c.aa[a]}},f3:Q(){O h=K,d,g,a,f,j={},e=1d;if(h.1S&&h.3B){O g=h.1S.1a;h.1S.8J(Q(l,i){R(i-l)});if(!h.4j){h.4j=h.1S[0]}if(!h.4k){h.4k=h.1S[g-1]}h.3B.8J(Q(l,i){R(l-i)});if(!h.4Q){h.4Q=h.3B[g-1]}if(!h.4R){h.4R=h.3B[0]}h.5G=g;R}1h(d=0,g=h.9s.1a;d<g;d++){a=h.9s[d];j[a]=h.2C[a];if(e&&h.2C[a]){e=1b}}if(h.f8==P){h.f8=e}if(j.1S==P){j.1S=h.f7(j.3B)}if(j.1S==P){j.1S=h.f6(j)}if(h.U.1S&&h.U.3B){h.1S=h.U.1S;h.3B=h.U.3B;O g=h.1S.1a;h.1S.8J(Q(l,i){R(i-l)});if(!h.4j){h.4j=h.1S[0]}if(!h.4k){h.4k=h.1S[g-1]}h.3B.8J(Q(l,i){R(l-i)});if(!h.4Q){h.4Q=h.3B[g-1]}if(!h.4R){h.4R=h.3B[0]}h.5G=g;R}if(j.1S==P){1h(d=0,g=h.9s.1a;d<g;d++){a=h.9s[d];j[a]=h.2C[a]!=P?h.2C[a]:h.U[a]}if(j.1S==P){j.1S=h.f7(j.3B)}if(j.1S==P){if(h.U.2b!=P){j.1S=h.U.2b.1S}}if(j.1S==P){j.1S=h.f6(j)}}O c;if(h.2C.4j&&h.2C.4j!=="4i"){c=h.2C.4j}if(h.2C.4R){c=N.1c.gZ(h.2C.4R,h.4r,h.2N,h.58)}O b;if(h.2C.4k&&h.2C.4k!=="4i"){b=h.2C.4k}if(h.2C.4Q){b=N.1c.gZ(h.2C.4Q,h.4r,h.2N,h.58)}if(j.1S){j.1S.8J(Q(l,i){R(i-l)});if(!c){c=j.1S[0]}if(!b){O k=j.1S.1a-1;b=j.1S[k]}}h.1S=j.1S;if(h.1S){g=h.1S.1a;h.3B=[g];if(h.U.2b){f=K.qM(h.1S)}V{f=0}1h(d=f;d<g+f;d++){h.3B[d]=N.1c.f5(h.1S[d-f],h.4r,h.2N,h.58)}h.5G=g}h.4k=b;if(b){h.4Q=N.1c.f5(b,h.4r,h.2N,h.58)}h.4j=c;if(c){h.4R=N.1c.f5(c,h.4r,h.2N,h.58)}},qM:Q(b){O e=K,d,a,c,f;f=e.U.2b.1S;a=f.1a;c=b[0];1h(d=0;d<a;d++){if(c===f[d]){R d}}R 0},f7:Q(e){if(e==P){R}O d=K,b,a;a=e.1a;b=[a];1h(O c=0;c<a;c++){b[c]=N.1c.gZ(e[c],d.4r,d.2N,d.58)}R b},f6:Q(l){O k=K,n=l.4j;if(l.4R!=P){n=N.1c.gZ(l.4R,k.4r,k.2N,k.58)}V{if(n==="4i"&&k.3b!=P){O m,j,g;m=k.U.5c();j=k.3b.3L()/m.w;g=k.3b.4y()/m.h;n=1k.3f(j,g)}}O f=l.4k;if(l.4Q!=P){f=N.1c.gZ(l.4Q,k.4r,k.2N,k.58)}V{if(l.4k==="4i"&&k.71!=P){O m,j,g;m=k.U.5c();j=k.71.3L()/m.w;g=k.71.4y()/m.h;f=1k.3f(j,g)}}if(2t n!=="6n"&&2t f!=="6n"&&K.3b!=P){O o=K.U.qW();n=1k.3f(K.3b.3L()/o.w,K.3b.4y()/o.h)}O a=l.bd;O b=l.5G;if(2t f==="6n"&&2t n==="6n"&&b===2q){O h=n/f;b=1k.a0(1k.eR(h)/1k.eR(2))+1}V{if(b===2q&&a!=P){b=a+1}}if(2t b!=="6n"||b<=0||(2t n!=="6n"&&2t f!=="6n")){R}O d=[b];O c=2;if(2t f==="6n"&&2t n==="6n"){c=1k.2Y((n/f),(1/(b-1)))}if(2t n==="6n"){1h(O e=0;e<b;e++){d[e]=n/1k.2Y(c,e)}}V{1h(e=0;e<b;e++){d[b-1-e]=f*1k.2Y(c,e)}}R d},1p:"N.4P"});N.1C.h2=N.1z(N.4P,{xu:{mW:1b,xs:1d},ji:P,jj:P,6J:P,7L:P,3D:P,4r:P,cT:1b,dP:1b,e1:P,ai:P,go:-1,9g:-1,iq:P,1o:Q(b,c,d,j){O h=K;N.4P.1g.1o.1j(h,1r);N.1c.4I(h.3J,h.xu);h.1n.f9("xw");h.1n.f9("Hk");if(h.3J.mW){if(h.5L==="TM"){h.5L=N.1c.gA()?"ly":"2Z"}if(h.5L==="Hn"){h.5L=N.1c.gA()?"Hn":"2Z"}}if(2t h.3J.cL!=="2q"){if(h.3J.cL 1W N.1f){h.3J.H6=1d;O g=N.1l.8s.ho(h.3J.cL);h.3J.cL=N.1c.7q(g)}V{2s h.3J.cL}}if(2t h.3J.8U!=="2q"){if(!h.3J.8U){2s h.3J.8U}}if(h.3J.dP){h.dP=1d}if(h.2N){h.2N=h.2N.eb()}if(h.4r&&h.3b&&(h.1S||h.3B)){}V{if(!h.4r&&(!h.6J||!h.7L||!h.3D)){if(!!N.dJ){O i={41:h};qV.fB(Q(k){R Q(l){k.41.Hm(k,l)}}(i),Q(k){},"qU","TL",[K.2l,K.xB])}V{O e=h.1B;if(N.1c.4f(c)){e=c[0]}O a=S N.1l.nt(e,{2F:{56:h.xz,2y:h,5H:h.xv},2Q:h.2Q});a.8n()}}}if(h.2Q){if(2t h.2Q==="aY"){h.2Q=S N.3g(h.2Q)}O f=h.2Q.7K().4U(":");if(f 1W 3Q&&f.1a===2){h.ji=\'{"hu":\'+f[1]+"}"}}},Hm:Q(TK,r){O 9v=r.5J;O me=K;if(9v!=="1b"){9v=nC("("+9v+")");O 2c=9v.2c;2c=S N.1U(2c.1s,2c.1L,2c.1I,2c.1t);me.3b=2c;if(9v.4r){me.4r=9v.4r;me.2C.3B=9v.3B;me.2N=9v.aZ;me.58=uy}V{O 6J=9v.6J,bQ=9v.bQ,7L=9v.7L,3D=9v.3D,58=9v.58;6J=S N.1U(6J.1s,6J.1L,6J.1I,6J.1t);me.6J=6J;7L=S N.2M(7L.bj.x,7L.bj.y);me.7L=7L;me.3D=3D;bQ=bQ.eb();me.2N=me.2N||bQ;me.58=58;me.4r=N.1c.Hl(6J,7L,3D,me.2N,58)}me.1n.1M("xw",me)}V{O xA=me.1B;if(N.1c.4f(me.1B)){xA=me.1B[0]}O jj=S N.1l.nt(xA,{2F:{56:me.xz,2y:me,5H:me.xv},2Q:me.2Q});jj.8n()}},xz:Q(c){O j=K;if(c.3r){O g=P;O d=c.nA;if(d){g=d.TJ;if(!j.3B&&d.TI&&(g&&g.1a&&g.1a>0)){K.2C.3B=g}}O c=c.3r;O b=c.2c,f=c.6J,i=c.bQ,h=c.7L,e=c.3D,k=c.58,a=c.zX;f=S N.1U(f.1s,f.1L,f.1I,f.1t);j.6J=f;h=S N.2M(h.bj.x,h.bj.y);j.7L=h;j.3D=e;b=S N.1U(b.1s,b.1L,b.1I,b.1t);j.3b=b;i=i.eb();j.2N=j.2N||i;j.58=k;j.4r=N.1c.Hl(f,h,e,j.2N,k);if(!j.2Q&&a){j.2Q="4E:"+a}if(!!N.dJ){qV.fB(Q(){},Q(l){},"qU","TH",[K.2l,c])}j.1n.1M("xw",j)}},xv:Q(a){O b=K;b.1n.1M("Hk",a)},1m:Q(){O a=K;if(a.jj){a.jj.1n.92=P;a.jj.1m()}a.6J=P;a.7L=P;a.3D=P;N.4P.1g.1m.1j(a,1r);a.xu=P},1T:Q(b){O a=K;if(b==P){b=S N.1C.h2(a.2l,a.1B,a.3J,a.8H())}b=N.4P.1g.1T.1j(a,[b]);b.8i=P;R b},Hj:Q(a){O e=K,c,h=e.3c,i=e.U.4G(),b=e.3B[i];if(!b){b=K.mf(i)}if(K.U&&K.U.2b&&K!==K.U.2b){O d=K.U.2b.mf(i);O f=[1e-9,2e-9,4e-9,8e-9,1.6e-8,3.2e-8,6.4e-8,1.Hi-7,2.Hh-7,5.Hg-7,0.Hf,0.He,0.Hd,0.Hc,0.Hb,0.Ha,0.H9,0.H8];O g=i>f.1a?f.1a:i;if(d&&1k.3N(d-b)>f[g]){b=d}}c={1A:h.w,1E:h.h,6J:\'{"9B":{"x":\'+a.1s+\',"y":\'+a.1L+\'},"aW":{"x":\'+a.1I+\',"y":\'+a.1t+"}}",3D:b,dP:e.dP};if(N.8u.9C){c[N.8u.9C.2l]=N.8u.9C.xt()}if(!e.3J.xs){c.t=S 8j().dO()}if(2t e.3J.8U!=="2q"&&2t c.8U==="2q"){if(e.3J.8U&&e.3J.8U.1a>0){c.8U=e.3J.8U}}if(e.ji){c.5i=e.ji}R e.qT(c)},f0:Q(b){O d=K,h,e=d.3c,g=d.3B[b.z];if(!g){g=K.mf(b.z)}if(K.U&&K.U.2b&&K!==K.U.2b){O c=K.U.2b.mf(b.z);O f=[1e-9,2e-9,4e-9,8e-9,1.6e-8,3.2e-8,6.4e-8,1.Hi-7,2.Hh-7,5.Hg-7,0.Hf,0.He,0.Hd,0.Hc,0.Hb,0.Ha,0.H9,0.H8];O a=b.z>f.1a?f.1a:b.z;if(c&&1k.3N(c-g)>f[a]){g=c}}h={1A:e.w,1E:e.h,x:b.x,y:b.y,3D:g,dP:d.dP};if(N.8u.9C){h[N.8u.9C.2l]=N.8u.9C.xt()}if(!d.3J.xs){h.t=S 8j().dO()}if(2t d.3J.8U!=="2q"&&2t h.8U==="2q"){if(d.3J.8U&&d.3J.8U.1a>0){h.8U=d.3J.8U}}if(d.ji){h.5i=d.ji}R d.qT(h)},qT:Q(e,d){O g=K,b=d||K.1B,f,a,c;f=N.1c.1K({},g.3J);f=N.1c.1K(f,e);if(f.cT===1b){g.e1=f.e1;g.cT=f.cT;2s f.cT;2s f.e1}a=N.1c.iu(f);if(N.1c.4f(b)){O i=""+e.x+e.y;b=g.eZ(i,b)}if(g.ab){b=b+"/5p."+g.5L}V{b=b+"/TG."+g.5L}c=N.1c.qS(N.1c.gt(b));1h(O h in f){if(h.hy()in c){2s f[h]}}a=N.1c.iu(f);if(g.f4){a=a+\'&6z={"x":\'+g.f4.1P+\',"y":\'+g.f4.1R+"}"}if(g.cT===1b){a+="&cT=1b";if(g.e1){a+="&e1="+g.e1.7r()}}V{a+="&cT=1d"}R N.1c.xr(b,a)},md:Q(b){if(K.47){K.H7()}if(2t(b.cL)!=="2q"){if(b.cL 1W N.1f){b.H6=1d;O a=N.1l.8s.ho(b.cL);b.cL=N.1c.7q(a)}V{2s b.cL}}R N.1C.bG.1g.md.1j(K,[b])},Dq:Q(){K.9g=K.go-1;K.lc()},Dr:Q(){K.9g=K.go+1;K.lc()},lc:Q(){O d=K;if(d.ai!==P){if(d.9g!==d.go&&K.9g>-1){if(d.ai){O b=d.ai.aX;if(b&&d.9g<b.1a&&d.9g>=0){O c=b[d.9g].2l;O a=d.md({TF:c});if(a&&d.iq){d.go=d.9g;O e=b[K.9g].TE;K.iq.Dp(e)}}}}}V{d.uV()}},uV:Q(){O b=K;O a=S N.1l.sg(b.1B,{2F:{56:c,2y:b}});a.8n();Q c(d){b.ai=d.3r;b.lc();if(b.iq){b.iq.DE()}}},1p:"N.1C.h2"});N.1C.h1=N.1z(N.4P,{xq:"${8Y}4n${w}x${h}/${3D}/${x}/${y}.${5L}",8Y:P,1o:Q(d,c,b,a){O e=K;e.8Y=b;N.4P.1g.1o.1j(e,[d,c,{},a])},1T:Q(b){O a=K;if(b==P){b=S N.1C.h1(a.2l,a.1B,a.8Y,a.8H())}b=N.4P.1g.1T.1j(a,[b]);R b},1m:Q(){O a=K;N.4P.1g.1m.1j(a,1r);a.8Y=P;a.xq=P},f0:Q(f){O e=K,h=e.3c,b=e.3B[f.z],a=e.1B,d=e.xq,c=e.8Y,g=e.5L;if(N.1c.4f(a)){O i=""+f.x+f.y+f.z+h.h+h.w+c+g;a=e.eZ(i,a)}a=(a.dU(a.1a-1)==="/")?a+d:a+"/"+d;R N.6K.5L(a,{x:f.x,y:f.y,3D:1k.2w(1/b),h:h.h,w:h.w,8Y:c,5L:g})},1p:"N.1C.h1"});N.1C.mb=N.1z(N.4P,{4r:96,2l:"mb",1B:"6s://t2.TD.cp/TC/5p",dt:P,mc:"TB",2E:"TA",1o:Q(a){O b=K;K.dt=N.bT("Tz");b.H5(b.1B);a=N.1c.1K({3b:S N.1U(-6F.qR,-6F.qR,6F.qR,6F.qR),1S:[Gp.Ty,Go.Tx,Gn.Tw,Gm.Tv,Gl.Tu,Gk.Tt,Gj.Ts,Gi.Tr,76.Tq,38.Tp,19.To,9.Tn,4.Tm,2.Tl,1.Tk,0.Tj]},a);N.4P.1g.1o.1j(b,[b.2l,b.1B,P,a]);b.2N="Ti"},H5:Q(a){if(a){K.1B+="?U=${mc}&2E=${2E}&x=${x}&y=${y}&z=${z}"}},1m:Q(){O a=K;N.4P.1g.1m.1j(a,1r);a.mc=P;a.2l=P;a.1B=P},1T:Q(b){O a=K;if(b==P){b=S N.1C.mb(a.2l,a.1B,a.8Y,a.8H())}b=N.4P.1g.1T.1j(a,[b]);R b},f0:Q(a){O c=K,b=c.1B;R N.6K.5L(b,{mc:c.mc,2E:c.2E,x:a.x,y:a.y,z:a.z+3})},1p:"N.1C.mb"});N.1C.xo=N.1z(N.1C,{5S:1b,7H:P,8f:1b,1o:Q(b,a){N.1C.1g.1o.1j(K,1r);K.7H=[]},1m:Q(){K.H4();K.7H=P;N.1C.1g.1m.1j(K,1r)},9N:Q(b){if(b!==K.2J){K.2J=b;1h(O c=0,a=K.7H.1a;c<a;c++){K.7H[c].9N(K.2J)}}},2O:Q(d,b,e){N.1C.1g.2O.1j(K,1r);if(b||!K.8f){1h(O c=0,a=K.7H.1a;c<a;c++){K.xp(K.7H[c])}K.8f=1d}},Th:Q(a){K.7H.1w(a);if(K.2J!=P){a.9N(K.2J)}if(K.U&&K.U.42()){a.U=K.U;K.xp(a)}},wM:Q(a){if(K.7H&&K.7H.1a){N.1c.am(K.7H,a);a.jh()}},H4:Q(){if(K.7H!=P){4W(K.7H.1a>0){K.wM(K.7H[0])}}},xp:Q(a){O b=K.U.bm(a.5q);if(b==P){a.23(1b)}V{if(!a.qQ()){O c=a.2H(b);K.1q.1V(c)}V{if(a.4O){a.4O.2O(b)}}}},tE:Q(){O b=P;if(K.7H&&(K.7H.1a>0)){O b=S N.1U();1h(O d=0,a=K.7H.1a;d<a;d++){O c=K.7H[d];b.1K(c.5q)}}R b},1p:"N.1C.xo"});N.1C.4w=N.1z(N.1C,{5S:1d,1B:P,47:1d,52:P,9u:0,9t:0,aa:P,41:P,qO:P,1o:Q(c,b,d,a){O e=N.93;K.1B=b;K.52=d;K.3b=d;N.1C.1g.1o.1j(K,[c,a]);if(K.47){K.47=N.1c.qP()}if(e.iS==="oD"){K.47=1b}if(K.47){K.1u=1Q.2G("1u");K.1u.id="H3"+K.id;K.1u.W.2v="3d";K.1q.1V(K.1u);K.6G=K.1u.5Q("2d")}},1m:Q(){if(K.41){K.jd(K.41);K.41.1m();K.41=P}K.1B=P;K.47=1d;K.aa=P;K.5S=1d;K.52=P;N.1C.1g.1m.1j(K,1r)},1T:Q(a){if(a==P){a=S N.1C.4w(K.2l,K.1B,K.52,K.8H())}a=N.1C.1g.1T.1j(K,[a]);R a},2O:Q(e,a,f){O d=K.U.3o.W,h=2g(d.1s),g=2g(d.1t);K.9u=-h;K.9t=-g;N.1C.1g.2O.1j(K,1r);O b=(K.41==P);if(a||b){K.h0();O c=K.qO=K.U.bm({1P:K.52.1s,1R:K.52.1t});if(b){if(K.47){K.41=S N.5v.ma(K,S N.2B(c.x-K.9u,c.y-K.9t),K.52,P,K.3c,K.47);K.je(K.41)}V{K.41=S N.5v.4w(K,c,K.52,P,K.3c);K.je(K.41)}}V{K.41.1G=K.3c.1T();if(K.47){K.41.2v=S N.2B(c.x-K.9u,c.y-K.9t)}V{K.41.2v=c.1T()}}K.41.2H();if(!K.47){K.41.67.W.23="";K.41.3C.W.2J=1}}V{if(K.47){K.jg()}}},jg:Q(){O c=K.qO.x-K.9u;O b=K.qO.y-K.9t;O a=S N.2B(c,b);K.jf(K.41.7G,a)},aB:Q(b,a){if(K.47){K.9u+=b;K.9t+=a;K.jg()}},jf:Q(b,a){K.1u.1A=K.U.3z.i2;K.1u.1E=K.U.3z.oH;K.6G.4Y(0,0,K.1u.1A,K.1u.1E);K.6G.8I(b,a.x,a.y,K.41.1G.w,K.41.1G.h)},xn:Q(a){R K.aa},H2:Q(a,b){K.aa=b},m9:Q(a){R{x:0,y:0,z:0}},h0:Q(){O b=K.52.3L()/K.U.2r();O a=K.52.4y()/K.U.2r();K.3c=S N.2M(b,a)},je:Q(a){a.jc=Q(){K.1n.1M("av")};a.1n.4N("av",K,a.jc);a.cK=Q(){K.1n.1M("7k")};a.1n.4N("7k",K,a.cK);a.1n.4N("a2",K,a.cK)},jd:Q(a){a.a2();a.1n.un({av:a.jc,7k:a.cK,a2:a.cK,2y:K})},qN:Q(){R K.1B},f3:Q(){O h=K,d,g,a,f,j={},e=1d;if(h.1S&&h.3B){O g=h.1S.1a;h.1S.8J(Q(l,i){R(i-l)});if(!h.4j){h.4j=h.1S[0]}if(!h.4k){h.4k=h.1S[g-1]}h.3B.8J(Q(l,i){R(l-i)});if(!h.4Q){h.4Q=h.3B[g-1]}if(!h.4R){h.4R=h.3B[0]}h.5G=g;R}1h(d=0,g=h.9s.1a;d<g;d++){a=h.9s[d];j[a]=h.2C[a];if(e&&h.2C[a]){e=1b}}if(h.f8==P){h.f8=e}if(j.1S==P){j.1S=h.f7(j.3B)}if(j.1S==P){j.1S=h.f6(j)}if(h.U.1S&&h.U.3B){h.1S=h.U.1S;h.3B=h.U.3B;O g=h.1S.1a;h.1S.8J(Q(l,i){R(i-l)});if(!h.4j){h.4j=h.1S[0]}if(!h.4k){h.4k=h.1S[g-1]}h.3B.8J(Q(l,i){R(l-i)});if(!h.4Q){h.4Q=h.3B[g-1]}if(!h.4R){h.4R=h.3B[0]}h.5G=g;R}if(j.1S==P){1h(d=0,g=h.9s.1a;d<g;d++){a=h.9s[d];j[a]=h.2C[a]!=P?h.2C[a]:h.U[a]}if(j.1S==P){j.1S=h.f7(j.3B)}if(j.1S==P){if(h.U.2b!=P){j.1S=h.U.2b.1S}}if(j.1S==P){j.1S=h.f6(j)}}O c;if(h.2C.4j&&h.2C.4j!=="4i"){c=h.2C.4j}if(h.2C.4R){c=N.1c.gZ(h.2C.4R,h.4r,h.2N,h.58)}O b;if(h.2C.4k&&h.2C.4k!=="4i"){b=h.2C.4k}if(h.2C.4Q){b=N.1c.gZ(h.2C.4Q,h.4r,h.2N,h.58)}if(j.1S){j.1S.8J(Q(l,i){R(i-l)});if(!c){c=j.1S[0]}if(!b){O k=j.1S.1a-1;b=j.1S[k]}}h.1S=j.1S;if(h.1S){g=h.1S.1a;h.3B=[g];if(h.U.2b){f=K.qM(h.1S)}V{f=0}1h(d=f;d<g+f;d++){h.3B[d]=N.1c.f5(h.1S[d-f],h.4r,h.2N,h.58)}h.5G=g}h.4k=b;if(b){h.4Q=N.1c.f5(b,h.4r,h.2N,h.58)}h.4j=c;if(c){h.4R=N.1c.f5(c,h.4r,h.2N,h.58)}},qM:Q(b){O e=K,d,a,c,f;f=e.U.2b.1S;a=f.1a;c=b[0];1h(d=0;d<a;d++){if(c===f[d]){R d}}R 0},1p:"N.1C.4w"});N.1C.m8=N.1z(N.4P,{Tg:P,4r:96,dt:"qz by <a W=\'bE-qy: kQ\' bw=\'qx\' 9l=\'6s://U.Tf.cp/\'>m8</a>",1o:Q(k){O j=K;j.2l="m8";j.1B="6s://Te${qK}.U.Td.cp/Tc/?qt=41&x=${x}&y=${y}&z=${z}&6x=pl&Tb=Ta&T9=1";O d=-qL;O c=-qL;O b=qL;O a=qL;O h=1k.2Y(2,15);O e=[];1h(O f=0;f<17;f++){e[f]=h;h*=0.5}O g=[];1h(O f=0;f<17;f++){g[f]=0.T8/(96*e[f])}k=N.1c.1K({3b:S N.1U(d,c,b,a),f4:S N.3i(d,a),1S:e},k);N.4P.1g.1o.1j(j,[j.2l,j.1B,P,k]);j.2N="m";j.2Q="4E:gV"},1T:Q(b){O a=K;if(b==P){b=S N.1C.m8(a.2l,a.1B,a.3J,a.8H())}b=N.4P.1g.1T.1j(a,[b]);b.8i=P;R b},f0:Q(f){O e=K,a=e.1B;O g=f.z-1;O d=1k.2Y(2,g+3);O b=d-1;O i=f.x-d;O h=-f.y+b;g=f.z+3;O c=1k.3N((f.x+f.y)%8)+1;a=N.6K.5L(a,{qK:c,x:i,y:h,z:g});a=a.4D(/-/g,"M");R a},1p:"N.1C.m8"});N.1C.m6=N.1z(N.4P,{jb:"xm",H0:1b,dt:"qz by <a W=\'bE-qy: kQ\' bw=\'qx\' 9l=\'6s://l2.H1.cp\'>m6</a>",1B:"6s://t${qK}.H1.cp/T7?T=${2E}4n${81}&x=${x}&y=${y}&l=${z}",m7:1,4r:96,1o:Q(a){O b=K;b.2l="m6";N.4P.1g.1o.1j(b,[b.2l,b.1B,P,a])},1T:Q(b){O a=K;if(b==P){b=S N.1C.m6(a.2l,a.1B,a.3J,a.8H())}b=N.4P.1g.1T.1j(a,[b]);b.8i=P;R b},f0:Q(g){O f=K,a=f.1B;O b=K.2Q;if(b.7K){b=b.7K()}if(b=="4E:9E"){O b="c"}V{O b="w"}O i=g.x;O h=g.y;O e=g.z+f.m7;O d=1k.3N((g.x+g.y)%7);O c=K.jb;if(K.H0){if(K.jb=="xm"){c="T6"}if(K.jb=="5b"){c="T5"}if(K.jb=="GY"){c="T4"}}a=N.6K.5L(a,{qK:d,x:i,y:h,z:e,81:b,2E:c});R a},3a:Q(c){N.4P.1g.3a.1j(K,[c]);O a=P;O b=K.2Q||c.2Q;if(b){if(b.7K){a=b.7K()}V{a=b}}K.GZ(a)},GZ:Q(j){O f=K.jb;if(f=="xm"){O k=17;O h=0;K.m7=1;K.5G=17}V{if(f=="5b"){O k=17;O h=0;K.m7=1;K.5G=17}V{if(f=="GY"){O k=13;O h=0;K.m7=1;K.5G=13}}}if(j=="4E:9E"){O e=-2R;O d=-90;O b=2R;O a=90;O c=[];1h(O g=h;g<k;g++){c.1w(1.GK/2/1k.2Y(2,g))}K.2N="T3";K.2Q=S N.3g("4E:9E");K.3b=S N.1U(e,d,b,a);K.f4=S N.3i(e,a);K.1S=c}V{O e=-6F.qJ;O d=-6F.qJ;O b=6F.qJ;O a=6F.qJ;O c=[];1h(O g=h;g<k;g++){c.1w(GX.T2/2/1k.2Y(2,g))}K.2N="m";K.2Q=S N.3g("4E:gV");K.3b=S N.1U(e,d,b,a);K.f4=S N.3i(e,a);K.1S=c}},1p:"N.1C.m6"});N.1C.m2={42:Q(){O a=P;if(K.a7){a=K.U.9J()}V{a=N.1C.m3.1g.42.1j(K)}R a},5n:Q(a){R N.1C.1g.5n.1j(K,1r)},8c:Q(a){R N.1C.1g.8c.1j(K,1r)},GJ:Q(){K.m4=[];O a=GX.T1;1h(O b=0;b<=K.xh;++b){K.m4[b]=a/1k.2Y(2,b)}K.2N="m";K.2Q=K.2Q||"4E:m0"},ja:Q(c,b){O a=c*6F.34/2R;O d=1k.eR(1k.GW((90+b)*1k.PI/ks))/(1k.PI/2R);d=d*6F.34/2R;R S N.3i(a,d)},f1:Q(a,d){O c=(a/6F.34)*2R;O b=(d/6F.34)*2R;b=2R/1k.PI*(2*1k.p7(1k.GV(b*1k.PI/2R))-1k.PI/2);R S N.3i(c,b)},GS:Q(a){O b=N.1C.m2.ja(a.x,a.y);a.x=b.1P;a.y=b.1R;R a},GR:Q(a){O b=N.1C.m2.f1(a.x,a.y);a.x=b.1P;a.y=b.1R;R a}};(Q(){O a=["4E:m0","4E:gV","4E:GU","4E:GT"];O k=N.3g.xl;O e=N.1C.m2;O h=N.3g.m5;O d,f,b,g,c;1h(d=0,f=a.1a;d<f;++d){b=a[d];k("4E:9E",b,e.GS);k(b,"4E:9E",e.GR);1h(c=d+1;c<f;++c){g=a[c];k(b,g,h);k(g,b,h)}}})();N.1C.dN=N.1z(N.1C,{GP:1d,5S:1d,g6:1d,7E:P,3A:P,1o:Q(b,a){N.1C.1g.1o.1j(K,1r);if(K.7E==P){K.7E=N.1c.7m(K.1q.id+"T0")}},1m:Q(){K.3A=P;K.7E=P;N.1C.1g.1m.1j(K,1r)},3a:Q(a){N.1C.1g.3a.1j(K,1r);K.7E.W.5j=2g(K.1q.W.5j)+1;K.7E.W.23=K.1q.W.23;K.7E.W.1A="4b%";K.7E.W.1E="4b%";if(N.SZ=="hz"){K.7E.W.pk="1B("+N.1c.4M()+"pU.ly)"}if(K.g6){K.U.6v.1V(K.7E)}V{K.U.3o.1V(K.7E)}K.xc();if(K.3A==P){K.GQ()}},9O:Q(a){if(K.7E&&K.7E.2V){K.7E.2V.2T(K.7E)}N.1C.1g.9O.1j(K,1r)},GQ:Q(){K.1q.W.dD="SY";O g=K.U.5c();O a=1k.4v(g.w,e8);O e=1k.4v(g.h,cW);O b=S N.2M(a,e);O d=S N.2B(g.w/2,g.h/2);O c=d.3p(-b.w/2,-b.h/2);O f=N.1c.7m(K.2l+"SX",c,b,P,P,P,"4i");f.W.4A="SW";f.W.dD="SV";f.5N=K.xe();K.1q.1V(f)},xe:Q(){R""},23:Q(a){N.1C.1g.23.1j(K,1r);K.7E.W.23=K.1q.W.23},gN:Q(a){N.1C.1g.gN.1j(K,1r);K.7E.W.5j=2g(K.1q.W.5j)+1},aB:Q(b,a){N.1C.1g.aB.1j(K,1r);if(K.j9){K.j9(b,-a)}V{K.2O(K.U.a9())}},2O:Q(c,d,j){N.1C.1g.2O.1j(K,1r);if(K.3A!=P){O e=K.U.aG();O g=K.U.4G();if(e!=P){O f=K.qI();O b=K.xk(f);O h=K.GI();O m=K.GM(h);if(!(e.3w(b))||!(g==m)){if(!d&&b&&K.j9&&K.GP){O i=K.U.8c(b);O k=K.U.8c(e);K.j9(k.x-i.x,i.y-k.y)}V{O a=K.xj(e);O l=K.GL(g);K.x5(a,l,j)}}}}},5n:Q(a){O b=P;if((K.3A!=P)&&(K.qI()!=P)){O d=K.GN(a);O c=K.x7(d);b=K.xk(c)}R b},8c:Q(b){O a=P;if((K.3A!=P)&&(K.qI()!=P)){O d=K.xj(b);O c=K.x6(d);a=K.GO(c)}R a},xk:Q(d){O a=P;if(d!=P){O c=K.qE(d);O b=K.qD(d);a=S N.3i(c,b)}R a},xj:Q(a){O b=P;if(a!=P){b=K.qC(a.1P,a.1R)}R b},GO:Q(d){O b=P;if(d!=P){O a=K.GH(d);O c=K.GG(d);b=S N.2B(a,c)}R b},GN:Q(a){O b=P;if(a!=P){b=K.qB(a.x,a.y)}R b},1p:"N.1C.dN"});N.1C.m3=N.1z({1o:Q(){},f3:Q(){O c=S 3Q("ar","bd","5G");1h(O b=0,a=c.1a;b<a;b++){O f=c[b];K[f]=(K.2C[f]!=P)?K.2C[f]:K.U[f]}if((K.ar==P)||(K.ar<K.xi)){K.ar=K.xi}O g;O e=K.xh-K.ar+1;if(((K.2C.5G==P)&&(K.2C.bd!=P))||((K.5G==P)&&(K.bd!=P))){g=K.bd-K.ar+1}V{g=K.5G}if(g!=P){K.5G=1k.4v(g,e)}V{K.5G=e}K.bd=K.ar+K.5G-1;if(K.m4!=P){O d=0;K.1S=[];1h(O b=K.ar;b<=K.bd;b++){K.1S[d++]=K.m4[b]}K.4j=K.1S[0];K.4k=K.1S[K.1S.1a-1]}},2r:Q(){if(K.1S!=P){R N.1C.1g.2r.1j(K,1r)}V{O a=P;O c=K.U.5c();O b=K.42();if((c!=P)&&(b!=P)){a=1k.3f(b.3L()/c.w,b.4y()/c.h)}R a}},42:Q(){O c=P;O b=K.U.5c();O e=S N.2B(0,0);O f=K.5n(e);O a=S N.2B(b.w,b.h);O d=K.5n(a);if((f!=P)&&(d!=P)){c=S N.1U(f.1P,d.1R,d.1P,f.1R)}R c},a5:Q(a){if(K.1S!=P){R N.1C.1g.a5.1j(K,1r)}V{O b=N.1C.1g.42.1j(K,[]);R K.gY(b)}},GM:Q(a){O b=P;if(a!=P){b=a-K.ar;if(K.U.2b!==K){b=K.U.2b.a5(K.a6(b))}}R b},GL:Q(a){O b=P;if(a!=P){b=a+K.ar;if(K.U.2b!==K){b=K.a5(K.U.2b.a6(b))}}R b},1p:"N.1C.m3"});N.1C.5T=N.1z(N.1C.dN,N.1C.m3,{xi:0,xh:21,m4:[1.GK,0.SU,0.ST,0.SS,0.SR,0.SQ,0.SP,0.SO,0.SN,0.SM,0.SL,0.SK,0.SJ,0.SI,0.SH,0.SG,0.SF,0.SE,0.SD,0.SC,0.SB,6.Sz-7],2E:P,5C:1d,a7:1b,gJ:P,4r:96,1o:Q(c,b){b=b||{};if(!b.gJ){b.gJ=2t GF==="Q"?"2":"3"}O a=N.1C.5T["v"+b.gJ.4D(/\\./g,"4n")];if(a){N.1c.4I(b,a)}V{7z"Sy 5T Sx Sw gJ: "+b.gJ}N.1c.4I(b,a.GA);if(b.3b){b.3b=b.3b.1T()}N.1C.dN.1g.1o.1j(K,[c,b]);N.1C.m3.1g.1o.1j(K,[c,b]);if(K.a7){N.1c.1K(K,N.1C.m2);K.GJ()}},1T:Q(){R S N.1C.5T(K.2l,K.8H())},eK:Q(b){O a=K.2J==P?1:K.2J;N.1C.dN.1g.eK.1j(K,1r);K.9N(a)},23:Q(a){if(!K.xg){K.f2(a)}N.1C.dN.1g.23.1j(K,1r)},2O:Q(b,a,c){K.xg=c;N.1C.dN.1g.2O.1j(K,1r);2s K.xg},9N:Q(b){if(b!==K.2J){if(K.U!=P){K.U.1n.1M("7B",{1i:K,bh:"2J"})}K.2J=b}if(K.cY()){O a=K.m1();N.1c.j6(a,P,P,P,P,P,P,b)}},1m:Q(){if(K.U){K.f2(1b);O a=N.1C.5T.a8[K.U.id];if(a&&a.6y<=1){K.xf()}}N.1C.dN.1g.1m.1j(K,1r)},xf:Q(){O d=N.1C.5T.a8[K.U.id];if(d){O b=K.3A&&K.m1();if(b&&b.2V){b.2V.2T(b)}O c=d.7o;if(c&&c.2V){c.2V.2T(c)}O a=d.bF;if(a&&a.2V){a.2V.2T(a)}}},9O:Q(b){if(K.3j&&K.3A){K.f2(1b)}O a=N.1C.5T.a8[b.id];if(a){if(a.6y<=1){K.xf();2s N.1C.5T.a8[b.id]}V{--a.6y}}2s K.7o;2s K.bF;2s K.3A;2s K.qH;N.1C.dN.1g.9O.1j(K,1r)},Sv:Q(b){O c=P;if(b!=P){O a=b.Su();O d=b.St();if(K.a7){a=K.ja(a.gX(),a.1R());d=K.ja(d.gX(),d.1R())}V{a=S N.3i(a.gX(),a.1R());d=S N.3i(d.gX(),d.1R())}c=S N.1U(a.1P,a.1R,d.1P,d.1R)}R c},xe:Q(){R N.bT("Ss")},qI:Q(){R K.3A.aG()},GI:Q(){R K.3A.4G()},qE:Q(a){R K.a7?K.ja(a.gX(),a.1R()).1P:a.gX()},qD:Q(b){O a=K.a7?K.ja(b.gX(),b.1R()).1R:b.1R();R a},GH:Q(a){R a.x},GG:Q(a){R a.y},1p:"N.1C.5T"});N.1C.5T.a8={};N.1C.5T.v2={7o:P,bF:P,qH:P,xc:Q(){if(!K.2E){K.2E=Sr}O g,d,a;O c=N.1C.5T.a8[K.U.id];if(c){g=c.3A;d=c.7o;a=c.bF;++c.6y}V{O b=K.U.3z;O h=1Q.2G("1q");h.id=K.U.id+"Sq";h.W.2v="3d";h.W.1A="4b%";h.W.1E="4b%";b.1V(h);bu{g=S GF(h);d=h.nX;b.1V(d);d.W.5j="qF";d.W.1I="";d.W.1L="";d.3M="Gz";a=h.nX;b.1V(a);a.W.5j="qF";a.W.1I="";a.W.1L="";a.3M="Gy Gw"}bt(f){7z(f)}N.1C.5T.a8[K.U.id]={3A:g,7o:d,bF:a,6y:1}}K.3A=g;K.7o=d;K.bF=a;if(N.1c.2S(K.3A.Sp(),K.2E)===-1){K.3A.So(K.2E)}if(2t g.GE=="Q"){K.qH=g.GE()}V{K.j9=P}if(K.5S===1b){K.f2(K.1q.W.23!=="2L")}},de:Q(){if(K.3j&&K.3A.Sn()){K.3A.GC()}V{if(!K.xd){O a=K;O b=GD.Sm(K.3A,"au",Q(){GD.Gr(b);2s a.xd;a.3A.GC();a.2O(a.U.aG(),a.U.4G())})}K.xd=1d}},f2:Q(c){O b=N.1C.5T.a8[K.U.id];if(b){O a=K.3A.GB();if(c===1d){K.3A.Sl(K.2E);a.W.23="";K.7o.W.1s="";K.7o.W.23="";K.bF.W.23="";b.j8=K.id}V{if(b.j8===K.id){2s b.j8}if(!b.j8){a.W.23="2L";K.7o.W.23="2L";K.7o.W.1s="-x9";K.bF.W.23="2L"}}}},m1:Q(){R K.3A.GB()},Gv:Q(c){O b=P;if(c!=P){O a=K.a7?K.f1(c.1L,c.1s):S N.3i(c.1L,c.1s);O d=K.a7?K.f1(c.1t,c.1I):S N.3i(c.1t,c.1I);b=S Sk(S qG(a.1R,a.1P),S qG(d.1R,d.1P))}R b},x5:Q(a,b){K.3A.5X(a,b)},j9:Q(b,a){K.qH.Sj(S Si(-b,a))},x7:Q(a){R K.3A.Sh(a)},x6:Q(a){R K.3A.Sg(a)},Gt:Q(a){R K.3A.Gs(a)},qC:Q(d,b){O c;if(K.a7){O a=K.f1(d,b);c=S qG(a.1R,a.1P)}V{c=S qG(b,d)}R c},qB:Q(a,b){R S Sf(a,b)}};N.1C.5T=N.1C.5T||{};N.1C.5T.v3={GA:{a7:1d,2Q:"4E:gV"},Gu:1d,xc:Q(){if(!K.2E){K.2E=7Z.7F.Se.Sd}O d;O c=N.1C.5T.a8[K.U.id];if(c){d=c.3A;++c.6y}V{O b=K.U.3z;O e=1Q.2G("1q");e.id=K.U.id+"Sc";e.W.2v="3d";e.W.1A="4b%";e.W.1E="4b%";b.1V(e);O a=K.U.aG();d=S 7Z.7F.dE(e,{3U:a?S 7Z.7F.j7(a.1R,a.1P):S 7Z.7F.j7(0,0),5d:K.U.4G()||0,Sb:K.2E,Sa:1d,S9:1b,S8:1b,S7:1d,S6:1b,S5:1b});c={3A:d,6y:1};N.1C.5T.a8[K.U.id]=c;K.x3=7Z.7F.b7.x4(d,"S4",N.2u.3E(K.xb,K))}K.3A=d;K.f2(K.3j)},xb:Q(){7Z.7F.b7.nT(K.3A,"7C");O f=K.3A.x8().9U;if(!f||f.b8.1a<3){K.wZ=2k.6u(N.2u.3E(K.xb,K),CZ);R 1b}O d=N.1C.5T.a8[K.U.id];O b=K.U.3z;1h(O e=f.gW.1a-1;e>=0;--e){if(f.gW[e].W.5j==S3){O c=f.gW[e];b.1V(c);c.W.5j="qF";c.W.1L="";c.3M="Gz Gx";c.W.23="";d.7o=c}if(f.gW[e].W.5j==S2){O a=f.gW[e];b.1V(a);a.W.5j="qF";a.W.1L="";a.3M="Gy Gx Gw";a.W.23="";d.bF=a}if(f.gW[e].W.5j==S1){b.1V(f.gW[e])}}K.f2(K.3j)},de:Q(){if(K.3j){7Z.7F.b7.nT(K.3A,"7C")}V{O a=N.1C.5T.a8[K.U.id];if(!a.xa){O b=K;7Z.7F.b7.x4(K.3A,"S0",Q(){7Z.7F.b7.nT(b.3A,"7C");b.2O(b.U.aG(),b.U.4G());2s a.xa})}a.xa=1d}},f2:Q(g){O b=N.1C.5T.a8[K.U.id];if(b){O e=K.2E;O f=K.U.1O;O d;1h(O c=f.1a-1;c>=0;--c){d=f[c];if(d 1W N.1C.5T&&d.3j===1d&&d.7X===1d){e=d.2E;g=1d;1F}}O a=K.3A.x8();if(g===1d){K.3A.RZ(e);a.W.1s="";if(b.7o&&b.7o.W){b.7o.W.1s="";b.7o.W.23="";b.bF.W.23=""}b.j8=K.id}V{2s b.j8;a.W.1s="-x9";if(b.7o&&b.7o.W){b.7o.W.23="2L";b.7o.W.1s="-x9";b.bF.W.23="2L"}}}},m1:Q(){R K.3A.x8()},Gv:Q(c){O b=P;if(c!=P){O a=K.a7?K.f1(c.1L,c.1s):S N.3i(c.1L,c.1s);O d=K.a7?K.f1(c.1t,c.1I):S N.3i(c.1t,c.1I);b=S 7Z.7F.RY(S 7Z.7F.j7(a.1R,a.1P),S 7Z.7F.j7(d.1R,d.1P))}R b},x7:Q(h){O b=K.U.5c();O f=K.qE(K.3A.3U);O d=K.qD(K.3A.3U);O a=K.U.2r();O g=h.x-(b.w/2);O e=h.y-(b.h/2);O c=S N.3i(f+g*a,d-e*a);if(K.5C){c=c.5C(K.3b)}R K.qC(c.1P,c.1R)},x6:Q(e){O d=K.qE(e);O c=K.qD(e);O a=K.U.2r();O b=K.U.42();R K.qB((1/a*(d-b.1s)),(1/a*(b.1t-c)))},x5:Q(a,c){if(K.Gu===1b&&c!=K.3A.5d){O b=K.m1();7Z.7F.b7.x4(K.3A,"RX",Q(){b.W.3j=""});b.W.3j="8C"}K.3A.jA({3U:a,5d:c})},Gt:Q(a){R K.3A.Gs(a)},qC:Q(d,b){O c;if(K.a7){O a=K.f1(d,b);c=S 7Z.7F.j7(a.1R,a.1P)}V{c=S 7Z.7F.j7(b,d)}R c},qB:Q(a,b){R S 7Z.7F.1D(a,b)},1m:Q(){if(K.x3){7Z.7F.b7.Gr(K.x3)}if(K.wZ){2k.6t(K.wZ)}N.1C.5T.1g.1m.1j(K,1r)}};N.1C.wY=N.1z(N.4P,{2l:"Gq",1B:["6s://a.41.qA.eF/${z}/${x}/${y}.2Z","6s://b.41.qA.eF/${z}/${x}/${y}.2Z","6s://c.41.qA.eF/${z}/${x}/${y}.2Z"],4r:96,dt:"qz CC-By-SA by <a W=\'bE-qy: kQ\' bw=\'qx\' 9l=\'6s://qA.eF/\'>Gq</a>",1o:Q(b,a){a=N.1c.1K({2Q:"4E:gV",5G:20},a);N.4P.1g.1o.1j(K,[b,K.1B,{},a])},1T:Q(a){if(a==P){a=S N.1C.wY(K.2l,K.1B,K.8H())}a=N.4P.1g.1T.1j(K,[a]);R a},1m:Q(){O a=K;N.4P.1g.1m.1j(a,1r)},f0:Q(a){O c=K,b;if(N.1c.4f(K.1B)){b=c.eZ(a,K.1B)}b=N.6K.5L(b,{x:a.x,y:a.y,z:a.z});R b},eZ:Q(a,c){O d=1k.3N(a.x+a.y)%c.1a;O b=c[d];R b},1p:"N.1C.wY"});N.1C.qv=N.1z(N.4P,{4r:96,2l:"qv dE",1B:["6s://wX.t0.wW.wV.wU.cp/wT/ch/${qw}?it=G,VE,BX,L,LA&wS=zh-cn,wR&n=z&og=wQ&ur=CN","6s://wX.t1.wW.wV.wU.cp/wT/ch/${qw}?it=G,VE,BX,L,LA&wS=zh-cn,wR&n=z&og=wQ&ur=CN","6s://wX.t2.wW.wV.wU.cp/wT/ch/${qw}?it=G,VE,BX,L,LA&wS=zh-cn,wR&n=z&og=wQ&ur=CN"],dt:"qz CC-By-SA by <a W=\'bE-qy: kQ\' bw=\'qx\' 9l=\'6s://l2.RW.cp/7F/\'>RV</a>",dM:[RU.RT,RS.RR,Gp.RQ,Go.RP,Gn.RO,Gm.RN,Gl.RM,Gk.RL,Gj.RK,Gi.RJ,76.RI,38.RH,19.RG,9.RF,4.RE,2.RD,1.RC,0.RB],1o:Q(b,a){a=N.1c.1K({2Q:"4E:m0",1S:K.dM,5G:18},a);N.4P.1g.1o.1j(K,[b||K.2l,K.1B,{},a])},1T:Q(a){if(a==P){a=S N.1C.qv(K.2l,K.1B,K.8H())}a=N.4P.1g.1T.1j(K,[a]);R a},1m:Q(){O a=K;N.4P.1g.1m.1j(a,1r)},f0:Q(g){O f=K,a;if(N.1c.4f(K.1B)){a=f.eZ(g,K.1B)}O k=g.x,j=g.y,e=g.z+1;O b=[];1h(O c=e;c>0;--c){O h="0";O l=1<<(c-1);if((k&l)!=0){h++}if((j&l)!=0){h++;h++}b.1w(h)}O d=b.6b("");R N.6K.5L(a,{qw:d})},eZ:Q(a,c){O d=1k.3N(a.x+a.y)%c.1a;O b=c[d];R b},1p:"N.1C.qv"});N.1C.wN=N.1z(N.1C,{2P:["RA","Rz","Ry","Gh","Rx","Rw","Rv","wO","Dk","Dj","Di","Ru","Rt","Rs","os","tO","tN","kE","hU","c5"],5S:1b,g6:1b,cc:1d,4u:P,4V:P,cs:P,lZ:P,2f:P,8f:1b,hT:1d,aA:P,1o:Q(b,a,c){K.2P=N.1C.wN.1g.2P.b1(N.1C.1g.2P);N.1C.1g.1o.1j(K,1r);K.2f=S N.1Z.df(K.1q,c);K.4u=[];K.cs=[];K.lZ={}},1m:Q(){K.Gg();K.4u=P;K.cs=P;K.lZ=P;if(K.2f){K.2f.1m()}K.2f=P;K.8f=P;N.1C.1g.1m.1j(K,1r)},c5:Q(a){if(K.c6()&&K.3j){K.1n.1M("c5",a)}},3a:Q(b){N.1C.1g.3a.1j(K,1r);if(!K.2f){K.U.b6(K)}V{K.2f.U=K.U;O a=K.U.5c();K.2f.6A(a)}},9O:Q(){K.8f=1b},de:Q(){N.1C.1g.de.1j(K,1r);O a=K.U.5c();K.2f.6A(a)},2O:Q(e,a,g){N.1C.1g.2O.1j(K,1r);K.cc=1b;K.aA=a;O b=1d;if(!g){K.2f.31.W.3j="8C";O f=0,d=0;f+=2g(K.U.3o.W.1s,10);f=-1k.2w(f);d+=2g(K.U.3o.W.1t,10);d=-1k.2w(d);K.1q.W.1s=f+"px";K.1q.W.1t=d+"px";O c=K.U.42();b=K.2f.9e(c,a);K.2f.31.W.3j="6I";if(N.fO===1d){K.1q.ca=K.1q.ca}if(!a&&b){K.wP(e)}}if(!K.8f||(a||!b)){K.8f=1d;if(!K.oq){K.wP(e)}K.hT=1b}},aB:Q(b,a){if(K.g6){K.1q.W.1s=-2g(K.U.3o.W.1s,10)+"px";K.1q.W.1t=-2g(K.U.3o.W.1t,10)+"px"}},wP:Q(d){O c=K,f,e=c.4u;c.2f.7O=1d;1h(O b=0,a=e.1a;b<a;b++){if(b===(a-1)){c.2f.7O=1b}f=e[b];c.kF(f,{hH:c.hT||c.aA,2J:K.2J})}},3y:Q(){R N.1C.1g.3y.1j(K,1r)},23:Q(a){N.1C.1g.23.1j(K,1r);O b=K.1q.W.23;if(b!==K.2f.31.W.23){K.2f.31.W.23=b}},9N:Q(a){if(a!==K.2J){K.2J=a;O b=K.2f.31;N.1c.j6(b,P,P,P,P,P,P,a);if(K.U!=P){K.U.1n.1M("7B",{1i:K,bh:"2J"})}}},Ge:Q(b){O g=[];K.2f.7O=1d;1h(O c=0,a=b.1a;c<a;c++){if(c===(a-1)){K.2f.7O=1b}O f=b[c];K.4u.1w(f);O e=K.kF(f,{hH:1d});if(!e){g.1w(f)}}O d=g.1a==0?1d:1b;K.1n.1M("Gh",{4u:g,5V:d})},Gg:Q(a,b){O d=(a==2q);if(d){a=K.4u}if(a){K.Gf(a,b);1h(O c=a.1a-1;c>=0;c--){a[c].1m()}}},Gf:Q(h){if(!h||h.1a===0){R}if(h===K.4u){R K.Gd()}if(!(N.1c.4f(h))){h=[h]}if(h===K.cs){h=h.9D()}O g=[];1h(O e=h.1a-1;e>=0;e--){O a=h[e];2s K.lZ[a.id];O j=N.1c.2S(K.4u,a);if(j===-1){g.1w(a);5y}K.4u.6c(j,1);if(N.1c.2S(K.cs,a)!==-1){N.1c.am(K.cs,a)}a.1i=P}K.2f.5z();O c=[];1h(O b=0,f=K.4u.1a;b<f;b++){a=K.4u[b];c.1w(a)}K.4u=[];K.Ge(c);O d=g.1a==0?1d:1b;K.1n.1M("wO",{4u:g,5V:d})},Gd:Q(){K.2f.5z();K.4u=[];K.lZ={};K.cs=[];K.1n.1M("wO",{4u:[],5V:1d})},kF:Q(b){if(!K.8f){R}O a;a=K.2f.kF(b);R a},ov:Q(a){K.2f.ov(a)},w4:Q(a){if(K.3j==1b){R P}if(!K.2f){7z S g3("w4 BT on 1i op no 2f. BS BR BQ BP BO a 1i, BN fU BM 3s hR is BL op it.")}O c=P;O b=K.2f.C7(a);if(b){if(2t b==="aY"){c=K.Gc(b)}V{c=b}}R c},Gb:Q(b,a){O d=P;1h(O c in K.4u){if(K.4u[c][b]===a){d=K.4u[c];1F}}R d},Gc:Q(a){R K.Gb("id",a)},Rr:Q(b,c){O e,a=[];1h(O d in K.4u){e=K.4u[d];if(e&&e.6O){if(e.6O[b]===c){a.1w(e)}}}R a},1p:"N.1C.wN"});N.3k=N.1z({1i:P,id:P,5q:P,57:P,aP:P,wL:P,5R:P,1o:Q(a,c,b){K.1i=a;K.5q=c;K.57=(b!=P)?b:{};K.id=N.1c.7x(K.1p+"4n")},1m:Q(){if((K.1i!=P)&&(K.1i.U!=P)){if(K.5R!=P){K.1i.U.lY(K.5R)}}if(K.1i!=P&&K.aP!=P){K.1i.wM(K.aP)}K.1i=P;K.id=P;K.5q=P;K.57=P;if(K.aP!=P){K.wJ(K.aP);K.aP=P}if(K.5R!=P){K.wI(K.5R);K.5R=P}},wK:Q(){O b=1b;if((K.1i!=P)&&(K.1i.U!=P)){O a=K.1i.U.42();b=a.eI(K.5q)}R b},Ga:Q(){if(K.5q!=P){K.aP=S N.gU(K.5q,K.57.4O)}R K.aP},wJ:Q(){K.aP.1m()},G9:Q(b){if(K.5q!=P){if(!K.5R){O a=(K.aP)?K.aP.4O:P;O c=K.wL?K.wL:N.3Y.Rq;K.5R=S c(K.id+"Rp",K.5q,K.57.Ro,K.57.Rn,a,b)}if(K.57.9M!=P){K.5R.4Z.W.9M=K.57.9M}K.5R.1J=K}R K.5R},wI:Q(){if(K.5R){K.5R.1J=P;K.5R.1m();K.5R=P}},1p:"N.3k"});N.69={gT:"Rm",gu:"Rl",dw:"Rk",bK:"Rj"};N.3k.2X=N.1z(N.3k,{jZ:P,1x:P,6O:P,2c:P,7I:P,W:P,1B:P,7N:"49",8P:P,1o:Q(c,a,b){N.3k.1g.1o.1j(K,[P,P,a]);K.5q=P;K.1x=c?c:P;K.7I=P;K.6O={};if(a){K.6O=N.1c.1K(K.6O,a)}K.W=b?b:P},1m:Q(){if(K.1i){K.1i.9P(K);K.1i=P}K.1x=P;K.8P=P;N.3k.1g.1m.1j(K,1r)},1T:Q(){R S N.3k.2X(K.1x?K.1x.1T():P,K.6O,K.W)},wK:Q(d){O c=1b;if(K.1i&&K.1i.U){O a=K.1i.U.42();if(d){O b=K.1x.6k();c=a.9R(b)}V{O e=a.fA();c=e.6L(K.1x)}}R c},cY:Q(){R!(K.W&&K.W.23==="2L"||!K.1i||K.1i&&K.1i.az&&K.1i.az.fS(K,K.7N).23==="2L"||K.1i&&!K.1i.cY())},Ga:Q(){R P},wJ:Q(){},G9:Q(){R P},mN:Q(b,d,c){O a=1b;if(K.1x){a=K.1x.mN(b,d,c)}R a},wI:Q(){},3x:Q(a){if(!K.1i||!K.1x.3x){R 2q}O b;if(a.1p==="N.3i"){b=K.1i.8c(a)}V{b=a}O d=K.1i.8c(K.1x.6k().5P());O c=K.1i.U.2r();K.1x.3x(c*(b.x-d.x),c*(d.y-b.y));K.1i.3V(K);R d},Ri:Q(a){if(a===N.69.dw){5U(K.7I){1N N.69.gT:1N N.69.bK:K.7I=a;1F;1N N.69.dw:1N N.69.gu:1F}}V{if(a===N.69.gu){5U(K.7I){1N N.69.gT:1F;49:K.7I=a;1F}}V{if(a===N.69.bK){5U(K.7I){1N N.69.gu:1F;1N N.69.bK:1F;1N N.69.gT:1N N.69.dw:K.7I=a;1F}}V{if(a===N.69.gT){K.7I=a}}}}},1p:"N.3k.2X"});N.3k.2X.W={"49":{7j:"#o2",4H:0.4,wH:"bE",wG:0.8,8A:"#o2",at:1,4x:1,bf:"2w",as:"c3",wF:"8Z",wE:1,wD:0.2,4z:6,wC:1,wB:"%",dc:"wA",3G:"oJ",8b:"#aq",3W:"cm",wz:"bE",wy:3},7d:{7j:"9A",4H:0.4,wH:"bE",wG:0.8,8A:"9A",at:1,4x:2,bf:"2w",as:"c3",wF:"8Z",wE:1,wD:0.2,4z:6,wC:1,wB:"%",dc:"wA",3G:"4m",8b:"#aq",3W:"cm",wz:"bE",wy:3},hL:{7j:"#G8",4H:0.2,wH:"bE",wG:0.8,8A:"#G8",at:1,bf:"2w",4x:2,as:"c3",wF:"8Z",wE:1,wD:0.2,4z:6,wC:1,wB:"%",dc:"wA",3G:"49",8b:"#aq",3W:"cm",wz:"bE",wy:3},"2s":{23:"2L"}};N.1Y=N.1z({id:P,6Z:P,U:P,dF:P,3I:1b,7b:P,1o:Q(d,b,a){N.1c.1K(K,a);K.6Z=d;K.3F=b;O c=K.U||d.U;if(c){K.3a(c)}K.id=N.1c.7x(K.1p+"4n")},3a:Q(a){K.U=a},j1:Q(a){if(K.dF==P){R 1d}O b=(a.wb?N.1Y.w0:0)|(a.Rh?N.1Y.G7:0)|(a.Rg?N.1Y.G6:0);R(b===K.dF)},2p:Q(){if(K.3I){R 1b}O c=N.4l.1g.lX;1h(O b=0,a=c.1a;b<a;b++){if(K[c[b]]){K.4N(c[b],K[c[b]])}}K.3I=1d;R 1d},2a:Q(){if(!K.3I){R 1b}O c=N.4l.1g.lX;1h(O b=0,a=c.1a;b<a;b++){if(K[c[b]]){K.6S(c[b],K[c[b]])}}K.3I=1b;R 1d},3n:Q(b,a){if(b&&K.3F[b]){K.3F[b].1j(K.6Z,a)}},4N:Q(a,b){K.U.1n.lU(a,K,b);K.U.1n.lU(a,K,K.qp)},6S:Q(a,b){K.U.1n.6S(a,K,b);K.U.1n.6S(a,K,K.qp)},qp:Q(a){K.7b=a;R 1d},1m:Q(){K.2a();K.6Z=K.U=P},1p:"N.1Y"});N.1Y.Rf=0;N.1Y.w0=1;N.1Y.G7=2;N.1Y.G6=4;N.1Y.lz=N.1z(N.1Y,{gR:e8,vF:1d,"gF":1b,a1:0,FZ:13,pW:1b,iX:1b,3O:P,5t:1b,4q:P,3u:P,lW:P,gS:P,1o:Q(c,b,a){N.1Y.1g.1o.1j(K,1r)},8R:Q(a){if(!K.5t){K.G5();K.5t=1d}K.4q=K.eY(a);K.3u=K.eY(a);R 1d},9q:Q(a){K.3u=K.eY(a);R 1d},eU:Q(a){if(K.4q){a.xy=K.3u.xy;a.lE=K.3u.6E;K.wx(a);K.4q=P}R 1d},G5:Q(){K.U.1n.un({48:K.48,4o:K.4o,2U:K.2U,4F:K.4F,2y:K})},48:Q(a){K.4q=K.eY(a);K.3u=K.eY(a);R 1d},4o:Q(b){O a=1d;if(K.j1(b)&&K.6Z.vZ&&N.1H.G4(b)){a=K.eV(b)}R a},eV:Q(b){if(K.cJ(b)){if(K.gS!=P){K.eX();K.3n("vY",[b]);R!K.iX}V{O a=K["gF"]?N.1c.1K({},b):K.3n("eV",[b]);O c=N.2u.3E(K.G3,K,a);K.gS=2k.6u(c,K.gR)}}R!K.pW},G3:Q(a){K.gS=P;if(a){K.3n("eV",[a])}},2U:Q(a){if(!K.3u){K.3u=K.eY(a)}K.wx(a);R!K.pW},4F:Q(a){K.ww(a);R!K.iX},ww:Q(a){if(K["gF"]&&K.G0(a)){K.3n("4F",[a])}},wx:Q(b){if(K.cJ(b)){if(K.3O!=P){if(K.3u.6E&&K.3u.6E.1a===1){if(K["gF"]){N.1H.2K(b)}K.ww(b)}if(!K.3u.6E||K.3u.6E.1a!==2){K.eX()}}V{K.lW=K.eY(b);O a=K.vF?N.1c.1K({},b):P;K.G2(a)}}},G2:Q(a){K.3O=2k.6u(N.2u.3E(K.qu,K,a),K.gR)},cJ:Q(a){O d=1d;if(K.a1!=P&&K.4q&&K.4q.xy){d=K.a1>=K.4q.xy.74(a.xy);if(d&&K.5t&&K.4q.6E.1a===K.3u.6E.1a){1h(O b=0,c=K.4q.6E.1a;b<c;++b){if(K.G1(K.4q.6E[b],K.3u.6E[b])>K.a1){d=1b;1F}}}}R d},G1:Q(b,a){R 1k.5r(1k.2Y(b.aF-a.aF,2)+1k.2Y(b.9Z-a.9Z,2))},G0:Q(a){O b=1d;if(K.4q&&K.lW){b=K.4q.xy.74(K.lW.xy)<=K.FZ}R b},eX:Q(){if(K.3O!=P){2k.6t(K.3O);K.3O=P}if(K.gS!=P){2k.6t(K.gS);K.gS=P}},qu:Q(a){K.3O=P;if(a){K.3n("2U",[a])}},eY:Q(b){O d;if(b.6E){O a=b.6E.1a;d=S 3Q(a);O e;1h(O c=0;c<a;c++){e=b.6E[c];d[c]={aF:e.aF,9Z:e.9Z}}}R{xy:b.xy,6E:d}},2a:Q(){O a=1b;if(N.1Y.1g.2a.1j(K,1r)){K.eX();K.4q=P;K.lW=P;K.3u=P;K.5t=1b;a=1d}R a},1p:"N.1Y.lz"});N.1Y.FX=N.1z(N.1Y,{gR:rP,a1:P,FY:1b,px:P,3O:P,1o:Q(c,b,a){N.1Y.1g.1o.1j(K,1r)},4p:Q(a){if(K.cJ(a.xy)){K.eX();K.3n("3x",[a]);K.px=a.xy;a=N.1c.1K({},a);K.3O=2k.6u(N.2u.3E(K.qu,K,a),K.gR)}R!K.FY},aL:Q(a){if(N.1c.wl(a,K.U.6v)){K.eX();K.3n("3x",[a])}R 1d},cJ:Q(b){O c=1d;if(K.a1&&K.px){O a=1k.5r(1k.2Y(K.px.x-b.x,2)+1k.2Y(K.px.y-b.y,2));if(a<K.a1){c=1b}}R c},eX:Q(){if(K.3O!=P){2k.6t(K.3O);K.3O=P}},qu:Q(a){K.3n("Re",[a])},2a:Q(){O a=1b;if(N.1Y.1g.2a.1j(K,1r)){K.eX();a=1d}R a},1p:"N.1Y.FX"});N.1Y.1D=N.1z(N.1Y,{3l:P,1i:P,eN:1b,aI:1b,cI:P,dL:P,aO:P,ak:1b,7W:1b,lR:1b,cB:P,a1:5,5t:1b,j5:P,1o:Q(c,b,a){if(!(a&&a.cB&&a.cB.az)){K.W=N.1c.1K(N.3k.2X.W["49"],{})}N.1Y.1g.1o.1j(K,1r)},2p:Q(){if(!N.1Y.1g.2p.1j(K,1r)){R 1b}O a=N.1c.1K({kA:1b,c6:N.2u.qk},K.cB);K.1i=S N.1C.2X(K.1p,a);K.U.fL(K.1i);N.2I.54(K.U.3z,"qj");R 1d},lV:Q(a){O b=K.1i.5n(a);O c=S N.1f.1D(b.1P,b.1R);K.3l=S N.3k.2X(c);K.3n("lj",[K.3l.1x,K.3l]);K.3l.1x.9W();K.1i.7u([K.3l],{5B:1d})},2a:Q(){if(!N.1Y.1g.2a.1j(K,1r)){R 1b}K.8w();if(K.1i.U!=P){N.2I.9Y(K.U.3z,"qj");K.gO(1d);K.1i.1m(1b)}K.1i=P;K.5t=1b;R 1d},gO:Q(a){if(K.1i&&(a||!K.ak)){K.1i.9I()}K.3l=P},j4:Q(){O a=K.1i;if(a&&a.2z.1a>1){K.1i.2z[0].1m()}},bD:Q(b){O a=b?"8w":"7c";K.aI=1b;K.dL=P;K.aO=P;K.j5=P;K.3n(a,[K.FW()]);K.gO(b)},8w:Q(){K.bD(1d)},2U:Q(a){N.1H.2K(a);R 1b},4F:Q(a){N.1H.2K(a);R 1b},dK:Q(a){if(!K.3l){K.lV(a)}O b=K.1i.5n(a);if(K.6Z.cz){b=K.6Z.cz.jz(b)}K.3l.1x.x=b.1P;K.3l.1x.y=b.1R;K.3n("fH",[K.3l.1x,K.3l,1b]);K.3l.1x.9W();K.3V()},3V:Q(){K.1i.3V(K.3l,K.W)},lS:Q(){O a=K.3l&&K.3l.1x;if(a&&K.eN){a=S N.1f.8k([a])}R a},FW:Q(){O a=K.lS();R a&&a.1T()},48:Q(a){R K.4q(a)},8R:Q(a){if(!K.5t){K.5t=1d;K.U.1n.un({48:K.48,4o:K.4o,4p:K.4p,2U:K.2U,4F:K.4F,2y:K})}K.j5=a.xy;R K.4q(a)},4p:Q(a){R K.3x(a)},9q:Q(a){K.j5=a.xy;R K.3x(a)},4o:Q(a){R K.up(a)},eU:Q(a){a.xy=K.j5;R K.up(a)},4q:Q(a){K.aI=1d;K.dL=a.xy;if(!K.5t){K.dK(a.xy)}K.cI=K.7W;R!K.7W},3x:Q(a){if(!K.5t&&(!K.aI||K.cI)){K.dK(a.xy)}R 1d},up:Q(a){K.aI=1b;K.cI=K.7W;if(!K.j1(a)){R 1d}if(K.aO&&K.aO.3w(a.xy)){R 1d}if(K.dL&&K.cJ(K.dL,a.xy,K.a1)){if(K.5t){K.dK(a.xy)}if(K.ak){K.j4()}K.aO=a.xy;K.bD();R!K.lR}V{R 1d}},aL:Q(a){if(N.1c.wl(a,K.U.6v)){K.cI=K.7W;K.aI=1b}},cJ:Q(e,d,a){O b=1d;if(a!=P&&e&&d){O c=e.74(d);if(c>a){b=1b}}R b},1p:"N.1Y.1D"});N.1Y.gP=N.1z(N.1Y.1D,{3Z:P,qs:P,FV:20,wu:1b,wv:"wb",3O:P,eW:P,1o:Q(c,b,a){N.1Y.1D.1g.1o.1j(K,1r)},lV:Q(a){O b=K.U.6M(a);O c=S N.1f.1D(b.1P,b.1R);K.3l=S N.3k.2X(c);K.3Z=S N.3k.2X(S N.1f.2n([K.3l.1x]));K.3n("lj",[K.3l.1x,K.j3()]);K.3l.1x.9W();K.1i.7u([K.3Z,K.3l],{5B:1d})},gO:Q(a){N.1Y.1D.1g.gO.4g(K,a);K.3Z=P},j4:Q(){O a=K.1i;if(a&&a.2z.1a>2){K.1i.2z[0].1m()}},ic:Q(){if(K.3l){K.1i.9P([K.3l])}},ie:Q(a){K.1i.9P([K.3l]);O b=K.1i.5n(a);if(K.6Z.cz){b=K.6Z.cz.jz(b)}K.3l=S N.3k.2X(S N.1f.1D(b.1P,b.1R));K.3Z.1x.7U(K.3l.1x,K.3Z.1x.1y.1a);K.1i.7u([K.3l]);K.3n("3l",[K.3l.1x,K.lS()]);K.3n("fH",[K.3l.1x,K.j3()]);K.3V();2s K.eW},pD:Q(a,b){K.3Z.1x.7U(S N.1f.1D(a,b),K.gQ());K.3V();2s K.eW},pC:Q(b,a){O c=K.gQ()-1;O d=K.3Z.1x.1y[c];if(d&&!2x(d.x)&&!2x(d.y)){K.pD(d.x+b,d.y+a)}},pB:Q(d,c){d*=1k.PI/2R;O b=c*1k.8y(d);O a=c*1k.7P(d);K.pC(b,a)},vd:Q(c,b){O d=K.gQ()-1;if(d>0){O e=K.3Z.1x.1y[d];O f=K.3Z.1x.1y[d-1];O a=1k.l9(e.y-f.y,e.x-f.x);K.pB((a*2R/1k.PI)+c,b)}},gQ:Q(){R K.3Z.1x.1y.1a-1},pA:Q(){O e=K.3Z.1x;O b=e.1y;O a=K.gQ()-1;O d=b[a];O c=e.9V(d);if(c){if(!K.eW){K.eW=[]}K.eW.1w(d);K.3V()}R c},pz:Q(){O a=K.eW&&K.eW.9h();if(a){K.3Z.1x.7U(a,K.gQ());K.3V()}R!!a},fG:Q(a){R(K.wv&&a[K.wv])?!K.wu:K.wu},dK:Q(b,a){if(!K.3Z){K.lV(b)}O c=K.1i.5n(b);if(K.6Z.cz){c=K.6Z.cz.jz(c)}K.3l.1x.x=c.1P;K.3l.1x.y=c.1R;K.3n("fH",[K.3l.1x,K.j3(),a]);K.3l.1x.9W();K.3V()},3V:Q(){K.1i.3V(K.3Z,K.W);K.1i.3V(K.3l,K.W)},j3:Q(){R K.3Z},lS:Q(){O a=K.3Z&&K.3Z.1x;if(a&&K.eN){a=S N.1f.83([a])}R a},8R:Q(a){if(K.3O&&K.cJ(K.j5,a.xy,K.FV)){K.iB();2k.6t(K.3O);K.3O=P;R 1b}V{if(K.3O){2k.6t(K.3O);K.3O=P}K.3O=2k.6u(N.2u.3E(Q(){K.3O=P},K),e8);R N.1Y.1D.1g.8R.4g(K,a)}},4q:Q(a){O b=K.7W;if(K.fG(a)){b=1d;if(K.5t){K.dK(a.xy,!!K.aO);N.1H.2K(a)}}if(!K.5t&&(!K.dL||!K.cJ(K.dL,a.xy,K.a1))){K.dK(a.xy,!!K.aO)}K.aI=1d;K.dL=a.xy;K.cI=b;R!b},3x:Q(a){if(K.cI&&K.fG(a)){if(K.ak){K.j4()}if(K.qs&&K.3Z&&K.3Z.1x.1y.1a===K.qs){K.ic();K.bD()}V{K.ie(a.xy)}R 1b}if(!K.5t&&(!K.aI||K.cI)){K.dK(a.xy,!!K.aO)}R 1d},up:Q(a){if(K.aI&&(!K.aO||!K.aO.3w(a.xy))){if(K.cI&&K.fG(a)){if(K.ak){K.j4()}K.ic();K.bD()}V{if(K.cJ(K.dL,a.xy,K.a1)){if(K.5t){K.dK(a.xy)}if(K.aO==P&&K.ak){K.j4()}K.ie(a.xy);K.aO=a.xy;if(K.3Z.1x.1y.1a===K.qs+1){K.iB()}}}}K.cI=K.7W;K.aI=1b;R!K.lR},iB:Q(){O a=K.3Z.1x.1y.1a-1;K.3Z.1x.9V(K.3Z.1x.1y[a]);K.ic();K.bD()},4F:Q(a){if(!K.fG(a)){K.iB()}R 1b},1p:"N.1Y.gP"});N.1Y.3T=N.1z(N.1Y.gP,{wt:P,lT:1b,6U:P,1o:Q(c,b,a){N.1Y.gP.1g.1o.1j(K,1r)},lV:Q(a){O b=K.1i.5n(a);O c=S N.1f.1D(b.1P,b.1R);K.3l=S N.3k.2X(c);K.3Z=S N.3k.2X(S N.1f.4s([K.3l.1x]));K.6U=S N.3k.2X(S N.1f.3T([K.3Z.1x]));K.3n("lj",[K.3l.1x,K.j3()]);K.3l.1x.9W();K.1i.7u([K.6U,K.3l],{5B:1d})},ie:Q(a){if(!K.lT&&K.wt&&K.7b&&K.7b[K.wt]){O f=K.3l.1x;O e=K.6Z.1i.2z;O d,c;1h(O b=e.1a-1;b>=0;--b){d=e[b].1x;if((d 1W N.1f.3T||d 1W N.1f.8W)&&d.6L(f)){c=e[b];K.6Z.1i.9P([c],{5B:1d});K.6Z.1i.1n.lU("hU",K,K.wr);K.6Z.1i.1n.lU("kE",K,K.wq);c.1x.7U(K.3Z.1x);K.6U=c;K.lT=1d;1F}}}N.1Y.gP.1g.ie.1j(K,1r)},gQ:Q(){R K.3Z.1x.1y.1a-2},wq:Q(d){O a=d.dv;O c=K.3Z.1x.1y;if(!K.6U.1x.6L(a)){O b=c[c.1a-3];a.x=b.x;a.y=b.y}},iB:Q(){O a=K.3Z.1x.1y.1a-2;K.3Z.1x.9V(K.3Z.1x.1y[a]);K.ic();K.bD()},wr:Q(){O c=K.3Z.1x;O b=(c.94()!==0);if(b){O h=K.6U.1x.1y;1h(O d=h.1a-2;d>=0;--d){if(c.6L(h[d])){b=1b;1F}}if(b){O g;cr:1h(O d=h.1a-2;d>0;--d){O e=h[d].1y;1h(O a=0,f=e.1a;a<f;++a){if(c.dq(e[a])){b=1b;1F cr}}}}}if(b){if(K.6U.7I!==N.69.gu){K.6U.7I=N.69.dw}}V{K.6U.1x.9V(c)}K.ws();R 1b},8w:Q(){if(K.lT){K.6U.1x.9V(K.3Z.1x);K.ws(1d)}R N.1Y.gP.1g.8w.1j(K,1r)},ws:Q(a){K.6Z.1i.1n.6S("hU",K,K.wr);K.6Z.1i.1n.6S("kE",K,K.wq);K.1i.9P([K.6U],{5B:1d});K.6Z.1i.7u([K.6U],{5B:1d});K.lT=1b;if(!a){K.6Z.1i.1n.1M("hU",{1J:K.6U})}},gO:Q(a){N.1Y.gP.1g.gO.4g(K,a);K.6U=P},3V:Q(){K.1i.3V(K.6U,K.W);K.1i.3V(K.3l,K.W)},j3:Q(){R K.6U},lS:Q(){O a=K.6U&&K.6U.1x;if(a&&K.eN){a=S N.1f.8W([a])}R a},1p:"N.1Y.3T"});N.1Y.3k=N.1z(N.1Y,{FS:{2U:{"in":"2U",4t:"97"},4p:{"in":"6f",4t:"4t"},4F:{"in":"4F",4t:P},48:{"in":P,4t:P},4o:{"in":P,4t:P},8R:{"in":"2U",4t:"97"},j0:{"in":"eV",4t:P}},1J:P,7M:P,4q:P,up:P,5t:1b,FR:4,k9:1b,64:P,wp:1d,7W:1b,lR:1b,1o:Q(d,b,c,a){N.1Y.1g.1o.1j(K,[d,c,a]);K.1i=b},8R:Q(a){if(!K.5t){K.5t=1d;K.U.1n.un({48:K.48,4o:K.4o,4p:K.4p,2U:K.2U,4F:K.4F,2y:K})}K.FU=N.1H.qm(a)?1b:1d;N.1H.2K(a);R K.dH(a)?!K.7W:1d},9q:Q(a){K.FU=1b;N.1H.2K(a)},48:Q(a){if(N.1H.aE(a)||N.1H.pQ(a)){K.4q=a.xy}R K.dH(a)?!K.7W:1d},4o:Q(a){K.up=a.xy;R K.dH(a)?!K.lR:1d},2U:Q(a){R K.dH(a)?!K.wp:1d},j0:Q(a){if(a.bv){a.bv()}V{a.FT=1b}R K.dH(a)?!K.wp:1d},4p:Q(a){if(!K.3F.6f&&!K.3F.4t){R 1d}K.dH(a);R 1d},4F:Q(a){R!K.dH(a)},w2:Q(a){R K.64==P||N.1c.2S(K.64,a.1x.1p)>-1},dH:Q(a){if(K.1J&&!K.1J.1i){K.1J=P}O c=a.2E;O f=1b;O e=!!(K.1J);O d=(c==="2U"||c==="4F"||c==="j0"||c==="8R");K.1J=K.1i.kz(a);if(K.1J&&!K.1J.1i){K.1J=P}if(K.7M&&!K.7M.1i){K.7M=P}if(K.1J){if(c==="8R"){N.1H.2K(a)}O b=(K.1J!==K.7M);b=K.k9?1d:b;if(K.w2(K.1J)){if(e&&b){if(K.7M){K.bB(c,"4t",[K.7M,a])}K.bB(c,"in",[K.1J,a])}V{if(!e||d){K.bB(c,"in",[K.1J,a])}}K.7M=K.1J;f=1d}V{if(K.7M&&(e&&b||d)){K.bB(c,"4t",[K.7M,a])}K.1J=P}}V{if(K.7M&&(e||d)){K.bB(c,"4t",[K.7M,a])}}R f},bB:Q(d,e,b){O c=K.FS[d][e];if(c){if(d==="2U"&&K.up&&K.4q){O a=1k.5r(1k.2Y(K.up.x-K.4q.x,2)+1k.2Y(K.up.y-K.4q.y,2));if(a<=K.FR){K.3n(c,b)}}V{K.3n(c,b)}}},2p:Q(){O a=1b;if(N.1Y.1g.2p.1j(K,1r)){K.wo();K.U.1n.on({du:K.lQ,7B:K.lQ,2y:K});a=1d}R a},2a:Q(){O a=1b;if(N.1Y.1g.2a.1j(K,1r)){K.FQ();K.1J=P;K.7M=P;K.4q=P;K.up=P;K.5t=1b;K.U.1n.un({du:K.lQ,7B:K.lQ,2y:K});a=1d}R a},lQ:Q(a){if(a.2E==="du"||a.bh==="88"){K.wo()}},wo:Q(){O a=1k.3f(K.U.bC.qr-1,K.1i.gk())+1;K.1i.gN(a)},FQ:Q(){O a=K.1i.gk()-1;if(a>=K.U.bC.qr){K.1i.gN(a)}V{K.U.lP(K.1i,K.U.qq(K.1i))}},1p:"N.1Y.3k"});N.1Y.cA=N.1z(N.1Y,{6D:1b,7W:1d,3S:1b,5t:1b,3u:P,3X:P,wm:P,gM:P,6Y:0,qo:P,7D:1b,lO:P,1o:Q(d,c,a){N.1Y.1g.1o.1j(K,1r);if(K.7D===1d){O b=K;K.wg=Q(e){b.4p({xy:{x:e.aF,y:e.9Z},2h:1Q})};K.wf=Q(e){b.4o({xy:{x:e.aF,y:e.9Z}})}}},iA:Q(b){O a=1d;K.3S=1b;if(K.j1(b)&&(N.1H.aE(b)||N.1H.pQ(b))&&!N.dJ){K.6D=1d;K.3X=b.xy;K.3u=b.xy;N.2I.54(K.U.3z,"li");O c=N.1c.4M();K.U.3z.W.3G="1B(\'"+c+"wk/Rd.wj\'),3x";K.4q(b);K.3n("4q",[b.xy]);N.1H.2K(b);if(!K.gM){K.gM=1Q.cl?1Q.cl:N.2u.qk}1Q.cl=N.2u.i3;a=!K.7W}V{K.6D=1b;K.3X=P;K.3u=P}R a},wn:Q(a){K.wm=a;if(K.6D&&!K.qo&&(a.xy.x!==K.3u.x||a.xy.y!==K.3u.y)){if(K.7D===1d&&K.lO){if(a.2h===1Q){K.wi(a);K.qp(a)}V{K.wh()}}if(K.6Y>0){K.qo=6u(N.2u.3E(K.FP,K),K.6Y)}K.3S=1d;K.3x(a);K.3n("3x",[a.xy]);if(!K.gM){K.gM=1Q.cl;1Q.cl=N.2u.i3}K.3u=a.xy}R 1d},qn:Q(b){if(K.6D){if(K.7D===1d&&K.lO){K.wi(b);K.wh()}O a=(K.3X!==K.3u);K.6D=1b;K.3S=1b;N.2I.9Y(K.U.3z,"li");K.U.3z.W.3G="";K.up(b);K.3n("up",[b.xy]);if(a){K.3n("7c",[b.xy])}1Q.cl=K.gM}R 1d},4q:Q(a){},3x:Q(a){},up:Q(a){},4t:Q(a){},48:Q(a){R K.iA(a)},8R:Q(a){if(!K.5t){K.5t=1d;K.U.1n.un({48:K.48,4o:K.4o,4p:K.4p,2U:K.2U,2y:K})}R K.iA(a)},4p:Q(a){R K.wn(a)},9q:Q(a){R K.wn(a)},FP:Q(){K.qo=P;if(K.3S){K.4p(K.wm)}},4o:Q(a){R K.qn(a)},eU:Q(a){a.xy=K.3u;R K.qn(a)},aL:Q(b){if(K.6D&&N.1c.wl(b,K.U.6v)){if(K.7D===1d){K.FN()}V{O a=(K.3X!==K.3u);K.6D=1b;K.3S=1b;N.2I.9Y(K.U.3z,"li");O c=N.1c.4M();K.U.3z.W.3G="1B(\'"+c+"wk/FO.wj\'),49";K.4t(b);K.3n("4t",[]);if(a){K.3n("7c",[b.xy])}if(1Q.cl){1Q.cl=K.gM}}}R 1d},2U:Q(a){R(K.3X===K.3u)},2p:Q(){O a=1b;if(N.1Y.1g.2p.1j(K,1r)){K.3S=1b;a=1d}R a},2a:Q(){O a=1b;if(N.1Y.1g.2a.1j(K,1r)){K.5t=1b;K.6D=1b;K.3S=1b;K.3X=P;K.3u=P;a=1d}R a},wi:Q(a){O b=N.1c.vv(K.U.3z);a.xy.x-=b[0];a.xy.y-=b[1]},FN:Q(){K.lO=1d;N.1H.3m(1Q,"4p",K.wg);N.1H.3m(1Q,"4o",K.wf)},wh:Q(){K.lO=1b;N.1H.a3(1Q,"4p",K.wg);N.1H.a3(1Q,"4o",K.wf)},1p:"N.1Y.cA"});N.1Y.vT=N.1z(N.1Y,{6D:1b,7W:1b,dI:1b,3u:P,3X:P,gL:P,3D:P,1o:Q(d,c,a){O b=K;N.1Y.1g.1o.1j(b,1r)},we:Q(a){O b=2t FM;if(K.gL===P&&(b!=="2q")){K.gL=S FM();K.gL.bw=a.bw}if(a.Rc!=="uM"&&(b!=="2q")){K.gL.Rb(a.Ra)}},wd:Q(a){if(K.gL){K.gL.2K()}},FL:Q(a){K.we(a)},FK:Q(a){K.wd(a)},8R:Q(b){O a=1d;K.dI=1b;if(N.1H.qm(b)||N.dJ){K.6D=1d;K.3u=K.3X={3H:K.wc(b.6E),gI:0,3D:1};K.3n("3X",[b,K.3X]);a=!K.7W}V{K.6D=1b;K.3X=P;K.3u=P}N.1H.2K(b);R a},9q:Q(a){if(K.6D&&N.1H.qm(a)||N.dJ){K.dI=1d;O b=K.FH(a);K.3n("3x",[a,b]);K.3u=b;N.1H.2K(a)}R 1d},eU:Q(a){if(K.6D){bu{if(N.dJ){K.U.2b.ql=0}}bt(b){}K.6D=1b;K.dI=1b;K.3n("7c",[a,K.3X,K.3u]);K.3X=P;K.3u=P}R 1d},FJ:Q(b){O a=1d;K.dI=1b;K.6D=1d;K.3D=1;K.3u=K.3X={3D:1};K.3n("Fa",[b,K.3X]);a=!K.7W;N.1H.2K(b);R a},FI:Q(a){if(a.3D===1){R}K.U.iZ=1b;if(K.6D){K.dI=1d;K.3D=a.3D*K.3D;O b={3D:K.3D};K.3n("F9",[a,b]);K.3u=b;N.1H.2K(a)}R 1d},vN:Q(a){if(K.6D){K.6D=1b;K.dI=1b;K.3n("F8",[a,K.3X,K.3u]);K.3X=P;K.3u=P;K.3D=P}R 1d},2p:Q(){O a=1b;if(N.1Y.1g.2p.1j(K,1r)){K.dI=1b;a=1d}R a},2a:Q(){O a=1b;if(N.1Y.1g.2a.1j(K,1r)){K.6D=1b;K.dI=1b;K.3X=P;K.3u=P;K.R9=P,K.R8=0,K.3D=1,a=1d}R a},wc:Q(c){O b=c[0];O a=c[1];if(!a){R 0}V{R 1k.5r(1k.2Y(b.aF-a.aF,2)+1k.2Y(b.9Z-a.9Z,2))}},FH:Q(a){O c=K.wc(a.6E);O b=c/K.3X.3H;if(c==0||K.3X.3H==0){O b=1}V{O b=c/K.3X.3H}R{3H:c,gI:K.3u.3H-c,3D:b}},1p:"N.1Y.vT"});N.1Y.FE=N.1z(N.1Y.cA,{gm:4,4J:P,j2:P,w9:"wb",cB:P,ak:1b,qh:1b,6g:P,qi:1b,1J:P,1i:P,6z:P,1o:Q(c,b,a){if(!(a&&a.cB&&a.cB.az)){K.W=N.1c.1K(N.3k.2X.W["49"],{})}N.1Y.cA.1g.1o.1j(K,[c,b,a]);K.2C=(a)?a:{}},jA:Q(a){N.1c.1K(K.2C,a);N.1c.1K(K,a)},2p:Q(){O a=1b;if(N.1Y.cA.1g.2p.1j(K,1r)){O b=N.1c.1K({kA:1b,c6:N.2u.qk},K.cB);K.1i=S N.1C.2X(K.1p,b);K.U.fL(K.1i);a=1d;N.2I.54(K.U.3z,"qj")}R a},2a:Q(){O a=1b;if(N.1Y.cA.1g.2a.1j(K,1r)){if(K.3S){K.8w()}if(K.1i.U!=P){K.1i.1m(1b);if(K.1J){K.1J.1m()}}K.1i=P;K.1J=P;a=1d;N.2I.9Y(K.U.3z,"qj")}R a},4q:Q(a){K.qi=!!(K.4J);O b=K.1i.5n(a.xy);K.6z=S N.1f.1D(b.1P,b.1R);N.2I.9Y(K.U.3z,"li");K.U.3z.W.3G="";if(!K.qi||K.qh){K.4J=K.U.2r()}if(K.ak){K.5z()}K.1J=S N.3k.2X();K.wa();K.3n("lj",[K.6z,K.1J]);K.1i.7u([K.1J],{5B:1d});K.1i.3V(K.1J,K.W)},3x:Q(c){O f=K.1i.5n(c.xy);O a=S N.1f.1D(f.1P,f.1R);if(K.qh){O g=1k.5r(2)*1k.3N(a.y-K.6z.y)/2;K.4J=1k.3f(K.U.2r()/2,g)}V{if(K.qi){K.6z=a}V{K.FF(a,c);K.4J=1k.3f(K.U.2r()/2,a.74(K.6z))}}K.FG();if(K.qh){O d=a.x-K.6z.x;O b=a.y-K.6z.y;O e;if(b==0){e=d/(K.4J*1k.5r(2))}V{e=d/b}K.1J.1x.7C(1,K.6z,e);K.1J.1x.3x(d/2,b/2)}K.1i.3V(K.1J,K.W)},up:Q(a){K.bD();if(K.3X===K.3u){K.3n("7c",[a.xy])}},4t:Q(a){K.bD()},wa:Q(){K.6g=1k.PI*((1/K.gm)-(1/2));if(K.j2){K.6g+=K.j2*(1k.PI/2R)}K.1J.1x=N.1f.3T.D6(K.6z,K.4J,K.gm,K.j2)},FG:Q(){O d,a;O b=K.1J.1x.1y[0];if(b.1y.1a!==(K.gm+1)){K.wa();b=K.1J.1x.1y[0]}1h(O c=0;c<K.gm;++c){a=b.1y[c];d=K.6g+(c*2*1k.PI/K.gm);a.x=K.6z.x+(K.4J*1k.8y(d));a.y=K.6z.y+(K.4J*1k.7P(d));a.9W()}},FF:Q(a,b){O d=1k.l9(a.y-K.6z.y,a.x-K.6z.x);if(K.j2&&(K.w9&&!b[K.w9])){O c=(1k.PI/2R)*K.j2;K.6g=1k.2w(d/c)*c}V{K.6g=d}},8w:Q(){K.3n("8w",P);K.bD()},bD:Q(){K.6z=P;K.4J=K.2C.4J},5z:Q(){if(K.1i){K.1i.2f.5z();K.1i.9I()}},3n:Q(b,a){if(K.3F[b]){K.3F[b].1j(K.6Z,[K.1J.1x.1T()])}if(!K.ak&&(b==="7c"||b==="8w")){K.5z()}},1p:"N.1Y.FE"});N.1Y.k8=N.1z(N.1Y,{8T:P,nR:"R7",lN:P,gK:P,1o:Q(c,b,a){N.1Y.1g.1o.1j(K,1r);K.8T=S N.1Y.cA(K,{4q:K.FD,3x:K.FB,4t:K.qg,up:K.FA},{dF:K.dF});if(a&&a.gK){K.gK=a.gK}},1m:Q(){N.1Y.1g.1m.1j(K,1r);if(K.8T){K.8T.1m();K.8T=P}},3a:Q(a){N.1Y.1g.3a.1j(K,1r);if(K.8T){K.8T.3a(a)}},FD:Q(a){K.3n("3X",[]);K.5e=N.1c.7m("5e",{x:-FC,y:-FC});K.5e.3M=K.nR;K.5e.W.5j=K.U.bC.3Y-1;K.U.6v.1V(K.5e);N.2I.54(K.U.6v,"Fz");if(K.gK){K.U.6v.W.3G=K.gK}},FB:Q(e){O d=K.8T.3X.x;O b=K.8T.3X.y;O c=1k.3N(d-e.x);O a=1k.3N(b-e.y);O f=K.Fy();K.5e.W.1A=(c+f.1A+1)+"px";K.5e.W.1E=(a+f.1E+1)+"px";K.5e.W.1s=(e.x<d?d-c-f.1s:d-f.1s)+"px";K.5e.W.1t=(e.y<b?b-a-f.1t:b-f.1t)+"px"},FA:Q(b){O a;if(1k.3N(K.8T.3X.x-b.x)>5||1k.3N(K.8T.3X.y-b.y)>5){O g=K.8T.3X;O f=1k.4v(g.y,b.y);O c=1k.3f(g.y,b.y);O e=1k.4v(g.x,b.x);O d=1k.3f(g.x,b.x);a=S N.1U(e,c,d,f)}V{a=K.8T.3X.1T()}K.qg();if(K.gK){K.U.6v.W.3G=""}K.3n("7c",[a])},qg:Q(){K.U.6v.2T(K.5e);K.5e=P;K.lN=P;N.2I.9Y(K.U.6v,"Fz")},2p:Q(){if(N.1Y.1g.2p.1j(K,1r)){K.8T.2p();R 1d}V{R 1b}},2a:Q(){if(N.1Y.1g.2a.1j(K,1r)){if(K.8T.2a()){if(K.5e){K.qg()}}R 1d}V{R 1b}},Fy:Q(){if(!K.lN){O d=1Q.2G("1q");d.W.2v="3d";d.W.8S="oI c3 R6";d.W.1A="E8";1Q.7n.1V(d);O a=d.i2===3;1Q.7n.2T(d);O f=2g(N.2I.9r(K.5e,"8S-1s-1A"));O c=2g(N.2I.9r(K.5e,"8S-1I-1A"));O e=2g(N.2I.9r(K.5e,"8S-1t-1A"));O b=2g(N.2I.9r(K.5e,"8S-1L-1A"));K.lN={1s:f,1I:c,1t:e,1L:b,1A:a===1b?f+c:0,1E:a===1b?e+b:0}}R K.lN},1p:"N.1Y.k8"});N.1Y.vW=N.1z(N.1Y,{lM:P,qe:P,6Y:0,gI:0,w5:1d,1o:Q(c,b,a){N.1Y.1g.1o.1j(K,1r);K.lM=N.2u.59(K.Fx,K)},1m:Q(){N.1Y.1g.1m.1j(K,1r);K.lM=P},Fx:Q(k){if(!K.U||!K.j1(k)){R}O g=1b;O m=1b;O f=1b;O b=N.1H.2h(k);4W((b!=P)&&!f&&!g){if(!g){bu{if(b.iN){O c=b.iN.9M}V{O a=1Q.iM.iL(b,P);O c=a.w8("9M")}g=(c&&(c==="4i")||(c==="w7"))}bt(d){}}if(!m){1h(O h=0,j=K.U.1O.1a;h<j;h++){if(b===K.U.1O[h].1q||b===K.U.1O[h].7E){m=1d;1F}}}f=(b===K.U.1q);b=b.2V}if(!g&&f){if(m){O l=0;if(!k){k=2k.b7}if(k.Fw){l=k.Fw/lg;if(2k.qf&&2k.qf.gJ()<9.2){l=-l}}V{if(k.Fv){l=-k.Fv/3}}K.gI=K.gI+l;if(K.6Y){2k.6t(K.8i);K.8i=2k.6u(N.2u.3E(Q(){K.w6(k)},K),K.6Y)}V{K.w6(k)}}N.1H.2K(k)}},w6:Q(a){O b=K.gI;K.gI=0;if(b){if(K.qe){a.xy=K.qe}if(!a.xy){a.xy=K.U.dg(K.U.aG())}if(b<0){K.3n("4q",[a,K.w5?b:-1])}V{K.3n("up",[a,K.w5?b:1])}}},4p:Q(a){K.qe=a.xy},2p:Q(a){if(N.1Y.1g.2p.1j(K,1r)){O b=K.lM;N.1H.3m(2k,"Fu",b);N.1H.3m(2k,"qd",b);N.1H.3m(1Q,"qd",b);R 1d}V{R 1b}},2a:Q(a){if(N.1Y.1g.2a.1j(K,1r)){O b=K.lM;N.1H.a3(2k,"Fu",b);N.1H.a3(2k,"qd",b);N.1H.a3(1Q,"qd",b);R 1d}V{R 1b}},1p:"N.1Y.vW"});N.1Y.py=N.1z(N.1Y,{lL:["fh","R5"],lK:P,1o:Q(c,b,a){N.1Y.1g.1o.1j(K,1r);K.lK=N.2u.59(K.Ft,K)},1m:Q(){K.2a();K.lK=P;N.1Y.1g.1m.1j(K,1r)},2p:Q(){if(N.1Y.1g.2p.1j(K,1r)){1h(O b=0,a=K.lL.1a;b<a;b++){N.1H.3m(1Q,K.lL[b],K.lK)}R 1d}V{R 1b}},2a:Q(){O c=1b;if(N.1Y.1g.2a.1j(K,1r)){1h(O b=0,a=K.lL.1a;b<a;b++){N.1H.a3(1Q,K.lL[b],K.lK)}c=1d}R c},Ft:Q(a){if(K.j1(a)){K.3n(a.2E,[a])}},1p:"N.1Y.py"});N.1Y.df=N.1z(N.1Y.3k,{4L:P,cu:P,1o:Q(d,b,c,a){N.1Y.3k.1g.1o.1j(K,[d,b,c,a])},dH:Q(a){if(K.4L&&!K.4L.1i){K.4L=P}O c=a.2E;O f=1b;O e=!!(K.4L);O d=(c==="2U"||c==="4F"||c==="j0"||c==="8R");K.4L=K.1i.w4(a);if(K.4L){if(c==="8R"){N.1H.2K(a)}O b=(K.4L!==K.cu);b=K.k9?1d:b;if(K.w2(K.4L)){if(e&&b){if(K.cu){K.bB(c,"4t",[K.cu,a])}K.bB(c,"in",[K.4L,a])}V{if(!e||d){K.bB(c,"in",[K.4L,a])}}K.cu=K.4L;f=1d}V{if(K.cu&&(e&&b||d)){K.bB(c,"4t",[K.cu,a])}K.4L=P}}V{K.bB(c,"4t",[K.cu,a]);K.4L=P}R f},1p:"N.1Y.df"});N.1v=N.1z({id:P,U:P,1q:P,gr:P,2E:P,Fr:1b,5M:"",8x:"",2v:P,98:1b,3I:P,3s:P,2F:P,1n:P,2P:["2p","2a"],1o:Q(a){K.5M=K.1p.4D("N.","sm").4D(/\\./g,"");N.1c.1K(K,a);K.1n=S N.4l(K,P,K.2P);if(K.2F 1W 78){K.1n.on(K.2F)}if(K.id==P){K.id=N.1c.7x(K.1p+"4n")}},1m:Q(){if(K.1n){if(K.2F){K.1n.un(K.2F)}K.1n.1m();K.1n=P}K.2F=P;if(K.3s){K.3s.1m();K.3s=P}if(K.1X){1h(O a in K.1X){if(K.1X.dX(a)&&2t K.1X[a].1m==="Q"){K.1X[a].1m()}}K.1X=P}if(K.U){K.U.Fs(K);K.U=P}K.1q=P},3a:Q(a){K.U=a;if(K.3s){K.3s.3a(a)}},R4:Q(a){K.2H(a)},2H:Q(a){if(K.1q==P){K.1q=N.1c.7m(K.id);K.1q.3M=K.5M;if(!K.Fr){K.1q.3M+=" R3";K.1q.c2("Cl","on",0);K.1q.cl=N.2u.i3}if(K.8x!=""){K.1q.8x=K.8x}}if(a!=P){K.2v=a.1T()}K.2O(K.2v);R K.1q},2O:Q(b){if(!b){b=K.gr}if((b!=P)&&(K.1q!=P)){O c=K.1q.W,e=N.2B.Fq,a=b.x+"px",d=b.y+"px";if(b.8N){c.1s=P;c.1t=P;c.1I=P;c.1L=P}if(!e){c.1s=a;c.1t=d;R}5U(b.8N){1N e.Fp:c.1s=a;c.1t=d;1F;1N e.Fo:c.1I=a;c.1t=d;1F;1N e.Fn:c.1I=a;c.1L=d;1F;1N e.Fm:c.1s=a;c.1L=d;1F;49:c.1s=a;c.1t=d;1F}}},2p:Q(){if(K.3I){R 1b}if(K.3s){K.3s.2p()}K.3I=1d;if(K.U){N.2I.54(K.U.3z,K.5M.4D(/ /g,"")+"Fl")}K.1n.1M("2p");R 1d},2a:Q(){if(K.3I){if(K.3s){K.3s.2a()}K.3I=1b;if(K.U){N.2I.9Y(K.U.3z,K.5M.4D(/ /g,"")+"Fl")}K.1n.1M("2a");R 1d}R 1b},1p:"N.1v"});N.1v.gy="R2";N.1v.B2=1;N.1v.B1=2;N.1v.kc=3;N.1v.vX=N.1z(N.1v,{2E:N.1v.kc,4t:1b,dF:P,89:P,Fk:1b,1o:Q(b,a){N.1v.1g.1o.1j(K,1r);if(a){K.89=a}},2H:Q(){O a=N.1c.1K({dF:K.dF},K.89);K.3s=S N.1Y.k8(K,{7c:K.5e},a)},5e:Q(h){if(h 1W N.1U){O b;if(!K.4t){O i=K.U.6M({x:h.1s,y:h.1L});O m=K.U.6M({x:h.1I,y:h.1t});b=S N.1U(i.1P,i.1R,m.1P,m.1R)}V{O g=1k.3N(h.1I-h.1s);O j=1k.3N(h.1t-h.1L);O e=1k.4v((K.U.1G.h/j),(K.U.1G.w/g));O n=K.U.42();O a=K.U.6M(h.vI());O c=a.1P-(n.3L()/2)*e;O f=a.1P+(n.3L()/2)*e;O l=a.1R-(n.4y()/2)*e;O d=a.1R+(n.4y()/2)*e;b=S N.1U(c,l,f,d)}O k=K.U.4G();K.U.qc(b);if(k===K.U.4G()&&K.Fk==1d){K.U.gz(k+(K.4t?-1:1))}}V{if(!K.4t){K.U.5X(K.U.6M(h),K.U.4G()+1)}V{K.U.5X(K.U.6M(h),K.U.4G()-1)}}},1p:"N.1v.vX"});N.1v.q5=N.1z(N.1v,{2E:N.1v.kc,qa:1b,6Y:1,7D:1b,dG:P,qb:1b,Fj:10,2H:Q(){if(K.qb){O a={6Y:K.Fj};if(2t K.qb==="6q"){a=N.1c.1K(a,K.qb)}K.dG=S N.w1(a)}K.3s=S N.1Y.cA(K,{3x:K.Fh,7c:K.Fg,4q:K.Fi},{6Y:K.6Y,7D:K.7D})},Fi:Q(){if(K.dG&&K.U.iZ){K.dG.aC()}},Fh:Q(a){if(!K.U.iZ){R}if(K.dG){K.dG.6P(a)}K.qa=1d;K.U.6X(K.3s.3u.x-a.x,K.3s.3u.y-a.y,{3S:1d,lJ:1b})},Fg:Q(c){if(!K.U.iZ){R}if(K.qa){O b=P;if(K.dG){b=K.dG.fP(c)}K.U.6X(K.3s.3u.x-c.x,K.3s.3u.y-c.y,{3S:!!b,lJ:1b});if(b){O a=K;K.dG.3x(b,Q(d,f,e){a.U.6X(d,f,{3S:!e,lJ:1b})})}K.qa=1b}},1p:"N.1v.q5"});N.1v.vU=N.1z(N.1v,{8h:P,q4:P,8g:P,q3:P,7D:1b,5e:P,q8:1d,q7:1d,Fe:P,vZ:1b,Ff:N.1Y.w0,98:1d,1o:Q(a){K.1X={};N.1v.1g.1o.1j(K,1r)},1m:Q(){K.2a();if(K.8h){K.8h.1m()}K.8h=P;if(K.5e){K.5e.1m()}K.5e=P;if(K.8g){K.8g.1m()}K.8g=P;N.1v.1g.1m.1j(K,1r)},2p:Q(){K.8h.2p();if(K.q7){K.1X.lI.2p()}K.1X.2U.2p();if(K.q8){K.5e.2p()}if(K.8g){K.8g.2p()}R N.1v.1g.2p.1j(K,1r)},2a:Q(){if(K.8g){K.8g.2a()}K.5e.2a();K.8h.2a();K.1X.2U.2a();K.1X.lI.2a();R N.1v.1g.2a.1j(K,1r)},2H:Q(){if(K.vZ){K.U.3z.R1=N.2u.i3}O a={2U:K.q2,4F:K.q1,vY:K.Fd};O b={"gF":1d,iX:1d};K.1X.2U=S N.1Y.lz(K,a,b);K.8h=S N.1v.q5(N.1c.1K({U:K.U,7D:K.7D},K.q4));K.5e=S N.1v.vX({U:K.U,dF:K.Ff});K.8h.2H();K.5e.2H();K.1X.lI=S N.1Y.vW(K,{up:K.Fc,4q:K.Fb},K.Fe);if(N.1v.lF){K.8g=S N.1v.lF(N.1c.1K({U:K.U},K.q3))}},q2:Q(a){if(a.lE&&a.lE.1a===2){K.U.cD()}},q1:Q(b){O a=K.U.5n(b.xy);K.U.5X(a,K.U.5d+1)},Fd:Q(b){O a=K.U.5n(b.xy);K.U.5X(a,K.U.5d-1)},vV:Q(i,c){O h=K.U.4G();O f=K.U.4G()+1k.2w(c);f=1k.3f(f,0);f=1k.4v(f,K.U.9p());if(f===h){R}O j=K.U.5c();O e=j.w/2-i.xy.x;O d=i.xy.y-j.h/2;K.U.q9=S N.2B(e,d);O g=K.U.2b.a6(f);O a=K.U.6M(i.xy);O b=S N.3i(a.1P+e*g,a.1R+d*g);K.U.5X(b,f);K.U.q9=S N.2B(0,0)},Fc:Q(a,b){K.vV(a,b||1)},Fb:Q(a,b){K.vV(a,b||-1)},R0:Q(){K.q8=1b;K.5e.2a()},QZ:Q(){K.q8=1d;if(K.3I){K.5e.2p()}},QY:Q(){K.q7=1b;K.1X.lI.2a()},QX:Q(){K.q7=1d;if(K.3I){K.1X.lI.2p()}},1p:"N.1v.vU"});N.1v.lF=N.1z(N.1v,{2E:N.1v.kc,vQ:P,lH:P,lG:P,98:1d,1o:Q(a){N.1v.1g.1o.1j(K,1r);K.3s=S N.1Y.vT(K,{3X:K.vS,3x:K.vR,7c:K.vP,Fa:K.vS,F9:K.vR,F8:K.vP},K.89)},2p:Q(){O a=N.1v.1g.2p.1j(K,1r);if(a){K.U.1n.on({7w:K.q6,2y:K});K.q6()}R a},2a:Q(){O a=N.1v.1g.2a.1j(K,1r);if(K.U&&K.U.1n){K.U.1n.un({7w:K.q6,2y:K})}R a},q6:Q(){O a=K.U.3o;K.vQ={x:2g(a.W.1s,10),y:2g(a.W.1t,10)};K.F7={x:2g(0,10),y:2g(0,10)}},vS:Q(a,b){K.lH=a.xy;K.lG=a.xy},vR:Q(h,c){O d=c.3D;O i=K.vQ;O f=K.F7;O a=K.lH;O g=h.xy;O k=1k.2w((g.x-a.x)+(d-1)*(i.x-a.x));O j=1k.2w((g.y-a.y)+(d-1)*(i.y-a.y));O e=1k.2w((g.x-a.x)+(d-1)*(f.x-a.x));O b=1k.2w((g.y-a.y)+(d-1)*(f.y-a.y));K.vO("4c("+k+"px, "+j+"px) 3D("+d+")");K.lG=g},vO:Q(a){O b=K.U.3o.W;b["-QW-3K"]=a;b["-QV-3K"]=a;b["-ms-3K"]=a;b.3K=a},vP:Q(b,h,g){K.vO("");if(b.2E==="vN"){K.U.vM=1d;K.U.4X=g.3D}O f=K.U.a5(K.U.2r()/g.3D,1d);if(f!==K.U.4G()||!K.lG.3w(K.lH)){O d=K.U.a6(f);O a=K.U.6M(K.lH);O c=K.lG;O e=K.U.5c();a.1P+=d*((e.w/2)-c.x);a.1R-=d*((e.h/2)-c.y);K.U.5X(a,f);K.U.vM=1b;K.U.iZ=1d}},1p:"N.1v.lF"});N.1v.F5=N.1z(N.1v,{8h:P,q4:P,8g:P,q3:P,F6:P,7D:1b,98:1d,1o:Q(a){K.1X={};N.1v.1g.1o.1j(K,1r)},1m:Q(){K.2a();if(K.8h){K.8h.1m()}K.8h=P;if(K.8g){K.8g.1m();2s K.8g}N.1v.1g.1m.1j(K,1r)},2p:Q(){if(N.1v.1g.2p.1j(K,1r)){K.8h.2p();K.1X.2U.2p();K.8g.2p();R 1d}R 1b},2a:Q(){if(N.1v.1g.2a.1j(K,1r)){K.8h.2a();K.1X.2U.2a();K.8g.2a();R 1d}R 1b},2H:Q(){O a={2U:K.q2,4F:K.q1};O b=N.1c.1K({"gF":1d,iX:1d,a1:2},K.F6);K.1X.2U=S N.1Y.lz(K,a,b);K.8h=S N.1v.q5(N.1c.1K({U:K.U,7D:K.7D},K.q4));K.8h.2H();K.8g=S N.1v.lF(N.1c.1K({U:K.U},K.q3))},q2:Q(a){if(a.lE&&a.lE.1a===2){K.U.cD()}},q1:Q(b){O a=K.U.5n(b.xy);K.U.5X(a,K.U.5d+1)},1p:"N.1v.F5"});N.1v.F0=N.1z(N.1v,{98:1d,2h:P,F2:"",po:", ",F1:"",F3:5,vL:10,vK:P,iY:P,5E:P,1m:Q(){K.2a();N.1v.1g.1m.1j(K,1r)},2p:Q(){if(N.1v.1g.2p.1j(K,1r)){K.U.1n.4N("4p",K,K.3y);K.U.1n.4N("aL",K,K.4C);K.3y();R 1d}V{R 1b}},2a:Q(){if(N.1v.1g.2a.1j(K,1r)){K.U.1n.6S("4p",K,K.3y);K.U.1n.6S("aL",K,K.4C);K.2h.5N="";R 1d}V{R 1b}},2H:Q(){N.1v.1g.2H.1j(K,1r);if(!K.2h){K.1q.1s="";K.1q.1t="";K.2h=K.1q}if(K.2v){N.2I.9Y(K.1q,K.5M);K.1q.W.23="i5";K.1q.W.2v="3d";K.1q.W["9H-t9"]="QU";K.1q.W["9H-1G"]="QT"}R K.1q},3y:Q(a){O c;if(a==P){K.4C();R}V{if(K.iY==P||1k.3N(a.xy.x-K.iY.x)>K.vL||1k.3N(a.xy.y-K.iY.y)>K.vL){K.iY=a.xy;R}c=K.U.6M(a.xy);if(!c){R}if(K.5E){c.3K(K.U.5Y(),K.5E)}K.iY=a.xy}O b=K.F4(c);if(b!==K.2h.5N){K.2h.5N=b}},4C:Q(a){if(K.vK!=P){K.2h.5N=K.vK}},F4:Q(b){O c=2g(K.F3);O a=K.F2+b.1P.l1(c)+K.po+b.1R.l1(c)+K.F1;R a},1p:"N.1v.F0"});N.1v.EK=N.1z(N.1v,{2h:P,3q:P,1G:{w:2R,h:2R},1O:P,gE:8,EO:"QS",pZ:24,pY:32,ER:P,EU:1d,1X:P,vE:1,lC:1d,1o:Q(d){O a=1b,e,c,b;K.1O=[];K.1X={};N.1v.1g.1o.1j(K,[d])},3a:Q(a){N.1v.1g.3a.1j(K,[a]);K.U.1n.4N("8L",K,K.vJ)},EZ:Q(){if(K.U.2b){O e=K.1O;1h(O c=0,a=e.1a;c<a;c++){K.3q.b6(e[c]);K.1O.9h()}O b=K.U.2b.1T();b.5S=1d;K.1O.1w(b);K.3q.pX(K.1O);O d=K;6u(Q(){if(d.U&&d.U.42()){d.6P();d.vH()}},0);K.3q.lD=P;K.3q.pK()}R 1b},1m:Q(){if(!K.a4){R}if(K.1X.2U){K.1X.2U.1m()}if(K.1X.5s){K.1X.5s.1m()}K.3q&&K.3q.6v.2T(K.6m);K.6m=P;if(K.iW){K.iW.1m();K.iW=P}if(K.3q){K.3q.1m();K.3q=P}K.2h.2T(K.a4);K.a4=P;K.1q.2T(K.2h);K.2h=P;if(K.5u){N.1H.9F(K.5u);K.1q.2T(K.5u);K.5u=P}if(K.5g){N.1H.9F(K.5g);K.1q.2T(K.5g);K.5g=P}K.U.1n.un({7w:K.6P,8L:K.vJ,2y:K});N.1v.1g.1m.1j(K,1r)},2H:Q(c){N.1v.1g.2H.1j(K);if(K.3q!==P){R K.EZ()}if(!(K.1O.1a>0)){if(K.U.2b){O e=K.U.2b.1T();e.5S=1d;K.1O=[e]}V{R K.1q}}if(2t K.2h==="2q"||K.2h===P){K.2h=1Q.2G("1q");K.2h.3M=K.5M+"2I";K.2h.W.23="2L";K.a4=1Q.2G("1q");K.a4.W.1A=K.1G.w+"px";K.a4.W.1E=K.1G.h+"px";K.a4.W.2v="fW";K.a4.W.9M="8C";K.a4.id=N.1c.7x("QR");if(N.1v.gy!=="iD"){K.a4.W.EY="#q0";K.a4.W.EX="#q0";K.2h.W.EY="#q0";K.2h.W.EX="#q0"}K.6m=1Q.2G("1q");K.6m.W.2v="3d";K.6m.W.5j=ib;K.6m.3M=K.5M+"EN";K.2h.1V(K.a4);K.1q.1V(K.2h);if(!K.pI){K.1q.3M+=" "+K.5M+"QQ";O f=N.1c.4M();O b;if(N.1v.gy==="iD"){b=f+"eO/EW.2Z"}V{b=f+"pF/EW.2Z"}K.5u=N.1c.8F(K.5M+"EV",P,S N.2M(15,15),b,"3d");K.5u.W.23="2L";K.5u.3M=K.5M+"EV";N.1H.3m(K.5u,"2U",N.2u.59(K.iC,K));K.1q.1V(K.5u);if(N.1v.gy==="iD"){b=f+"eO/vg.2Z"}V{b=f+"pF/vg.2Z"}K.5g=N.1c.8F("QP",P,S N.2M(15,15),b,"3d");K.5g.W.23="2L";K.5g.3M=K.5M+"QO";N.1H.3m(K.5g,"2U",N.2u.59(K.gv,K));K.1q.1V(K.5g);O g=["4F","48"];1h(O d=0,a=g.1a;d<a;d++){N.1H.3m(K.5u,g[d],N.1H.2K);N.1H.3m(K.5g,g[d],N.1H.2K)}K.gv()}V{K.2h.W.23=""}}if(K.U.42()){K.6P(c)}K.U.1n.4N("7w",K,K.6P);if(K.lC){K.iC()}R K.1q},vJ:Q(){K.lA=1d;K.2H({lA:1d})},EQ:Q(i){O d=K.1X.5s.3u.x-i.x;O b=K.1X.5s.3u.y-i.y;if(d!==0||b!==0){O g=K.bz.1t;O a=K.bz.1s;O e=1k.3N(K.bz.4y());O c=K.bz.3L();O f=1k.3f(0,(g-b));f=1k.4v(f,K.3q.1G.h-K.iV-e);O h=1k.3f(0,(a-d));h=1k.4v(h,K.3q.1G.w-K.iU-c);K.pV(S N.1U(h,f+e,h+c,f))}},EP:Q(i){O b=K.bz.vI();O e=i.xy.x-b.x;O d=i.xy.y-b.y;O g=K.bz.1t;O c=K.bz.1s;O j=1k.3N(K.bz.4y());O a=K.bz.3L();O f=1k.3f(0,(g+d));f=1k.4v(f,K.3q.1G.h-j);O h=1k.3f(0,(c+e));h=1k.4v(h,K.3q.1G.w-a);K.pV(S N.1U(h,f+j,h+a,f));K.vC()},iC:Q(a){K.2h.W.23="";K.lB(1b);if(a!=P){N.1H.2K(a)}if(K.U&&K.U.42()){K.6P();if(K.lA===1d){K.lA=1b;K.vH()}}},vH:Q(){O c=K.1O;1h(O b=0,a=c.1a;b<a;b++){c[b].3y()}},gv:Q(a){K.2h.W.23="2L";K.lB(1d);if(a!=P){N.1H.2K(a)}},lB:Q(a){K.5u.W.23=a?"":"2L";K.5g.W.23=a?"2L":""},6P:Q(a){if(K.3q==P){if(K.lC){K.vG()}V{K.lC=1d;K.lB(1b);K.2h.W.23="";K.vG();K.lC=1b;K.lB(1d);K.2h.W.23="2L"}}if(K.5u&&K.5u.W.23!=="2L"){R}if(K.EU||!K.ET()){K.ES(a)}K.vD()},ET:Q(){O b=K.U.42();O a=K.U.3b;O c=S N.1U(1k.3f(b.1s,a.1s),1k.3f(b.1L,a.1L),1k.4v(b.1I,a.1I),1k.4v(b.1t,a.1t));if(K.3q.bA()!==K.U.bA()){c=c.3K(K.U.5Y(),K.3q.5Y())}O d=K.3q.2r()/K.U.2r();R((d>K.pZ)&&(d<=K.pY)&&(K.3q.42().bg(c)))},ES:Q(c){O d=K.U.2r();O b=K.3q.2r();O e=b/d;if(e>K.pY){b=K.pZ*d}V{if(e<=K.pZ){b=K.pY*d}}if(!c||!c.lA){O a;if(K.3q.bA()!==K.U.bA()){a=K.U.3U.1T();a.3K(K.U.5Y(),K.3q.5Y())}V{a=K.U.3U}K.3q.5X(a,K.3q.a5(b*K.vE))}K.vD()},vG:Q(){O b=N.1c.1K({3R:[],4j:"4i",gH:1b},K.ER);K.3q=S N.dE(K.a4,b);K.3q.6v.1V(K.6m);N.1H.a3(2k,"a2",K.3q.gG);K.3q.pX(K.1O);K.3q.pK();K.iU=2g(N.2I.9r(K.6m,"8S-1s-1A"))+2g(N.2I.9r(K.6m,"8S-1I-1A"));K.iU=(K.iU)?K.iU:2;K.iV=2g(N.2I.9r(K.6m,"8S-1t-1A"))+2g(N.2I.9r(K.6m,"8S-1L-1A"));K.iV=(K.iV)?K.iV:2;K.1X.5s=S N.1Y.cA(K,{3x:K.EQ,7c:K.vC},{U:K.3q});K.1X.2U=S N.1Y.lz(K,{2U:K.EP},{vF:1d,"gF":1b,pW:1d,iX:1d,a1:1,U:K.3q});K.1X.2U.2p();K.iW=S N.4l(K,K.6m,P,1d);K.iW.4N("dx",K,Q(d){if(!K.1X.5s.3I&&!K.U.3S){K.1X.5s.2p()}});K.iW.4N("aL",K,Q(d){if(!K.1X.5s.3S){K.1X.5s.2a()}});if(K.3q.bA()!==K.U.bA()){O c=K.U.5Y().bU()||K.U.2N||K.U.2b.2N;O a=K.3q.5Y().bU()||K.3q.2N||K.3q.2b.2N;K.vE=c&&a?N.fD[c]/N.fD[a]:1}},vD:Q(){O b;if(K.3q.bA()!==K.U.bA()){b=K.U.42().3K(K.U.5Y(),K.3q.5Y())}V{b=K.U.42()}O a=K.EM(b);if(a){K.pV(a)}},vC:Q(){O a=K.EL(K.bz);if(K.3q.bA()!==K.U.bA()){a=a.3K(K.3q.5Y(),K.U.5Y())}K.U.vB(a.5P())},pV:Q(d){O g=1k.3f(d.1t,0);O e=1k.3f(d.1s,0);O b=1k.4v(d.1t+1k.3N(d.4y()),K.3q.1G.h-K.iV);O h=1k.4v(d.1s+d.3L(),K.3q.1G.w-K.iU);O c=1k.3f(h-e,0);O i=1k.3f(b-g,0);if(c<K.gE||i<K.gE){K.6m.3M=K.5M+K.EO;O f=e+(c/2)-(K.gE/2);O a=g+(i/2)-(K.gE/2);if(!2x(a)){K.6m.W.1t=1k.2w(a)+"px"}if(!2x(f)){K.6m.W.1s=1k.2w(f)+"px"}K.6m.W.1E=K.gE+"px";K.6m.W.1A=K.gE+"px"}V{K.6m.3M=K.5M+"EN";if(!2x(g)){K.6m.W.1t=1k.2w(g)+"px"}if(!2x(e)){K.6m.W.1s=1k.2w(e)+"px"}if(!2x(i)){K.6m.W.1E=1k.2w(i)+"px"}if(!2x(c)){K.6m.W.1A=1k.2w(c)+"px"}}K.bz=S N.1U(1k.2w(e),1k.2w(b),1k.2w(h),1k.2w(g))},EM:Q(c){O b=K.vz({1P:c.1s,1R:c.1L});O a=K.vz({1P:c.1I,1R:c.1t});O d=P;if(b&&a){d=S N.1U(b.x,b.y,a.x,a.y)}R d},EL:Q(b){O a=K.vA({x:b.1s,y:b.1L});O c=K.vA({x:b.1I,y:b.1t});R S N.1U(a.1P,a.1R,c.1P,c.1R)},vA:Q(f){O e=K.3q.1G;O d=K.3q.2r();O b=K.3q.42().5P();O c=f.x-(e.w/2);O a=f.y-(e.h/2);R{1P:b.1P+c*d,1R:b.1R-a*d}},vz:Q(c){O a=K.3q.2r();O b=K.3q.42();if(b){R{x:1k.2w(1/a*(c.1P-b.1s)),y:1k.2w(1/a*(b.1t-c.1R))}}},1p:"N.1v.EK"});N.1v.EE=N.1z(N.1v,{98:1d,gD:75,2H:Q(){K.3s=S N.1Y.py(K,{fh:K.EJ})},EJ:Q(a){O b,c=1d;5U(a.DL){1N N.1H.EI:K.U.6X(-K.gD,0);1F;1N N.1H.EH:K.U.6X(K.gD,0);1F;1N N.1H.EG:K.U.6X(0,-K.gD);1F;1N N.1H.EF:K.U.6X(0,K.gD);1F;1N 33:b=K.U.5c();K.U.6X(0,-0.75*b.h);1F;1N 34:b=K.U.5c();K.U.6X(0,0.75*b.h);1F;1N 35:b=K.U.5c();K.U.6X(0.75*b.w,0);1F;1N 36:b=K.U.5c();K.U.6X(-0.75*b.w,0);1F;1N 43:1N 61:1N QN:1N QM:K.U.eS();1F;1N 45:1N QL:1N QK:1N 95:K.U.cD();1F;49:c=1b}if(c){N.1H.2K(a)}},1p:"N.1v.EE"});N.1v.iF=N.1z(N.1v,{gD:50,vy:P,7Y:P,6C:13,6V:lg,QJ:11,cF:11,9m:P,iQ:P,cE:P,vx:P,vu:1b,eT:P,lu:P,aN:[],cG:P,lv:P,8K:1b,iR:1d,gC:P,1o:Q(k){N.1v.1g.1o.1j(K,1r);O c=1b,j=1b,i=S N.2M(17,17),f=S N.2M(27,27),b=S N.2M(11,11),a=S N.2M(63,62),g,e,h,d;if(k){K.8K=2t k.8K!=="2q"?k.8K:1b;K.iR=2t k.iR!=="2q"?k.iR:1d;K.6C=2t k.6C!=="2q"?k.6C:13;K.6V=2t k.6V!=="2q"?k.6V:lg}N.1v.iF.1g.2H=Q(l){N.1v.1g.2H.1j(K,1r);l=l||S N.2B(4,4);l.y+=a.h/2;K.7Y=[];h=K.QI;h=S N.2B(l.x+a.w/2,l.y);O m;if(K.iR){K.cH("6X","5d-vs-aM.2Z",h.3p(-a.w/2+i.w/2,-a.h/2+i.h/2),a);K.cH("iK","",h.3p(-a.w/6+i.w/2,-a.h/2+i.h/2),a);K.cH("iI","",h.3p(-a.w/2+i.w/2,-a.h/6+i.h/2),a);K.cH("iH","",h.3p(a.w/6+i.w/2,-a.h/6+i.h/2),a);K.cH("iJ","",h.3p(-a.w/6+i.w/2,a.w/6+i.w/2),a);K.cH("vp","5d-vs-aM.2Z",h,i);m=a.w/2}V{m=-a.w/2}K.cH("Eq","eO/5d-Ep-aM.2Z",h.3p(-f.w/2+i.w/2,m+i.h/2+10),f);if(K.8K){K.cH("vq","eO/5d-vo-aM.2Z",h.3p(-f.w/2+i.w/2,m+i.h/2+10+f.h+K.6V),f);K.ED(h.3p(i.w/2-K.6C/2,m+i.h/2+10+f.h))}V{K.cH("vq","eO/5d-vo-aM.2Z",h.3p(-f.w/2+i.w/2,m+i.h/2+10+f.h),f)}R K.1q};N.1v.iF.1g.cH=Q(s,m,p,r){g=N.1c.4M()+m;if(s==="iK"||s==="iI"||s==="iJ"||s==="iH"){O o=N.1c.7m(K.id+"4n"+s,p,"","","3d");o.W.1A=r.w/3+"px";o.W.1E=r.w/3+"px";o.W.3G="4m";if(!!(2k.iT&&b4.i1.2S("Ez")===-1)){o.W.dD="#QH";o.W.4V="kR(2J=0)";o.W.2J=0}}V{if(s==="6X"){O o=N.1c.8F(K.id+"4n"+s,p,r,g,"3d")}V{O o=N.1c.8F(K.id+"4n"+s,p,r,g,"3d");o.W.3G="4m"}}K.1q.1V(o);N.1H.3m(o,"48",N.2u.59(K.Er,o));N.1H.3m(o,"4F",N.2u.59(K.8Q,o));N.1H.3m(o,"2U",N.2u.59(K.8Q,o));N.1H.3m(o,"dx",N.2u.59(K.Eu,o));N.1H.3m(o,"aL",N.2u.59(K.Et,o));N.1H.3m(o,"4o",N.2u.59(K.5D,K));o.pL=s;o.id=K.id;o.U=K.U;if(!K.vy){O n=K.gD;O l=Q(){R n}}V{O q=K.vy;O l=Q(t){R K.U.5c()[t]*q}}o.iG=l;K.7Y.1w(o);R o};N.1v.iF.1g.ED=Q(s){if(K.U.9p()){K.cF=(K.6V-11.5)/(K.U.9p()-1)}g=N.1c.4M();O o=P;O n=K.id+"4n"+K.U.id;O x=K.U.9p()-1-K.U.4G();o=N.1c.8F(n,s.3p(K.6C/2-5.5,x*K.cF+1),b,g+"9m.2Z","3d");o.W.3G="4m";K.9m=o;K.iQ=S N.4l(K,o,P,1d,{dB:1d});K.iQ.on({8R:K.pR,9q:K.lw,eU:K.pP,48:K.pR,4p:K.lw,4o:K.pP,4F:K.8Q,2U:K.8Q});O w=S N.2M(K.6C-2,3);O y=P;if(N.1c.gA()){O n=K.id+"4n"+K.U.id;y=N.1c.8F(n,s.3p(1,K.6V),S N.2M(K.6C-2,K.6V),g+"EC.2Z","3d",P,"pN");y.W.1E=w.h+"px"}V{y=N.1c.7m("ls"+K.U.id,s.3p(1,K.6V),S N.2M(K.6C-2,K.6V),g+"EC.2Z")}y.W.3G="4m";K.dC=y;K.cE=S N.4l(K,y,P,1d,{dB:1d});K.cE.on({9q:K.5D,48:K.lx,4p:K.5D,4F:K.8Q,2U:K.8Q});K.1q.1V(y);O q=P;if(N.1c.gA()){O n=K.id+"4n"+K.U.id;q=N.1c.8F(n,s.3p(K.6C/2-0.5,0),S N.2M(1,K.6V),g+"EB.2Z","3d",P,"pN");q.W.1E=K.6V+"px"}V{q=N.1c.7m("ls"+K.U.id,s.3p(K.6C/2-0.5,0),S N.2M(1,K.6V),g+"EB.2Z")}q.W.3G="4m";K.pT=q;K.1q.1V(q);O v=P;if(N.1c.gA()){O n=K.id+"4n"+K.U.id;v=N.1c.8F(n,s,S N.2M(K.6C,K.6V),g+"EA.2Z","3d",P,"pN");v.W.1E=K.6V+"px"}V{v=N.1c.7m("ls"+K.U.id,s,S N.2M(K.6C,K.6V),g+"EA.2Z")}v.W.3G="4m";K.gB=v;K.cE=S N.4l(K,v,P,1d,{dB:1d});if(N.93.iS==="pc"){K.cE.on({9q:K.5D,48:K.lx,4p:K.5D,4o:K.5D,4F:K.8Q,2U:K.8Q,dx:K.pM})}V{K.cE.on({9q:K.5D,48:K.lx,4p:K.5D,4o:K.5D,4F:K.8Q,2U:K.8Q})}K.1q.1V(v);if(K.U.9p()){O m=1b;K.cG=N.1c.7m("",s.3p(K.6C,0),S N.2M(K.6C+30,lg));O u=s.3p(-s.x,-s.y);if(!!(2k.iT&&b4.i1.2S("Ez")===-1)){O l="1B(\'"+g+"pU.ly\')";K.cG.W.pk=l}if(N.93.iS==="pc"){K.vx=S N.4l(K,K.cG,P,1d,{dB:1d});K.vx.on({aL:K.Ev,dx:K.pM,4o:K.5D})}O t=S N.2M(29,21);if(k&&k.gC){K.gC=k.gC;O z=P;1h(O p=0,r=K.gC.Ey.1a;p<r;p++){K.Ew(K.cG,z,u,K.gC.QG[p],K.gC.Ey[p],t)}}}K.Ex=2g(v.W.1t);K.1q.1V(o);K.pO();K.U.1n.4N("pS",K,K.pO)}},QF:Q(){O a={};a.66=K.1q;if(K.iR){a.6X=K.7Y[0];a.iK=K.7Y[1];a.iI=K.7Y[2];a.iH=K.7Y[3];a.iJ=K.7Y[4];a.vp=K.7Y[5];a.eS=K.7Y[6];a.cD=K.7Y[7]}V{a.eS=K.7Y[0];a.cD=K.7Y[1]}if(K.8K){a.QE=K.pT;a.QD=K.gB;a.QC=K.dC;a.9m=K.9m}R a},1m:Q(){K.vw();K.U.1n.un({8L:K.3y,2y:K});K.vr();K.7Y=P;K.2v=P;N.1v.1g.1m.1j(K,1r);2s K.eT;2s K.lv},3a:Q(a){N.1v.1g.3a.1j(K,1r);K.U.1n.4N("8L",K,K.3y)},3y:Q(){if(K.1q!=P){K.vr();K.vw();if(K.cG&&K.cG.2V){K.cG.2V.2T(K.cG);K.cG=P}K.aN=[]}K.2H()},vw:Q(){if(K.8K){K.iQ.un({9q:K.lw,48:K.pR,4p:K.lw,4o:K.pP,4F:K.8Q,2U:K.8Q});K.iQ.1m();K.cE.un({9q:K.5D,48:K.lx,4p:K.5D,4F:K.8Q,2U:K.8Q,dx:K.pM,4o:K.5D});K.cE.1m();K.1q.2T(K.9m);K.1q.2T(K.dC);K.1q.2T(K.pT);K.1q.2T(K.gB);K.9m=P;K.dC=P;K.pT=P;K.gB=P}K.U.1n.6S("pS",K,K.pO)},5D:Q(a){if(K.8K){K.iQ.pe(a)}},lx:Q(a){if(!N.1H.aE(a)){R}O c=a.xy.y/K.cF;if(K.vu||!K.U.iO){c=1k.a0(c)}O b=(K.U.9p()-1)-c;b=1k.4v(1k.3f(b,0),K.U.9p()-1);K.U.gz(b);N.1H.2K(a)},pR:Q(a){if(!N.1H.aE(a)&&!N.1H.pQ(a)){R}K.U.1n.on({9q:K.5D,4p:K.5D,4o:K.5D,2y:K});K.eT=a.xy.1T();K.lv=a.xy.1T();K.gB.iP=P;N.1H.2K(a)},lw:Q(c){if(K.eT!=P){O a=K.eT.y-c.xy.y;O e=N.1c.vv(K.gB);if((c.9Z-e[1])>5.5&&(c.9Z-e[1])<2g(K.gB.W.1E)-5.5){O d=2g(K.9m.W.1t)-a;K.9m.W.1t=d+"px";K.dC.W.1t=d+6+"px";O b=2g(K.dC.W.1E)+a;K.dC.W.1E=b+"px";K.eT=c.xy.1T()}K.lu=K.lv.y-c.xy.y;N.1H.2K(c)}},pP:Q(a){if(!N.1H.aE(a)&&a.2E!=="eU"){R}if(K.eT){K.1q.W.3G="";K.U.1n.un({9q:K.5D,4o:K.5D,4p:K.5D,2y:K});O b=K.U.5d;if(!K.vu&&K.U.iO){b+=K.lu/K.cF;b=1k.4v(1k.3f(b,0),K.U.9p()-1)}V{b+=K.lu/K.cF;b=1k.3f(1k.2w(b),0)}if(b>K.U.9p()-1){b=K.U.9p()-1}K.U.gz(b);K.eT=P;K.lv=P;K.lu=0;N.1H.2K(a)}},pO:Q(){O a=(K.U.9p()-1-K.U.4G())*K.cF+K.Ex+1;if(2x(a)){a=0}K.9m.W.1t=a+"px";K.dC.W.1t=a+6+"px";K.dC.W.1E=K.U.4G()*K.cF+4.5+"px"},Ew:Q(c,f,g,d,a,h,e){O l=S 3Q();O k=d.rU("/"),j=d.rU(".");O i=d.aU(k+1,j);if(N.1c.gA()){O b=K.id+"4n"+K.U.id;f=N.1c.8F(b,g.3p(0,K.cF*a-10),h,d,"3d",P,"pN")}V{f=N.1c.7m("ls"+i,g.3p(0,K.cF*a-3),h,d)}l[0]="ls"+i;l[1]=a;K.aN.1w(l);f.W.3G="4m";f.W.23="2L";f.3M="QB"+i;K.QA=f;K.cE=S N.4l(K,f,P,1d,{dB:1d});K.cE.on({4F:K.vt,2U:K.vt});c.1V(f);K.1q.1V(c)},vt:Q(b){O e,g,f;O d=b?b:2k.7b;if(d.oW){g=d.oW}V{g=d.bw}f=g.id;1h(O c=0,a=K.aN.1a;c<a;c++){if(K.aN[c][0]===f){e=K.U.9p()-1-K.aN[c][1]}}K.U.gz(e);N.1H.2K(b)},pM:Q(b){1h(O c=0,a=K.aN.1a;c<a;c++){if(K.aN[c]){1Q.8G(K.aN[c][0]).W.23="i5"}}},Ev:Q(){1h(O b=0,a=K.aN.1a;b<a;b++){if(K.aN[b]){1Q.8G(K.aN[b][0]).W.23="2L"}}},Eu:Q(){O a=N.1c.4M();5U(K.pL){1N"iK":1Q.8G(K.id+"lr").5o=a+"Qz-aM.2Z";1F;1N"iJ":1Q.8G(K.id+"lr").5o=a+"Qy-aM.2Z";1F;1N"iI":1Q.8G(K.id+"lr").5o=a+"Qx-aM.2Z";1F;1N"iH":1Q.8G(K.id+"lr").5o=a+"Qw-aM.2Z";1F}},Et:Q(){O a=N.1c.4M();5U(K.pL){1N"iK":1N"iJ":1N"iI":1N"iH":1Q.8G(K.id+"lr").5o=a+"5d-vs-aM.2Z";1F}},Qv:Q(b,c){if(b.iN){R b.iN[c]}V{if(2k.iL){O a=c.4D(/([A-Z])/g,"-$1");a=c.eb();R 1Q.iM.iL(b,P)[a]}}R P},Es:Q(a){N.1H.9F(a);a.U=P;a.iG=P;K.1q.2T(a);N.1c.am(K.7Y,a)},vr:Q(){1h(O a=K.7Y.1a-1;a>=0;--a){K.Es(K.7Y[a])}},8Q:Q(a){N.1H.2K(a);R 1b},Er:Q(a){if(!N.1H.aE(a)){R}5U(K.pL){1N"iK":K.U.6X(0,-K.iG("h"));1F;1N"iJ":K.U.6X(0,K.iG("h"));1F;1N"iI":K.U.6X(-K.iG("w"),0);1F;1N"iH":K.U.6X(K.iG("w"),0);1F;1N"Eq":K.U.eS();1F;1N"vq":K.U.cD();1F;1N"vp":K.U.pK();1F}N.1H.2K(a)},1p:"N.1v.iF"});N.1v.Ej=N.1z(N.1v,{Eo:"Qu",En:"Qt",7n:P,1o:Q(a){K.gr=S N.2B(10,10);N.1v.1g.1o.1j(K,1r)},2H:Q(){O e=N.1v.1g.2H.1j(K,1r),b=K.pm(e),d=b.eS,a=b.cD;if(!K.pn){O c=Q(f){R Q(g){f.ph(g)}}(K);N.1H.3m(a.2V,"48",N.2u.59(c,a.2V));K.pn=1d}K.lq=d;K.lp=a;R e},pm:Q(e){O f=K.lq,c=K.lp,a,d;a=K.7n;if(!a){a=1Q.2G("1q");e.1V(a);K.7n=a}if(!f){f=K.ip(a,"5d-Ep-aM.2Z",K.Eo);N.2I.54(f,"ih")}if(!c){c=K.ip(a,"5d-vo-aM.2Z",K.En);N.2I.54(c,"ih")}R{eS:f,cD:c}},ip:Q(i,f,k){O g,e,j=1Q,h;g=j.2G("1q");g.3M=k;h=g.W;h.1A="Em";h.1E="El";h.3G="4m";i.1V(g);e=j.2G("5b");h=e.W;h.1A="Em";h.1E="El";if(N.1v.gy==="iD"){e.5o=N.1c.4M()+"eO/"+f}V{e.5o=N.1c.4M()+"pF/"+f}g.1V(e);R g},Ek:Q(a){O b=a.pg;if(b===K.lq){K.U.eS()}V{if(b===K.lp){K.U.cD()}}},ph:Q(a){O d=N.1H.2h(a);if(d&&(N.1H.aE(a)||!~a.2E.2S("uM"))){O c=K.pd(d);if(c){O b={pg:c};K.Ek(b)}}},pd:Q(b){O c=3,a;do{if(N.2I.ii(b,"ih")){a=b;1F}b=b.2V}4W(--c>0&&b);R a},1m:Q(){N.1H.9F(K.lq);N.1H.9F(K.lp);2s K.lq;2s K.lp;2s K.7n;N.1v.1g.1m.1j(K)},1p:"N.1v.Ej"});N.1v.Eg=N.1z(N.1v,{vn:4b,Ei:1d,vm:"km",pJ:"m",vl:"mi",vk:"ft",cC:P,dA:P,k3:1b,2H:Q(){N.1v.1g.2H.1j(K,1r);if(!K.cC){K.cC=1Q.2G("1q");K.cC.3M=K.5M+"Qs";O a=K.pJ.1a;K.1q.1V(K.cC);if((K.vm=="")||(K.pJ=="")){K.cC.W.3j="8C"}V{K.cC.W.3j="6I"}K.dA=1Q.2G("1q");K.dA.3M=K.5M+"Qr";K.1q.1V(K.dA);if((K.vl=="")||(K.vk=="")||!K.Ei){K.dA.W.3j="8C"}V{K.dA.W.3j="6I"}}K.U.1n.4N("7w",K,K.6P);K.6P();R K.1q},vj:Q(b){O d=2g(1k.eR(b)/1k.eR(10));O a=1k.2Y(10,d);O c=2g(b/a);O e;if(c>5){e=5}V{if(c>2){e=2}V{e=1}}R e*a},6P:Q(){O j=K.U.2r();if(!j){R}O o=K.U.bU();O e=N.fD;O l=K.vn*j*e[o];O n=1;if(K.k3===1d){O b=(K.U.Eh().w||0.Qq)*K.vn;O f=l/e.km;n=b/f;l*=n}O a;O d;if(l>ht){a=K.vm;d=K.vl}V{a=K.pJ;d=K.vk}O h=l/e[a];O k=l/e[d];O i=K.vj(h);O g=K.vj(k);h=i/e[o]*e[a];k=g/e[o]*e[d];O c=h/j/n;O m=k/j/n;if(K.dA.W.3j==="6I"){K.dA.W.1A=1k.2w(m)+"px";K.dA.5N=g+" "+N.bT(d)}if(K.cC.W.3j==="6I"){K.cC.W.1A=1k.2w(c)+"px";K.cC.5N=i+" "+N.bT(a)}},1p:"N.1v.Eg"});N.1v.ve=N.1z(N.1v,{eQ:P,5F:P,aJ:P,pH:P,eP:P,aK:P,pG:P,5g:P,5u:P,hr:P,ll:P,pE:1b,1o:Q(a){N.1v.1g.1o.1j(K,1r);K.eQ=[]},1m:Q(){K.lo("gs");K.lo("57");K.U.1n.un({eJ:K.3y,7B:K.3y,du:K.3y,8L:K.3y,2y:K});K.1n.6S("Qp",K,K.Qo);N.1v.1g.1m.1j(K,1r)},3a:Q(a){N.1v.1g.3a.1j(K,1r);K.U.1n.on({eJ:K.3y,7B:K.3y,du:K.3y,8L:K.3y,2y:K})},2H:Q(){N.1v.1g.2H.1j(K,1r);K.E6();if(!K.pI){K.gv()}K.3y();R K.1q},lo:Q(a){K[a+"Qn"].5N="";K[a+"Qm"]=[]},Ef:Q(){O e=1b;if(!K.eQ.1a||(K.U.1O.1a!==K.eQ.1a)){e=1d}V{1h(O c=0,a=K.eQ.1a;c<a;c++){O d=K.eQ[c];O b=K.U.1O[c];if((d.2l!==b.2l)||(d.7X!==b.7X)||(d.id!==b.id)||(d.3j!==b.3j)){e=1d;1F}}}R e},3y:Q(){if(!K.Ef()){R K.1q}K.lo("gs");K.lo("57");O e=1b;O k=1b;O q=K.U.1O.1a;K.eQ=S 3Q(q);1h(O o=0;o<q;o++){O t=K.U.1O[o];K.eQ[o]={2l:t.2l,3j:t.3j,7X:t.7X,id:t.id}}O j=K.U.1O.9D();if(!K.pE){j.Ql()}1h(O o=0,q=j.1a;o<q;o++){O t=j[o];O d=t.5S;if(t.kA){if(d){k=1d}V{e=1d}O h=(d)?(t===K.U.2b):t.cY();O f=1Q.2G("Qk");N.2I.54(f,"dz");f.id=K.id+"Qj"+t.2l;f.2l=(d)?K.id+"Qi":t.2l;f.2E="ln";f.Qh=h;f.iE=h;O l=N.1c.4M(),p="1B("+l+"1i-gw-on.2Z)",a="1B("+l+"1i-gw-Qg.2Z)",s="1B("+l+"1i-gw-hg.2Z)",g="1B("+l+"1i-gw-Qf.2Z)";if(h){f.W.Ed=(d)?a:p}V{f.W.Ed=(d)?g:s}if(!d&&!t.7X){f.Ea=1d}O b={dz:f,1i:t,E9:K};N.1H.3m(f,"4o",N.2u.59(K.Eb,b));O n=1Q.2G("oV");N.2I.54(n,"Ec");if(!d&&!t.7X){n.W.4S="Qe"}n.5N=t.2l;O r=1Q.2G("br");O c=(d)?K.pH:K.pG;c.1w({1i:t,dz:f,Ec:n});O m=(d)?K.aJ:K.aK;m.1V(f);m.1V(n);m.1V(r)}}if(N.1v.gy==="iD"){K.eP.W.23=(e)?"":"2L";K.gx.W.23=(k)?"":"2L"}V{K.hr.W.23=(e&&k)?"":"2L"}R K.1q},Eb:Q(a){if(!K.dz.Ea){if(K.1i.5S){K.dz.iE=1d;K.1i.U.eL(K.1i)}V{K.dz.iE=!K.dz.iE;K.E9.vi()}}N.1H.2K(a)},Qd:Q(a){K.vi()},vi:Q(){1h(O b=0,a=K.pH.1a;b<a;b++){O c=K.pH[b];if(c.dz.iE){K.U.eL(c.1i,1b)}}1h(O b=0,a=K.pG.1a;b<a;b++){O c=K.pG[b];c.1i.eK(c.dz.iE)}},iC:Q(a){K.1q.W.1A="";K.1q.W.1E="";K.1q.W.E7="E8";K.vh(1b);if(a!=P){N.1H.2K(a)}},E5:Q(b){O a=K;K.ll=6u(Q(c){a.gv(c)},4b)},E4:Q(){if(K.ll){2k.6t(K.ll);K.ll=P}},gv:Q(a){K.1q.W.1A="bk";K.1q.W.1E="bk";K.1q.W.E7="bk";K.vh(1d);if(a!=P){N.1H.2K(a)}},vh:Q(a){K.5u.W.23=a?"":"2L";K.5g.W.23=a?"2L":"";K.5F.W.23=a?"2L":""},E6:Q(){N.1H.3m(K.1q,"4o",N.2u.59(K.E0,K));N.1H.3m(K.1q,"2U",K.lk);N.1H.3m(K.1q,"48",N.2u.59(K.aI,K));N.1H.3m(K.1q,"4F",K.lk);if(N.1v.gy!=="iD"){K.5F=1Q.2G("1q");K.5F.id=K.id+"E3";N.2I.54(K.5F,"Qc");K.aJ=1Q.2G("1q");N.2I.54(K.aJ,"aJ");K.hr=1Q.2G("hr");N.2I.54(K.hr,"Qb");K.aK=1Q.2G("1q");N.2I.54(K.aK,"aK");if(K.pE){K.5F.1V(K.aJ);K.5F.1V(K.hr);K.5F.1V(K.aK)}V{K.5F.1V(K.aK);K.5F.1V(K.hr);K.5F.1V(K.aJ)}O d=N.1c.4M();O c=S N.2M(34,34);O a=d+"pF/1i-gw-E2.2Z";K.5u=N.1c.8F("E1",P,c,a,"3d",P);N.2I.54(K.5u,"Qa");K.5u.W.23="2L";N.1H.3m(K.5u,"dx",N.2u.59(K.iC,K));K.1q.1V(K.5u);K.5g=1Q.2G("1q");K.5g.3M="Q9";K.5g.W.23="2L";N.1H.3m(K.5g,"aL",N.2u.59(K.E5,K));N.1H.3m(K.5g,"dx",N.2u.59(K.E4,K));K.1q.W.Q8="mW";K.5g.1V(K.5F);K.1q.1V(K.5g)}V{K.5F=1Q.2G("1q");K.5F.id=K.id+"E3";N.2I.54(K.5F,"5F");K.1q.1V(K.5F);K.gx=1Q.2G("1q");K.gx.5N=N.bT("Q7 1C");N.2I.54(K.gx,"gx");K.aJ=1Q.2G("1q");N.2I.54(K.aJ,"aJ");K.eP=1Q.2G("1q");K.eP.5N=N.bT("Q6");N.2I.54(K.eP,"eP");K.aK=1Q.2G("1q");N.2I.54(K.aK,"aK");if(K.pE){K.5F.1V(K.gx);K.5F.1V(K.aJ);K.5F.1V(K.eP);K.5F.1V(K.aK)}V{K.5F.1V(K.eP);K.5F.1V(K.aK);K.5F.1V(K.gx);K.5F.1V(K.aJ)}d=N.1c.4M();O c=S N.2M(24,24);a=d+"eO/1i-gw-E2.2Z";K.5u=N.1c.8F("E1",P,c,a,"3d","Du");N.2I.54(K.5u,"5u");K.5u.W.23="2L";N.1H.3m(K.5u,"2U",N.2u.59(K.iC,K));K.1q.1V(K.5u);a=d+"eO/1i-gw-vg.2Z";O c=S N.2M(Q5,24);K.5g=N.1c.8F("Q4",P,c,a,"3d");O b=1Q.2G("oV");b.5N=N.bT("ve");b.3M="Q3";K.5g.1V(b);N.2I.54(K.5g,"5g");K.5g.W.23="2L";N.1H.3m(K.5g,"2U",N.2u.59(K.gv,K));K.1q.1V(K.5g)}},lk:Q(a){N.1H.2K(a)},aI:Q(a){K.vf=1d;K.lk(a)},E0:Q(a){if(K.vf){K.vf=1b;K.lk(a)}},1p:"N.1v.ve"});N.1v.vc=N.1z(N.1v,{cz:P,1i:P,3F:P,2P:["tP","tQ"],eN:1b,DZ:Q(){},89:P,W:P,1o:Q(b,c,a){K.2P=N.1v.vc.1g.2P.b1(N.1v.1g.2P);N.1v.1g.1o.1j(K,[a]);K.3F=N.1c.1K({7c:K.3V,fH:Q(f,e){K.1i.1n.1M("kE",{dv:f,1J:e})},lj:Q(f,e){K.1n.1M("tQ",{1J:e});K.1i.1n.1M("tN",{dv:f,1J:e})}},K.3F);K.1i=b;K.89=K.89||{};if(!("eN"in K.89)){K.89.eN=K.eN}O d=K.1i.az&&K.1i.az.6x.hL;if(d){K.89.cB=N.1c.4I(K.89.cB,{az:S N.ob({"49":d})})}K.3s=S c(K,K.3F,K.89);if(K.1i&&K.1i.1p==="N.1C.Q2"){K.1i.Q1=K}},3V:Q(f){if(f.1p==="N.1U"){O e=K.U.6M(S N.2B(f.1s,f.1L)),a=K.U.6M(S N.2B(f.1I,f.1t));O f=S N.1f.9S(e.1P,e.1R,a.1P-e.1P,a.1R-e.1R)}V{if(f.1p==="N.2B"){O d=K.U.6M(f);O f=S N.1f.1D(d.1P,d.1R)}}O b=P;if(f.1p==="N.3k.2X"){b=f}V{b=S N.3k.2X(f);if(K.W){b.W=K.W}}O c=K.1i.1n.1M("hU",{1J:b});if(c!==1b){b.7I=N.69.gu;K.1i.7u([b]);K.DZ(b);K.1n.1M("tP",{1J:b})}},pD:Q(a,b){if(K.3s&&K.3s.3Z){K.3s.pD(a,b)}},pC:Q(b,a){if(K.3s&&K.3s.3Z){K.3s.pC(b,a)}},pB:Q(b,a){if(K.3s&&K.3s.3Z){K.3s.pB(b,a)}},vd:Q(b,a){if(K.3s&&K.3s.3Z){K.3s.vd(b,a)}},pA:Q(){R K.3s.pA&&K.3s.pA()},pz:Q(){R K.3s.pz&&K.3s.pz()},Q0:Q(){K.3s.iB()},8w:Q(){K.3s.8w()},1p:"N.1v.vc"});N.1v.v6=N.1z(N.1v,{eM:P,64:P,va:Q(b,a){},v9:Q(b,a){},v8:Q(b,a){},DX:Q(a){},DS:Q(a){},7D:1b,1i:P,1J:P,DY:{},v7:{},iz:P,1o:Q(b,a){N.1v.1g.1o.1j(K,[a]);K.1i=b;K.1X={5s:S N.1Y.cA(K,N.1c.1K({4q:K.DW,3x:K.DV,up:K.DU,4t:K.8w,7c:K.DT},K.DY),{7D:K.7D}),1J:S N.1Y.3k(K,K.1i,N.1c.1K({2U:K.ei,97:K.hF,6f:K.d0,4t:K.eh},K.v7),{64:K.64})};if(a&&a.eM){K.eM=a.eM}},ei:Q(a){if(K.1X.1J.5t&&!K.6f&&K.d0(a)){K.1X.5s.iA(K.1X.1J.7b);K.1X.5s.7W=1b}},hF:Q(a){if(K.1X.1J.5t&&K.6f){K.eh(a);K.1X.5s.7W=1d}},1m:Q(){K.1i=P;K.7D=P;N.1v.1g.1m.1j(K,[])},2p:Q(){R(K.1X.1J.2p()&&N.1v.1g.2p.1j(K,1r))},2a:Q(){K.1X.5s.2a();K.1X.1J.2a();K.1J=P;K.3S=1b;K.iz=P;N.2I.9Y(K.U.3z,K.5M+"vb");R N.1v.1g.2a.1j(K,1r)},d0:Q(b){O a=1b;if(!K.1X.5s.3S){K.1J=b;K.1X.5s.2p();a=1d;K.6f=1d;N.2I.54(K.U.3z,K.5M+"vb");K.DX(b)}V{if(K.1J.id===b.id){K.6f=1d}V{K.6f=1b}}R a},DW:Q(a){K.iz=a;K.va(K.1J,a)},DV:Q(f){O g=K.U.2r();O e=K.1i.5n(f);if(K.eM&&K.eM.cz&&K.1J.1x.1p==="N.1f.1D"){K.1J.1x.x=e.1P;K.1J.1x.y=e.1R;O c=S N.3i(K.1J.1x.x,K.1J.1x.y);O a=K.eM.cz.jz(c);O d=a.1P-c.1P;O b=a.1R-c.1R;K.1J.1x.3x(d,b)}V{O h=K.1i.5n(K.iz);K.1J.1x.3x(e.1P-h.1P,e.1R-h.1R)}K.1i.3V(K.1J);K.iz=f;K.v9(K.1J,f)},DU:Q(a){if(!K.6f){K.1X.5s.2a()}},DT:Q(a){K.v8(K.1J,a)},eh:Q(a){if(!K.1X.5s.3S){K.6f=1b;K.1X.5s.2a();N.2I.9Y(K.U.3z,K.5M+"vb");K.DS(a);K.1J=P}V{if(K.1J.id===a.id){K.6f=1b}}},8w:Q(){K.1X.5s.2a();K.6f=1b},3a:Q(a){K.1X.5s.3a(a);K.1X.1J.3a(a);N.1v.1g.3a.1j(K,1r)},1p:"N.1v.v6"});N.1v.8M=N.1z(N.1v,{cz:P,2P:["ou","hV","ot"],64:P,97:1d,bY:1d,aH:1b,1i:P,1J:P,7V:P,8O:P,9n:P,6W:P,1X:P,iy:P,lh:P,pu:P,8N:P,8P:1b,9o:P,bx:P,1o:Q(d,c){c=c||{};K.1i=d;K.7V=[];K.8O=[];K.lh=N.1c.1K({},K.1i.W||K.1i.az.fS(P,c.pu));K.lh.4H=0.3;K.lh.at=0.3;K.iy=[46,68];K.8N=N.1v.8M.ps;N.1v.1g.1o.1j(K,[c]);if(!(N.1c.4f(K.iy))){K.iy=[K.iy]}O f=K;O a={64:K.64,97:K.97,bY:K.bY,fK:K.v4,cZ:K.DQ,fJ:K.v1,2y:K};if(K.aH===1b){K.9n=S N.1v.k5(d,a)}O b={64:["N.1f.1D"],DR:K.DR,va:Q(h,g){f.DP.1j(f,[h,g])},v9:Q(h,g){f.DO.1j(f,[h,g])},v8:Q(g){f.DN.1j(f,[g])},v7:{6f:Q(g){if(f.aH!==1d||g.iw||f.1J===g){f.6W.d0.1j(f.6W,[g])}}}};b.eM=K;K.6W=S N.1v.v6(d,b);O e={fh:K.DM};K.1X={v5:S N.1Y.py(K,e)}},1m:Q(){K.1i=P;K.aH||K.9n.1m();K.6W.1m();N.1v.1g.1m.1j(K,[])},2p:Q(){R((K.aH||K.9n.2p())&&K.1X.v5.2p()&&N.1v.1g.2p.1j(K,1r))},2a:Q(){O c=1b;if(N.1v.1g.2a.1j(K,1r)){K.1i.9P(K.7V,{5B:1d});K.1i.9P(K.8O,{5B:1d});K.7V=[];K.6W.2a();O a=K.1J;O b=a&&a.1x&&a.1i;if(K.aH===1b){if(b){K.9n.b5.1j(K.9n,[a])}K.9n.2a()}V{if(b){K.v1(a)}}K.1X.v5.2a();c=1d}R c},v4:Q(a){K.1n.1M("ou",{1J:a});R K.1i.1n.1M("ou",{1J:a})},DQ:Q(b){if(!K.aH||K.v4(b)!==1b){K.1J=b;K.8P=1b;K.pv();K.6W.2p()}O a=b.8P;if(b.1x&&!(a&&a.1x)){K.pw=b.1x.1T()}},v1:Q(a){K.1i.9P(K.7V,{5B:1d});K.7V=[];K.1i.9I(K.8O,{5B:1d});K.8O=[];if(K.bx){K.1i.9I([K.bx],{5B:1d});2s K.bx}if(K.9o){K.1i.9I([K.9o],{5B:1d});2s K.9o}K.1J=P;K.6W.2a();K.1n.1M("ot",{1J:a,8P:K.8P});K.1i.1n.1M("ot",{1J:a,8P:K.8P});K.8P=1b},DP:Q(b,a){if(b!==K.1J&&!b.1x.dr&&b!==K.bx&&b!==K.9o){if(K.aH===1b&&K.1J){K.9n.ei.1j(K.9n,[K.1J])}if(K.64==P||N.1c.2S(K.64,b.1x.1p)!==-1){K.aH||K.9n.ei.1j(K.9n,[b]);K.6W.d0.1j(K.6W,[b]);K.6W.iz=a;K.6W.1X.5s.6D=1d;K.6W.1X.5s.3X=a;K.6W.1X.5s.3u=a}}N.2I.9Y(K.U.3z,"li");K.U.3z.W.3G="4m"},DO:Q(b,a){K.8P=1d;if(K.1J.1x.1p==="N.1f.1D"){if(K.1J!==b){K.1J=b}K.1i.1n.1M("os",{dv:b.1x,1J:K.1J,ix:a})}V{if(b.pt){b.1x.dr.7U(b.1x,b.pt);2s b.pt;N.1c.am(K.8O,b);K.7V.1w(b)}V{if(b===K.bx){K.1i.9P(K.7V,{5B:1d});K.7V=[];if(K.9o){K.1i.9I([K.9o],{5B:1d});K.9o=P}}V{if(b!==K.9o){K.1i.1n.1M("os",{dv:b.1x,1J:K.1J,ix:a})}}}if(K.8O.1a>0){K.1i.9I(K.8O,{5B:1d});K.8O=[]}K.1i.3V(K.1J,K.aH?2q:K.9n.7N)}K.1i.3V(b)},DN:Q(a){K.pv();K.v0();K.1n.1M("hV",{1J:K.1J});K.1i.1n.1M("hV",{1J:K.1J})},v0:Q(){if(K.1J.7I!==N.69.gu&&K.1J.7I!==N.69.bK){K.1J.7I=N.69.dw;if(K.8P&&K.pw){O a=K.1J;a.8P=N.1c.1K(a.8P,{1x:K.pw});2s K.pw}}},pv:Q(){if(K.6W.1J){K.6W.eh(K.6W.1J)}if(K.7V.1a>0){K.1i.9P(K.7V,{5B:1d});K.7V=[]}if(K.8O.1a>0){K.1i.9P(K.8O,{5B:1d});K.8O=[]}if(K.bx){K.1i.9I([K.bx],{5B:1d});K.bx=P}if(K.9o){K.1i.9I([K.9o],{5B:1d});K.9o=P}if(K.1J&&K.1J.1x.1p!=="N.1f.1D"){if((K.8N&N.1v.8M.DH)){K.DJ()}if((K.8N&(N.1v.8M.uZ|N.1v.8M.pr))){K.DI()}if(K.8N&N.1v.8M.ps){if(!(K.8N&N.1v.8M.pr)){K.DK()}}}},DM:Q(a){O b=a.DL;if(K.1J&&N.1c.2S(K.iy,b)!==-1){O c=K.6W.1J;if(c&&N.1c.2S(K.7V,c)!==-1&&!K.6W.1X.5s.3S&&c.1x.dr){c.1x.dr.9V(c.1x);K.1i.1n.1M("tO",{dv:c.1x,1J:K.1J,ix:a.xy});K.1i.3V(K.1J,K.aH?2q:K.9n.7N);K.8P=1d;K.pv();K.v0();K.1n.1M("hV",{1J:K.1J});K.1i.1n.1M("hV",{1J:K.1J})}}},DK:Q(){K.7V=[];K.8O=[];O a=K;Q b(h){O d,e,j,f;if(h.1p==="N.1f.1D"){e=S N.3k.2X(h);e.iw=1d;e.7N=a.pu;a.7V.1w(e)}V{O c=h.1y.1a;if(h.1p==="N.1f.4s"){c-=1}1h(d=0;d<c;++d){j=h.1y[d];if(j.1p==="N.1f.1D"){e=S N.3k.2X(j);e.iw=1d;e.7N=a.pu;a.7V.1w(e)}V{b(j)}}if(h.1p!=="N.1f.8k"){1h(d=0,f=h.1y.1a;d<f-1;++d){O m=h.1y[d];O n=h.1y[d+1];if(m.1p==="N.1f.1D"&&n.1p==="N.1f.1D"){O k=(m.x+n.x)/2;O g=(m.y+n.y)/2;O l=S N.3k.2X(S N.1f.1D(k,g),P,a.lh);l.1x.dr=h;l.pt=d+1;l.iw=1d;a.8O.1w(l)}}}}}b.4g(K,K.1J.1x);K.1i.7u(K.8O,{5B:1d});K.1i.7u(K.7V,{5B:1d})},DJ:Q(){O d=K;O e=K.1J.1x;O a=e.6k().5P();O c=S N.1f.1D(a.1P,a.1R);O b=S N.3k.2X(c);c.3x=Q(f,g){N.1f.1D.1g.3x.4g(K,f,g);e.3x(f,g);d.1i.1n.1M("C6",{dv:e,1J:d.1J,ix:S N.2B(f,g)})};b.iw=1d;K.bx=b;K.1i.7u([K.bx],{5B:1d})},DI:Q(){O h=K;O i=K.1J.1x;O a=i.6k();O b=a.5P();O j=S N.1f.1D(b.1P,b.1R);O g=S N.1f.1D(a.1I,a.1L);O f=S N.3k.2X(g);O c=(K.8N&N.1v.8M.pr);O e=(K.8N&N.1v.8M.ps);O d=(K.8N&N.1v.8M.uZ);g.3x=Q(u,t){N.1f.1D.1g.3x.4g(K,u,t);O v=K.x-j.x;O q=K.y-j.y;O w=v-u;O r=q-t;if(d){O l=1k.l9(r,w);O k=1k.l9(q,v);O o=k-l;o*=2R/1k.PI;i.5m(o,j);h.1i.1n.1M("C5",{dv:i,1J:h.1J,ix:S N.2B(u,t)})}if(c){O n,s;if(e){n=q/r;s=(v/w)/n}V{O p=1k.5r((w*w)+(r*r));O m=1k.5r((v*v)+(q*q));n=m/p}i.7C(n,j,s);h.1i.1n.1M("C4",{dv:i,1J:h.1J,ix:S N.2B(u,t)})}};f.iw=1d;K.9o=f;K.1i.7u([K.9o],{5B:1d})},3a:Q(a){K.aH||K.9n.3a(a);K.6W.3a(a);N.1v.1g.3a.1j(K,1r)},1p:"N.1v.8M"});N.1v.8M.ps=1;N.1v.8M.pr=2;N.1v.8M.uZ=4;N.1v.8M.DH=8;N.1v.pp=N.1z(N.1v,{3U:P,5d:P,1O:P,5E:P,gt:Q(b){b=b||2k.ir.9l;O c=N.1c.gt(b);O a=b.2S("#");if(a>0){b="?"+b.aU(a+1,b.1a);N.1c.1K(c,N.1c.gt(b))}R c},3a:Q(e){N.1v.1g.3a.1j(K,1r);1h(O c=0,a=K.U.3R.1a;c<a;c++){O d=K.U.3R[c];if((d!==K)&&(d.1p==="N.1v.pp")){if(d.5E!==K.5E){K.5E=d.5E}1F}}if(c===K.U.3R.1a){O b=K.gt();if(b.1O){K.1O=b.1O;K.U.1n.4N("eJ",K,K.pq);K.pq()}if(b.1R&&b.1P){K.3U=S N.3i(3t(b.1P),3t(b.1R));if(b.5d){K.5d=3t(b.5d)}K.U.1n.4N("8L",K,K.5X);K.5X()}}},5X:Q(){if(K.U.2b){K.U.1n.6S("8L",K,K.5X);if(K.5E){K.3U.3K(K.5E,K.U.5Y())}K.U.5X(K.3U,K.5d)}},pq:Q(){if(K.1O.1a===K.U.1O.1a){K.U.1n.6S("eJ",K,K.pq);1h(O d=0,a=K.1O.1a;d<a;d++){O b=K.U.1O[d];O e=K.1O.dU(d);if(e==="B"){K.U.eL(b)}V{if((e==="T")||(e==="F")){b.eK(e==="T")}}}}},1m:Q(){K.3U=P;K.5d=P;K.1O=P;K.5E=P},1p:"N.1v.pp"});N.1v.uX=N.1z(N.1v,{uY:N.1v.pp,2h:P,3h:1b,gs:"",5E:P,1o:Q(b,c,a){if(b!==P&&2t b==="6q"&&!N.1c.PZ(b)){a=b;K.gs=1Q.ir.9l;N.1v.1g.1o.1j(K,[a]);if(K.2h!==P){K.2h=N.1c.6l(K.2h)}}V{N.1v.1g.1o.1j(K,[a]);K.2h=N.1c.6l(b);K.gs=c||1Q.ir.9l}},1m:Q(){if(K.2h&&K.2h.2V===K.1q){K.1q.2T(K.2h);K.2h=P}if(K.U){K.U.1n.6S("7w",K,K.iv)}N.1v.1g.1m.1j(K,1r)},3a:Q(d){N.1v.1g.3a.1j(K,1r);1h(O b=0,a=K.U.3R.1a;b<a;b++){O c=K.U.3R[b];if(c.1p===K.uY.1p){if(c.5E!==K.5E){K.5E=c.5E}1F}}if(b===K.U.3R.1a){K.U.kb(S K.uY({5E:K.5E}))}},2H:Q(){N.1v.1g.2H.1j(K,1r);if(!K.2h&&!K.3h){K.2h=1Q.2G("a");K.2h.5N=N.bT("uX");K.2h.9l="";K.1q.1V(K.2h)}K.U.1n.on({7w:K.iv,7B:K.iv,8L:K.iv,2y:K});K.iv();R K.1q},iv:Q(){O b=K.3h?"#":"?";O a=K.gs;if(a.2S(b)!==-1){a=a.aU(0,a.2S(b))}a+=b+N.1c.iu(K.DG());if(K.3h&&!K.2h){2k.ir.9l=a}V{K.2h.9l=a}},DG:Q(a,k,e){a=a||K.U.aG();O d=N.1c.gt(K.gs);if(a){d.5d=k||K.U.4G();O j=a.1R;O b=a.1P;if(K.5E){O c=N.3g.3K({x:b,y:j},K.U.5Y(),K.5E);b=c.x;j=c.y}d.1R=1k.2w(j*ht)/ht;d.1P=1k.2w(b*ht)/ht;e=e||K.U.1O;d.1O="";1h(O f=0,h=e.1a;f<h;f++){O g=e[f];if(g.5S){d.1O+=(g===K.U.2b)?"B":"0"}V{d.1O+=(g.cY())?"T":"F"}}}R d},1p:"N.1v.uX"});N.1v.uW=N.1z(N.1v,{po:", ",DF:"${1O}",1m:Q(){K.U.1n.un({du:K.cw,eJ:K.cw,7B:K.cw,8L:K.cw,2y:K});N.1v.1g.1m.1j(K,1r)},2H:Q(){N.1v.1g.2H.1j(K,1r);K.U.1n.on({8L:K.cw,7B:K.cw,eJ:K.cw,du:K.cw,2y:K});K.cw();R K.1q},cw:Q(){O d=[];if(K.U&&K.U.1O){1h(O c=0,a=K.U.1O.1a;c<a;c++){O b=K.U.1O[c];if(b.dt&&b.cY()){if(N.1c.2S(d,b.dt)===-1){d.1w(b.dt)}}}K.1q.5N=N.6K.5L(K.DF,{1O:d.6b(K.po)})}},1p:"N.1v.uW"});N.1v.Dn=N.1z(N.1v,{7n:P,ik:P,1i:P,gq:50,lf:29,io:32,9m:P,le:7,uU:P,6V:20,6C:18,im:[],ld:[],gn:1b,8K:1d,ij:P,gp:PY,il:P,pi:P,1o:Q(a){K.gr=S N.2B(lg,60);N.1v.1g.1o.1j(K,1r)},1m:Q(){O a=K;K.7n=P;K.ik=P;K.1i=P;K.gq=P;K.lf=P;K.io=P;K.9m=P;K.le=P;K.6V=P;K.uU=P;K.im=P;K.ld=P;K.gn=P;if(K.8K){K.ij.un({48:a.uS,4p:a.uR,4o:a.uQ});K.uT.un({4p:a.5D,4o:a.5D})}K.8K=P;K.ij=P;K.gp=P;K.il=P;K.pi=P;N.1v.1g.1m.1j(K,1r)},fI:Q(a){K.gn=1b;K.1i=a;a.iq=K;a.uV()},DE:Q(){O c=K;if(c.1i&&c.1i.ai){O a=c.1i.ai.aX;O b=a.1a;if(b>0){c.il=c.gp/a.1a;c.gn=1d}}},2H:Q(){O f=N.1v.1g.2H.1j(K,1r),a=K.pm(f),c=a.DC,b=a.DB,e=a.DA;if(!K.pn){O d=Q(g){R Q(h){g.ph(h)}}(K);N.1H.3m(c,"48",N.2u.59(d,c));N.1H.3m(e,"48",N.2u.59(d,c));K.pn=1d}K.uN=c;K.DD=b;K.uO=e;R f},pm:Q(f){O d=K.uN,c=K.DD,g=K.uO,a=K.7n,e;if(!a){a=K.9X(f,"1q",P,K.gr.y,K.gr.x);K.7n=a}if(!d){d=K.ip(a,"ds-cv-PX.2Z",0);N.2I.54(d,"ih")}if(!c){c=K.Dz(a)}if(!g){g=K.ip(a,"ds-cv-3p.2Z",1);N.2I.54(g,"ih")}R{DC:d,DB:c,DA:g}},ip:Q(g,a,d){O e=K,c,b,h,f;if(d===1){c=e.8K?(e.gp+e.6C):e.gq;f=e.io+c}h=N.1c.4M()+a;b=e.9X(g,"1q","3d",P,f,e.lf,e.io,P,h,"4m");R b},Dz:Q(d){O f,a,e,b=K;a=b.8K?(b.gp+b.6C):b.gq;e=N.1c.4M()+"ds-cv-3U.2Z";f=b.9X(d,"1q","3d",P,b.io,b.lf,a,P,e,P);if(b.8K){b.Dy(f);b.Dw(f)}V{b.Dx(f)}R f},Dy:Q(b){O e,f,i,g=1Q,h=K,j,a,c;c=h.lf/2;j=c-h.le/2;a=N.1c.4M()+"ds-cv-PW.2Z";e=h.9X(b,"1q","3d",j,h.6C/2,h.le,h.gp,P,a,"4m");N.1H.3m(e,"48",N.2u.59(h.Dt,h));a=N.1c.4M()+"ds-cv-PV.2Z";f=h.9X(e,"1q","3d",1,1,h.le-1,P,P,a,"4m");h.9m=f;j=c-h.6V/2;a=N.1c.4M()+"PU-cv-PT.2Z";i=h.9X(b,"1q","3d",j,0,h.6V,h.6C,P,a,"4m");h.uU=i;h.im.1w(i);h.ld.1w(0);h.Ds=h.gr.x+h.io+h.6C/2;h.ij=S N.4l(h,i,P,1d);h.ij.on({48:h.uS,4p:h.uR,4o:h.uQ});h.uT=S N.4l(h,g,P,1d);h.uT.on({4p:h.5D,4o:h.5D})},Dx:Q(c){O a,e=1Q,b;a=e.2G("1q");b=a.W;b.Dv="PS";b.kj="3U";c.1V(a);K.ik=a},Dw:Q(f){O k,g,b,h,a,d,i,l=K,o;O r=8;O q=8;O j=26;O m=6;O c=3;O n=j+q;O e=2*m+l.gq;i=-e/2+m;k=l.9X(f,"1q","3d",-n-c,i,n,e);k.W.23="2L";l.pi=k;l.im.1w(k);l.ld.1w(i);o=N.1c.4M()+"ds-cv-PR.2Z";h=l.9X(k,"1q","3d",7,P,j,m,P,o,"4m");o=N.1c.4M()+"ds-cv-PQ.2Z";g=l.9X(k,"1q","3d",7,m,j,l.gq,P,o,"4m");o=N.1c.4M()+"ds-cv-PP.2Z";i=m+l.gq;a=l.9X(k,"1q","3d",7,i,j,m,P,o,"4m");i=e/2-r/2;o=N.1c.4M()+"ds-cv-PO.2Z";b=l.9X(k,"1q","3d",j+c,i,q,r,P,o,"4m");d=l.9X(g,"1q",P,P,P,P,P,P,P,"4m");d.W.Dv="Du";d.W.kj="3U";N.2I.54(d,"PN");l.ik=d},9X:Q(f,j,g,k,c,n,b,a,m,l){O o,h,i=1Q;if(f){h=i.2G(j);o=h.W;if(g){o.2v=g}if(k){o.1t=k+"px"}if(c){o.1s=c+"px"}if(n){o.1E=n+"px"}if(b){o.1A=b+"px"}if(a){o.pk=a}if(m){o.pk="1B("+m+")"}if(l){o.3G=l}f.1V(h);R h}R P},Dt:Q(a){if(!N.1H.aE(a)){R}O b=K;if(b.gn){b.uP=1d;b.3e=a.fM;b.la(a.fM)}N.1H.2K(a)},la:Q(c){O b=K;b.9m.W.1A=c+"px";1h(O a=0;a<b.im.1a;a++){b.im[a].W.1s=c+b.ld[a]+"px"}},uS:Q(a){if(!N.1H.aE(a)){R}if(K.gn){K.pj=1d}N.1H.2K(a)},uR:Q(a){if(K.pj){O b=K;b.3e=a.aF-b.Ds;if(b.3e>=0&&b.3e<=b.gp){b.la(b.3e)}}N.1H.2K(a)},uQ:Q(a){if(!N.1H.aE(a)){R}O b=K;if(b.pj){b.pj=1b;b.pf(0)}V{if(b.uP){b.uP=1b;b.pf(0)}}N.1H.2K(a)},pf:Q(b){O c=K,a;if(b===0){a=1k.2w(c.3e/c.il);if(a>=1&&a<=c.1i.ai.aX.1a-1){a-=1}V{if(a<0){a=0}V{if(a>c.1i.ai.aX.1a-1){a=c.1i.ai.aX.1a-1}}}c.1i.9g=a;c.1i.lc();if(c.1i.9g===c.1i.go){c.la((a+1)*c.il)}}if(b===1){a=c.1i.go;if(c.1i.9g===a){c.la((a+1)*c.il)}}if(c.gn){c.pi.W.23="i5"}},Do:Q(a){K.1i.ik=K;O b=a.pg;if(b===K.uO){K.1i.Dr()}V{if(b===K.uN){K.1i.Dq()}}N.1H.2K(a)},Dp:Q(a){if(a&&a!==P){K.ik.5N=a}},ph:Q(a){O d=N.1H.2h(a);if(d&&(N.1H.aE(a)||!~a.2E.2S("uM"))){O c=K.pd(d);if(c){O b={pg:c};K.Do(b);K.pf(1)}}},5D:Q(a){if(K.8K){K.ij.pe(a)}},pd:Q(b){O c=3,a;do{if(N.2I.ii(b,"ih")){a=b;1F}b=b.2V}4W(--c>0&&b);R a},1p:"N.1v.Dn"});N.1v.k5=N.1z(N.1v,{nQ:P,nO:P,bV:1b,97:1d,bY:1b,k6:1b,bX:1b,hE:1b,5f:1b,fK:Q(){},cZ:Q(){},fJ:Q(){},2y:P,64:P,1i:P,1O:P,3F:P,nM:P,nS:1b,7N:"7d",1X:P,1o:Q(c,a){N.1v.1g.1o.1j(K,[a]);if(K.2y===P){K.2y=K}K.hB(c);O b={2U:K.ei,97:K.hF,6f:K.d0,4t:K.eh};K.3F=N.1c.1K(b,K.3F);K.1X={1J:S N.1Y.3k(K,K.1i,K.3F,{64:K.64,k9:K.nS})};if(K.5f){K.1X.5f=S N.1Y.k8(K,{7c:K.nK},{nR:"AS"})}},hB:Q(a){if(N.1c.4f(a)){K.1O=a;K.1i=S N.1C.2X.k7(K.id+"AR",{1O:a})}V{K.1i=a}},1m:Q(){if(K.3I&&K.1O){K.U.b6(K.1i)}N.1v.1g.1m.1j(K,1r);if(K.1O){K.1i.1m()}},2p:Q(){if(!K.3I){if(K.1O){K.U.fL(K.1i)}K.1X.1J.2p();if(K.5f&&K.1X.5f){K.1X.5f.2p()}}R N.1v.1g.2p.1j(K,1r)},2a:Q(){if(K.3I){K.1X.1J.2a();if(K.1X.5f){K.1X.5f.2a()}if(K.1O){K.U.b6(K.1i)}}R N.1v.1g.2a.1j(K,1r)},al:Q(b){O f=K.1O||[K.1i];O e,d;1h(O a=0;a<f.1a;++a){e=f[a];1h(O c=e.5Z.1a-1;c>=0;--c){d=e.5Z[c];if(!b||b.hG!==d){K.b5(d)}}}},ei:Q(b,a){if(!K.bX){O c=(N.1c.2S(b.1i.5Z,b)>-1);if(c){if(K.nP()){K.b5(b)}V{if(!K.ee()){K.al({hG:b});if(K.k6){K.cZ.4g(K.2y,b,a)}}}}V{if(!K.ee()){K.al({hG:b})}K.7d(b,a)}}},ee:Q(){R K.bV||(K.1X.1J.7b&&K.1X.1J.7b[K.nQ])},nP:Q(){R K.bY||(K.1X.1J.7b&&K.1X.1J.7b[K.nO])},hF:Q(a){if(!K.bX&&K.97){K.al()}},d0:Q(c,a){O b=c.1i;if(K.bX){if(K.hE){K.ef(c)}V{if(N.1c.2S(b.5Z,c)===-1){K.7d(c,a)}}}V{K.1i.U.6v.W.3G="4m"}},eh:Q(a){if(K.bX){if(K.hE){if(a.ao===K.id){if(a.7t&&a.7t!==K.id){2s a.ao;O b=K.U.nN(a.7t);if(b){b.ef(a)}}V{K.hC(a)}}}V{K.b5(a)}}V{K.1i.U.6v.W.3G=""}},ef:Q(c){O b=c.1i;if(b 1W N.1C.nL){R}O a=K.1n.1M("AQ",{1J:c});if(a!==1b){c.7t=c.ao;c.ao=K.id;O d=c.bW=N.1c.eg(K.nM);c.7N=K.7N;if(d&&!d.5k){if(c.W&&c.W.5k){d.5k=c.W.5k}}b.3V(c,d,{hD:1d});K.1n.1M("AP",{1J:c})}},hC:Q(b){O a=b.1i;if(a 1W N.1C.nL){R}if(b.7t==2q){2s b.ao}V{if(b.7t===K.id){2s b.7t}V{b.ao=b.7t;2s b.7t}}if(b.bW||b.bW==P){2s b.bW}b.7N="49";a.3V(b,b.W||b.1i.W||"49",{hD:1d});K.1n.1M("AO",{1J:b})},7d:Q(d,b){O a=K.fK.4g(K.2y,d);O c=d.1i;if(a!==1b){a=c.1n.1M("sN",{1J:d});if(a!==1b){c.5Z.1w(d);K.ef(d);if(!K.1X.1J.7M){K.1X.1J.7M=c.5Z[0]}c.1n.1M("sM",{1J:d,7b:b});K.cZ.4g(K.2y,d,b)}}},b5:Q(b){O a=b.1i;K.hC(b);N.1c.am(a.5Z,b);a.1n.1M("sL",{1J:b});K.fJ.4g(K.2y,b)},nK:Q(e){if(e 1W N.1U){O h=K.U.6M({x:e.1s,y:e.1L});O k=K.U.6M({x:e.1I,y:e.1t});O a=S N.1U(h.1P,h.1R,k.1P,k.1R);if(!K.ee()){K.al()}O j=K.bV;K.bV=1d;O d=K.1O||[K.1i];O f;1h(O b=0;b<d.1a;++b){f=d[b];1h(O c=0,g=f.2z.1a;c<g;++c){O m=f.2z[c];if(!m.cY()){5y}if(K.64==P||N.1c.2S(K.64,m.1x.1p)>-1){if(a.fA().6L(m.1x)){if(N.1c.2S(f.5Z,m)===-1){K.7d(m)}}}}}K.bV=j}},3a:Q(a){K.1X.1J.3a(a);if(K.5f){K.1X.5f.3a(a)}N.1v.1g.3a.1j(K,1r)},fI:Q(b){O a=K.3I;K.al();K.2a();if(K.1O){K.1i.1m();K.1O=P}K.hB(b);K.1X.1J.1i=K.1i;if(a){K.2p()}},1p:"N.1v.k5"});N.1v.Dh=N.1z(N.1v,{97:1d,bY:1b,k6:1b,fK:Q(){},cZ:Q(){},fJ:Q(){},2y:P,64:P,1i:P,1O:P,3F:P,7N:"7d",1X:P,1o:Q(b,a){N.1v.1g.1o.1j(K,[a]);if(K.2y===P){K.2y=K}if(b){K.1i=b}O c={2U:K.7d,97:K.b5,6f:K.Dm,4t:K.Dl};K.3F=N.1c.1K(c,K.3F);K.1X={4L:S N.1Y.df(K,K.1i,K.3F)}},1m:Q(){if(K.3I&&K.1O){K.U.b6(K.1i)}N.1v.1g.1m.1j(K,1r);if(K.1O){K.1i.1m()}},2p:Q(){if(!K.3I){if(K.1O){K.U.fL(K.1i)}K.1X.4L.2p();if(K.5f&&K.1X.5f){K.1X.5f.2p()}}R N.1v.1g.2p.1j(K,1r)},2a:Q(){if(K.3I){K.1X.4L.2a();if(K.1X.5f){K.1X.5f.2a()}if(K.1O){K.U.b6(K.1i)}}R N.1v.1g.2a.1j(K,1r)},Dm:Q(){K.1i.U.6v.W.3G="4m"},Dl:Q(){K.1i.U.6v.W.3G=""},7d:Q(d,b){O a=K.fK.4g(K.2y,d);O c=K.1i;if(a!==1b){a=c.1n.1M("Dk",{4L:d});if(a!==1b){c.cs.1w(d);if(!K.1X.4L.cu){K.1X.4L.cu=c.cs[0]}c.1n.1M("Dj",{4L:d,7b:b});K.cZ.4g(K.2y,d,b)}}},b5:Q(b){O a=K.1i;N.1c.am(a.cs,b);a.1n.1M("Di",{4L:b});K.fJ.4g(K.2y,b)},3a:Q(a){K.1X.4L.3a(a);if(K.5f){K.1X.5f.3a(a)}N.1v.1g.3a.1j(K,1r)},1p:"N.1v.Dh"});N.1f=N.1z({id:P,dr:P,2c:P,sw:P,1o:Q(){K.id=N.1c.7x(K.1p+"4n")},1m:Q(){K.id=P;K.2c=P;K.sw=P},1T:Q(){R S N.1f()},uK:Q(a){if(a){K.2c=a.1T()}},9W:Q(){K.2c=P;if(K.dr){K.dr.9W()}},PM:Q(b){O a=K.6k();if(!a){K.uK(b)}V{K.2c.1K(b)}},6k:Q(){if(K.2c==P){K.9J()}R K.2c},9J:Q(){},74:Q(b,a){},55:Q(a){},mN:Q(e,h,f){O c=1b;O d=K.6k();if((d!=P)&&(e!=P)){O b=(h!=P)?h:0;O a=(f!=P)?f:0;O g=S N.1U(K.2c.1s-b,K.2c.1L-a,K.2c.1I+b,K.2c.1t+a);c=g.eI(e)}R c},ec:Q(){R 0},94:Q(){R 0},9a:Q(){R P},7r:Q(){O a;if(N.ig&&N.ig.pb){a=N.ig.pb.1g.PL(S N.3k.2X(K))}V{a=78.1g.7r.4g(K)}R a},1p:"N.1f"});N.1f.uL=Q(f){O d;if(N.ig&&N.ig.pb){O g=N.1f.uL.5L;if(!g){g=S N.ig.pb();N.1f.uL.5L=g}O b=g.tf(f);if(b 1W N.3k.2X){d=b.1x}V{if(N.1c.4f(b)){O a=b.1a;O e=S 3Q(a);1h(O c=0;c<a;++c){e[c]=b[c].1x}d=S N.1f.5A(e)}}}R d};N.1f.pa=Q(a,H,b){O s=b&&b.3l;O z=b&&b.uG;O f=1b;O B=a.x1-H.x1;O F=a.y1-H.y1;O o=a.x2-a.x1;O w=a.y2-a.y1;O t=H.y2-H.y1;O l=H.x2-H.x1;O D=(t*o)-(l*w);O e=(l*F)-(t*B);O c=(o*F)-(w*B);if(D==0){if(e==0&&c==0){f=1d}}V{O E=e/D;O C=c/D;if(E>=0&&E<=1&&C>=0&&C<=1){if(!s){f=1d}V{O h=a.x1+(E*o);O g=a.y1+(E*w);f=S N.1f.1D(h,g)}}}if(z){O r;if(f){if(s){O n=[a,H];O A,h,g;cr:1h(O v=0;v<2;++v){A=n[v];1h(O u=1;u<3;++u){h=A["x"+u];g=A["y"+u];r=1k.5r(1k.2Y(h-f.x,2)+1k.2Y(g-f.y,2));if(r<z){f.x=h;f.y=g;1F cr}}}}}V{O n=[a,H];O q,G,h,g,m,k;cr:1h(O v=0;v<2;++v){q=n[v];G=n[(v+1)%2];1h(O u=1;u<3;++u){m={x:q["x"+u],y:q["y"+u]};k=N.1f.p9(m,G);if(k.3H<z){if(s){f=S N.1f.1D(m.x,m.y)}V{f=1d}1F cr}}}}}R f};N.1f.p9=Q(k,d){O c=k.x;O j=k.y;O b=d.x1;O i=d.y1;O a=d.x2;O f=d.y2;O m=a-b;O l=f-i;O h=((m*(c-b))+(l*(j-i)))/(1k.2Y(m,2)+1k.2Y(l,2));O g,e;if(h<=0){g=b;e=i}V{if(h>=1){g=a;e=f}V{g=b+h*m;e=i+h*l}}R{3H:1k.5r(1k.2Y(g-c,2)+1k.2Y(e-j,2)),x:g,y:e}};N.1f.5A=N.1z(N.1f,{1y:P,dp:P,1o:Q(a){N.1f.1g.1o.1j(K,1r);K.1y=[];if(a!=P){K.Dg(a)}},1m:Q(){K.1y.1a=0;K.1y=P;N.1f.1g.1m.1j(K,1r)},1T:Q(){O 1x=nC("S "+K.1p+"()");1h(O i=0,nB=K.1y.1a;i<nB;i++){1x.7U(K.1y[i].1T())}N.1c.4I(1x,K);R 1x},kZ:Q(){O b=[];1h(O c=0,a=K.1y.1a;c<a;c++){b.1w(K.1y[c].uJ())}R b.6b(",")},9J:Q(){K.2c=P;O d=S N.1U();O c=K.1y;if(c){1h(O b=0,a=c.1a;b<a;b++){d.1K(c[b].6k())}}if(d.1s!=P&&d.1L!=P&&d.1I!=P&&d.1t!=P){K.uK(d)}},Dg:Q(c){if(!(N.1c.4f(c))){c=[c]}1h(O b=0,a=c.1a;b<a;b++){K.7U(c[b])}},7U:Q(b,a){O d=1b;if(b){if(K.dp==P||(N.1c.2S(K.dp,b.1p)>-1)){if(a!=P&&(a<K.1y.1a)){O e=K.1y.9D(0,a);O c=K.1y.9D(a,K.1y.1a);e.1w(b);K.1y=e.b1(c)}V{K.1y.1w(b)}b.dr=K;K.9W();d=1d}}R d},PK:Q(b){O c=1b;if(!(N.1c.4f(b))){b=[b]}1h(O a=b.1a-1;a>=0;--a){c=K.9V(b[a])||c}R c},9V:Q(a){N.1c.am(K.1y,a);K.9W();R 1d},ec:Q(){O c=0;1h(O b=0,a=K.1y.1a;b<a;b++){c+=K.1y[b].ec()}R c},94:Q(){O c=0;1h(O b=0,a=K.1y.1a;b<a;b++){c+=K.1y[b].94()}R c},fE:Q(b){O d=0;1h(O c=0,a=K.1y.1a;c<a;c++){d+=K.1y[c].fE(b)}R d},9a:Q(g){if(!g){R K.1y.1a&&K.1y[0].9a()}O l=K.1y.1a;if(!l){R 1b}O b=[];O c=[];O d=0;O h=6r.kP;O m;1h(O k=0;k<l;++k){m=K.1y[k];O e=m.94();O f=m.9a(1d);if(2x(e)||2x(f.x)||2x(f.y)){5y}b.1w(e);d+=e;h=(e<h&&e>0)?e:h;c.1w(f)}l=b.1a;if(d===0){1h(O k=0;k<l;++k){b[k]=1}d=b.1a}V{1h(O k=0;k<l;++k){b[k]/=h}d/=h}O j=0,a=0,f,e;1h(O k=0;k<l;++k){f=c[k];e=b[k];j+=f.x*e;a+=f.y*e}R S N.1f.1D(j/d,a/d)},nH:Q(b){O d=0;1h(O c=0,a=K.1y.1a;c<a;c++){d+=K.1y[c].nH(b)}R d},3x:Q(b,d){1h(O c=0,a=K.1y.1a;c<a;c++){K.1y[c].3x(b,d)}},5m:Q(d,b){1h(O c=0,a=K.1y.1a;c<a;++c){K.1y[c].5m(d,b)}},7C:Q(d,a,c){1h(O b=0;b<K.1y.1a;++b){K.1y[b].7C(d,a,c)}R K},74:Q(h,j){O c=!(j&&j.l6===1b);O a=c&&j&&j.mL;O k,d,b;O e=6r.uF;1h(O f=0,g=K.1y.1a;f<g;++f){k=K.1y[f].74(h,j);b=a?k.3H:k;if(b<e){e=b;d=k;if(e==0){1F}}}R d},3w:Q(d){O b=1d;if(!d||!d.1p||(K.1p!==d.1p)){b=1b}V{if(!(N.1c.4f(d.1y))||(d.1y.1a!==K.1y.1a)){b=1b}V{1h(O c=0,a=K.1y.1a;c<a;++c){if(!K.1y[c].3w(d.1y[c])){b=1b;1F}}}}R b},3K:Q(e,c){if(e&&c){1h(O d=0,a=K.1y.1a;d<a;d++){O b=K.1y[d];b.3K(e,c)}K.2c=P}R K},6L:Q(d){O b=1b;1h(O c=0,a=K.1y.1a;c<a;++c){b=d.6L(K.1y[c]);if(b){1F}}R b},55:Q(b){O c=[];1h(O d=0,a=K.1y.1a;d<a;++d){3Q.1g.1w.1j(c,K.1y[d].55(b))}R c},1p:"N.1f.5A"});N.1f.1D=N.1z(N.1f,{x:P,y:P,uI:P,2E:P,1o:Q(b,d,c,a){N.1f.1g.1o.1j(K,1r);K.x=3t(b);K.y=3t(d);if(a||a==0){K.uI=3t(a)}K.2E=c||"6B"},1T:Q(a){if(a==P){a=S N.1f.1D(K.x,K.y)}N.1c.4I(a,K);R a},9J:Q(){K.2c=S N.1U(K.x,K.y,K.x,K.y)},74:Q(f,j){O d=!(j&&j.l6===1b);O a=d&&j&&j.mL;O b,e,h,c,g,i;if(f 1W N.1f.1D){e=K.x;h=K.y;c=f.x;g=f.y;b=1k.5r(1k.2Y(e-c,2)+1k.2Y(h-g,2));i=!a?b:{x0:e,y0:h,x1:c,y1:g,3H:b}}V{i=f.74(K,j);if(a){i={x0:i.x1,y0:i.y1,x1:i.x0,y1:i.y0,3H:i.3H}}}R i},3w:Q(a){O b=1b;if(a!=P){b=((K.x===a.x&&K.y===a.y)||(2x(K.x)&&2x(K.y)&&2x(a.x)&&2x(a.y)))}R b},uJ:Q(){R(K.x+", "+K.y)},3x:Q(a,b){K.x=K.x+a;K.y=K.y+b;K.9W()},5m:Q(d,b){d*=1k.PI/2R;O a=K.74(b);O c=d+1k.l9(K.y-b.y,K.x-b.x);K.x=b.x+(a*1k.8y(c));K.y=b.y+(a*1k.7P(c));K.9W()},9a:Q(){R S N.1f.1D(K.x,K.y)},7C:Q(c,a,b){b=(b==2q)?1:b;K.x=a.x+(c*b*(K.x-a.x));K.y=a.y+(c*(K.y-a.y));K.9W();R K},6L:Q(b){O a=1b;if(b.1p==="N.1f.1D"){a=K.3w(b)}V{a=b.6L(K)}R a},3K:Q(b,a){if((b&&a)){N.3g.3K(K,b,a);K.2c=P}R K},1m:Q(){K.x=P;K.y=P;K.uI=P;N.1f.1g.1m.1j(K,1r)},55:Q(a){R[K]},1p:"N.1f.1D"});N.1f.8k=N.1z(N.1f.5A,{dp:["N.1f.1D"],1o:Q(a){N.1f.5A.1g.1o.1j(K,1r)},ie:Q(a,b){K.7U(a,b)},ic:Q(a){K.9V(a)},1p:"N.1f.8k"});N.1f.dn=N.1z(N.1f.8k,{dp:["N.1f.1D","N.1l.z1"],1o:Q(a){N.1f.8k.1g.1o.1j(K,1r)},ec:Q(){O c=0;if(K.1y&&(K.1y.1a>1)){1h(O b=1,a=K.1y.1a;b<a;b++){c+=K.1y[b-1].74(K.1y[b])}}R c},nH:Q(b){O e=K;if(b){O c=S N.3g("4E:9E");if(!c.3w(b)){e=K.1T().3K(b,c)}}O f=0;if(e.1y&&(e.1y.1a>1)){O h,g;1h(O d=1,a=e.1y.1a;d<a;d++){h=e.1y[d-1];g=e.1y[d];f+=N.1c.uH({1P:h.x,1R:h.y},{1P:g.x,1R:g.y})}}R f*ib},1p:"N.1f.dn"});N.1f.2n=N.1z(N.1f.dn,{1o:Q(a){N.1f.dn.1g.1o.1j(K,1r)},9V:Q(a){O b=K.1y&&(K.1y.1a>2);if(b){N.1f.5A.1g.9V.1j(K,1r)}R b},6L:Q(m){O c=1b;O l=m.1p;if(l==="N.1f.2n"||l==="N.1f.4s"||l==="N.1f.1D"){O p=K.ia();O n;if(l==="N.1f.1D"){n=[{x1:m.x,y1:m.y,x2:m.x,y2:m.y}]}V{n=m.ia()}O s,g,e,a,r,q,d,b;cr:1h(O h=0,k=p.1a;h<k;++h){s=p[h];g=s.x1;e=s.x2;a=s.y1;r=s.y2;PJ:1h(O f=0,o=n.1a;f<o;++f){q=n[f];if(q.x1>e){1F}if(q.x2<g){5y}d=q.y1;b=q.y2;if(1k.4v(d,b)>1k.3f(a,r)){5y}if(1k.3f(d,b)<1k.4v(a,r)){5y}if(N.1f.pa(s,q)){c=1d;1F cr}}}}V{c=m.6L(K)}R c},ia:Q(){O a=K.1y.1a-1;O b=S 3Q(a),e,d;1h(O c=0;c<a;++c){e=K.1y[c];d=K.1y[c+1];if(e.x<d.x){b[c]={x1:e.x,y1:e.y,x2:d.x,y2:d.y}}V{b[c]={x1:d.x,y1:d.y,x2:e.x,y2:e.y}}}Q f(h,g){R h.x1-g.x1}R b.8J(f)},Df:Q(r,b){O c=!(b&&b.l6===1b);O o=b&&b.uG;O a=[];O t=K.55();O n=[];O v=[];O h=1b;O e,d,l;O j,q,u;O f={3l:1d,uG:o};O g=P;1h(O m=0,k=t.1a-2;m<=k;++m){e=t[m];n.1w(e.1T());d=t[m+1];u={x1:e.x,y1:e.y,x2:d.x,y2:d.y};l=N.1f.pa(r,u,f);if(l 1W N.1f.1D){if((l.x===r.x1&&l.y===r.y1)||(l.x===r.x2&&l.y===r.y2)||l.3w(e)||l.3w(d)){q=1d}V{q=1b}if(q||c){if(!l.3w(v[v.1a-1])){v.1w(l.1T())}if(m===0){if(l.3w(e)){5y}}if(l.3w(d)){5y}h=1d;if(!l.3w(e)){n.1w(l)}a.1w(S N.1f.2n(n));n=[l.1T()]}}}if(h){n.1w(d.1T());a.1w(S N.1f.2n(n))}if(v.1a>0){O p=r.x1<r.x2?1:-1;O s=r.y1<r.y2?1:-1;g={De:a,5K:v.8J(Q(w,i){R(p*w.x-p*i.x)||(s*w.y-s*i.y)})}}R g},4U:Q(x,b){O n=P;O d=b&&b.uw;O l,e,m,c;if(x 1W N.1f.2n){O w=K.55();O g,f,v,h,a,p;O s=[];m=[];1h(O t=0,o=w.1a-2;t<=o;++t){g=w[t];f=w[t+1];v={x1:g.x,y1:g.y,x2:f.x,y2:f.y};c=c||[x];if(d){s.1w(g.1T())}1h(O r=0;r<c.1a;++r){h=c[r].Df(v,b);if(h){a=h.De;if(a.1a>0){a.i9(r,1);3Q.1g.6c.1j(c,a);r+=a.1a-2}if(d){1h(O q=0,u=h.5K.1a;q<u;++q){p=h.5K[q];if(!p.3w(g)){s.1w(p);m.1w(S N.1f.2n(s));if(p.3w(f)){s=[]}V{s=[p.1T()]}}}}}}}if(d&&m.1a>0&&s.1a>0){s.1w(f.1T());m.1w(S N.1f.2n(s))}}V{n=x.ux(K,b)}if(c&&c.1a>1){e=1d}V{c=[]}if(m&&m.1a>1){l=1d}V{m=[]}if(e||l){if(d){n=[m,c]}V{n=c}}R n},ux:Q(b,a){R b.4U(K,a)},55:Q(a){O b;if(a===1d){b=[K.1y[0],K.1y[K.1y.1a-1]]}V{if(a===1b){b=K.1y.9D(1,K.1y.1a-1)}V{b=K.1y.9D()}}R b},74:Q(h,g){O k=!(g&&g.l6===1b);O B=k&&g&&g.mL;O q,e={};O t=6r.uF;if(h 1W N.1f.1D){O r=K.ia();O p=h.x;O o=h.y;O z;1h(O v=0,w=r.1a;v<w;++v){z=r[v];q=N.1f.p9(h,z);if(q.3H<t){t=q.3H;e=q;if(t===0){1F}}V{if(z.x2>p&&((o>z.y1&&o<z.y2)||(o<z.y1&&o>z.y2))){1F}}}if(B){e={3H:e.3H,x0:e.x,y0:e.y,x1:p,y1:o}}V{e=e.3H}}V{if(h 1W N.1f.2n){O d=K.ia();O c=h.ia();O b,a,n,A,f;O m=c.1a;O l={3l:1d};cr:1h(O v=0,w=d.1a;v<w;++v){b=d[v];A=b.x1;f=b.y1;1h(O u=0;u<m;++u){a=c[u];n=N.1f.pa(b,a,l);if(n){t=0;e={3H:0,x0:n.x,y0:n.y,x1:n.x,y1:n.y};1F cr}V{q=N.1f.p9({x:A,y:f},a);if(q.3H<t){t=q.3H;e={3H:t,x0:A,y0:f,x1:q.x,y1:q.y}}}}}if(!B){e=e.3H}if(t!==0){if(b){q=h.74(S N.1f.1D(b.x2,b.y2),g);O s=B?q.3H:q;if(s<t){if(B){e={3H:t,x0:q.x1,y0:q.y1,x1:q.x0,y1:q.y0}}V{e=s}}}}}V{e=h.74(K,g);if(B){e={3H:e.3H,x0:e.x1,y0:e.y1,x1:e.x0,y1:e.y0}}}}R e},PH:Q(h){if(K&&K!==P){O j=K.55();if(j.1a<3){R K}O d=Q(l,k){R(l-k)};O f=0;O i=j.1a-1;O e=[];O b=Q(o,n,l){O p=1k.3N(0.5*(o.x*n.y+n.x*l.y+l.x*o.y-n.x*o.y-l.x*n.y-o.x*l.y));O m=1k.5r(1k.2Y(o.x-n.x,2)+1k.2Y(o.y-n.y,2));O k=p/m*2;R k};O c=Q(n,q,o,k){O p=0;O m=0;1h(O l=q,r;l<o;l++){r=b(n[q],n[o],n[l]);if(r>p){p=r;m=l}}if(p>k&&m!==q){e.1w(m);c(n,q,m,k);c(n,m,o,k)}};e.1w(f);e.1w(i);4W(j[f].3w(j[i])){i--;e.1w(i)}c(j,f,i,h);O a=[];e.8J(d);1h(O g=0;g<e.1a;g++){a.1w(j[e[g]])}R S N.1f.2n(a)}V{R K}},1p:"N.1f.2n"});N.1f.2n.PG=Q(B,c,x,A){O h="PF";if(c!=2q){h=c}O k=10;if(x!=2q){k=x}O n={6p:h,PE:"PD",PC:k,PB:0};O z=[];1h(O C=0;C<B.1a;C++){z.1w([B[C].x,B[C].y])}O e=Q(p,i){R 1k.5r(1k.2Y(p[0]-i[0],2)+1k.2Y(p[1]-i[1],2))};O D=80;if(A!=2q){D=A}O y=[];O l,r,d,g,v,q,f,o,m,j,b,a;l=e(z[0],z[z.1a-1])/D;g=2;q=PA(z,n);1h(o=0,j=1/g;o<1;o+=j){b=[q(C+o),q(C+o+1/g)],f=b[0],d=b[1];v=e(f,d);r=l/v;1h(m=0,a=1/g;0<=a?m<a:m>a;m+=r){O w=q(C+o+m);y.1w(S N.1f.1D(w[0],w[1]))}}O w=q(C+1);y.1w(S N.1f.1D(w[0],w[1]));R S N.1f.2n(y)};N.1f.2n.Pz=Q(m,f){if(m.1a<2){R P}O s=[];O h=10;if(f!=2q){h=f}O n,l,v,u,t,c,b,a;O q,p;c=1/h;O e=1k.5r((1k.2Y(m[1].x-m[0].x,2)+1k.2Y(m[1].y-m[0].y,2))/2);O o=S N.1f.1D(m[0].x-e,m[0].y-e);O r=[];r[0]=o;1h(n=0;n<m.1a-1;n++){O d=[];d[0]=m[n];O g=S N.1f.1D(m[n].x*2-r[n].x,m[n].y*2-r[n].y);d[1]=g;r[n+1]=g;d[2]=m[n+1];s.1w(d[0]);1h(l=0;l<=h;l++){b=l*c;a=b*b;v=(a-2*b+1)/2;u=(2*b-2*a+1)/2;t=a/2;q=v*d[0].x+u*d[1].x+t*d[2].x;p=v*d[0].y+u*d[1].y+t*d[2].y;s.1w(S N.1f.1D(q,p))}}s.1w(m[m.1a-1]);R S N.1f.2n(s)};N.1f.2n.Py=Q(o,h,a){if(a){R N.1f.2n.Dc(o,a)}O b=[];1h(O d=0;d<o.1a;d++){b[d]=o[d]}O g;O e;O f=0;O p;O l=b.1a;O c=[];O n=1d;4W(n){p=1d;1h(g=0;g<l-3;g+=3){if(uC(b,g)>h){p=1b;uD(b,g,c);b.6c(g+1,2);1h(e=0;e<5;e++){b.6c(g+1+e,0,c[e+1])}g-=3;l=b.1a}if(p){1F}}4W(f<l-1){if(b[f]===b[f+1]){b.6c(f+1,1);l--}f++}n=1b}R S N.1f.2n(b)};N.1f.2n.Dd=Q(l,a){if(!a){a=20}O b=[];O d=0.uE;if(a>0){d=1/a}1h(O f=0;f<l.1a-2;){O c=l[f];O o=l[f+1];O k=l[f+2];b.1w(c);1h(O n=0;n<1;){O h=(1-n)*(1-n)*c.x+2*n*(1-n)*o.x+n*n*k.x;O g=(1-n)*(1-n)*c.y+2*n*(1-n)*o.y+n*n*k.y;O j=S N.1f.1D(h,g);b.1w(j);n+=d}f+=2;if(f>=l.1a){b.1w(c)}}O e=b[b.1a-1];O m=l[l.1a-1];if(!e.3w(m)){b.1w(m.1T())}R b};N.1f.2n.Db=Q(n,a){if(!a){a=20}O b=[];O d=0.uE;if(a>0){d=1/a}1h(O f=0;f<n.1a-3;){O c=n[f];O h=n[f+1];O g=n[f+2];O m=n[f+3];b.1w(c);1h(O p=0;p<1;){O k=(1-p)*(1-p)*(1-p)*c.x+3*p*(1-p)*(1-p)*h.x+3*p*p*(1-p)*g.x+p*p*p*m.x;O j=(1-p)*(1-p)*(1-p)*c.y+3*p*(1-p)*(1-p)*h.y+3*p*p*(1-p)*g.y+p*p*p*m.y;O l=S N.1f.1D(k,j);b.1w(l);p+=d}f+=3;if(f>=n.1a){b.1w(c)}}O e=b[b.1a-1];O o=n[n.1a-1];if(!e.3w(o)){b.1w(o.1T())}R b};N.1f.2n.p6=Q(m,a){if(!a){a=m.1a*8}O c=[];O e=0.uE;if(a>0){e=1/a}1h(O p=0;p<=1;){O k=0;O j=0;O d=m.1a;1h(O g=0;g<m.1a;g++){O h=N.1f.2n.Da(d-1,g,p);k+=m[g].x*h;j+=m[g].y*h}O l=S N.1f.1D(k,j);c.1w(l);p+=e}O f=c[c.1a-1];O o=m[m.1a-1];if(!f.3w(o)){c.1w(o.1T())}R c};N.1f.2n.Px=Q(b,a){O c=N.1f.2n.Dd(b,a);R S N.1f.2n(c)};N.1f.2n.Dc=Q(b,a){O c=N.1f.2n.Db(b,a);R S N.1f.2n(c)};N.1f.2n.Pw=Q(l,g){O a=[];1h(O c=0;c<l.1a;c++){a[c]=l[c]}O f,d,e=0,n,h=a.1a;O b=[];4W(1d){n=1d;1h(f=0;f<h-3;f+=3){if(uC(a,f)>g){n=1b;uD(a,f,b);a.6c(f+1,2);1h(d=0;d<5;d++){a.6c(f+1+d,0,b[d+1])}f-=3;h=a.1a}if(n){1F}}4W(e<h-1){if(a[e]===a[e+1]){a.6c(e+1,1);h--}e++}R S N.1f.2n(a)}};Q uD(b,c,e){O a=[];a[0]=[];a[1]=[];a[2]=[];O d;1h(d=0;d<3;d++){a[0][d]=S N.1f.1D;a[0][d].x=(b[c+d].x+b[c+d+1].x)/2;a[0][d].y=(b[c+d].y+b[c+d+1].y)/2}1h(d=0;d<2;d++){a[1][d]=S N.1f.1D;a[1][d].x=(a[0][d].x+a[0][d+1].x)/2;a[1][d].y=(a[0][d].y+a[0][d+1].y)/2}a[2][0]=S N.1f.1D;a[2][0].x=(a[1][0].x+a[1][1].x)/2;a[2][0].y=(a[1][0].y+a[1][1].y)/2;e[0]=b[c];e[1]=a[0][0];e[2]=a[1][0];e[3]=a[2][0];e[4]=a[1][1];e[5]=a[0][2];e[6]=b[c+3];R 1d}Q uC(a,b){O d=0;1h(O c=1;c<4;c++){if(1k.3N(a[b+c].x-a[b+c-1].x)>d){d=1k.3N(a[b+c].x-a[b+c-1].x)}if(1k.3N(a[b+c].y-a[b+c-1].y)>d){d=1k.3N(a[b+c].y-a[b+c-1].y)}}R d}N.1f.2n.Pv=Q(b,a){O c=N.1f.2n.p6(b,a);R S N.1f.2n(c)};N.1f.2n.Da=Q(c,a,b){R N.1f.2n.D9(c,a)*1k.2Y(b,a)*1k.2Y(1-b,c-a)};N.1f.2n.D9=Q(d,a){O c=N.1f.2n.p8(d);O b=N.1f.2n.p8(a)*N.1f.2n.p8(d-a);R c/b};N.1f.2n.p8=Q(c){O a=1;1h(O b=1;b<=c;b++){a*=b}R a};N.1f.2n.Pu=Q(z){if(z==P||z.1a<3){R z}O A=z;O j=[];O p=0.4;O H=0.5;O D=0.D8;O v=A.1a-1;1h(O y=0;y<=v+1-3;y++){O g=A[y];O f=A[y+1];O d=A[y+2];O m=S N.1f.1D();O h=S N.1f.1D();O F=S N.1f.1D(f.x-g.x,f.y-g.y);O a=S N.1f.1D(d.x-f.x,d.y-f.y);O u=1k.5r(F.x*F.x+F.y*F.y);O I=1k.5r(a.x*a.x+a.y*a.y);O s=S N.1f.1D(F.x/u,F.y/u);O l=S N.1f.1D(a.x/I,a.y/I);O G=S N.1f.1D(s.x+l.x,s.y+l.y);O c=1k.5r(G.x*G.x+G.y*G.y);O r=S N.1f.1D(G.x/c,G.y/c);O o=(s.x*l.x+s.y*l.y)/1;if(1k.3N(1-o)<D){m.x=f.x-l.x*u*p;m.y=f.y-l.y*u*p;h.x=f.x+s.x*I*p;h.y=f.y+s.y*I*p}V{m.x=f.x-r.x*u*p;m.y=f.y-r.y*u*p;h.x=f.x+r.x*I*p;h.y=f.y+r.y*I*p}j[y*3+2+0]=m;j[y*3+2+1]=f;j[y*3+2+2]=h;if(y==0){O E=S N.1f.1D();O x=S N.1f.1D(m.x-g.x,m.y-g.y);O C=1k.5r(x.x*x.x+x.y*x.y);O i=S N.1f.1D(x.x/C,x.y/C);E.x=g.x+i.x*u*p*H;E.y=g.y+i.y*u*p*H;j[y*3+0]=g;j[y*3+1]=E}if(y==v+1-3){O w=S N.1f.1D();O J=S N.1f.1D(h.x-d.x,h.y-d.y);O B=1k.5r(J.x*J.x+J.y*J.y);O q=S N.1f.1D(J.x/B,J.y/B);w.x=d.x+q.x*I*p*H;w.y=d.y+q.y*I*p*H;j[y*3+2+3]=w;j[y*3+2+4]=d}}R j};N.1f.2n.Pt=Q(w){if(w==P||w.1a<3){R w}O o=w[0];w.1w(o);O x=w;O i=[];O p=0.4;O B=0.5;O y=0.D8;O u=x.1a-1;1h(O v=0;v<=u-1;v++){if(v==u-1){O g=x[u-1];O f=x[0];O d=x[1]}V{O g=x[v];O f=x[v+1];O d=x[v+2]}O l=S N.1f.1D();O h=S N.1f.1D();O z=S N.1f.1D(f.x-g.x,f.y-g.y);O a=S N.1f.1D(d.x-f.x,d.y-f.y);O s=1k.5r(z.x*z.x+z.y*z.y);O C=1k.5r(a.x*a.x+a.y*a.y);O r=S N.1f.1D(z.x/s,z.y/s);O j=S N.1f.1D(a.x/C,a.y/C);O A=S N.1f.1D(r.x+j.x,r.y+j.y);O c=1k.5r(A.x*A.x+A.y*A.y);O q=S N.1f.1D(A.x/c,A.y/c);O m=(r.x*j.x+r.y*j.y)/1;if(1k.3N(1-m)<y){l.x=f.x-j.x*s*p;l.y=f.y-j.y*s*p;h.x=f.x+r.x*C*p;h.y=f.y+r.y*C*p}V{l.x=f.x-q.x*s*p;l.y=f.y-q.y*s*p;h.x=f.x+q.x*C*p;h.y=f.y+q.y*C*p}if(v==u-1){i[0]=f;i[1]=h;i[(u-2)*3+2+3]=l;i[(u-2)*3+2+4]=x[u]}V{i[v*3+2+0]=l;i[v*3+2+1]=f;i[v*3+2+2]=h}}R i};N.1f.2n.uA=Q(z){if(z.1a<3){R z}O A=z.1a,u={},e=z[0],b=z[1],a=z[2];O k=0,j=0,t=1d,B=0,G=0,C=0,c=72,u={},s=[];O v=(a.y-e.y)/(a.x-e.x);O f=a.y-v*a.x;if((((a.x!=e.x)&&(a.y!=e.y))&&(b.y==v*b.x+f))||((a.x==e.x)&&(b.x==e.x))||((a.y==e.y)&&(b.y==e.y))||((a.x==e.x)&&(a.y==e.y))||((a.x==b.x)&&(a.y==b.y))||((e.x==b.x)&&(e.y==b.y))){s.1w(e);s.1w(b);s.1w(a)}V{O q=((b.x*b.x+b.y*b.y)-(e.x*e.x+e.y*e.y))*(2*(a.y-e.y))-((a.x*a.x+a.y*a.y)-(e.x*e.x+e.y*e.y))*(2*(b.y-e.y));O p=(2*(b.x-e.x))*((a.x*a.x+a.y*a.y)-(e.x*e.x+e.y*e.y))-(2*(a.x-e.x))*((b.x*b.x+b.y*b.y)-(e.x*e.x+e.y*e.y));O o=4*((b.x-e.x)*(a.y-e.y)-(a.x-e.x)*(b.y-e.y));u.x=q/o;u.y=p/o;k=1k.5r((e.x-u.x)*(e.x-u.x)+(e.y-u.y)*(e.y-u.y));O r=(e.x-a.x)*(e.x-a.x)+(e.y-a.y)*(e.y-a.y);O h=(2*k*k-r)/(2*k*k);h=h>=1?1:h;h=h<=-1?-1:h;C=1k.Ps(h)*2R/1k.PI;if(a.x==e.x){C=((u.x>e.x&&b.x>e.x)||(u.x<e.x&&b.x<e.x))?(ks-C):C}V{C=((u.y>(v*u.x+f)&&b.y>(v*b.x+f))||(u.y<(v*u.x+f)&&b.y<(v*b.x+f)))?(ks-C):C}j=C/72;if(a.y!=e.y){if(a.x==e.x){if(a.y>e.y){if(b.x<e.x){t=1b}}V{if(b.x>e.x){t=1b}}}V{if(a.x<e.x){if(b.y<v*b.x+f){t=1b}}V{if(b.y>v*b.x+f){t=1b}}}}V{if(a.x>e.x){if(b.y>e.y){t=1b}}V{if(b.y<e.y){t=1b}}}O g=(e.y-u.y)/(e.x-u.x);O l=g>=0?1k.p7(g)*2R/1k.PI:1k.3N(1k.p7(g)*2R/1k.PI)+90;O H=1k.3N(u.y);if((e.y==H)&&(H==a.y)){if(e.x<a.x){l=l+2R}}O d=e.y-u.y;s.1w(e);1h(O w=1;w<c;w++){B=j*w;G=l;if(t){if(d>=0){if(g>=0){G=G+B}V{G=(2R-(G-90))+B}}V{if(g>0){G=(G-2R)+B}V{G=(90-G)+B}}}V{if(d>=0){if(g>=0){G=G-B}V{G=(2R-(G-90))-B}}V{if(g>=0){G=(G-2R)-B}V{G=(90-G)-B}}}G=G*1k.PI/2R;O n=u.x+k*1k.8y(G);O m=u.y+k*1k.7P(G);s.1w(S N.1f.1D(n,m))}s.1w(a)}R s};N.1f.2n.k1=Q(e){O f=[],b=0,a=e.1a;if(e==P||a<2){R e}1h(O c=0;c<a;){O d=e[c].2E;if(d=="p5"){O g=N.1f.2n.D7(f,c,a,e);f=g[0];c=g[1]}V{f.1w(e[c]);c++}}R f},N.1f.2n.D7=Q(e,b,a,c){if(b==0){O f=N.1f.2n.l8(c,b,a,"p5");3Q.1g.1w.1j(e,f[0]);b=f[1]+1}V{if(b==a-1){O d=[c[b-1],c[b]],g=N.1f.2n.uA(d);3Q.1g.1w.1j(e,g);b++}V{O f=N.1f.2n.l8(c,b,a,"p5");e.9h();3Q.1g.1w.1j(e,f[0]);b=f[1]+1}}R[e,b]},N.1f.2n.Pr=Q(e,b,a,c){if(b==0){O f=N.1f.2n.l8(c,b,a,"uB");3Q.1g.1w.1j(e,f[0]);b=f[1]+1}V{if(b==a-1){O d=[c[b-1],c[b]],g=N.1f.2n.p6(d);3Q.1g.1w.1j(e,g);b++}V{O f=N.1f.2n.l8(c,b,a,"uB");e.9h();3Q.1g.1w.1j(e,f[0]);b=f[1]+1}}R[e,b]},N.1f.2n.l8=Q(e,c,a,d){O f=[],b=c+1;if(c==0){3Q.1g.1w.1j(f,[e[c],e[c+1]])}V{if(c==a-1){3Q.1g.1w.1j(f,[e[c-1],e[c]])}V{3Q.1g.1w.1j(f,[e[c-1],e[c],e[c+1]])}}if(d=="uB"){O g=N.1f.2n.p6(f)}V{if(d=="p5"){O g=N.1f.2n.uA(f)}}R[g,b]};N.1f.4s=N.1z(N.1f.2n,{dp:["N.1f.1D"],1o:Q(a){N.1f.2n.1g.1o.1j(K,1r)},7U:Q(a,b){O c=1b;O d=K.1y.9h();if(b!=P||!a.3w(d)){c=N.1f.5A.1g.7U.1j(K,1r)}O e=K.1y[0];N.1f.5A.1g.7U.1j(K,[e]);R c},9V:Q(a){O b=K.1y&&(K.1y.1a>3);if(b){K.1y.9h();N.1f.5A.1g.9V.1j(K,1r);O c=K.1y[0];N.1f.5A.1g.7U.1j(K,[c])}R b},3x:Q(b,d){1h(O c=0,a=K.1y.1a;c<a-1;c++){K.1y[c].3x(b,d)}},5m:Q(d,b){1h(O c=0,a=K.1y.1a;c<a-1;++c){K.1y[c].5m(d,b)}},7C:Q(e,b,d){1h(O c=0,a=K.1y.1a;c<a-1;++c){K.1y[c].7C(e,b,d)}R K},3K:Q(e,c){if(e&&c){1h(O d=0,a=K.1y.1a;d<a-1;d++){O b=K.1y[d];b.3K(e,c)}K.2c=P}R K},9a:Q(){if(K.1y&&(K.1y.1a>2)){O h=0;O g=0;1h(O e=0;e<K.1y.1a-1;e++){O d=K.1y[e];O k=K.1y[e+1];h+=(d.x+k.x)*(d.x*k.y-k.x*d.y);g+=(d.y+k.y)*(d.x*k.y-k.x*d.y)}O f=-1*K.94();O a=h/(6*f);O j=g/(6*f);R S N.1f.1D(a,j)}V{R P}},94:Q(){O g=0;if(K.1y&&(K.1y.1a>2)){O f=0;1h(O e=0,d=K.1y.1a;e<d-1;e++){O a=K.1y[e];O h=K.1y[e+1];f+=(a.x+h.x)*(h.y-a.y)}g=-f/2}R g},fE:Q(b){O d=K;if(b){O c=S N.3g("4E:9E");if(!c.3w(b)){d=K.1T().3K(b,c)}}O f=0;O a=d.1y&&d.1y.1a;if(a>2){O h,g;1h(O e=0;e<a-1;e++){h=d.1y[e];g=d.1y[e+1];f+=N.1c.uz(g.x-h.x)*(2+1k.7P(N.1c.uz(h.y))+1k.7P(N.1c.uz(g.y)))}f=f*uy*uy/2}R f},dq:Q(m){O s=N.6r.l7;O l=14;O k=s(m.x,l);O j=s(m.y,l);Q r(w,t,v,i,u){R(w-u)*((i-t)/(u-v))+i}O a=K.1y.1a-1;O g,f,q,d,o,b,e,c;O h=0;1h(O n=0;n<a;++n){g=K.1y[n];q=s(g.x,l);d=s(g.y,l);f=K.1y[n+1];o=s(f.x,l);b=s(f.y,l);if(d===b){if(j===d){if(q<=o&&(k>=q&&k<=o)||q>=o&&(k<=q&&k>=o)){h=-1;1F}}5y}e=s(r(j,q,d,o,b),l);if(e===k){if(d<b&&(j>=d&&j<=b)||d>b&&(j<=d&&j>=b)){h=-1;1F}}if(e<=k){5y}if(q!==o&&(e<1k.4v(q,o)||e>1k.3f(q,o))){5y}if(d<b&&(j>=d&&j<b)||d>b&&(j<d&&j>=b)){++h}}O p=(h===-1)?1:!!(h&1);R p},6L:Q(d){O b=1b;if(d.1p==="N.1f.1D"){b=K.dq(d)}V{if(d.1p==="N.1f.2n"){b=d.6L(K)}V{if(d.1p==="N.1f.4s"){b=N.1f.2n.1g.6L.1j(K,[d])}V{1h(O c=0,a=d.1y.1a;c<a;++c){b=d.1y[c].6L(K);if(b){1F}}}}}R b},55:Q(a){R(a===1d)?[]:K.1y.9D(0,K.1y.1a-1)},1p:"N.1f.4s"});N.1f.83=N.1z(N.1f.5A,{dp:["N.1f.2n"],1o:Q(a){N.1f.5A.1g.1o.1j(K,1r)},4U:Q(n,s){O g=P;O r=s&&s.uw;O o,a,q,m,b;O e=[];O p=[n];1h(O f=0,h=K.1y.1a;f<h;++f){a=K.1y[f];m=1b;1h(O d=0;d<p.1a;++d){o=a.4U(p[d],s);if(o){if(r){q=o[0];1h(O c=0,l=q.1a;c<l;++c){if(c===0&&e.1a){e[e.1a-1].7U(q[c])}V{e.1w(S N.1f.83([q[c]]))}}m=1d;o=o[1]}if(o.1a){o.i9(d,1);3Q.1g.6c.1j(p,o);1F}}}if(!m){if(e.1a){e[e.1a-1].7U(a.1T())}V{e=[S N.1f.83(a.1T())]}}}if(e&&e.1a>1){m=1d}V{e=[]}if(p&&p.1a>1){b=1d}V{p=[]}if(m||b){if(r){g=[e,p]}V{g=p}}R g},ux:Q(n,s){O g=P;O r=s&&s.uw;O o,c,q,m,a,e,p;if(n 1W N.1f.2n){p=[];e=[n];1h(O f=0,h=K.1y.1a;f<h;++f){a=1b;c=K.1y[f];1h(O d=0;d<e.1a;++d){o=e[d].4U(c,s);if(o){if(r){q=o[0];if(q.1a){q.i9(d,1);3Q.1g.6c.1j(e,q);d+=q.1a-2}o=o[1];if(o.1a===0){o=[c.1T()]}}1h(O b=0,l=o.1a;b<l;++b){if(b===0&&p.1a){p[p.1a-1].7U(o[b])}V{p.1w(S N.1f.83([o[b]]))}}a=1d}}if(!a){if(p.1a){p[p.1a-1].7U(c.1T())}V{p=[S N.1f.83([c.1T()])]}}}}V{g=n.4U(K)}if(e&&e.1a>1){m=1d}V{e=[]}if(p&&p.1a>1){a=1d}V{p=[]}if(m||a){if(r){g=[e,p]}V{g=p}}R g},1p:"N.1f.83"});N.1f.3T=N.1z(N.1f.5A,{dp:["N.1f.4s"],1o:Q(a){N.1f.5A.1g.1o.1j(K,1r)},94:Q(){O c=0;if(K.1y&&(K.1y.1a>0)){c+=1k.3N(K.1y[0].94());1h(O b=1,a=K.1y.1a;b<a;b++){c-=1k.3N(K.1y[b].94())}}R c},fE:Q(b){O d=0;if(K.1y&&(K.1y.1a>0)){d+=1k.3N(K.1y[0].fE(b));1h(O c=1,a=K.1y.1a;c<a;c++){d-=1k.3N(K.1y[c].fE(b))}}R d},dq:Q(a){O e=K.1y.1a;O c=1b;if(e>0){c=K.1y[0].dq(a);if(c!==1){if(c&&e>1){O d;1h(O b=1;b<e;++b){d=K.1y[b].dq(a);if(d){if(d===1){c=1}V{c=1b}1F}}}}}R c},6L:Q(e){O b=1b;O d,a;if(e.1p==="N.1f.1D"){b=K.dq(e)}V{if(e.1p==="N.1f.2n"||e.1p==="N.1f.4s"){1h(d=0,a=K.1y.1a;d<a;++d){b=e.6L(K.1y[d]);if(b){1F}}if(!b){1h(d=0,a=e.1y.1a;d<a;++d){b=K.dq(e.1y[d]);if(b){1F}}}}V{1h(d=0,a=e.1y.1a;d<a;++d){b=K.6L(e.1y[d]);if(b){1F}}}}if(!b&&e.1p==="N.1f.3T"){O c=K.1y[0];1h(d=0,a=c.1y.1a;d<a;++d){b=e.dq(c.1y[d]);if(b){1F}}}R b},74:Q(d,b){O c=!(b&&b.l6===1b);O a;if(!c&&K.6L(d)){a=0}V{a=N.1f.5A.1g.74.1j(K,[d,b])}R a},1p:"N.1f.3T"});N.1f.3T.D6=Q(j,f,b,l){O c=1k.PI*((1/b)-(1/2));if(l){c+=(l/2R)*1k.PI}O a,h,g;O k=[];1h(O e=0;e<b;++e){a=c+(e*2*1k.PI/b);h=j.x+(f*1k.8y(a));g=j.y+(f*1k.7P(a));k.1w(S N.1f.1D(h,g))}O d=S N.1f.4s(k);R S N.1f.3T([d])};N.1f.3T.Pq=Q(n,j,c,a,h,d){if(d==2q){d=1}O m=a*1k.PI/(2R*c);O b,l,k;O o=[];1h(O g=0;g<c;++g){b=m*g;l=n.x+(j*d*1k.8y(b));k=n.y+(j*d*1k.7P(b));o.1w(S N.1f.1D(l,k))}b=a*1k.PI/2R;l=n.x+(j*d*1k.8y(b));k=n.y+(j*d*1k.7P(b));o.1w(S N.1f.1D(l,k));o.1w(n);O e=S N.1f.4s(o);e.5m(3t(h),n);O f=S N.1f.3T([e]);f.6z=n;f.4J=j;f.r=a;f.uv=h;f.gm=c;f.uu="dn";R f};N.1f.3T.Pp=Q(j,k,c,a,g,d){if(d==2q){d=1}O h=[];h.1w(j);h.1w(S N.1f.1D(j.x+a*d,j.y));O b=S N.1f.2n(h);b.5m(3t(g),j);O e=[];e.1w(S N.1f.1D(j.x+k*d,j.y));e.1w(S N.1f.1D(j.x+a*d,j.y+c*d/2));e.1w(S N.1f.1D(j.x+a*d,j.y-c*d/2));O i=S N.1f.4s(e);i.5m(3t(g),j);O f=S N.1f.5A([b,i]);f.6z=j;f.1E=k;f.1A=c;f.Po=a;f.uv=g;f.uu="Pn";R f};N.1f.3T.Pm=Q(v,f,h,a,m,o){if(m==2q){m=1}if(o==2q){o=10}O l=[];l.1w(v);l.1w(v);l.1w(S N.1f.1D(v.x+f*m*2/3,v.y+h*m/2));l.1w(S N.1f.1D(v.x+f*m,v.y+h*m/2));l.1w(S N.1f.1D(v.x+f*m,v.y-h*m/2));l.1w(S N.1f.1D(v.x+f*m*2/3,v.y-h*m/2));l.1w(v);l.1w(v);O r=[];O q,p,y,w,u,e,d,c;O t,s;O g=l.1a;e=1/o;r.1w(S N.1f.1D((l[0].x+l[1].x)/2,(l[0].y+l[1].y)/2));1h(q=1;q<g-1;q++){1h(p=0;p<=o;p++){d=p*e;c=d*d;y=(c-2*d+1)/2;w=(2*d-2*c+1)/2;u=c/2;t=y*l[q-1].x+w*l[q].x+u*l[q+1].x;s=y*l[q-1].y+w*l[q].y+u*l[q+1].y;r.1w(S N.1f.1D(t,s))}}O b=S N.1f.4s(r);b.5m(3t(a),v);O x=S N.1f.5A([b]);x.6z=v;x.1E=f;x.1A=h;x.uv=a;x.uu="Pl";R x};N.1f.8W=N.1z(N.1f.5A,{dp:["N.1f.3T"],1o:Q(a){N.1f.5A.1g.1o.1j(K,1r)},1p:"N.1f.8W"});N.1f.9S=N.1z(N.1f,{x:P,y:P,1A:P,1E:P,1o:Q(b,d,c,a){N.1f.1g.1o.1j(K,1r);K.x=b;K.y=d;K.1A=c;K.1E=a},9J:Q(){K.2c=S N.1U(K.x,K.y,K.x+K.1A,K.y+K.1E)},ec:Q(){O a=(2*K.1A)+(2*K.1E);R a},94:Q(){O a=K.1A*K.1E;R a},3x:Q(a,b){K.x=K.x+a;K.y=K.y+b;K.9J()},9a:Q(){O b=K.x+K.1A/2,a=K.y+K.1E/2;R S N.1f.1D(b,a)},1p:"N.1f.9S"});N.1f.d2=N.1z(N.1f,{x:P,y:P,99:P,ba:P,1o:Q(a,c,b){N.1f.1g.1o.1j(K,1r);K.ba={h:P,w:P};K.x=3t(a);K.y=3t(c);K.99=b.7r();K.2h=1Q.2G("oV")},1m:Q(){N.1f.1g.1m.1j(K,1r);K.x=P;K.y=P;K.99=P},9a:Q(){R S N.1f.1D(K.x,K.y)},1T:Q(a){if(a==P){a=S N.1f.d2(K.x,K.y,K.99)}N.1c.4I(a,K);R a},9J:Q(){K.2c=S N.1U(K.x,K.y,K.x,K.y)},nU:Q(g,j,f,c){O d,e,b,k,m;O i=N.1c.eg(g);O h=c.5k||K.99;O a=h.4U("\\n");O l=a.1a;j=3t(j);f=3t(f);if(l>1){f=3t(f)*l}if(c.3W&&c.3W!=="cm"){5U(c.3W){1N"lt":i.x+=j/2;i.y+=f/2;1F;1N"lm":i.x+=j/2;1F;1N"lb":i.x+=j/2;i.y-=f/2;1F;1N"ct":i.y+=f/2;1F;1N"cb":i.y-=f/2;1F;1N"rt":i.x-=j/2;i.y+=f/2;1F;1N"rm":i.x-=j/2;1F;1N"rb":i.x-=j/2;i.y-=f/2;1F;49:1F}}K.ba.h=f;K.ba.w=j;e=i.x-3t(j)/2;b=i.y+3t(f)/2;m=i.x+3t(j)/2;k=i.y-3t(f)/2;d=S N.1U(e,b,m,k);R d},ta:Q(e,b){O c,d,a,h,i;O f=K.D5(b);O g=N.1c.eg(e);if(b.3W&&b.3W!=="cm"){5U(b.3W){1N"lt":g.x+=f.w/2;g.y+=f.h/2;1F;1N"lm":g.x+=f.w/2;1F;1N"lb":g.x+=f.w/2;g.y-=f.h/2;1F;1N"ct":g.y+=f.h/2;1F;1N"cb":g.y-=f.h/2;1F;1N"rt":g.x-=f.w/2;g.y+=f.h/2;1F;1N"rm":g.x-=f.w/2;1F;1N"rb":g.x-=f.w/2;g.y-=f.h/2;1F;49:1F}}K.ba.h=f.h;K.ba.w=f.w;d=g.x-f.w/2;a=g.y+f.h/2;if(b.7f&&b.7f&&b.7f==="n0"){i=g.x+f.w/2+2g(3t(b.4h)/2)}V{i=g.x+f.w/2}h=g.y-f.h/2;c=S N.1U(d,a,i,h);R c},D5:Q(b){O m,n,j=1,f=3t(b.4x);m=b.5k||K.99;if(b.4h){n=3t(b.4h)}V{R P}O k,e;O a=m.4U("\\n");O h=a.1a;if(h>1){e=n*h+h+f}V{e=n+f+1}k=0;if(K.p4&&k<K.p4){k=K.p4}1h(O g=0;g<h;g++){O c=K.D3(a[g]);O l=K.p4=K.D4(b,a[g])+c.D1*j+f;if(k<l){k=l}}O d=S 78();d.h=e;d.w=k;R d},D4:Q(a,c){1Q.7n.1V(K.2h);K.2h.W.1A="4i";K.2h.W.1E="4i";if(a.4h){K.2h.W.4h=a.4h}if(a.8a){K.2h.W.8a=a.8a}if(a.79){K.2h.W.79=a.79}K.2h.W.2v="3d";K.2h.W.3j="8C";K.2h.5N=c;O b=K.2h.i2;1Q.7n.2T(K.2h);R b},Pk:Q(a,b){b.5k=K.99;O e={};e=N.1c.bM(e,b);if(e.4h.7r().2S("px")===-1){e.4h+="px"}O d=a.dg(S N.3i(K.x,K.y));O h=K.ta(d,e);O c=a.6M(S N.2B(h.1s,h.1t));O j=a.6M(S N.2B(h.1I,h.1L));O l=S N.1U(c.1P,j.1R,j.1P,c.1R);if(e.8z){O k=[];k.1w(S N.1f.1D(l.1s,l.1t));k.1w(S N.1f.1D(l.1I,l.1t));k.1w(S N.1f.1D(l.1I,l.1L));k.1w(S N.1f.1D(l.1s,l.1L));1h(O g=0;g<k.1a;g++){k[g].5m(-e.8z,S N.1f.1D(K.x,K.y))}O f=S N.1f.2n(k);R f.6k()}V{R l}},D3:Q(e){O d=S 78();O c=0;O a=0;1h(O b=0;b<e.1a;b++){if(e.D2(b)>7J){c++}V{a++}}d.Pj=c;d.Pi=a;d.D1=e.1a;R d},1p:"N.1f.d2"});N.1Z=N.1z({66:P,31:P,52:P,7O:1b,1G:P,7v:P,U:P,gb:0,1o:Q(a,b){K.66=N.1c.6l(a);N.1c.1K(K,b)},1m:Q(){K.66=P;K.52=P;K.1G=P;K.7v=P;K.U=P},bn:Q(){R 1b},9e:Q(a,b){K.52=a.1T();if(K.U.2b&&K.U.2b.5C){K.52=a.5C(K.U.9i())}if(b){K.7v=P}R 1d},6A:Q(a){K.1G=a.1T();K.7v=P},2r:Q(){K.7v=K.7v||K.U.2r();R K.7v},3V:Q(i,b){if(b==P){b=i.W}if(i.1x){O a=i.1x.6k();if(a){O h;if(K.U.2b&&K.U.2b.5C){h=K.U.9i()}if(!a.9R(K.52,{dm:h})){b={23:"2L"}}V{K.ox(a,h)}O c=K.9Q(i.1x,b,i.id);if(i.1x.tG&&i.1x.tG===1d){R 1d}if(b.23!=="2L"&&b.5k&&c!==1b){O g;if(b.Bi){O j=i.1x.2c.5P();g=S N.1f.1D(j.1P,j.1R)}V{g=i.1x.9a()}if(g==P){R P}if(b.7h||b.7g){O e=2x(b.7h)?0:b.7h;O d=2x(b.7g)?0:b.7g;O f=K.2r();g.3x(e*f,d*f)}K.dj(i.id,b,g)}V{K.kB(i.id)}R c}}},ox:Q(e,d){K.gb=0;if(d){O f=d.3L(),b=(K.52.1s+K.52.1I)/2,c=(e.1s+e.1I)/2,a=1k.2w((c-b)/f);K.gb=a*f}},9Q:Q(c,a,b){},dj:Q(c,b,a){},kB:Q(a){},5z:Q(){},g2:Q(a){},g4:Q(d){if(!(N.1c.4f(d))){d=[d]}1h(O c=0,a=d.1a;c<a;++c){O b=d[c];K.g8(b.1x,b.id);K.kB(b.id)}},g8:Q(b,a){},hQ:Q(a){},tD:Q(){R K.66.id},uc:Q(b){O a=N.1c.1K({},N.1Z.D0);if(b.2o===1b){2s a.4x;2s a.8A}if(b.2j===1b){2s a.7j}N.1c.1K(a,b);R a},1p:"N.1Z"});N.1Z.D0={7j:"#aq",8A:"#aq",4x:1,4H:1,at:1,4z:0};N.1Z.ck={Ph:[ut,75,Pg,p3,Pf,p3,Pe,CX,Pd,CY,ut,CZ,Pc,CY,Pb,CX,Pa,p3,P9,p3,ut,75],P8:[4,0,6,0,6,4,10,4,10,6,6,6,6,10,4,10,4,6,0,6,0,4,4,4,4,0],x:[0,0,25,0,50,35,75,0,4b,0,65,50,4b,4b,75,4b,50,65,25,4b,0,4b,35,50,0,0],P7:[0,0,0,1,1,1,1,0,0,0],P6:[0,10,10,10,5,0,0,10],dk:[0,0,9.oY,-3.oZ,9.p0,-1.p1,9.p2,-0.61,9.p2,0.61,9.p0,1.p1,9.oY,3.oZ,0,0],P5:[0,0,-3.oZ,-9.oY,-1.p1,-9.p0,-0.61,-9.p2,0.61,-9.p2,1.p1,-9.p0,3.oZ,-9.oY,0,0,9.CM,2.CL,9.CO,3.ts,8.CQ,4.CP,8.CS,5.CR,7.CU,6.CT,6.CW,7.CV,0,0,-6.CW,7.CV,-7.CU,6.CT,-8.CS,5.CR,-8.CQ,4.CP,-9.CO,3.ts,-9.CM,2.CL,0,0]};N.eH=N.1z({gl:P,88:P,i8:P,us:P,1o:Q(a){K.us=a?N.eH.l5.CH:N.eH.l5.CI;K.5z()},CF:Q(c){if(K.CK(c)){K.i7(c)}O f=c.id;K.CJ(c);O d=-1;O e=K.88.1a;O a;4W(e-d>1){a=2g((d+e)/2);O b=K.us(K,c,N.1c.6l(K.88[a]));if(b>0){d=a}V{e=a}}K.88.6c(e,0,f);K.i8[f]=K.gk(c);R K.uq(e)},i7:Q(b){O d=b.id;O a=N.1c.2S(K.88,d);if(a>=0){K.88.6c(a,1);2s K.i8[d];if(K.88.1a>0){O c=K.88[K.88.1a-1];K.gl=K.i8[c]}V{K.gl=0}}},5z:Q(){K.88=[];K.i8={};K.gl=0},CK:Q(a){R(K.i8[a.id]!=P)},gk:Q(a){R a.9k.oX},CJ:Q(a){O b=a.9k.oX;if(b==P){b=K.gl;a.9k.oX=b}V{if(b>K.gl){K.gl=b}}},uq:Q(b){O a=b+1;if(a<K.88.1a){O c=N.1c.6l(K.88[a]);if(c==2q){c=K.uq(a)}R c}V{R P}},1p:"N.eH"});N.eH.l5={uo:Q(e,d,b){O a=e.gk(d);O f=0;if(b){O c=e.gk(b);f=a-c}R f},CI:Q(c,b,a){O d=N.eH.l5.uo(c,b,a);if(a&&d==0){d=1}R d},CH:Q(d,c,b){O e=N.eH.l5.uo(d,c,b);if(b&&e===0){O a=b.um-c.um;e=(a===0)?1:a}R e}};N.1Z.bp=N.1z(N.1Z,{9T:P,31:P,ap:P,c0:P,i6:P,eG:P,l3:"P4",el:"P3",1o:Q(a,b){N.1Z.1g.1o.1j(K,1r);K.9T=K.u1();K.31=K.u0("P2");K.ap=K.31;K.c0=K.31;K.9T.1V(K.31);K.66.1V(K.9T);if(b&&(b.P1||b.CG)){K.eG=S N.eH(b.CG)}},1m:Q(){K.5z();K.9T=P;K.31=P;K.i6=P;N.1Z.1g.1m.1j(K,1r)},5z:Q(){O b;O a=K.ap;if(a){4W(b=a.9U){a.2T(b)}}a=K.c0;if(a){4W(b=a.9U){a.2T(b)}}if(K.eG){K.eG.5z()}},oP:Q(b,a){},9Q:Q(j,a,d){O h=j.1p;O c=1d;if((h==="N.1f.5A")||(h==="N.1f.8k")||(h==="N.1f.83")||(h==="N.1f.8W")||j.tH||(h==="N.1l.jy")){1h(O f=0,g=j.1y.1a;f<g;f++){c=K.9Q(j.1y[f],a,d)&&c}R c}c=1b;O e=1b;if(a.23!=="2L"){if(a.l4){K.CE(j.id,j,a,d)}V{e=1d}c=K.ul(j.id,j,a,d)}if(c==1b){O b=1Q.8G(j.id);if(b){if(b.9k.l4){e=1d}b.2V.2T(b)}}if(e){O b=1Q.8G(j.id+K.l3);if(b){b.2V.2T(b)}}R c},ul:Q(g,f,b,e){b=K.uc(b);O c=K.6N(g,K.oP(f,b));c.d5=e;c.um=f.6k().1L;c.d4=f.1p;c.9k=b;O a=K.Cz(c,f,b);if(a===1b){R 1b}c=a.Cy;if(K.eG){O d=K.eG.CF(c);if(d){K.ap.ui(c,d)}V{K.ap.1V(c)}}V{if(c.2V!==K.ap){K.ap.1V(c)}}K.u6(c);R a.bq},CE:Q(e,d,b,c){O a=N.1c.1K({},b);a.6Q=a.l4;a.9L=a.CD;a.9K=a.CB;a.oX=a.CA;a.6j=a.P0||a.6j;a.6i=a.OZ||a.6i;a.l4=P;a.CD=P;a.CB=P;a.CA=P;R K.ul(e+K.l3,d,a,P)},Cz:Q(c,e,b){b=b||c.9k;O a={co:b.2j===2q?1d:b.2j,kU:b.2o===2q?!!b.4x:b.2o};O d;if(N.1f.4s&&(e 1W N.1f.4s)){d=K.6T(c,e)}V{if(N.1f.2n&&(e 1W N.1f.2n)){a.co=1b;d=K.eD(c,e)}V{if(N.1f.3T&&(e 1W N.1f.3T)){d=K.eC(c,e)}V{if(N.1f.1D&&(e 1W N.1f.1D)){if(b.4L===1b){a.co=1b;a.kU=1b}d=K.cd(c,e)}V{if(N.1f.9S&&(e 1W N.1f.9S)){d=K.eA(c,e)}}}}}c.ua=a;if(d!=1b){R{Cy:K.d6(c,b,a,e),bq:d}}V{R 1b}},u6:Q(a){},cd:Q(a,b){},eD:Q(a,b){},6T:Q(a,b){},eC:Q(a,b){},eA:Q(a,b){},gf:Q(a,b){},tY:Q(a,b){},dj:Q(c,b,a){},kB:Q(b){O a=1Q.8G(b+K.el);if(a){K.c0.2T(a)}},BU:Q(b){O a=1Q.8G(b+K.l3);if(a){a.2V.2T(a)}},g2:Q(a){O d=a.bw;O b=d&&d.OY;O c=b?b:(d||a.oW);O e=c.d5;R e},g8:Q(l,g){if((l.1p==="N.1f.8k")||(l.1p==="N.1f.83")||(l.1p==="N.1f.8W")||(l.1p==="N.1f.5A")||l.tH){1h(O h=0,k=l.1y.1a;h<k;h++){K.g8(l.1y[h],g)}}V{O j=N.1c.6l(l.id);if(j&&j.2V){if(j.1x){j.1x.1m();j.1x=P}j.2V.2T(j);if(K.eG){K.eG.i7(j)}if(j.9k.l4){O n=l.id+K.l3;O a=N.1c.6l(n);if(a&&a.2V){a.2V.2T(a)}}O d="Ct",c="Cs";O b=j.9k.7j,m;if(b 1W N.2D.ax){if(b 1W N.2D.ku){m=l.id+d}V{if(b 1W N.2D.kt){m=l.id+c}}O f=N.1c.6l(m);if(f&&f.2V){f.2V.2T(f)}}O o=j.9k.8A,m;if(o 1W N.2D.ax){if(o 1W N.2D.ku){m=l.id+d}V{if(o 1W N.2D.kt){m=l.id+c}}O e=N.1c.6l(m);if(e&&e.2V){e.2V.2T(e)}}}}},6N:Q(c,a){O b=N.1c.6l(c);if(b){if(!K.oL(b,a)){b.2V.2T(b);b=K.6N(c,a)}}V{b=K.gg(a,c)}R b},oL:Q(b,a){},gg:Q(a,b){},hQ:Q(b){O a=K.31;if(b.31.2V==K.9T){a=b.31}a.2V.2T(a);b.9T.1V(a)},tD:Q(){R K.31.2V.2V.id},kW:Q(a){R(a!="oB")&&!!a},1p:"N.1Z.bp"});N.1Z.6w=N.1z(N.1Z.bp,{i6:"6s://l2.w3.eF/OX/l0",Cw:"6s://l2.w3.eF/OW/OV",eE:OU,gj:P,kX:P,1o:Q(a){if(!K.bn()){R}N.1Z.bp.1g.1o.1j(K,1r);K.gj={x:0,y:0};K.kX={};if(N.93.2l!=="Cx"){K.eE=z7}K.2h=1Q.2G("oV")},bn:Q(){O a="6s://l2.w3.eF/TR/OT/1J#";R(1Q.oU&&(1Q.oU.uk("eF.OS.l0","1.0")||1Q.oU.uk(a+"6w","1.1")||1Q.oU.uk(a+"OR","1.1")))},5z:Q(){N.1Z.bp.1g.5z.4g(K);if(K.cq){O a;4W(a=K.cq.9U){K.cq.2T(a)}}},kY:Q(a,e,b){O d=a+(b?0:K.gj.x);O c=e+(b?0:K.gj.y);R(d>=-K.eE&&d<=K.eE&&c>=-K.eE&&c<=K.eE)},9e:Q(b,d){N.1Z.bp.1g.9e.1j(K,1r);O a=K.2r();O f=-b.1s/a;O e=b.1t/a;if(d){K.1s=f;K.1t=e;O c="0 0 "+K.1G.w+" "+K.1G.h;K.9T.2i(P,"oR",c);K.4c(0,0);R 1d}V{O g=K.4c(f-K.1s,e-K.1t);if(!g){K.9e(b,1d)}R g}},4c:Q(a,c){if(!K.kY(a,c,1d)){R 1b}V{O b="";if(a||c){b="4c("+a+","+c+")"}K.31.2i(P,"3K",b);K.gj={x:a,y:c};R 1d}},6A:Q(a){N.1Z.1g.6A.1j(K,1r);K.9T.2i(P,"1A",K.1G.w);K.9T.2i(P,"1E",K.1G.h)},oP:Q(c,b){O a=P;if(N.1f.4s&&(c 1W N.1f.4s)){a="6U"}V{if(N.1f.2n&&(c 1W N.1f.2n)){a="OQ"}V{if(N.1f.dn&&(c 1W N.1f.dn)){a="9j"}V{if(N.1f.3T&&(c 1W N.1f.3T)){a="9j"}V{if(N.1f.1D&&(c 1W N.1f.1D)){if(b.6Q){a="5p"}V{if(K.kW(b.4K)){a="l0"}V{a="oB"}}}V{if(N.1f.9S&&(c 1W N.1f.9S)){a="kS"}}}}}}R a},d6:Q(t,x,b,d){x=x||t.9k;b=b||t.ua;if(t.d4=="N.1f.3T"&&b.co==1b){O w=x.4H;x.4H=0;b.co=1d}O n=3t(t.oS(P,"r"));O m=1;O f;if(t.d4==="N.1f.1D"&&n){t.W.3j="";if(x.4L===1b){t.W.3j="8C"}V{if(x.6Q){f=K.oT(t);if(x.dl){t.2i(P,"8x",x.dl);O i=K.6N(P,"8x");i.nV=x.dl;t.1V(i)}if(x.6j&&x.6i){t.2i(P,"OP","2L")}O q=x.6j||x.6i;O p=x.6i||x.6j;q=q?q:x.4z*2;p=p?p:x.4z*2;O y=(x.9L!=2q)?x.9L:-(0.5*q);O j=(x.9K!=2q)?x.9K:-(0.5*p);O a=x.fV||x.4H;t.2i(P,"x",(f.x+y).l1());t.2i(P,"y",(f.y+j).l1());t.2i(P,"1A",q);t.2i(P,"1E",p);t.2i(K.Cw,"9l",x.6Q);t.2i(P,"W","2J: "+a);t.uj=N.1Z.6w.bv}V{if(K.kW(x.4K)){O e=x.4z*3;O o=e*2;O g=K.oF(x.4K);f=K.oT(t);m=K.kX[g.id][0]*3/o;O k=t.2V;O l=t.OO;if(k){k.2T(t)}t.9U&&t.2T(t.9U);t.1V(g.9U.Cv(1d));t.2i(P,"oR",g.oS(P,"oR"));t.2i(P,"1A",o);t.2i(P,"1E",o);t.2i(P,"x",f.x-e);t.2i(P,"y",f.y-e);if(l){k.ui(t,l)}V{if(k){k.1V(t)}}}V{t.2i(P,"r",x.4z)}}}O v=x.8q;if((v!==2q||t.oM!==2q)&&f){t.oM=v;v|=0;if(t.u2!=="l0"){t.2i(P,"3K","5m("+v+" "+f.x+" "+f.y+")")}V{O u=K.kX[g.id];t.9U.2i(P,"3K","5m("+v+" "+u[1]+" "+u[2]+")")}}}if(b.co){O c=x.7j;if(c 1W N.2D.ax){O h=K.ug(c,d.id);if(h){c="1B(#"+h+")";t.2i(P,"W","2j:"+c);t.W.2j=c}}V{t.2i(P,"2j",c);t.2i(P,"2j-2J",x.4H)}}V{t.2i(P,"2j","2L")}if(b.kU){O s=x.8A;if(s 1W N.2D.ax){O h=K.ug(s,d.id);if(h){s="1B(#"+h+")";t.2i(P,"W","2o:"+s);t.W.2o=s}}V{t.2i(P,"2o",x.8A)}t.2i(P,"2o-2J",x.at);t.2i(P,"2o-1A",x.4x*m);t.2i(P,"2o-ON",x.bf||"2w");t.2i(P,"2o-Bx","2w");x.as&&t.2i(P,"2o-OM",K.86(x,m))}V{t.2i(P,"2o","2L")}if(x.dc){t.2i(P,"4m-1n",x.dc);t.W.dc=x.dc}V{t.2i(P,"4m-1n","Cu");t.W.dc="Cu"}if(x.3G!=P){t.2i(P,"3G",x.3G)}if(w){x.4H=w;b.co=1b;w=""}R t},86:Q(c,b){O a=c.4x*b;O d=c.as;5U(d){1N"c3":R"2L";1N"kO":R[1,4*a].6b();1N"kN":R[4*a,4*a].6b();1N"kM":R[4*a,4*a,1,4*a].6b();1N"kL":R[8*a,4*a].6b();1N"kK":R[8*a,4*a,1,4*a].6b();49:R N.6K.kJ(d).4D(/\\s+/g,",")}},gg:Q(a,c){O b=1Q.OL(K.i6,a);if(c){b.2i(P,"id",c)}R b},oL:Q(b,a){R(a===b.u2)},u1:Q(){O a=K.6N(K.66.id+"OK","l0");a.W.23="i5";R a},u0:Q(a){R K.6N(K.66.id+a,"g")},uf:Q(){O a=K.6N(K.66.id+"OJ","cq");K.9T.1V(a);R a},cd:Q(a,b){R K.gf(a,b,1)},gf:Q(d,e,b){O c=K.2r();O a=(e.x/c+K.1s);O f=(K.1t-e.y/c);if(K.kY(a,f)){d.2i(P,"cx",a);d.2i(P,"cy",f);d.2i(P,"r",b);R d}V{R 1b}},eD:Q(b,c){O a=K.kZ(c.1y);if(a.9j){b.2i(P,"5K",a.9j);R(a.bq?b:P)}V{R 1b}},6T:Q(b,c){O a=K.kZ(c.1y);if(a.9j){b.2i(P,"5K",a.9j);R(a.bq?b:P)}V{R 1b}},eC:Q(b,h){O g="";O i=1d;O a=1d;O c,k;1h(O e=0,f=h.1y.1a;e<f;e++){g+=" M";c=K.kZ(h.1y[e].1y," ");k=c.9j;if(k){g+=" "+k;a=c.bq&&a}V{i=1b}}g+=" z";if(i){b.2i(P,"d",g);b.2i(P,"2j-OI","OH");R a?b:P}V{R 1b}},eA:Q(c,d){O b=K.2r();O a=(d.x/b+K.1s);O e=(K.1t-(d.y+d.1E)/b);if(K.kY(a,e)){c.2i(P,"x",a);c.2i(P,"y",e);c.2i(P,"1A",d.1A/b);c.2i(P,"1E",d.1E/b);R c}V{R 1b}},tY:Q(f,h){O g=P;O b=1d;1h(O e=0,a=h.1y.1a;e<a;e++){if((e%3)==0&&(e/3)==0){O c=K.gh(h.1y[e]);if(!c){b=1b}g="M "+c}V{if((e%3)===1){O c=K.gh(h.1y[e]);if(!c){b=1b}g+=" C "+c}V{O c=K.gh(h.1y[e]);if(!c){b=1b}g+=" "+c}}}g+=" Z";if(b){f.2i(P,"d",g);R f}V{R 1b}},dj:Q(f,b,q){O c=K.2r();O p=(q.x/c+K.1s);O m,k=N.93.2l;if(k==="hz"){if(!b.4h){b.4h=12}O g=3t(b.4h)*0.35;m=(q.y/c-K.1t)-g}V{m=(q.y/c-K.1t)}O o=K.6N(f+K.el,"99");o.2i(P,"x",p);o.2i(P,"y",-m);if(b.23){o.2i(P,"23",b.23)}if(b.8z){o.2i(P,"3K","5m("+b.8z+" "+p+","+(-m)+")")}if(b.8b){o.2i(P,"2j",b.8b)}if(b.d3){o.2i(P,"2J",b.d3)}if(b.8a){o.2i(P,"9H-t9",b.8a)}if(b.4h){o.2i(P,"9H-1G",b.4h)}if(b.79){o.2i(P,"9H-t8",b.79)}if(b.7f){o.2i(P,"9H-W",b.7f)}if(b.hJ===1d){o.2i(P,"4m-1n","6I");o.d5=f}V{o.2i(P,"4m-1n","2L")}O j=b.3W||"cm";o.2i(P,"99-3h",N.1Z.6w.9G[j[0]]||"ki");if(N.fO===1d){o.2i(P,"Be-nW",N.1Z.6w.9G[j[1]]||"Bd")}O d=b.5k.4U("\\n");O h=d.1a;4W(o.b8.1a>h){o.2T(o.nX)}1h(O e=0;e<h;e++){O l=K.6N(f+K.el+"Bc"+e,"Bb");if(b.hJ===1d){l.d5=f;l.t7=q;l.d4=q.1p}if(N.fO===1b){l.2i(P,"nW-hI",N.1Z.6w.t6[j[1]]||"-35%")}l.c2("x",p);if(e==0){O n=N.1Z.6w.t5[j[1]];if(n==P){n=-0.5}l.c2("dy",(n*(h-1))+"em")}V{l.c2("dy","kk")}O a=(d[e]==="")?" ":d[e];if(b.OG){if(k=="hz"){K.2h.5N=a;l.nV=K.2h.5N}V{l.5N=a}}V{l.nV=a}if(!l.2V){o.1V(l)}}if(!o.2V){K.c0.1V(o)}},kZ:Q(d,c){O f=[];O a=1d;O e=d.1a;O j=[];O g,h;1h(O b=0;b<e;b++){h=d[b];f.1w(h);g=K.gh(h);if(g){j.1w(g)}V{if(b>0){if(K.gh(d[b-1])){j.1w(K.uh(d[b],d[b-1]))}}if(b<e-1){if(K.gh(d[b+1])){j.1w(K.uh(d[b],d[b+1]))}}a=1b}}R{9j:j.6b(c||","),bq:a}},uh:Q(e,h){if(h.3w(e)){R""}O f=K.2r();O b=K.eE-K.gj.x;O a=K.eE-K.gj.y;O d=h.x/f+K.1s;O j=K.1t-h.y/f;O c=e.x/f+K.1s;O i=K.1t-e.y/f;O g;if(c<-b||c>b){g=(i-j)/(c-d);c=c<0?-b:b;i=j+(c-d)*g}if(i<-a||i>a){g=(c-d)/(i-j);i=i<0?-a:a;c=d+(i-j)*g}R c+","+i},gh:Q(b){O c=K.2r();O a=(b.x/c+K.1s);O d=(K.1t-b.y/c);if(K.kY(a,d)){R a+","+d}V{R 1b}},oT:Q(a){R({x:3t(a.oS(P,"cx")),y:3t(a.oS(P,"cy"))})},oF:Q(f){if(!K.cq){K.cq=K.uf()}O b=K.66.id+"-"+f;O c=1Q.8G(b);if(c!=P){R c}O e=N.1Z.ck[f];if(!e){7z S g3(f+" is fU a oz ck 2l")}O h=K.6N(b,"ck");O d=K.6N(P,"6U");h.1V(d);O n=S N.1U(6r.kP,6r.kP,0,0);O l=[];O k,j;1h(O g=0;g<e.1a;g=g+2){k=e[g];j=e[g+1];n.1s=1k.4v(n.1s,k);n.1L=1k.4v(n.1L,j);n.1I=1k.3f(n.1I,k);n.1t=1k.3f(n.1t,j);l.1w(k,",",j)}d.2i(P,"5K",l.6b(" "));O a=n.3L();O m=n.4y();O o=[n.1s-a,n.1L-m,a*3,m*3];h.2i(P,"oR",o.6b(" "));K.kX[b]=[1k.3f(a,m),n.5P().1P,n.5P().1R];K.cq.1V(h);R h},ug:Q(k,a){if(!K.cq){K.cq=K.uf()}O f,e;if(k 1W N.2D.ku){e=a+"Ct";f=N.1c.6l(e);if(f){1h(O g=0,h=k.er.1a;g<h;g++){O j=k.er[g];O c=f.b8[g];O b="2K-4S:"+j.4S+";2K-2J:"+j.2J;c.W.ue=j.4S;c.W.ud=j.2J;c.2i(P,"W",b)}R e}f=K.6N(e,"OF");f.2i(P,"x1",k.x1);f.2i(P,"y1",k.y1);f.2i(P,"x2",k.x2);f.2i(P,"y2",k.y2)}V{if(k 1W N.2D.kt){e=a+"Cs";f=N.1c.6l(e);if(f){1h(O g=0,h=k.er.1a;g<h;g++){O j=k.er[g];O c=f.b8[g];O b="2K-4S:"+j.4S+";2K-2J:"+j.2J;c.W.ue=j.4S;c.W.ud=j.2J;c.2i(P,"W",b)}R e}f=K.6N(e,"OE");f.2i(P,"cx",k.cx);f.2i(P,"cy",k.cy);f.2i(P,"r",k.4J);f.2i(P,"fx",k.fx);f.2i(P,"fy",k.fy)}V{R}}O d=k.er;1h(O g=0,h=d.1a;g<h;g++){O j=d[g];O c=K.6N(P,"2K");c.2i(P,"3e",j.3e);O b="2K-4S:"+j.4S+";2K-2J:"+j.2J;c.W.ue=j.4S;c.W.ud=j.2J;c.2i(P,"W",b);f.1V(c)}K.cq.1V(f);R e},g2:Q(a){O c=N.1Z.bp.1g.g2.1j(K,1r);if(!c){O b=a.bw;c=b.2V&&b!==K.9T&&b.2V.d5}R c},1p:"N.1Z.6w"});N.1Z.6w.9G={l:"3X",r:"fP",b:"1L",t:"OD"};N.1Z.6w.t6={t:"-70%",b:"0"};N.1Z.6w.t5={t:0,b:-1};N.1Z.6w.bv=Q(a){a.bv&&a.bv()};N.1Z.5a=N.1z(N.1Z,{2W:1d,dh:0,1u:P,2z:P,aD:1b,di:{},hX:{},1o:Q(a,b){N.1Z.1g.1o.1j(K,1r);K.31=1Q.2G("1u");K.66.1V(K.31);K.1u=K.31.5Q("2d");K.2z={};if(K.2W){K.ce=1Q.2G("1u");K.2m=K.ce.5Q("2d")}},9e:Q(a,b){N.1Z.1g.9e.1j(K,1r);R 1b},g8:Q(b,a){K.g4(K.2z[a][0])},bn:Q(){O a=1Q.2G("1u");R!!a.5Q},6A:Q(b){K.1G=b.1T();O a=K.31;a.W.1A=b.w+"px";a.W.1E=b.h+"px";a.1A=b.w;a.1E=b.h;K.7v=P;if(K.2W){O c=K.ce;c.W.1A=b.w+"px";c.W.1E=b.h+"px";c.1A=b.w;c.1E=b.h}},3V:Q(a,b){O d;if(a.1x){b=K.uc(b||a.W);O c=a.1x.6k();d=(b.23!=="2L")&&!!c&&c.9R(K.52);if(d){K.2z[a.id]=[a,b]}V{2s(K.2z[a.id])}K.aD=1d}if(K.aD&&!K.7O){K.3y();K.aD=1b}R d},9Q:Q(f,d,e){O c=f.1p;if((c==="N.1f.5A")||(c==="N.1f.8k")||(c==="N.1f.83")||(c==="N.1f.8W")||(c==="N.1l.jy")){1h(O b=0;b<f.1y.1a;b++){K.9Q(f.1y[b],d,e)}R}if(N.1f.4s&&(f 1W N.1f.4s)){K.6T(f,d,e)}V{if(N.1f.2n&&(f 1W N.1f.2n)){K.eD(f,d,e)}V{if(N.1f.3T&&(f 1W N.1f.3T)){if(d.2j==1b){O a=d.4H;d.2j=1d;d.4H=0}K.eC(f,d,e)}V{if(N.1f.1D&&(f 1W N.1f.1D)){K.cd(f,d,e)}V{if(N.1f.9S&&(f 1W N.1f.9S)){K.eA(f,d,e)}}}}}if(a){d.2j=1b;d.4H=a;a=""}},oC:Q(f,d,e){O b=K;if(K.hX[e]){K.hX[e].gd=Q(){R 1b}}O c=Q(){O k=K.ub;O p=K.1x;O g=K.W;O l=K.5b;b.hX[k]=P;if(!b.2z[k]){R}O h=g.6j||g.6i;O r=g.6i||g.6j;h=h?h:g.4z*2;r=r?r:g.4z*2;O n=(g.9L!=2q)?g.9L:-(0.5*h);O j=(g.9K!=2q)?g.9K:-(0.5*r);O m=g.fV||g.4H;O u=b.7i(p);O t=u[0];O q=u[1];if(!2x(t)&&!2x(q)){O i=b.1u;i.cj();O s;if(g.8q){s=g.8q/2R*1k.PI}i.4c(t,q);if(s){i.5m(s)}i.4c(n,j);i.5l=m;O o=N.1Z.5a.hY||(N.1Z.5a.hY=/oD 2.1/.d1(b4.i1.eb())?Cf/2k.Ce.1A:1);i.8I(l,0,0,h*o,r*o);i.ci();if(b.2W){b.7S("2j",k);b.2m.cj();b.2m.4c(t,q);if(s){b.2m.5m(s)}b.2m.4c(n,j);b.2m.Cd(0,0,h,r);b.2m.ci()}}};if(K.2z[e][0].5b){O a=K.2z[e][0].5b;a.5o=d.6Q;a.gd=Q(){c.4g({ub:e,1x:f,W:d,5b:a})};a.gd()}V{O a=S 4w();a.5o=d.6Q;K.hX[e]=a;K.2z[e][0].5b=a;if(d.dl){a.8x=d.dl}a.gd=Q(){c.4g({ub:e,1x:f,W:d,5b:a})}}b.1u.cf="oy-6f"},5O:Q(b,a){if(b==="2j"){if(a.7j 1W Ch){K.1u.5l=1;K.1u.7Q=a.7j}V{K.1u.5l=a.4H;K.1u.7Q=a.7j}}V{if(b==="2o"){K.1u.5l=a.at;K.1u.aw=a.bf;K.1u.7y=a.8A;K.1u.8r=a.4x}V{K.1u.5l=0;K.1u.8r=1}}},oE:Q(c){O d=6r(c.4U("4n").9h())+1;if(d>=hW){K.dh=d-tS;d=d%hW+1}O b="aq"+d.7r(16);O a=b.1a;b="#"+b.aU(a-6,a);R b},7S:Q(b,d,a){O c=K.oE(d);if(b==="2j"){K.2m.5l=1;K.2m.7Q=c}V{if(b==="2o"){K.2m.5l=1;K.2m.7y=c;K.2m.8r=a.4x+2}V{K.2m.5l=0;K.2m.8r=1}}},cd:Q(g,c,f){if(c.4L!==1b){if(c.6Q){K.oC(g,c,f)}V{if(c.4K&&(c.4K!="oB")){K.oA(g,c,f)}V{O d=K.7i(g);O h=d[0];O e=d[1];if(!2x(h)&&!2x(e)){O b=1k.PI*2;O a=c.4z;if(c.2j!==1b){K.5O("2j",c);K.1u.6h();K.1u.da(h,e,a,0,b,1d);K.1u.2j();if(K.2W){K.7S("2j",f,c);K.2m.6h();K.2m.da(h,e,a,0,b,1d);K.2m.2j()}}if(c.2o!==1b){K.5O("2o",c);K.1u.6h();K.1u.da(h,e,a,0,b,1d);K.1u.2o();if(K.2W){K.7S("2o",f,c);K.2m.6h();K.2m.da(h,e,a,0,b,1d);K.2m.2o()}K.5O("4C")}}}}}},oA:Q(m,b,h){O n,l,g,f,j,a,c,e;O k;O o=1k.PI/2R;O d=N.1Z.ck[b.4K];if(!d){7z S g3(b.4K+" is fU a oz ck 2l")}if(!d.1a||d.1a<2){R}O r=K.7i(m);O q=r[0];O p=r[1];if(2x(q)||2x(p)){R}K.1u.aw="2w";K.1u.d8="2w";if(K.2W){K.2m.aw="2w";K.2m.d8="2w"}if(b.4K in K.di){a=K.di[b.4K]}V{a=S N.1U();if(b.4K==="dk"){}V{1h(j=0;j<d.1a;j+=2){a.1K(S N.3i(d[j],d[j+1]))}}K.di[b.4K]=a}K.1u.cj();if(K.2W){K.2m.cj()}K.1u.4c(q,p);if(K.2W){K.2m.4c(q,p)}e=o*b.8q;if(!2x(e)){K.1u.5m(e);if(K.2W){K.2m.5m(e)}}c=2*b.4z/1k.3f(a.3L(),a.4y());if(b.4K==="dk"){c=b.4z/10}K.1u.3D(c,c);if(K.2W){K.2m.3D(c,c)}g=a.5P().1P;f=a.5P().1R;if(b.4K!=="dk"){K.1u.4c(-g,-f)}if(K.2W&&b.4K!=="dk"){K.2m.4c(-g,-f)}k=b.4x;b.4x=k/c;if(b.2j!==1b){K.5O("2j",b);K.1u.6h();1h(j=0;j<d.1a;j=j+2){n=d[j];l=d[j+1];if(j==0){K.1u.2O(n,l)}K.1u.9c(n,l)}K.1u.9b();K.1u.2j();if(K.2W){K.7S("2j",h,b);K.2m.6h();1h(j=0;j<d.1a;j=j+2){n=d[j];l=d[j+1];if(j==0){K.1u.2O(n,l)}K.2m.9c(n,l)}K.2m.9b();K.2m.2j()}}if(b.2o!==1b){K.5O("2o",b);K.1u.6h();1h(j=0;j<d.1a;j=j+2){n=d[j];l=d[j+1];if(j==0){K.1u.2O(n,l)}K.1u.9c(n,l)}K.1u.9b();K.1u.2o();if(K.2W){K.7S("2o",h,b);K.2m.6h();1h(j=0;j<d.1a;j=j+2){n=d[j];l=d[j+1];if(j==0){K.1u.2O(n,l)}K.2m.9c(n,l)}K.2m.9b();K.2m.2o()}}b.4x=k;K.1u.ci();if(K.2W){K.2m.ci()}},eD:Q(c,a,b){a=N.1c.4I({2j:1b},a);K.6T(c,a,b)},6T:Q(c,a,b){if(a.2j!==1b){K.5O("2j",a);K.bo(K.1u,c,a,b,"2j");if(K.2W){K.7S("2j",b,a);K.bo(K.2m,c,a,b,"2j")}}if(a.2o!==1b){K.5O("2o",a);K.bo(K.1u,c,a,b,"2o");if(K.2W){K.7S("2o",b,a);K.bo(K.2m,c,a,b,"2o")}}K.5O("4C")},bo:Q(c,l,a,e,j){O h=1;if(2t c.bi==="Q"){O m=K.86(a,h);c.bi(m)}O f=l.1y;O g=f.1a;c.6h();O b=K.7i(f[0]);O n=b[0];O k=b[1];if(!2x(n)&&!2x(k)){c.2O(b[0],b[1]);1h(O d=1;d<g;++d){O o=K.7i(f[d]);c.9c(o[0],o[1])}if(j==="2j"){c.2j()}V{c.2o()}}if(2t c.bi==="Q"){c.bi([])}},eC:Q(f,c,e){O d=f.1y;O a=d.1a;K.6T(d[0],c,e);1h(O b=1;b<a;++b){K.1u.cf="oy-4t";if(K.2W){K.2m.cf="oy-4t"}K.6T(d[b],N.1c.4I({2o:1b,4H:1},c),e);K.1u.cf="kG-6f";if(K.2W){K.2m.cf="kG-6f"}K.6T(d[b],N.1c.4I({2j:1b},c),e)}},eA:Q(d,a,c){O b=(S N.1f.4s([S N.1f.1D(d.x,d.y),S N.1f.1D(d.x+d.1A,d.y),S N.1f.1D(d.x+d.1A,d.y+d.1E),S N.1f.1D(d.x,d.y+d.1E)]));K.6T(b,a,c)},dj:Q(n,a){a=N.1c.1K({8b:"#aq",3W:"cm"},a);O o=K.7i(n);if(a.7h||a.7g){O h=2x(a.7h)?0:a.7h;O c=2x(a.7g)?0:a.7g;o[0]+=h;o[1]-=c}K.5O("4C");K.1u.7Q=a.8b;K.1u.5l=a.d3||1;O e=[a.7f?a.7f:"bc","bc",a.79?a.79:"bc",a.4h?a.4h:"kk",a.8a?a.8a:"t4-t3"].6b(" ");O d=a.5k.4U("\\n");O g=d.1a;if(K.1u.fN){K.1u.9H=e;K.1u.kj=N.1Z.5a.9G[a.3W[0]]||"3U";K.1u.sZ=N.1Z.5a.9G[a.3W[1]]||"ki";O l=N.1Z.5a.bb[a.3W[1]];if(l==P){l=-0.5}O m=K.1u.ek("Mg").1E||K.1u.ek("xx").1A;o[1]+=m*l*(g-1);1h(O f=0;f<g;f++){if(a.8z!=0){K.1u.cj();K.1u.4c(o[0],o[1]);K.1u.5m(a.8z*1k.PI/2R);K.1u.fN(d[f],0,(m*f));K.1u.ci()}V{K.1u.fN(d[f],o[0],o[1]+(m*f))}}}V{if(K.1u.kh){K.1u.sY=e;O b=N.1Z.5a.bb[a.3W[0]];if(b==P){b=-0.5}O l=N.1Z.5a.bb[a.3W[1]];if(l==P){l=-0.5}O m=K.1u.kg("xx");o[1]+=m*(1+(l*g));1h(O f=0;f<g;f++){O k=o[0]+(b*K.1u.kg(d[f]));O j=o[1]+(f*m);K.1u.4c(k,j);K.1u.kh(d[f]);K.1u.4c(-k,-j)}}}K.5O("4C")},86:Q(c,b){if(!c){R[]}O a=c.4x*b;O d=c.as;5U(d){1N"c3":R[];1N"kO":R[1,4*a];1N"kN":R[4*a,4*a];1N"kM":R[4*a,4*a,1,4*a];1N"kL":R[8*a,4*a];1N"kK":R[8*a,4*a,1,4*a];49:if(!d){R[]}if(N.1c.4f(d)){R d}d=N.6K.kJ(d).4D(/\\s+/g,",");R d.4D(/\\[|\\]/gi,"").4U(",")}},7i:Q(b){O c=K.2r();O d=K.52;O a=(b.x/c+(-d.1s/c));O e=((d.1t/c)-b.y/c);R[a,e]},5z:Q(){O a=K.31.1E;O b=K.31.1A;K.1u.4Y(0,0,b,a);K.2z={};if(K.2W){K.2m.4Y(0,0,b,a)}},g2:Q(b){O c=P;if(K.2W){if(!K.U.3S){O f=b.xy;O a=f.x|0;O h=f.y|0;O d=K.2m.tR(a,h,1,1).57;if(d[3]===7J){O g=d[2]+(ex*(d[1]+(ex*d[0])));if(g){O e=K.2z["N.3k.Cb"+(g-1+K.dh)];c=e&&e[0]}}}}R c},g4:Q(b){if(!(N.1c.4f(b))){b=[b]}1h(O a=0;a<b.1a;++a){2s K.2z[b[a].id]}K.3y()},3y:Q(){if(!K.7O){O h=K.31.1E;O c=K.31.1A;K.1u.4Y(0,0,c,h);if(K.2W){K.2m.4Y(0,0,c,h)}O f=[];O k,a;1h(O b in K.2z){if(!K.2z.dX(b)){5y}k=K.2z[b][0];a=K.2z[b][1];K.9Q(k.1x,a,k.id);if(a.5k){f.1w([k,a])}}O j;1h(O d=0,e=f.1a;d<e;++d){j=f[d];O g=j[0].1x.9a();if(g==P){5y}K.dj(g,j[1])}}},1p:"N.1Z.5a"});N.1Z.5a.9G={l:"1s",r:"1I",t:"1t",b:"1L"};N.1Z.5a.bb={l:0,r:-1,t:0,b:-1};N.1Z.5a.hY=P;N.1Z.b9=N.1z(N.1Z.bp,{i6:"Cr:OC-OB-cp:OA",tW:{},3e:P,1o:Q(b){if(!K.bn()){R}if(!1Q.oQ.7T){1Q.oQ.3p("7T",K.i6);O e=1Q.Oz();O c=["i4","kS","Cq","2j","2o","Co","Ck","Cj"];1h(O d=0,a=c.1a;d<a;d++){e.Oy("7T\\\\:"+c[d],"Ox: 1B(#49#b9); 2v: 3d; 23: Ow-i5;")}}N.1Z.bp.1g.1o.1j(K,1r)},bn:Q(){bu{R!!(1Q.oQ)}bt(a){R 1d}},9e:Q(j,a){N.1Z.bp.1g.9e.1j(K,1r);O c=K.2r();O b=(j.1s/c)|0;O f=(j.1t/c-K.1G.h)|0;if(a||!K.3e){K.3e={x:b,y:f};b=0;f=0}V{b=b-K.3e.x;f=f-K.3e.y}O l=b+" "+f;K.31.u4=l;O h=[K.31,K.ap,K.c0];O g;1h(O d=0,e=h.1a;d<e;++d){g=h[d];O k=K.1G.w+" "+K.1G.h;g.u3=k}K.31.W.oK="y";R 1d},6A:Q(f){N.1Z.1g.6A.1j(K,1r);O d=[K.9T,K.31,K.ap,K.c0];O c=K.1G.w+"px";O g=K.1G.h+"px";O b;1h(O e=0,a=d.1a;e<a;++e){b=d[e];b.W.1A=c;b.W.1E=g}},oP:Q(c,b){O a=P;if(N.1f.4s&&(c 1W N.1f.4s)){a="7T:i4"}V{if(N.1f.2n&&(c 1W N.1f.2n)){a="7T:i4"}V{if(N.1f.dn&&(c 1W N.1f.dn)){a="7T:i4"}V{if(N.1f.3T&&(c 1W N.1f.3T)){a="7T:i4"}V{if(N.1f.1D&&(c 1W N.1f.1D)){if(b.6Q){a="7T:kS"}V{if(K.kW(b.4K)){a="7T:i4"}V{a="7T:Cq"}}}V{if(N.1f.9S&&(c 1W N.1f.9S)){a="7T:kS"}}}}}}R a},d6:Q(e,b,q,k){b=b||e.9k;q=q||e.ua;O c=b.7j;if(e.d4==="N.1f.1D"){if(b.6Q){q.co=1d;if(b.dl){e.8x=b.dl}O d=b.6j||b.6i;O l=b.6i||b.6j;d=d?d:b.4z*2;l=l?l:b.4z*2;O g=K.2r();O i=(b.9L!=2q)?b.9L:-(0.5*d);O f=(b.9K!=2q)?b.9K:-(0.5*l);e.W.1s=(((k.x/g-K.3e.x)+i)|0)+"px";e.W.1t=(((k.y/g-K.3e.y)-(f+l))|0)+"px";e.W.1A=d+"px";e.W.1E=l+"px";e.W.oK="y";c="2L";q.kU=1b}V{if(K.kW(b.4K)){O a=K.oF(b.4K);e.9j=a.9j;e.u4=a.1s+","+a.1L;O p=a.1G;e.u3=p+","+p;K.gf(e,k,b.4z);e.W.oK="y"}V{K.gf(e,k,b.4z)}}}if(q.co){e.u5=c}V{e.Ov="1b"}O j=e.kV("2j");O o=(j.1a==0)?P:j[0];if(!q.co){if(o){e.2T(o)}}V{if(!o){o=K.gg("7T:2j",e.id+"Ou")}if(b.e2==="oO"||b.e2==="oN"){if(b.e2==="oO"){o.2E="Ot";o.Cp="-4b%"}V{if(b.e2==="oN"){o.2E="Os";o.Or="50%, 50%"}}o.4S=b.7j;o.Oq=b.Op;o.2J=b.4H;o.Oo=b.On}V{o.2J=b.4H}if(e.d4==="N.1f.1D"&&b.6Q){if(b.fV){o.2J=b.fV}o.5o=b.6Q;o.2E="67";if(!(b.6j&&b.6i)){o.Om="Ol"}}if(o.2V!=e){e.1V(o)}}O n=b.8q;if((n!==2q||e.oM!==2q)){e.oM=n;if(b.6Q){K.u9(e,i,f,b);o.2J=0}V{if(e.d4==="N.1f.1D"){e.W.8q=n||0}}}O h=e.kV("2o");O m=(h.1a==0)?P:h[0];if(!q.kU){e.Ok=1b;if(m){m.on=1b}}V{if(!m){m=K.gg("7T:2o",e.id+"Oj");e.1V(m)}m.on=1d;m.4S=b.8A;m.t8=b.4x+"px";m.2J=b.at;m.Oi=b.bf==="Cg"?"Oh":(b.bf||"2w");if(b.as){m.Og=K.86(b)}}if(b.3G!=="oJ"&&b.3G!=P){e.W.3G=b.3G}R e},u9:Q(n,r,e,q){O q=q||n.9k;O o=q.8q||0;O a,j;if(!(q.6j&&q.6i)){O s=S 4w();s.bs=N.2u.3E(Q(){if(s.7a==="bq"||s.7a==="Of"){a=s.1A/s.1E;j=1k.3f(q.4z*2,q.6j||0,q.6i||0);r=r*a;q.6j=j*a;q.6i=j;K.u9(n,r,e,q)}},K);s.5o=q.6Q;R}V{j=1k.3f(q.6j,q.6i);a=q.6j/q.6i}O m=1k.2w(q.6j||j*a);O k=1k.2w(q.6i||j);n.W.1A=m+"px";n.W.1E=k+"px";O l=1Q.8G(n.id+"Cn");if(!l){l=K.gg("7T:Co",n.id+"Cn");n.1V(l)}l.W.1A=m+"px";l.W.1E=k+"px";l.5o=q.6Q;l.W.4V="u8:u7.kT.Oe(5o=\'\', Od=\'3D\')";O f=o*1k.PI/2R;O h=1k.7P(f);O d=1k.8y(f);O g="u8:u7.kT.Oc(Ob="+d+",Oa="+(-h)+",O9="+h+",O8="+d+",O7=\'4i O6\')\\n";O b=q.fV||q.4H;if(b&&b!==1){g+="u8:u7.kT.O5(2J="+b+")\\n"}n.W.4V=g;O p=S N.1f.1D(-r,-e);O c=S N.1U(0,0,m,k).fA();c.5m(q.8q,p);O i=c.6k();n.W.1s=1k.2w(2g(n.W.1s)+i.1s)+"px";n.W.1t=1k.2w(2g(n.W.1t)-i.1L)+"px"},u6:Q(a){a.W.3j="6I";O c=a.9k.7j;O b=a.9k.8A;if(c==="2L"&&a.u5!==c){a.u5=c}if(b==="2L"&&a.Cm!==b){a.Cm=b}},oG:Q(b,e){O d=e.6k();if(d){O a=K.2r();O c=S N.1U((d.1s/a-K.3e.x)|0,(d.1L/a-K.3e.y)|0,(d.1I/a-K.3e.x)|0,(d.1t/a-K.3e.y)|0);b.W.1s=c.1s+"px";b.W.1t=c.1t+"px";b.W.1A=c.3L()+"px";b.W.1E=c.4y()+"px";b.u4=c.1s+" "+c.1t;b.u3=c.3L()+" "+c.4y()}},86:Q(a){O c=a.as;5U(c){1N"c3":1N"kO":1N"kN":1N"kM":1N"kL":1N"kK":R c;49:O b=c.4U(/[ ,]/);if(b.1a===2){if(1*b[0]>=2*b[1]){R"kL"}R(b[0]===1||b[1]===1)?"kO":"kN"}V{if(b.1a===4){R(1*b[0]>=2*b[1])?"kK":"kM"}}R"c3"}},gg:Q(a,c){O b=1Q.2G(a);if(c){b.id=c}b.Cl="on";b.cl=N.2u.i3;R b},oL:Q(c,b){O d=b;O a=d.2S(":");if(a!==-1){d=d.8X(a+1)}O e=c.u2;a=e.2S(":");if(a!==-1){e=e.8X(a+1)}R(d===e)},u1:Q(){R K.6N(K.66.id+"O4","1q")},u0:Q(a){R K.6N(K.66.id+a,"7T:Ck")},cd:Q(a,b){R K.gf(a,b,1)},gf:Q(d,e,a){if(!2x(e.x)&&!2x(e.y)){O b=K.2r();d.W.1s=(((e.x/b-K.3e.x)|0)-a)+"px";d.W.1t=(((e.y/b-K.3e.y)|0)-a)+"px";O c=a*2;d.W.1A=c+"px";d.W.1E=c+"px";R d}R 1b},eD:Q(a,b){R K.tZ(a,b,1b)},6T:Q(a,b){R K.tZ(a,b,1d)},tZ:Q(b,k,g){K.oG(b,k);O c=K.2r();O a=k.1y.1a;O e=S 3Q(a);O h,l,j;1h(O f=0;f<a;f++){h=k.1y[f];l=(h.x/c-K.3e.x)|0;j=(h.y/c-K.3e.y)|0;e[f]=" "+l+","+j+" l "}O d=(g)?" x e":" e";b.9j="m"+e.6b("")+d;R b},eC:Q(c,m){K.oG(c,m);O d=K.2r();O r=[];O e,k,o,a,g,b,f,q,h,p,n,l;1h(e=0,k=m.1y.1a;e<k;e++){r.1w("m");o=m.1y[e].1y;a=(e===0);g=P;b=P;1h(f=0,q=o.1a;f<q;f++){h=o[f];n=(h.x/d-K.3e.x)|0;l=(h.y/d-K.3e.y)|0;p=" "+n+","+l;r.1w(p);if(f==0){r.1w(" l")}if(!a){if(!g){g=p}V{if(g!==p){if(!b){b=p}V{if(b!==p){a=1d}}}}}}r.1w(a?" x ":" ")}r.1w("e");c.9j=r.6b("");R c},eA:Q(b,c){O a=K.2r();b.W.1s=((c.x/a-K.3e.x)|0)+"px";b.W.1t=((c.y/a-K.3e.y)|0)+"px";b.W.1A=((c.1A/a)|0)+"px";b.W.1E=((c.1E/a)|0)+"px";R b},dj:Q(d,a,h){O g=K.6N(d+K.el,"7T:kS");O f=K.6N(d+K.el+"O3","7T:Cj");O c=K.2r();g.W.1s=((h.x/c-K.3e.x)|0)+"px";g.W.1t=((h.y/c-K.3e.y)|0)+"px";g.W.oK="y";f.O2=a.5k;if(a.3G!=="oJ"&&a.3G!=P){f.W.3G=a.3G}if(a.8b){f.W.4S=a.8b}if(a.d3){f.W.4V="kR(2J="+(a.d3*4b)+")"}if(a.8a){f.W.8a=a.8a}if(a.4h){f.W.4h=a.4h}if(a.79){f.W.79=a.79}if(a.7f){f.W.7f=a.7f}if(a.hJ===1d){g.d5=d;f.d5=d;f.t7=h;f.d4=h.1p}f.W.O1="kQ";f.O0="oI,bk,bk,bk";if(!g.2V){g.1V(f);K.c0.1V(g)}O e=a.3W||"cm";if(e.1a===1){e+="m"}O i=f.i2*(N.1Z.b9.tV[e.8X(0,1)]);O b=f.oH*(N.1Z.b9.tV[e.8X(1,1)]);if(2x(i)){i=0}if(2x(b)){b=0}g.W.1s=2g(g.W.1s)-i-1+"px";g.W.1t=2g(g.W.1t)+b+"px"},tY:Q(a,g){K.oG(a,g);O b=K.2r();O j=[];O d,h,f;1h(O c=0,e=g.1y.1a;c<e;c++){d=g.1y[c];h=(d.x/b-K.3e.x)|0;f=(d.y/b-K.3e.y)|0;if((c%3)==0&&(c/3)==0){j.1w("m")}V{if((c%3)===1){j.1w(" c")}}j.1w(" "+h+","+f)}j.1w(" x e");a.9j=j.6b("");R a},hQ:Q(b){O a=K.U.tX(b.66.id);if(a 1W N.1C.2X.k7){a=K.U.tX(K.66.id)}a&&a.2f.5z();N.1Z.bp.1g.hQ.1j(K,1r);a&&a.3y()},oF:Q(d){O b=K.66.id+"-"+d;O a=K.tW[b];if(a){R a}O c=N.1Z.ck[d];if(!c){7z S g3(d+" is fU a oz ck 2l")}O k=S N.1U(6r.kP,6r.kP,0,0);O e=["m"];1h(O f=0;f<c.1a;f=f+2){O h=c[f];O g=c[f+1];k.1s=1k.4v(k.1s,h);k.1L=1k.4v(k.1L,g);k.1I=1k.3f(k.1I,h);k.1t=1k.3f(k.1t,g);e.1w(h);e.1w(g);if(f==0){e.1w("l")}}e.1w("x e");O l=e.6b(" ");O j=(k.3L()-k.4y())/2;if(j>0){k.1L=k.1L-j;k.1t=k.1t+j}V{k.1s=k.1s+j;k.1I=k.1I-j}a={9j:l,1G:k.3L(),1s:k.1s,1L:k.1L};K.tW[b]=a;R a},1p:"N.1Z.b9"});N.1Z.b9.tV={l:0,c:0.5,r:1,t:0,m:0.5,b:1};N.1Z.or=N.1z(N.1Z,{2W:1d,dh:0,1u:P,2z:P,aD:1b,di:{},ez:P,i0:P,g9:P,tT:P,ey:P,ga:P,NZ:[],cg:P,1i:P,c9:P,kH:P,ow:P,eB:P,gc:P,1o:Q(a,b,c){N.1Z.1g.1o.1j(K,1r);K.31=1Q.2G("1u");K.1u=K.31.5Q("2d");K.66.1V(K.31);K.ez=1Q.2G("1u");K.i0=K.ez.5Q("2d");K.eB=1Q.2G("1u");K.gc=K.eB.5Q("2d");K.2z={};K.cg={};if(c){K.1i=c}K.c9=S N.Ci(K.1i);if(K.2W){K.ce=1Q.2G("1u");K.2m=K.ce.5Q("2d");K.ey=1Q.2G("1u");K.ga=K.ey.5Q("2d")}},9e:Q(a,b){K.g9=!!K.52?K.52.1T():a.1T();b&&K.ge();N.1Z.1g.9e.1j(K,1r);R 1b},NY:Q(a){K.7v=a},kD:Q(){K.tT=S N.2B(2g(K.66.W.1s),2g(K.66.W.1t));K.i0.4Y(0,0,K.1G.w,K.1G.h);K.i0.8I(K.31,0,0);if(K.2W){K.ga.4Y(0,0,K.1G.w,K.1G.h);K.ga.8I(K.ce,0,0)}},ge:Q(){K.i0.4Y(0,0,K.1G.w,K.1G.h);if(K.2W){K.ga.4Y(0,0,K.1G.w,K.1G.h)}},g8:Q(b,a){K.g4(K.2z[a][0])},ox:Q(e,d){K.gb=0;if(d){O f=d.3L(),b=(K.52.1s+K.52.1I)/2,c=(e.1s+e.1I)/2,a=1k.2w((c-b)/f);K.gb=a*f}},bn:Q(){O a=1Q.2G("1u");R!!a.5Q},6A:Q(b){K.1G=b.1T();O a=K.31;a.W.1A=b.w+"px";a.W.1E=b.h+"px";a.1A=b.w;a.1E=b.h;K.ez.1A=b.w;K.ez.1E=b.h;K.ez.W.1A=b.w+"px";K.ez.W.1E=b.h+"px";K.7v=P;K.NX={};if(K.2W){O c=K.ce;c.W.1A=b.w+"px";c.W.1E=b.h+"px";c.1A=b.w;c.1E=b.h;K.ey.W.1A=b.w+"px";K.ey.W.1E=b.h+"px";K.ey.1A=b.w;K.ey.1E=b.h}K.eB.1A=b.w;K.eB.1E=b.h;K.eB.W.1A=b.w+"px";K.eB.W.1E=b.h+"px"},tU:Q(g,t,p){p=p||K.U.2r();O f=g.1x;O a;if(t.6Q){O b=t.6j||t.6i;O l=t.6i||t.6j;b=b?b:t.4z*2;l=l?l:t.4z*2;O x=(t.9L!=2q)?t.9L:-(0.5*b);O k=(t.9K!=2q)?t.9K:-(0.5*l);O d,v,m,h,e,y,o;if(t.8q){o=t.8q/2R*1k.PI;e=1k.7P(o);y=1k.8y(o)}if(o){O w,u,n,s=[];s.1w({x:x,y:-k});s.1w({x:x,y:-k-l});s.1w({x:x+b,y:-k-l});s.1w({x:x+b,y:-k});1h(O r=0;r<4;r++){n=s[r];w=y*n.x+e*n.y;u=e*n.x-y*n.y;s[r]={x:w,y:u}}d=v=s[0].x;m=h=s[0].y;1h(O q=1;q<4;q++){if(d>s[q].x){d=s[q].x}if(s[q].x>v){v=s[q].x}if(m>s[q].y){m=s[q].y}if(s[q].y>h){h=s[q].y}}d=f.x+d*p;v=f.x+v*p;m=f.y-m*p;h=f.y-h*p}V{d=f.x+x*p;v=d+b*p;m=f.y-k*p;h=m-l*p}a=S N.1U(d,h,v,m)}V{O c=0;if(t.4x){c+=t.4x}if(t.4z){c+=t.4z}a=S N.1U(f.x+(-c*p),f.y+(-c*p),f.x+(c*p),f.y+(c*p))}R a},3V:Q(n,b,h){O d,m,f;O c=!!h&&!!h.hD;O i=!!h&&!!h.hH;O g=!!h&&!!h.NW;if(n.1x==P||!n.1x.6k()){R 1b}if(n.1x){O a;if(n.1x.1p==="N.1f.1D"){a=K.tU(n,b)}V{O a=n.1x.6k()}O k;if(K.U.2b&&K.U.2b.5C){k=K.U.9i()}O j=a&&a.9R(K.52,{dm:k});O e=1b;O l=1b;if(!i){e=K.g9.bg(a);l=!e&&K.g9.9R(a)||c}m=(b.23!=="2L")&&!!a&&j;d=m&&!e||(c&&m)||(i&&m);if(i){K.cg[n.id]=[n,b]}if(d){K.2z[n.id]=[n,b,l]}V{2s(K.2z[n.id])}K.aD=1d}if(K.aD&&!K.7O){K.3y(h);K.aD=1b}R d},5O:Q(a,c,b){if(c==="2j"){if(b.7j 1W Ch){a.5l=1;a.7Q=b.7j}V{a.5l=b.4H;a.7Q=b.7j}}V{if(c==="2o"){a.5l=b.at||1;a.aw=b.bf||"Cg";a.7y=b.8A;a.8r=b.4x}V{if(c==="5z"){a.5l=1;a.7Q="NV(7J, 7J, 7J)"}V{a.5l=1;a.8r=1}}}},7S:Q(b,d,a){O c=K.oE(d);if(b==="2j"){K.2m.5l=1;K.2m.7Q=c}V{if(b==="2o"&&a){K.2m.5l=1;K.2m.7y=c;K.2m.8r=a.4x+2}V{K.2m.5l=1;K.2m.8r=1}}},oE:Q(c){O d=6r(c.4U("4n").9h())+1;if(d>=hW){K.dh=d-tS;d=d%hW+1}O b="aq"+d.7r(16);O a=b.1a;b="#"+b.aU(a-6,a);R b},9Q:Q(f,d,e){O c=f.1p;if((c==="N.1f.5A")||(c==="N.1f.8k")||(c==="N.1f.83")||(c==="N.1f.8W")||(c==="N.1l.jy")){1h(O b=0;b<f.1y.1a;b++){K.9Q(f.1y[b],d,e)}R}if(N.1f.4s&&(f 1W N.1f.4s)){K.6T(f,d,e)}V{if(N.1f.2n&&(f 1W N.1f.2n)){K.eD(f,d,e)}V{if(N.1f.3T&&(f 1W N.1f.3T)){if(d.2j==1b){O a=d.4H;d.2j=1d;d.4H=0}K.eC(f,d,e)}V{if(N.1f.1D&&(f 1W N.1f.1D)){K.cd(f,d,e)}V{if(N.1f.9S&&(f 1W N.1f.9S)){K.eA(f,d,e)}}}}}if(a){d.2j=1b;d.4H=a;a=""}},oC:Q(i,a,d){O e=S 4w();if(a.dl){e.8x=a.dl}O b=a.6j||a.6i;O j=a.6i||a.6j;b=b?b:a.4z*2;j=j?j:a.4z*2;O g=(a.9L!=2q)?a.9L:-(0.5*b);O c=(a.9K!=2q)?a.9K:-(0.5*j);O f=1;O h=Q(){if(!K.cg[d]){R}O n=K.7i(i);O p=n[0];O o=n[1];if(!2x(p)&&!2x(o)){O k=K.1u;k.cj();k.4c(p,o);O m;if(a.8q){m=a.8q/2R*1k.PI}if(m){k.5m(m)}k.4c(g,c);k.5l=f;O l=N.1Z.5a.hY||(N.1Z.5a.hY=/oD 2.1/.d1(b4.i1.eb())?Cf/2k.Ce.1A:1);k.8I(e,0,0,b*l,j*l);if(K.2W){K.7S("2j",d);K.2m.cj();K.2m.4c(p,o);if(m){K.2m.5m(m)}K.2m.4c(g,c);K.2m.Cd(0,0,b,j)}}k.ci();K.2m.ci();K.5O(K.1u,"4C");if(!a.kI){K.kH--;if(K.kH==0){K.kD()}}};if(a.kI){e=a.kI;h.1j(K)}V{e.gd=N.2u.3E(h,K);e.5o=a.6Q}},cd:Q(f,b,d){if(b.4L!==1b){if(b.6Q||b.kI){K.oC(f,b,d)}V{if(b.4K&&(b.4K!="oB")){K.oA(f,b,d)}V{O i=K.7i(f);O h=2g(i[0]);O g=2g(i[1]);if(!2x(h)&&!2x(g)){O e=b.4z;O c=K.1u;c.6h();c.da(h,g,e,0,6.Cc,1d);if(b.2o!==1b){K.5O(K.1u,"2o",b);c.2o()}if(b.2j!==1b){K.5O(K.1u,"2j",b);c.2j()}if(K.2W){K.7S("2j",d,b);O a=K.2m;a.6h();a.da(h,g,e,0,6.Cc,1d);if(b.2o!==1b){a.2o()}if(b.2j!==1b){a.2j()}}}}}}},oA:Q(m,b,h){O n,l,g,f,j,a,c,e;O k;O o=1k.PI/2R;O d=N.1Z.ck[b.4K];if(!d){7z S g3(b.4K+" is fU a oz ck 2l")}if(!d.1a||d.1a<2){R}O r=K.7i(m);O q=r[0];O p=r[1];if(2x(q)||2x(p)){R}K.1u.aw="2w";K.1u.d8="2w";if(K.2W){K.2m.aw="2w";K.2m.d8="2w"}if(b.4K in K.di){a=K.di[b.4K]}V{a=S N.1U();if(b.4K==="dk"){}V{1h(j=0;j<d.1a;j+=2){a.1K(S N.3i(d[j],d[j+1]))}}K.di[b.4K]=a}K.1u.cj();if(K.2W){K.2m.cj()}K.1u.4c(q,p);if(K.2W){K.2m.4c(q,p)}e=o*b.8q;if(!2x(e)){K.1u.5m(e);if(K.2W){K.2m.5m(e)}}c=2*b.4z/1k.3f(a.3L(),a.4y());if(b.4K==="dk"){c=b.4z/10}K.1u.3D(c,c);if(K.2W){K.2m.3D(c,c)}g=a.5P().1P;f=a.5P().1R;if(b.4K!=="dk"){K.1u.4c(-g,-f)}if(K.2W&&b.4K!=="dk"){K.2m.4c(-g,-f)}k=b.4x;b.4x=k/c;if(b.2j!==1b){K.5O(K.1u,"2j",b);K.1u.6h();1h(j=0;j<d.1a;j=j+2){n=d[j];l=d[j+1];if(j==0){K.1u.2O(n,l)}K.1u.9c(n,l)}K.1u.9b();K.1u.2j();if(K.2W){K.7S("2j",h,b);K.2m.6h();1h(j=0;j<d.1a;j=j+2){n=d[j];l=d[j+1];if(j==0){K.1u.2O(n,l)}K.2m.9c(n,l)}K.2m.9b();K.2m.2j()}}if(b.2o!==1b){K.5O(K.1u,"2o",b);K.1u.6h();1h(j=0;j<d.1a;j=j+2){n=d[j];l=d[j+1];if(j==0){K.1u.2O(n,l)}K.1u.9c(n,l)}K.1u.9b();K.1u.2o();if(K.2W){K.7S("2o",h,b,c);K.2m.6h();1h(j=0;j<d.1a;j=j+2){n=d[j];l=d[j+1];if(j==0){K.1u.2O(n,l)}K.2m.9c(n,l)}K.2m.9b();K.2m.2o()}}b.4x=k;K.1u.ci();if(K.2W){K.2m.ci()}},eD:Q(c,a,b){a=N.1c.4I({2j:1b},a);K.6T(c,a,b)},6T:Q(e,a,d){O c=(a.2j!==1b);O b=(a.2o!==1b);K.bo(K.1u,e,a,d,{2j:c,2o:b});if(K.2W){K.bo(K.2m,e,a,d,{2j:c,2o:b},1d)}},bo:Q(c,l,a,e,j,o){O h=1;if(2t c.bi==="Q"){O m=K.86(a,h);c.bi(m)}O f=l.1y;O g=f.1a;c.6h();O b=K.7i(f[0]);O n=b[0];O k=b[1];if(!2x(n)&&!2x(k)){c.2O(b[0],b[1]);1h(O d=1;d<g;++d){O p=K.7i(f[d]);c.9c(p[0],p[1])}if(j.2j){if(o){K.7S("2j",e,a)}V{if(a){K.5O(c,"2j",a)}}c.2j()}if(j.2o){if(o){K.7S("2o",e,a)}V{if(a){K.5O(c,"2o",a)}}c.2o()}}if(2t c.bi==="Q"){c.bi([])}},eC:Q(g,a,c){O e=g.1y;O f=e.1a;if(f===1){K.6T(e[0],a,c)}V{K.gc.4Y(0,0,K.1G.w,K.1G.h);O h=(a.2j!==1b);O j=(a.2o!==1b);if(h){K.bo(K.gc,e[0],N.1c.4I({2o:1b,4H:1},a),c,{2j:1d});K.gc.cf="NU";1h(O d=1;d<f;++d){K.bo(K.gc,e[d],N.1c.4I({2o:1b,4H:1},a),c,{2j:1d})}K.gc.cf="kG-6f";O b=K.1u.5l;K.1u.5l=a.4H;K.1u.8I(K.eB,0,0);K.1u.5l=b}if(j){K.6T(e[0],N.1c.4I({2j:1b},a),c);1h(O d=1;d<f;++d){K.6T(e[d],N.1c.4I({2j:1b},a),c)}}if(K.2W){1h(O d=0;d<f;++d){K.bo(K.2m,e[d],a,c,{2j:h,2o:j},1d)}}}},eA:Q(d,a,c){O b=(S N.1f.4s([S N.1f.1D(d.x,d.y),S N.1f.1D(d.x+d.1A,d.y),S N.1f.1D(d.x+d.1A,d.y+d.1E),S N.1f.1D(d.x,d.y+d.1E)]));K.6T(b,a,c)},dj:Q(n,a){a=N.1c.1K({8b:"#aq",3W:"cm"},a);O o=K.7i(n);if(a.7h||a.7g){O h=2x(a.7h)?0:a.7h;O c=2x(a.7g)?0:a.7g;o[0]+=h;o[1]-=c}K.5O(K.1u,"4C");K.1u.7Q=a.8b;K.1u.5l=a.d3||1;O e=[a.7f?a.7f:"bc","bc",a.79?a.79:"bc",a.4h?a.4h:"kk",a.8a?a.8a:"t4-t3"].6b(" ");O d=a.5k.4U("\\n");O g=d.1a;if(K.1u.fN){K.1u.9H=e;K.1u.kj=N.1Z.5a.9G[a.3W[0]]||"3U";K.1u.sZ=N.1Z.5a.9G[a.3W[1]]||"ki";O l=N.1Z.5a.bb[a.3W[1]];if(l==P){l=-0.5}O m=K.1u.ek("Mg").1E||K.1u.ek("xx").1A;o[1]+=m*l*(g-1);1h(O f=0;f<g;f++){if(a.8z!=0){K.1u.cj();K.1u.4c(o[0],o[1]);K.1u.5m(a.8z*1k.PI/2R);K.1u.fN(d[f],0,(m*f));K.1u.ci()}V{K.1u.fN(d[f],o[0],o[1]+(m*f))}}}V{if(K.1u.kh){K.1u.sY=e;O b=N.1Z.5a.bb[a.3W[0]];if(b==P){b=-0.5}O l=N.1Z.5a.bb[a.3W[1]];if(l==P){l=-0.5}O m=K.1u.kg("xx");o[1]+=m*(1+(l*g));1h(O f=0;f<g;f++){O k=o[0]+(b*K.1u.kg(d[f]));O j=o[1]+(f*m);K.1u.4c(k,j);K.1u.kh(d[f]);K.1u.4c(-k,-j)}}}K.5O(K.1u,"4C")},86:Q(c,b){if(!c){R[]}O a=c.4x*b;O d=c.as;5U(d){1N"c3":R[];1N"kO":R[1,4*a];1N"kN":R[4*a,4*a];1N"kM":R[4*a,4*a,1,4*a];1N"kL":R[8*a,4*a];1N"kK":R[8*a,4*a,1,4*a];49:if(!d){R[]}if(N.1c.4f(d)){R d}d=N.6K.kJ(d).4D(/\\s+/g,",");R d.4D(/\\[|\\]/gi,"").4U(",")}},7i:Q(b){O c=K.2r();O d=K.52;O a=((b.x-K.gb)/c+(-d.1s/c));O e=((d.1t/c)-b.y/c);R[a,e]},Ca:Q(a,f){O b=K.2r();O c=K.52;O e=a*b+K.gb+c.1s;O d=c.1t-f*b;R S N.1f.1D(e,d)},5z:Q(){O a=K.31.1E;O b=K.31.1A;K.1u.4Y(0,0,b,a);K.2z={};K.cg={};if(K.2W){K.2m.4Y(0,0,b,a);K.ga.4Y(0,0,b,a)}K.i0.4Y(0,0,b,a);if(K.2W){K.ga.4Y(0,0,b,a)}},NT:Q(a){K.2z={}},g2:Q(g){O h=P;O j=P;if(K.2W){if(K.U&&!K.U.3S){O i=g.xy;O e=i.x|0;O d=i.y|0;O c=K.2m.tR(e,d,1,1).57;if(c[3]===7J){O b=c[2]+(ex*(c[1]+(ex*c[0])));if(b){h=K.cg["N.3k.Cb"+(b-1+K.dh)];if(h){j=h[0];O a;if(j.1x.1p==="N.1f.1D"){a=K.tU(j,h[1])}V{a=j.1x.6k()}O f=K.Ca(e,d);if(!a.c1(f.x,f.y)){j=P}}}}}}R j},g4:Q(j,n){if(!(N.1c.4f(j))){j=[j]}K.1u.cf="oy-4t";O e={};1h(O q=0,r=j.1a;q<r;++q){O l=j[q].1x.6k();O c=l&&l.9R(K.52);if(c){O h=K.cg[j[q].id];O f=h[0].1x;O s=h[1];O d=K.7i(S N.1f.1D(l.1s,l.1t));O b=K.7i(S N.1f.1D(l.1I,l.1L));K.1u.4Y(d[0],d[1],1k.3N(b[0]-d[0]),1k.3N(b[1]-d[1]));1h(O m in K.1i.2z){O p=K.1i.2z[m];if(!e[p.id]){if(l.9R(p.1x.6k())){K.2z[p.id]=[p,K.cg[p.id][1]];e[p.id]=[p,K.cg[p.id][1]]}}}1h(O k=NS;k<=NR;k++){1h(O g=NQ;g<=NP;g++){O u=k*1i.C3+g;O t=1i.tJ[u];if(t){1h(O o in t){O p=t[o]}}}}if(!(n&&n.NO)){2s K.cg[h[0].id]}}}1h(O o in e){O a=e[o];K.9Q(a[0].1x,N.1c.4I({4H:1,2o:1b},a[1]),a[0].id)}K.1u.cf="kG-6f";K.kD();K.3y()},3y:Q(f){if(K.7O){R}K.5O(K.1u,"4C");O m=K.31.1E;O c=K.31.1A;K.1u.4Y(0,0,c,m);if(K.2W){K.2m.4Y(0,0,c,m)}if(K.g9){if(f&&f.hD){O k=S N.2B(0,0)}V{O k=K.U.hZ(K.tT)}K.1u.8I(K.ez,k.x,k.y,K.1G.w,K.1G.h);if(K.2W){K.2m.8I(K.ey,k.x,k.y,K.1G.w,K.1G.h)}}K.ow=[];O n,j,a,g;O l=(K.U.2b&&K.U.2b.5C)&&K.U.9i();K.kH=0;O d=K.2z;1h(O b in d){g=d[b];n=g[0];a=g[1];j=n.1x;K.ox(j.6k(),l);if(a.6Q&&!a.kI&&j.1p==="N.1f.1D"){K.kH++}K.9Q(j,a,n.id);if(a.5k){K.ow.1w([n,a])}if(a.2o==1d){O h=j.1p;if((h==="N.1f.5A")||(h==="N.1f.8W")){1h(O e=0;e<j.1y.1a;e++){K.6T(j.1y[e],N.1c.4I({2j:1b},a),n.id)}}5U(j.1p){1N"N.1f.3T":K.6T(j.1y[0],N.1c.4I({2j:1b},a),n.id);1F;49:1F}}2s d[b]}K.C9(K.ow);K.kD();K.1u.cf="kG-6f"},C9:Q(e){O d;1h(O c=0,a=e.1a;c<a;++c){d=e[c];O b=d[0].1x.9a();if(b==P){5y}K.dj(b,d[1])}},1m:Q(){K.c9.1m();K.c9=P;N.1Z.1g.1m.1j(K,1r)},1p:"N.1Z.or"});N.1Z.5a.9G={l:"1s",r:"1I",t:"1t",b:"1L"};N.1Z.5a.bb={l:0,r:-1,t:0,b:-1};N.1Z.5a.hY=P;N.1Z.df=N.1z(N.1Z,{2W:1b,dh:0,1u:P,4u:P,aD:1b,di:{},hX:{},1o:Q(a,b){N.1Z.1g.1o.1j(K,1r);K.31=1Q.2G("1u");K.66.1V(K.31);K.1u=K.31.5Q("2d");K.4u={};if(b&&b.2W){K.2W=b.2W;K.ce=1Q.2G("1u");K.2m=K.ce.5Q("2d")}},9e:Q(a,b){N.1Z.1g.9e.1j(K,1r);R 1b},g8:Q(b,a){K.ov(K.4u[a][0])},bn:Q(){O a=1Q.2G("1u");R!!a.5Q},6A:Q(b){K.1G=b.1T();O a=K.31;a.W.1A=b.w+"px";a.W.1E=b.h+"px";a.1A=b.w;a.1E=b.h;K.7v=P;if(K.2W){O c=K.ce;c.W.1A=b.w+"px";c.W.1E=b.h+"px";c.1A=b.w;c.1E=b.h}},kF:Q(c){O b;if(c.1x){O a=c.1x.6k();b=!!a&&a.9R(K.52);if(b){K.4u[c.id]=[c]}V{2s(K.4u[c.id])}K.aD=1d}if(K.aD&&!K.7O){K.3y();K.aD=1b}R b},9Q:Q(c,a,b){if(N.1f.1D&&(c 1W N.1f.1D)){K.cd(c,a,b)}},C8:Q(c){O d=6r(c.4U("4n").9h())+1;if(d>=hW){K.dh=d-tS;d=d%hW+1}O b="aq"+d.7r(16);O a=b.1a;b="#"+b.aU(a-6,a);R b},7S:Q(b,d,a){O c=K.C8(d);if(b==="2j"){K.2m.5l=1;K.2m.7Q=c;K.2m.7y=c}},cd:Q(e,a,d){if(a.5p){O b=K.7i(e);O f=b[0]-a.5p.3h[0];O c=b[1]-a.5p.3h[1];K.1u.8I(a.5p.1u,f,c);if(K.2W){K.7S("2j",d);a.5p.kp(K.2m,f,c)}}},7i:Q(b){O c=K.2r();O d=K.52;O a=(b.x/c+(-d.1s/c));O e=((d.1t/c)-b.y/c);R[a,e]},5z:Q(){O a=K.31.1E;O b=K.31.1A;K.1u.4Y(0,0,b,a);K.4u={};if(K.2W){K.2m.4Y(0,0,b,a)}},C7:Q(h){O a=P;if(K.2W){if(!K.U.3S){O j=h.xy;O g=j.x|0;O f=j.y|0;O d=K.2m.tR(g,f,1,1).57;if(d[3]===7J){O c=d[2]+(ex*(d[1]+(ex*d[0])));if(c){O e=K.4u["N.NN"+(c-1+K.dh)];a=e&&e[0];if(a&&a.1x){O i=a.W.5p.1G;O b=K.U.dg(S N.3i(a.1x.x,a.1x.y));if(1k.3N(b.x-g)>=i[0]/2){a=P}V{if(1k.3N(b.y-f)>=i[0]/2){a=P}}}}}}}R a},ov:Q(a){if(!(N.1c.4f(a))){a=[a]}1h(O b=0;b<a.1a;++b){2s K.4u[a[b].id]}K.3y()},3y:Q(){if(!K.7O){O a=K.31.1E;O b=K.31.1A;K.1u.4Y(0,0,b,a);if(K.2W){K.2m.fT(1,0,0,1,0,0);K.2m.4Y(0,0,b,a)}O d;1h(O c in K.4u){if(!K.4u.dX(c)){5y}d=K.4u[c][0];K.9Q(d.1x,d.W,d.id)}}},1p:"N.1Z.df"});N.1C.2X=N.1z(N.1C,{2P:["tQ","BZ","tP","BY","NM","NL","NK","tI","sN","sM","sL","ou","hV","ot","os","tO","tN","kE","hU","c5","C6","C5","C4"],5S:1b,g6:1b,cc:1d,BV:1d,2z:P,4V:P,5Z:P,g5:P,NJ:1d,W:P,az:P,9f:P,c4:P,tM:["6w","b9","5a","or"],2f:P,C1:P,kC:P,8f:1b,4X:1,oq:1d,hT:1d,tJ:[],NI:10,C3:20,NH:P,NF:P,NE:[],aA:P,tK:1b,ew:0,g7:0,1o:Q(c,b){K.2P=N.1C.2X.1g.2P.b1(N.1C.1g.2P);N.1C.1g.1o.1j(K,1r);if(!K.2f||!K.2f.bn()){K.C2()}if(!K.2f||!K.2f.bn()){K.2f=P;K.C0()}if(!K.az){K.az=S N.ob()}K.2z=[];K.5Z=[];K.g5={};if(K.9f){1h(O d=0,a=K.9f.1a;d<a;d++){K.9f[d].fI(K)}}K.9g=[];K.tK=K.2f 1W N.1Z.or},1m:Q(){if(K.9f){O c,b,a;1h(b=0,a=K.9f.1a;b<a;b++){c=K.9f[b];if(c.th){c.1m()}}K.9f=P}if(K.c4){if(K.c4.th){K.c4.1m()}K.c4=P}K.9I();K.2z=P;K.5Z=P;K.g5=P;if(K.2f){K.2f.1m()}K.2f=P;K.kC=P;K.8f=P;N.1C.1g.1m.1j(K,1r)},1T:Q(e){if(e==P){e=S N.1C.2X(K.2l,K.8H())}e=N.1C.1g.1T.1j(K,[e]);O c=K.2z;O a=c.1a;O d=S 3Q(a);1h(O b=0;b<a;++b){d[b]=c[b].1T()}e.2z=d;R e},c5:Q(a){if(K.c6()&&K.3j){K.1n.1M("c5",a)}},C2:Q(){1h(O c=0,a=K.tM.1a;c<a;c++){O b=K.tM[c];O d=(2t b==="Q")?b:N.1Z[b];if(d&&d.1g.bn()){K.2f=S d(K.1q,K.C1,K);1F}}},C0:Q(){},3a:Q(b){N.1C.1g.3a.1j(K,1r);if(!K.2f){K.U.b6(K)}V{K.2f.U=K.U;O a=K.U.5c();a.w=a.w*K.4X;a.h=a.h*K.4X;K.2f.6A(a)}},tL:Q(){if(K.9f){O c,b,a;1h(b=0,a=K.9f.1a;b<a;b++){c=K.9f[b];if(c.98){c.2p()}}}},9O:Q(c){K.8f=1b;if(K.9f){O d,b,a;1h(b=0,a=K.9f.1a;b<a;b++){d=K.9f[b];if(d.98){d.2a()}}}},de:Q(){N.1C.1g.de.1j(K,1r);O a=K.U.5c();a.w=a.w*K.4X;a.h=a.h*K.4X;K.2f.6A(a)},2O:Q(a,b,n){O k=K;N.1C.1g.2O.1j(K,1r);if(K.g6&&!K.cc){if(b){K.1q.W.1s=0+"px";K.1q.W.1t=0+"px"}V{K.1q.W.1s=-2g(K.U.3o.W.1s,10)+"px";K.1q.W.1t=-2g(K.U.3o.W.1t,10)+"px"}R}K.cc=1b;O i=K.tK;K.aA=b;O g=(N.1Z.NG&&K.2f 1W N.1Z.NG);if(g){n||K.2f.ND(b)}V{O c=1d;if(!n){K.2f.31.W.3j="8C";if(i){K.2f.kD()}O m=K.U.5c(),j=m.w,f=m.h,e=(j/2*K.4X)-j/2,d=(f/2*K.4X)-f/2;e+=2g(K.U.3o.W.1s,10);e=-1k.2w(e);d+=2g(K.U.3o.W.1t,10);d=-1k.2w(d);K.1q.W.1s=e+"px";K.1q.W.1t=d+"px";O p=K.U.42().3D(K.4X);c=K.2f.9e(p,b);K.2f.31.W.3j="6I";if(N.fO===1d){K.1q.ca=K.1q.ca}if(!b&&c){K.ej(a)}}}if(!K.8f||(!g&&(b||!c))){K.8f=1d;if(K.oq&&i){if(!b||!K.g7){K.ej(a)}V{O h=K.U.bm(K.g7),o=N.2u.3E(Q(){R Q(q){k.ej(a,q)}(b)},K);K.2f.c9.aC(K.2f.31,h,o)}}if(!i||!K.oq){K.ej(a)}K.hT=1b}if(i){K.ew=K.U.2r();O l=S N.2B(2g(K.2f.66.W.1s),2g(K.2f.66.W.1t));K.g7=K.U.g1(l)}},aB:Q(b,a){if(K.g6){K.1q.W.1s=-2g(K.U.3o.W.1s,10)+"px";K.1q.W.1t=-2g(K.U.3o.W.1t,10)+"px"}},ej:Q(g,b){O f=K,e,d=f.2z;f.2f.7O=1d;1h(O c=0,a=d.1a;c<a;c++){if(c===(a-1)){f.2f.7O=1b}e=d[c];f.3V(e,2q,{hH:f.hT||(b||f.aA)})}},3y:Q(){if(N.1Z.NG&&K.2f 1W N.1Z.NG){K.8f=1b}R N.1C.1g.3y.1j(K,1r)},23:Q(a){N.1C.1g.23.1j(K,1r);O b=K.1q.W.23;if(b!==K.2f.31.W.23){K.2f.31.W.23=b}},7u:Q(b,l){if(!(N.1c.4f(b))){b=[b]}O j=!l||!l.5B;if(j){O a={2z:b};O h=K.1n.1M("BZ",a);if(h===1b){R}b=a.2z}O f=[];K.2f.7O=1d;1h(O d=0,g=b.1a;d<g;d++){if(d===(g-1)){K.2f.7O=1b}O k=b[d];if(K.kC&&!(k.1x 1W K.kC)){7z S hS("7u: NC NB be an "+K.kC.1g.1p)}k.1i=K;K.2z.1w(k);if(k.1x&&k.1x.1p==="N.1f.d2"){5y}O e=K.3V(k,2q,{hH:1d});if(!e){f.1w(k)}}O c=f.1a==0?1d:1b;K.1n.1M("BY",{2z:f,5V:c})},9I:Q(d,a){O c=(d==2q);if(c){d=K.2z}if(d){K.9P(d,a);1h(O b=d.1a-1;b>=0;b--){d[b].1m()}}},9P:Q(b){if(!b||b.1a===0){R}if(b===K.2z){R K.BW()}if(!(N.1c.4f(b))){b=[b]}if(b===K.5Z){b=b.9D()}O c=[];1h(O f=b.1a-1;f>=0;f--){O j=b[f];2s K.g5[j.id];O h=N.1c.2S(K.2z,j);if(h===-1){c.1w(j);5y}K.2z.6c(h,1);if(N.1c.2S(K.5Z,j)!==-1){N.1c.am(K.5Z,j)}j.1i=P}K.2f.5z();O a=[];1h(O d=0,g=K.2z.1a;d<g;d++){j=K.2z[d];a.1w(j)}K.2z=[];K.7u(a);O e=c.1a==0?1d:1b;K.1n.1M("tI",{2z:c,5V:e})},BW:Q(){K.2f.5z();K.tJ=[];K.2z=[];K.g5={};K.5Z=[];K.1n.1M("tI",{2z:[],5V:1d})},3V:Q(p,b,j){O o=K;if(!K.8f){R}if(!b||2t b!=="6q"){if(!b&&p.7I===N.69.bK){b="2s"}O n=p.7N;if(n==="7d"&&p.bW){b=p.bW}V{b=p.W||K.W}if(!b){b=K.az.fS(p,n)}}O h;if(K.BV&&(K.2f 1W N.1Z.6w)||(K.2f 1W N.1Z.b9)){O f=p.1x;if(f){K.2f.kB(p.id);K.2f.BU(f.id);if((f.1p==="N.1f.5A")||(f.1p==="N.1f.8k")||(f.1p==="N.1f.83")||(f.1p==="N.1f.8W")||f.tH||f.tG){1h(O g=0,k=f.1y.1a;g<k;g++){O c=f.1y[g].id;d(c)}}V{d(f.id)}}O l=K.42();O a=l.3L();O e=l.4y();O m=N.1c.NA(p.1x,S N.1U(l.1s-a,l.1L-e,l.1I+a,l.1t+e),1d,1d);p.1x=m;h=K.2f.3V(p,b,j);p.1x=f;K.2f.ap.W.3G="4m"}V{h=K.2f.3V(p,b,j)}if(h===1b||h===P){K.g5[p.id]=p}V{2s K.g5[p.id]}R h;Q d(s,r){if(r){O q=1Q.8G(s+"Nz"+r);r++}V{O q=1Q.8G(s);r=1}if(q){o.2f.ap.2T(q);d(s,r)}}},g4:Q(a){K.2f.g4(a)},kz:Q(a){if(K.3j==1b){R P}if(!K.2f){7z S g3("kz BT on 1i op no 2f. BS BR BQ BP BO a 1i, BN fU BM 3s hR is BL op it.")}O b=P;O c=K.2f.g2(a);if(c){if(2t c==="aY"){b=K.BK(c)}V{b=c}}R b},tF:Q(c,b){O a=P;1h(O d in K.2z){if(K.2z[d][c]===b){a=K.2z[d];1F}}R a},BK:Q(a){R K.tF("id",a)},Ny:Q(a){R K.tF("jZ",a)},Nx:Q(c,d){O b,a,f=[];1h(O e in K.2z){a=K.2z[e];if(a&&a.6O){if(a.6O[c]===d){f.1w(a)}}}R f},Nw:Q(a){},Nv:Q(a){},tE:Q(){O a=P;O b=K.2z;if(b){O c=P;1h(O d in K.2z){c=b[d].1x;if(c){if(a===P){a=S N.1U()}a.1K(c.6k())}}}R a},1p:"N.1C.2X"});N.1C.2X.k7=N.1z(N.1C.2X,{kA:1b,1O:P,1o:Q(b,a){N.1C.2X.1g.1o.1j(K,1r)},23:Q(){},kz:Q(a){O d=K.1O;O c;1h(O b=0;b<d.1a;b++){c=d[b].kz(a);if(c){R c}}},3a:Q(b){N.1C.2X.1g.3a.1j(K,1r);K.tA();1h(O a=0;a<K.1O.1a;a++){K.1O[a].1q.W.dc="2L"}b.1n.4N("7B",K,K.tC)},9O:Q(a){a.1n.6S("7B",K,K.tC);K.tB();N.1C.2X.1g.9O.1j(K,1r)},tA:Q(){O b;1h(O a=0;a<K.U.1O.1a;++a){b=K.U.1O[a];if(N.1c.2S(K.1O,b)!==-1){b.2f.hQ(K.2f)}}},tB:Q(){O b;1h(O a=0;a<K.1O.1a;++a){b=K.1O[a];if(K.2f&&b.2f.tD()===K.id){K.2f.hQ(b.2f)}}},tC:Q(a){O b=a.1i;if(a.bh==="88"&&N.1c.2S(K.1O,b)!==-1){K.tB();K.tA()}},1p:"N.1C.2X.k7"});N.3Y.fZ=N.1z(N.3Y,{9d:P,tz:1d,3h:P,1o:Q(h,d,g,c,b,f,e){O a=[h,d,g,c,f,e];N.3Y.1g.1o.1j(K,a);K.3h=(b!=P)?b:{1G:S N.2M(0,0),3e:S N.2B(0,0)}},1m:Q(){K.3h=P;K.9d=P;N.3Y.1g.1m.1j(K,1r)},ev:Q(){K.ty();N.3Y.1g.ev.1j(K,1r)},2O:Q(c){O b=K.9d;K.9d=K.tx(c);O d=K.om(c);O a=S 3Q(d);N.3Y.1g.2O.1j(K,a);if(K.9d!==b){K.oo()}},6A:Q(b){N.3Y.1g.6A.1j(K,1r);if((K.5q)&&(K.U)){O a=K.U.bm(K.5q);K.2O(a)}},tx:Q(b){O d=K.U.g1(b);O c=K.U.42();O a=c.BJ(d);R N.1U.BI(a)},oo:Q(){},om:Q(b){O e=b.3e(K.3h.3e);O a=K.1G||K.g0;if(K.kv){K.9d="tr"}O d=(K.9d.dU(0)==="t");e.y+=(d)?-a.h:K.3h.1G.h;O c=(K.9d.dU(1)==="l");e.x+=(c)?-a.w:K.3h.1G.w;R e},1p:"N.3Y.fZ"});N.3Y.of=N.1z(N.3Y.fZ,{oh:P,fX:P,ok:1b,eu:P,8D:P,oj:1b,1o:Q(g,c,f,b,a,e,d){N.3Y.fZ.1g.1o.1j(K,1r);if(K.oj){K.oo();K.tx=Q(h){R K.9d}}K.4Z.W.2v="3d";K.4Z.W.5j=1;if(e){K.6R.W.5j=1}K.8E.W.2v="3d";K.8E.W.1t="bk";K.8E.W.1s="bk";K.8E.W.1E="4b%";K.8E.W.1A="4b%"},1m:Q(){K.oh=P;K.fX=P;K.ok=P;K.oj=1b;K.eu=P;1h(O a=0;a<K.8D.1a;a++){O b=K.8D[a];if(b.5p){b.1q.2T(b.5p)}b.5p=P;if(b.1q){K.8E.2T(b.1q)}b.1q=P}K.8D=P;N.3Y.fZ.1g.1m.1j(K,1r)},tw:Q(a){},tv:Q(){},9N:Q(a){},6A:Q(a){N.3Y.fZ.1g.6A.1j(K,1r);K.tu()},oo:Q(){K.4A=K.eu[K.9d].4A;if(K.6R){O a=K.ky();K.6R.W.1I=a.1I+K.4A.1I+"px";K.6R.W.1t=a.1t+K.4A.1t+"px"}K.tu()},om:Q(a){O b=N.3Y.fZ.1g.om.1j(K,1r);b=b.3e(K.eu[K.9d].3e);R b},BH:Q(){K.8D=[];O f=P;1h(O e in K.eu){f=e;1F}O a=K.eu[f];1h(O d=0;d<a.8D.1a;d++){O h={};K.8D.1w(h);O b=K.id+"Nu"+d;h.1q=N.1c.7m(b,P,P,P,"3d",P,"8C",P);O c=K.id+"Nt"+d;O g=(K.ok)?N.1c.8F:N.1c.ol;h.5p=g(c,P,K.fX,K.oh,"3d",P,P,P);h.1q.1V(h.5p);K.8E.1V(h.1q)}},tu:Q(){if(!K.8D){K.BH()}if(K.1G&&K.9d){O j=K.eu[K.9d];1h(O f=0;f<j.8D.1a;f++){O c=j.8D[f];O e=K.8D[f];O d=c.3h.1s;O k=c.3h.1L;O a=c.3h.1I;O n=c.3h.1t;O m=(2x(c.1G.w))?K.1G.w-(a+d):c.1G.w;O g=(2x(c.1G.h))?K.1G.h-(k+n)+32:c.1G.h;e.1q.W.1A=(m<0?0:m)+"px";e.1q.W.1E=(g<0?0:g)+"px";e.1q.W.1s=(d!=P)?d+"px":"";e.1q.W.1L=(k!=P)?k+"px":"";e.1q.W.1I=(a!=P)?a+"px":"";e.1q.W.1t=(n!=P)?n+"px":"";e.5p.W.1s=c.2v.x+"px";e.5p.W.1t=c.2v.y+"px"}K.4Z.W.1s=K.4A.1s+"px";K.4Z.W.1t=K.4A.1t+"px"}},1p:"N.3Y.of"});N.3Y.BD=N.1z(N.3Y.of,{kx:"Ns",hP:1d,fY:1d,fX:S N.2M(Nr,Nq),ok:1b,oj:1b,eu:{tl:{3e:S N.2B(44,-32),4A:S N.1U(0,0,0,-2),8D:[{1G:S N.2M("4i","4i"),3h:S N.1U(0,51,22,0),2v:S N.2B(0,0)},{1G:S N.2M(22,"4i"),3h:S N.1U(P,50,0,0),2v:S N.2B(-et,0)},{1G:S N.2M("4i",19),3h:S N.1U(0,0,22,P),2v:S N.2B(0,-tt)},{1G:S N.2M(22,18),3h:S N.1U(P,0,0,P),2v:S N.2B(-et,-Np)},{1G:S N.2M(29,35),3h:S N.1U(P,-27,44,P),2v:S N.2B(-4,-No)}]},tr:{3e:S N.2B(-45,-32),4A:S N.1U(0,0,0,-1),8D:[{1G:S N.2M("4i","4i"),3h:S N.1U(0,51,22,0),2v:S N.2B(0,0)},{1G:S N.2M(22,"4i"),3h:S N.1U(P,50,0,0),2v:S N.2B(-et,0)},{1G:S N.2M("4i",19),3h:S N.1U(0,0,22,P),2v:S N.2B(0,-tt)},{1G:S N.2M(22,19),3h:S N.1U(P,0,0,P),2v:S N.2B(-et,-tt)},{1G:S N.2M(29,35),3h:S N.1U(43,-27,P,P),2v:S N.2B(-Nn,-Nm)}]},bl:{3e:S N.2B(45,32),4A:S N.1U(0,1,0,0),8D:[{1G:S N.2M("4i","4i"),3h:S N.1U(0,53,22,0),2v:S N.2B(0,0)},{1G:S N.2M(22,"4i"),3h:S N.1U(P,53,0,0),2v:S N.2B(-et,0)},{1G:S N.2M("4i",21),3h:S N.1U(0,0,22,P),2v:S N.2B(0,-oi)},{1G:S N.2M(22,21),3h:S N.1U(P,0,0,P),2v:S N.2B(-et,-oi)},{1G:S N.2M(29,33),3h:S N.1U(P,P,43,-27),2v:S N.2B(-Nl,-Nk)}]},br:{3e:S N.2B(-44,32),4A:S N.1U(0,1,0,0),8D:[{1G:S N.2M("4i","4i"),3h:S N.1U(0,53,22,0),2v:S N.2B(0,0)},{1G:S N.2M(22,"4i"),3h:S N.1U(P,53,0,0),2v:S N.2B(-et,0)},{1G:S N.2M("4i",21),3h:S N.1U(0,0,22,P),2v:S N.2B(0,-oi)},{1G:S N.2M(22,21),3h:S N.1U(P,0,0,P),2v:S N.2B(-et,-oi)},{1G:S N.2M(29,33),3h:S N.1U(45,P,P,-28),2v:S N.2B(-Nj,-Ni)}]}},hO:S N.2M(Nh,30),hN:S N.2M(Ng,Nf),c8:P,kv:1d,1o:Q(h,d,g,c,a,f,e,b){if(b!=2q){K.kv=b}K.oh=N.1c.4M()+"Ne-5R-fW.2Z";N.3Y.of.1g.1o.1j(K,1r);K.4Z.3M=K.kx},2H:Q(a){N.3Y.1g.2H.1j(K,[a]);if(K.kv){K.c8=K.BG(2g(K.1q.W.1s),2g(K.1q.W.1t),2g(K.1q.W.1A),2g(K.1q.W.1E));K.U.kw.1V(K.c8)}R K.1q},BG:Q(p,o,d,r){O q={1B:N.1c.4M()+"jM-5R-BE.2Z",1A:Nd,1E:Nc,7A:{x:ts,y:0},9B:{x:8,y:BF},aW:{x:Nb,y:0},bj:{x:Na,y:BF}};q.4X=(q.9B.y-q.7A.y)/(q.7A.x-q.9B.x);O k=r*(2/3);O a=k/q.4X;O c={1s:p,1t:2g(o+r-k+15),1A:2g(d+a+a/4),1E:2g(k)};O b=1Q.2G("1q");b.id=N.1c.7x("N9");b.W.2v="3d";b.W.1s=c.1s+"px";b.W.1t=c.1t+"px";b.W.1A=c.1A+"px";b.W.1E=c.1E+"px";O g=2g(a);O j=10;O m=[];m[0]={1q:{1s:0,1t:0,1A:g,1E:j},5b:{1s:-q.7A.x+g,1t:-q.7A.y,1A:q.1A,1E:q.1E}};m[1]={1q:{1s:g,1t:0,1A:c.1A-g*2,1E:j},5b:{1s:-q.7A.x,1t:-q.7A.y,1A:q.1A,1E:q.1E}};m[6]={1q:{1s:0,1t:c.1E-j,1A:g,1E:j},5b:{1s:-(c.1E)/q.4X-q.9B.x+g,1t:-q.9B.y+j,1A:q.1A,1E:q.1E}};m[3]={1q:{1s:0,1t:j,1A:g,1E:c.1E-j*2},5b:{1s:-q.7A.x+g,1t:-q.7A.y-j,1A:q.1A,1E:q.1E}};m[4]={1q:{1s:g,1t:j,1A:c.1A-g*2,1E:c.1E-j*2},5b:{1s:-q.7A.x,1t:-q.7A.y-j,1A:q.1A,1E:q.1E}};m[8]={1q:{1s:c.1A-g,1t:c.1E-j,1A:g,1E:j},5b:{1s:-q.bj.x,1t:-q.bj.y+j,1A:q.1A,1E:q.1E}};m[7]={1q:{1s:g,1t:c.1E-j,1A:c.1A-g*2,1E:j},5b:{1s:-q.bj.x+c.1A-g*2,1t:-q.bj.y+j,1A:q.1A,1E:q.1E}};m[5]={1q:{1s:c.1A-g,1t:j,1A:g,1E:c.1E-j*2},5b:{1s:-q.bj.x,1t:-q.bj.y+c.1E-j,1A:q.1A,1E:q.1E}};m[2]={1q:{1s:c.1A-g,1t:0,1A:g,1E:j},5b:{1s:-q.aW.x+(c.1E)/q.4X,1t:-q.aW.y,1A:q.1A,1E:q.1E}};1h(O h=0;h<m.1a;h++){if(m[h]!=P){O l=1Q.2G("1q");l.id=N.1c.7x("N8");l.W.9M="8C";l.W.bS=1;l.W.5j=h+1;l.W.2v="3d";l.W.1s=m[h].1q.1s+"px";l.W.1t=m[h].1q.1t+"px";l.W.1A=m[h].1q.1A+"px";l.W.1E=m[h].1q.1E+"px";O f=1Q.2G("5b");f.5o=N.1c.4M()+"jM-5R-BE.2Z";f.W.2v="3d";f.W.1s=m[h].5b.1s+"px";f.W.1t=m[h].5b.1t+"px";f.W.1A=m[h].5b.1A+"px";f.W.1E=m[h].5b.1E+"px";l.1V(f);b.1V(l)}}O e=1Q.2G("1q");e.id=N.1c.7x("N7");e.W.9M="8C";e.W.bS=1;e.W.5j=0;e.W.2v="3d";e.W.1s=50+"px";e.W.1t=c.1E-11+"px";e.W.1A=80+"px";e.W.1E=20+"px";O n=1Q.2G("5b");n.5o=N.1c.4M()+"jM-5R-N6.2Z";n.W.2v="3d";n.W.1s=0+"px";n.W.1t=0+"px";n.W.1A=80+"px";n.W.1E=20+"px";e.1V(n);b.1V(e);R b},ay:Q(){N.3Y.1g.ay.1j(K);if(K.c8){K.kv=1b;K.c8.W.23="2L"}},1p:"N.3Y.BD"});N.2D=N.1z({id:P,2l:P,8x:P,mV:P,8Y:P,N5:1b,8d:P,7l:P,7R:P,tp:1b,od:P,1o:Q(b,a){N.1c.1K(K,a);K.8d=[];if(a&&a.8d){K.tj(a.8d)}K.BC(b||N.3k.2X.W["49"]);K.id=N.1c.7x(K.1p+"4n")},1m:Q(){1h(O b=0,a=K.8d.1a;b<a;b++){K.8d[b].1m();K.8d[b]=P}K.8d=P;K.7R=P},fS:Q(k){O a=K.tp?{}:K.to(N.1c.1K({},K.7R),k);O j=K.8d;O h,b;O c=[];O f=1b;1h(O d=0,e=j.1a;d<e;d++){h=j[d];O g=h.o7(k);if(g){if(h 1W N.ko&&h.Bq){c.1w(h)}V{f=1d;K.tq(h,a,k)}}}if(f==1b&&c.1a>0){f=1d;1h(O d=0,e=c.1a;d<e;d++){K.tq(c[d],a,k)}}if(j.1a>0&&f==1b){a.23="2L"}if(a.5k!=P&&2t a.5k!=="aY"){a.5k=6K(a.5k)}R a},tq:Q(f,d,b){O a=b.1x?K.BB(b.1x):N.2D.tm[0];O c=f.8B[a]||f.8B;if(K.tp===1d){O e=K.7R;N.1c.4I(c,{4z:e.4z});if(c.2o===1d||c.4L===1d){N.1c.4I(c,{4x:e.4x,8A:e.8A,at:e.at,as:e.as,bf:e.bf})}if(c.2j===1d||c.4L===1d){N.1c.4I(c,{7j:e.7j,4H:e.4H})}if(c.4L===1d){N.1c.4I(c,{4z:K.7R.4z,6Q:K.7R.6Q,4K:K.7R.4K,fV:K.7R.fV,6j:K.7R.6j,6i:K.7R.6i,9L:K.7R.9L,9K:K.7R.9K})}}R K.to(N.1c.1K(d,c),b)},to:Q(d,c){O b=N.1c.1K({},c.6O||c.57);N.1c.1K(b,K.7l);1h(O a in K.od){d[a]=N.2D.o9(d[a],b,c,a)}R d},tn:Q(){O d={};O f=K.7R;K.oe(d,f);O h=K.8d;O e,g;1h(O c=0,a=h.1a;c<a;c++){e=h[c].8B;1h(O b in e){g=e[b];if(2t g==="6q"){K.oe(d,g)}V{K.oe(d,e);1F}}}R d},oe:Q(b,c){O d;1h(O a in c){d=c[a];if(2t d==="aY"&&d.es(/\\$\\{\\w+\\}/)){b[a]=1d}}R b},tj:Q(a){3Q.1g.1w.1j(K.8d,a);K.od=K.tn()},BC:Q(a){K.7R=a;K.od=K.tn()},BB:Q(d){O c=N.2D.tm;1h(O b=0,a=c.1a;b<a;b++){if(d.1p.2S(c[b])!==-1){R c[b]}}},1T:Q(){O b=N.1c.1K({},K);if(K.8d){b.8d=[];1h(O c=0,a=K.8d.1a;c<a;++c){b.8d.1w(K.8d[c].1T())}}b.7l=K.7l&&N.1c.1K({},K.7l);O d=N.1c.1K({},K.7R);R S N.2D(d,b)},1p:"N.2D"});N.2D.o9=Q(d,b,a,c){if(2t d==="aY"&&d.2S("${")!==-1){d=N.6K.5L(d,b,[a,c]);d=(2x(d)||!d)?d:3t(d)}R d};N.2D.tm=["1D","sC","3T","sA","sB"];N.2D.ax=N.1z({id:P,er:P,1o:Q(a){K.BA(a);K.id=N.1c.7x(K.1p+"4n")},1m:Q(){K.id=P;K.er=P},BA:Q(a){if(N.1c.4f(a)){if(a.1a>1){K.er=a}V{7z 77("it N4 be N3 N2 N1 4S!")}}V{7z 77("N0 is fU MZ!")}},1p:"N.2D.ax"});N.2D.ku=N.1z(N.2D.ax,{x1:P,y1:P,x2:P,y2:P,1o:Q(c,e,b,d,a){K.x1=c||0;K.y1=e||0;K.x2=b||0;K.y2=d||0;N.2D.ax.1g.1o.4g(K,a)},1m:Q(){K.x1=P;K.y1=P;K.x2=P;K.y2=P;N.2D.ax.1g.1m.4g(K)},1p:"N.2D.ku"});N.2D.kt=N.1z(N.2D.ax,{cx:P,cy:P,4J:P,fx:P,fy:P,1o:Q(b,f,a,e,d,c){K.cx=b||0;K.cy=f||0;K.4J=a||0;K.fx=e||0;K.fy=d||0;N.2D.ax.1g.1o.4g(K,c)},1m:Q(){K.cx=P;K.cy=P;K.4J=P;K.fx=P;K.fy=P;N.2D.ax.1g.1m.4g(K)},1p:"N.2D.kt"});N.2D.Bz=N.1z({4S:P,1o:Q(a){N.1c.1K(K,a)},1m:Q(){K.4S=P},1p:"N.2D.Bz"});N.2D.Bw=N.1z({4S:P,aw:"2w",d8:"2w",hM:10,1A:P,1o:Q(a){N.1c.1K(K,a)},1m:Q(){K.4S=P;K.aw=P;K.Bx=P;K.hM=P;K.1A=P},1p:"N.2D.Bw"});N.2D.4w=S N.1z({1u:P,2j:P,2o:P,4J:P,6z:[0,0],3h:P,1G:P,1o:Q(a){N.1c.1K(K,a)},1m:Q(){K.1u=P;if(K.2j){K.2j.1m();K.2j=P}if(K.2o){K.2o.1m();K.2o=P}K.4J=P;K.3h=P;K.1G=P},d9:Q(){},kp:Q(){},kq:Q(c,a){O b=1Q.2G("MY");if(c){b.1A=c}if(a){b.1E=a}R b.5Q("2d")},1p:"N.2D.4w"});N.2D.Bv=N.1z(N.2D.4w,{1o:Q(a){N.2D.4w.1g.1o.1j(K,[a]);K.d9()},1m:Q(){N.2D.4w.1g.1m.1j(K,1r)},d9:Q(){O a=P,f,e=0;if(K.2o){f=K.2o.4S;e=K.2o.1A;if(e===2q){e=1}a=K.2o.eq}O d=2*(K.4J+e)+1;O b={7y:f,4x:e,1G:d,eq:a};O c=K.kq(d,d);K.1u=c.1u;d=K.1u.1A;K.2H(b,c,0,0);K.3h=[d/2,d/2];K.1G=[d,d]},2H:Q(b,c,a,d){c.fT(1,0,0,1,0,0);c.4c(a,d);c.6h();c.da(b.1G/2,b.1G/2,K.4J,0,2*1k.PI,1d);if(K.2j){c.7Q=K.2j.4S;c.2j()}if(K.2o){c.7y=b.7y;c.8r=b.4x;if(b.eq){c.bi(b.eq)}c.2o()}c.9b()},kp:Q(b,a,c){b.fT(1,0,0,1,0,0);b.4c(a,c);b.6h();b.da(K.1G[0]/2,K.1G[0]/2,K.4J,0,2*1k.PI,1d);b.2j();b.9b()},1p:"N.2D.Bv"});N.2D.oc=N.1z(N.2D.4w,{6g:30,kr:0,6y:3,1o:Q(a){N.2D.4w.1g.1o.1j(K,1r);K.6g=a.6g!==2q?a.6g:K.6g;K.6y=a.6y!==2q?a.6y:K.6y;K.d9()},1m:Q(){N.2D.4w.1g.1m.1j(K,1r);K.6g=P;K.kr=P;K.6y=P},d9:Q(){O d=K.2o.1A===2q?1:K.2o.1A;O c=2*(K.4J+d)+1;O a={7y:K.2o,7Q:K.2j,1G:c};O b=K.kq(c,c);K.1u=b.1u;c=K.1u.1A;K.3h=[c/2,c/2];K.2H(b,a,0,0);K.1G=[c,c]},2H:Q(f,c,a,g){f.fT(1,0,0,1,0,0);O b=0;O e=K.6g;K.kr=ks/K.6y-K.6g;if(K.kr<0){R}f.4c(a,g);f.6h();1h(O d=0;d<K.6y;d++){K.tk(f,K.3h[0],K.3h[1],K.4J,b,e);b=e+K.kr;e=b+K.6g}if(c){K.d6(f,c)}V{f.2j()}f.9b()},d6:Q(b,a){if(a.7Q){b.7Q=a.7Q.4S;b.2j()}if(a.7y){b.7y=a.7y.4S;b.8r=a.7y.1A;if(a.7y.eq){b.bi(a.7y.eq)}b.2o()}},tk:Q(d,a,f,e,b,c){b=b/2R*1k.PI;c=c/2R*1k.PI;d.2O(a,f);d.9c(a+e*1k.8y(b),f+e*1k.7P(b));d.da(a,f,e,b,c);d.9c(a,f)},kp:Q(b,a,c){K.2H(b,2q,a,c)},1p:"N.2D.oc"});N.2D.Bu=N.1z(N.2D.oc,{7l:P,1o:Q(){},1m:Q(){N.2D.oc.1g.1m.1j(K,1r);K.7l=P},d9:Q(b){if(K.7l===P||K.1u.1A!==b.1G[0]){K.7l=K.kq(b.1G[0],b.1G[1]);K.1u=K.7l.1u}O a=K.1u.1A;K.3h=[a/2,a/2];K.2H(K.7l,b,0,0);K.1G=[a,a]},2H:Q(c,b,a,d){c.4Y(0,0,K.1u.1A,K.1u.1E);c.fT(1,0,0,1,0,0);c.4c(a,d);c.6h();K.tk(c,K.3h[0],K.3h[1],b.4J,b.MX,b.MW);K.d6(c,b);c.9b()},1p:"N.2D.Bu"});N.2D.Bt=S N.1z(N.2D.4w,{c7:P,ep:P,6g:P,1o:Q(a){O b=K;if(a.4J===P){R}N.2D.4w.1g.1o.1j(K,1r);b.c7=a.c7;b.ep=a.ep!==2q?a.ep:b.4J;b.6g=a.6g!==2q?a.6g/2R*1k.PI:0;K.d9()},1m:Q(){N.2D.4w.1g.1m.1j(K,1r);K.c7=P;K.ep=P;K.6g=P},d9:Q(){O h="";O a="";O b=0;O g;O f=0;if(K.2o){g=K.2o.4S;f=K.2o.1A;if(f===2q){f=1}a=K.2o.d8;h=K.2o.aw;b=K.2o.hM}O e=2*(K.4J+f)+1;O c={7y:g,4x:f,1G:e,aw:h,d8:a,hM:b};O d=K.kq(e,e);K.1u=d.1u;e=K.1u.1A;K.2H(c,d,0,0);K.3h=[e/2,e/2];K.1G=[e,e]},2H:Q(b,d,a,g){O c,f,e;d.fT(1,0,0,1,0,0);d.4c(a,g);d.6h();if(K.ep!==K.4J){K.c7=2*K.c7}1h(c=0;c<=K.c7;c++){f=c*2*1k.PI/K.c7-1k.PI/2+K.6g;e=c%2===0?K.4J:K.ep;d.9c(b.1G/2+e*1k.8y(f),b.1G/2+e*1k.7P(f))}if(K.2j){d.7Q=K.2j.4S;d.2j()}if(K.2o){d.7y=b.7y;d.8r=b.4x;if(b.eq){d.bi(b.eq)}d.aw=b.aw;d.d8=b.d8;d.hM=b.hM;d.2o()}d.9b()},kp:Q(c,a,f){c.fT(1,0,0,1,0,0);c.4c(a,f);c.6h();O b,d,e;1h(b=0;b<=K.c7;b++){e=b*2*1k.PI/K.c7-1k.PI/2+K.6g;d=b%2===0?K.4J:K.ep;c.9c(K.1G[0]/2+d*1k.8y(e),K.1G[0]/2+d*1k.7P(e))}c.2j();c.9b()},1p:"N.2D.Bt"});N.ob=N.1z({6x:P,Bs:1d,1o:Q(c,a){K.6x={"49":S N.2D(N.3k.2X.W["49"]),7d:S N.2D(N.3k.2X.W.7d),hL:S N.2D(N.3k.2X.W.hL),"2s":S N.2D(N.3k.2X.W["2s"])};if(c 1W N.2D){K.6x["49"]=c;K.6x.7d=c;K.6x.hL=c;K.6x["2s"]=c}V{if(2t c==="6q"){1h(O b in c){if(c[b]1W N.2D){K.6x[b]=c[b]}V{if(2t c[b]==="6q"){K.6x[b]=S N.2D(c[b])}V{K.6x["49"]=S N.2D(c);K.6x.7d=S N.2D(c);K.6x.hL=S N.2D(c);K.6x["2s"]=S N.2D(c);1F}}}}}N.1c.1K(K,a)},1m:Q(){1h(O a in K.6x){K.6x[a].1m()}K.6x=P},fS:Q(b,c){if(!b){b=S N.3k.2X()}if(!K.6x[c]){c="49"}b.7N=c;O a={};if(K.Bs&&c!=="49"){a=K.6x["49"].fS(b)}R N.1c.1K(a,K.6x[c].fS(b))},MV:Q(b,d,f,a){O e=[];1h(O c in f){e.1w(S N.ko({8B:f[c],7l:a,4V:S N.fR.Br({2E:N.fR.Br.MU,bh:d,d7:c})}))}K.6x[b].tj(e)},1p:"N.ob"});N.ko=N.1z({id:P,2l:P,8x:P,mV:P,7l:P,4V:P,Bq:1b,8B:P,eo:P,oa:P,o8:P,1o:Q(a){K.8B={};N.1c.1K(K,a);if(K.eo){2s K.8B}K.id=N.1c.7x(K.1p+"4n")},1m:Q(){1h(O a in K.8B){K.8B[a]=P}K.8B=P;2s K.eo},o7:Q(c){O b=K.5Q(c);O a=1d;if(K.oa||K.o8){O d=c.1i.U.ti()}if(K.oa){a=d>=N.2D.o9(K.oa,b)}if(a&&K.o8){a=d<N.2D.o9(K.o8,b)}if(a&&K.4V){if(K.4V.1p==="N.fR.MT"){a=K.4V.o7(c)}V{a=K.4V.o7(b)}}R a},5Q:Q(b){O a=K.7l;if(!a){a=b.6O||b.57}if(2t K.7l==="Q"){a=K.7l(b)}R a},1T:Q(){O b=N.1c.1K({},K);if(K.eo){O a=K.eo.1a;b.eo=S 3Q(a);1h(O d=0;d<a;++d){b.eo[d]=K.eo[d].1T()}}V{b.8B={};O f,e;1h(O c in K.8B){f=K.8B[c];e=2t f;if(e==="6q"){b.8B[c]=N.1c.1K({},f)}V{if(e==="aY"){b.8B[c]=f}}}}b.4V=K.4V&&K.4V.1T();b.7l=K.7l&&N.1c.1K({},K.7l);R S N.ko(b)},1p:"N.ko"});N.7e=N.1z({1i:P,2C:P,3I:P,98:1d,th:1d,1o:Q(a){N.1c.1K(K,a);K.2C=a;K.3I=1b},1m:Q(){K.2a();K.1i=P;K.2C=P},fI:Q(a){K.1i=a},2p:Q(){if(!K.3I){K.3I=1d;R 1d}R 1b},2a:Q(){if(K.3I){K.3I=1b;R 1d}R 1b},1p:"N.7e"});N.7e.tg=N.1z(N.7e,{2c:P,7v:P,4X:2,o6:P,hK:P,2p:Q(){O a=N.7e.1g.2p.4g(K);if(a){K.1i.1n.on({7w:K.6P,c5:K.6P,fQ:K.6P,2y:K});K.6P()}R a},2a:Q(){O a=N.7e.1g.2a.4g(K);if(a){K.1i.1n.un({7w:K.6P,c5:K.6P,fQ:K.6P,2y:K})}R a},6P:Q(b){O a=K.o5();if(a!==P&&((b&&b.MS)||(K.1i.3j&&K.1i.c6()&&K.Bp(a)))){K.9J(a);K.7v=K.1i.U.2r();K.Bo(b)}},o5:Q(){if(K.1i.U===P){R P}O a=K.1i.U.42();if(a&&!K.1i.2Q.3w(K.1i.U.5Y())){a=a.1T().3K(K.1i.U.5Y(),K.1i.2Q)}R a},Bp:Q(a){if(!a){a=K.o5()}O c=!K.2c||!K.2c.bg(a);if(!c&&K.o6){O b=K.7v/K.1i.U.2r();c=(b>=K.o6||b<=(1/K.o6))}R c},9J:Q(b){if(!b){b=K.o5()}O a=b.5P();O d=b.3L()*K.4X;O c=b.4y()*K.4X;K.2c=S N.1U(a.1P-(d/2),a.1R-(c/2),a.1P+(d/2),a.1R+(c/2))},Bo:Q(a){if(K.hK&&!(a&&a.MR===1d)){K.1i.c4.o4(K.hK);K.1i.1n.1M("7k")}K.1i.1n.1M("av");K.hK=K.1i.c4.tf(N.1c.4I({4V:K.Bn(),3n:K.o3,2y:K},a))},Bn:Q(){O a=S N.fR.Bm({2E:N.fR.Bm.tg,d7:K.2c,2Q:K.1i.2Q});if(K.1i.4V){a=S N.fR.Bl({2E:N.fR.Bl.MQ,MP:[K.1i.4V,a]})}R a},o3:Q(g){K.1i.9I();O e=g.2z;if(e&&e.1a>0){O f=K.1i.2Q;O d=K.1i.U.5Y();if(!d.3w(f)){O c;1h(O b=0,a=e.1a;b<a;++b){c=e[b].1x;if(c){c.3K(f,d)}}}K.1i.7u(e)}K.hK=P;K.1i.1n.1M("7k")},1p:"N.7e.tg"});N.7e.Bj=N.1z(N.7e,{Bk:1b,2p:Q(){O a=N.7e.1g.2p.1j(K,1r);if(a){K.1i.1n.on({c5:K.au,2y:K});if(K.1i.3j==1d||K.Bk){K.au()}V{K.1i.1n.on({fQ:K.au,2y:K})}}R a},2a:Q(){O a=N.7e.1g.2a.4g(K);if(a){K.1i.1n.un({c5:K.au,fQ:K.au,2y:K})}R a},au:Q(a){O b=K.1i;b.1n.1M("av",{4V:b.4V});b.c4.tf(N.1c.4I({3n:K.o3,4V:b.4V,2y:K},a));b.1n.un({fQ:K.au,2y:K})},o3:Q(h){O e=K.1i;e.9I();O f=h.2z;if(f&&f.1a>0){O g=e.2Q;O d=e.U.5Y();if(!d.3w(g)){O c;1h(O b=0,a=f.1a;b<a;++b){c=f[b].1x;if(c){c.3K(g,d)}}}e.7u(f)}e.1n.1M("7k",{hK:h})},1p:"N.7e.Bj"});N.7e.d2=N.1z(N.7e,{kn:P,W:P,7R:{8b:"#aq",d3:1,4h:"te",7f:"bc",79:"bc",3W:"cm",7h:0,7g:0,8z:0,2j:1b,7j:"#o2",4H:0.4,2o:1b,8A:"#o2",at:1,4x:1,bf:"2w",as:"c3",hJ:1d,Bi:1d},tc:1d,td:1d,o1:P,o0:P,nY:0,1o:Q(a){K.kn=[];N.7e.1g.1o.1j(K,1r)},1m:Q(){N.7e.1g.1m.1j(K,1r);K.kn=P;K.W=P;K.td=1d;K.tc=1d;K.o1=P;K.o0=P;K.nY=0},1T:Q(){O b=S N.7e.d2();O a={};1h(O d in K.W){O c=K.W[d];if(c!==2q){a[d]=c}}b.W=a;R b},d6:Q(g){O l=g;l.W=N.1c.bM(l.W,K.7R);if(K.W&&K.W.4h&&3t(K.W.4h)<12){K.W.4h="te"}l.W=N.1c.bM(l.W,K.W);if(K.o1&&K.o0&&l.6O){O f=K.o1;O e=l.6O;O j=K.o0;O b=1b;O d=P;1h(O h in e){if(f===h){b=1d;d=e[h];1F}}if(b){1h(O a=0,c=j.1a;a<c;a++){if((d>=j[a].3X)&&(d<j[a].fP)){O k=j[a].W;if(k&&k.4h&&3t(k.4h)<12){k.4h="te"}l.W=N.1c.bM(l.W,k)}}}}l.W.5k=l.1x.99;R l},B5:Q(f){O e,b=[];1h(O d=0,a=f.1a;d<a;d++){O c=f[d];if(c.1x.1p==="N.1f.d2"){e=K.d6(c);e.1i=K.1i;b.1w(e)}}R b},B4:Q(f){O m=[],p,h,u=[],v,b,d={3W:"cm",7h:0,7g:0};K.kn=[];1h(O s=0,t=f.1a;s<t;s++){h=f[s];if(h.nZ){h=K.d6(h)}O g=K.Bh(h);if((g.x>=0&&g.x<=K.1i.U.1G.w)&&(g.y>=0&&g.y<=K.1i.U.1G.h)){if(h.W.ar>-1){if(K.1i.U.4G()<=h.W.ar){5y}}if(h.W.bd>-1){if(K.1i.U.4G()>h.W.bd){5y}}O n=P;if(h.nZ){h.nZ=P;n=K.tb(h,g)}V{if(h.1x.ba.w&&h.1x.ba.h){n=K.Bg(h,g)}V{n=K.tb(h,g)}}O o=S N.1U(0,K.1i.U.1G.h,K.1i.U.1G.w,0),c=n.1a;if(K.td){O l=K.B9(o,n);if(l){if(l.sW==="1s"){h.W.7h+=l.fM;1h(O q=0;q<c;q++){n[q].x+=l.fM}}V{if(l.sW==="1I"){h.W.7h+=(-l.fM);1h(O q=0;q<c;q++){n[q].x+=(-l.fM)}}}if(l.sV==="1t"){h.W.7g+=l.ke;1h(O q=0;q<c;q++){n[q].y+=l.ke}}V{if(l.sV==="1L"){h.W.7g+=(-l.ke);1h(O q=0;q<c;q++){n[q].y+=(-l.ke)}}}h.nZ=1d}}if(K.tc){O k=1b;if(s!=0){1h(O q=0;q<u.1a;q++){if(K.B8(n,u[q])){k=1d;1F}}}if(k){5y}V{u.1w(n)}}O a=[];1h(O q=0;q<c-1;q++){a.1w(K.1i.5n(n[q]))}O r=[S N.1f.1D(a[0].1P,a[0].1R),S N.1f.1D(a[1].1P,a[1].1R),S N.1f.1D(a[2].1P,a[2].1R),S N.1f.1D(a[3].1P,a[3].1R)],w=S N.1f.4s(r),e=S N.1f.3T([w]);v=N.1c.eg(h.W);b=N.1c.eg(N.1c.bM(v,d));p=S N.3k.2X(e,h.6O,b);p.id=h.id;p.jZ=h.jZ;m.1w(p);K.kn.1w(p)}V{5y}}R m},Bh:Q(j){O a=S N.2B();O f=j.1x;O b=j.W;O c=f.9a();O i=S N.3i(c.x,c.y);O d=K.1i.8c(i);O g=S N.1f.1D(d.x,d.y);if(b.7h||b.7g){O h=2x(b.7h)?0:b.7h;O e=2x(b.7g)?0:b.7g;g.3x(h,-e);a.x=g.x;a.y=g.y;R a}V{a.x=g.x;a.y=g.y;R a}},tb:Q(c,f){O e=c.1x;O a=P;if(K.nY==0){a=e.ta(f,c.W)}V{if(K.nY===1){K.Bf();if((K.1i.2f.1p==="N.1Z.6w")||(K.1i.2f.1p==="N.1Z.b9")){O d=K.1i.2f.kl(c.id,c.W,c.1x.9a());a=e.nU(f,d.w,d.h,c.W)}V{O d=K.1i.2f.kl(c.1x.9a(),c.W);a=e.nU(f,d.w,d.h,c.W)}}V{R P}}O b=[];if((c.W.8z%2R)==0){b=[{x:a.1s,y:a.1t},{x:a.1I,y:a.1t},{x:a.1I,y:a.1L},{x:a.1s,y:a.1L},{x:a.1s,y:a.1t}]}V{b=K.sX(a,f,c.W.8z)}e.2c=S N.1U(b[1].x,b[3].y,b[2].x,b[4].y);R b},Bg:Q(k,f){O j,c,a,g,i;O d=k.1x.ba;O b=k.W;O e=N.1c.eg(f);if(b.3W&&b.3W!=="cm"){5U(b.3W){1N"lt":e.x+=d.w/2;e.y+=d.h/2;1F;1N"lm":e.x+=d.w/2;1F;1N"lb":e.x+=d.w/2;e.y-=d.h/2;1F;1N"ct":e.y+=d.h/2;1F;1N"cb":e.y-=d.h/2;1F;1N"rt":e.x-=d.w/2;e.y+=d.h/2;1F;1N"rm":e.x-=d.w/2;1F;1N"rb":e.x-=d.w/2;e.y-=d.h/2;1F;49:1F}}c=e.x-d.w/2;a=e.y+d.h/2;if(b.7f&&b.7f==="n0"){i=e.x+d.w/2+2g(3t(b.4h)/2)}V{i=e.x+d.w/2}g=e.y-d.h/2;j=S N.1U(c,a,i,g);O h=[];if((b.8z%2R)==0){h=[{x:j.1s,y:j.1t},{x:j.1I,y:j.1t},{x:j.1I,y:j.1L},{x:j.1s,y:j.1L},{x:j.1s,y:j.1t}]}V{h=K.sX(j,f,b.8z)}k.1x.2c=S N.1U(h[1].x,h[3].y,h[2].x,h[4].y);R h},Bf:Q(){O a=K.1i;if(a.2f.kl){R}if((a.2f.1p==="N.1Z.6w")||(a.2f.1p==="N.1Z.b9")){a.2f.kl=Q(p,r,b){O n=K.2r();O s=0;O d=[];O j=(b.x/n+K.1s);O h=(b.y/n-K.1t);O g=K.6N(p+K.el,"99");g.2i(P,"x",j);g.2i(P,"y",-h);if(r.8z){g.2i(P,"3K","5m("+r.8z+" "+j+","+(-h)+")")}if(r.8b){g.2i(P,"2j",r.8b)}if(r.d3){g.2i(P,"2J",0)}if(r.8a){g.2i(P,"9H-t9",r.8a)}if(r.4h){g.2i(P,"9H-1G",r.4h)}if(r.79){g.2i(P,"9H-t8",r.79)}if(r.7f){g.2i(P,"9H-W",r.7f)}if(r.hJ===1d){g.2i(P,"4m-1n","6I");g.d5=p}V{g.2i(P,"4m-1n","2L")}O o=r.3W||"cm";g.2i(P,"99-3h",N.1Z.6w.9G[o[0]]||"ki");if(N.fO===1d){g.2i(P,"Be-nW",N.1Z.6w.9G[o[1]]||"Bd")}O e=r.5k.4U("\\n");O c=e.1a;4W(g.b8.1a>c){g.2T(g.nX)}1h(O q=0;q<c;q++){O f=K.6N(p+K.el+"Bc"+q,"Bb");if(r.hJ===1d){f.d5=p;f.t7=b;f.d4=b.1p}if(N.fO===1b){f.2i(P,"nW-hI",N.1Z.6w.t6[o[1]]||"-35%")}f.c2("x",j);if(q==0){O k=N.1Z.6w.t5[o[1]];if(k==P){k=-0.5}f.c2("dy",(k*(c-1))+"em")}V{f.c2("dy","kk")}f.nV=(e[q]==="")?" ":e[q];if(!f.2V){g.1V(f)}d.1w(f)}if(!g.2V){K.c0.1V(g)}1h(O q=0;q<d.1a;q++){O t=d[q];O m=t.MO();if(s<m){s=m}}O l=S 78();if(s){l.w=s}V{R P}l.h=r.4h;l.Ba=c;R l}}V{a.2f.kl=Q(p,b){b=N.1c.1K({8b:"#aq",3W:"cm"},b);O q=K.7i(p);O m=0;if(b.7h||b.7g){O l=2x(b.7h)?0:b.7h;O d=2x(b.7g)?0:b.7g;q[0]+=l;q[1]-=d}K.5O("4C");K.1u.7Q=b.8b;K.1u.5l=b.d3||1;O f=[b.7f?b.7f:"bc","bc",b.79?b.79:"bc",b.4h?b.4h:"kk",b.8a?b.8a:"t4-t3"].6b(" ");O e=b.5k.4U("\\n");O k=e.1a;if(K.1u.fN){K.1u.9H=f;K.1u.kj=N.1Z.5a.9G[b.3W[0]]||"3U";K.1u.sZ=N.1Z.5a.9G[b.3W[1]]||"ki";O n=N.1Z.5a.bb[b.3W[1]];if(n==P){n=-0.5}O o=K.1u.ek("Mg").1E||K.1u.ek("xx").1A;q[1]+=o*n*(k-1);1h(O g=0;g<k;g++){O j=K.1u.ek(e[g]).1A;if(m<j){m=j}}}V{if(K.1u.kh){K.1u.sY=f;O c=N.1Z.5a.bb[b.3W[0]];if(c==P){c=-0.5}O n=N.1Z.5a.bb[b.3W[1]];if(n==P){n=-0.5}O o=K.1u.kg("xx");q[1]+=o*(1+(n*k));1h(O g=0;g<k;g++){O j=K.1u.ek(e[g]).1A;if(m<j){m=j}}}}K.5O("4C");O h=S 78();if(m){h.w=m}V{R P}h.h=b.4h;h.Ba=e.1a;R h}}},nU:Q(g,j,f,c){O d,e,b,k,m;O i=N.1c.eg(g);O h=c.5k||K.1i.99;O a=h.4U("\\n");O l=a.1a;j=3t(j);f=3t(f);if(l>1){f=3t(f)*l}if(c.3W&&c.3W!=="cm"){5U(c.3W){1N"lt":i.x+=j/2;i.y+=f/2;1F;1N"lm":i.x+=j/2;1F;1N"lb":i.x+=j/2;i.y-=f/2;1F;1N"ct":i.y+=f/2;1F;1N"cb":i.y-=f/2;1F;1N"rt":i.x-=j/2;i.y+=f/2;1F;1N"rm":i.x-=j/2;1F;1N"rb":i.x-=j/2;i.y-=f/2;1F;49:1F}}K.ba.h=f;K.ba.w=j;e=i.x-3t(j)/2;b=i.y+3t(f)/2;m=i.x+3t(j)/2;k=i.y-3t(f)/2;d=S N.1U(e,b,m,k);R d},sX:Q(a,c,e){O g=S N.1f.1D(a.1s,a.1t);O b=S N.1f.1D(a.1I,a.1t);O j=S N.1f.1D(a.1I,a.1L);O d=S N.1f.1D(a.1s,a.1L);O h=[];h.1w(K.kf(g.x,g.y,c.x,c.y,e));h.1w(K.kf(b.x,b.y,c.x,c.y,e));h.1w(K.kf(j.x,j.y,c.x,c.y,e));h.1w(K.kf(d.x,d.y,c.x,c.y,e));O k=[];1h(O f=0;f<h.1a;f++){k.1w({x:h[f].x,y:h[f].y})}k.1w({x:h[0].x,y:h[0].y});R k},kf:Q(a,h,e,d,g){O f=S 78(),b,c;h=-h;d=-d;g=-g;b=(a-e)*1k.8y((g/2R)*1k.PI)-(h-d)*1k.7P((g/2R)*1k.PI)+e;c=(a-e)*1k.7P((g/2R)*1k.PI)+(h-d)*1k.8y((g/2R)*1k.PI)+d;f.x=b;f.y=-c;R f},B9:Q(a,q){if(q.1a!==5){R P}O d=[{x:a.1s,y:a.1t},{x:a.1I,y:a.1t},{x:a.1I,y:a.1L},{x:a.1s,y:a.1L},{x:a.1s,y:a.1t}];O e=1b,m=d.1a,f=q.1a;O l=0,k=0,p="",c="";1h(O h=0;h<m-1;h++){1h(O g=0;g<f-1;g++){O n=N.1c.B7(d[h],d[h+1],q[g],q[g+1]);if(n.1p==="N.1f.1D"){o(q[g]);o(q[g+1]);e=1d}}}if(e){O b={sW:c,sV:p,fM:l,ke:k};R b}V{R P}Q o(r){if(!a.c1(r.x,r.y)){if(r.y<a.1t){O i=1k.3N(a.1t-r.y);if(i>k){k=i;p="1t"}}if(r.y>a.1L){O i=1k.3N(r.y-a.1L);if(i>k){k=i;p="1L"}}if(r.x<a.1s){O j=1k.3N(a.1s-r.x);if(j>l){l=j;c="1s"}}if(r.x>a.1I){O j=1k.3N(r.x-a.1I);if(j>l){l=j;c="1I"}}}}},B8:Q(b,h){O g=b.1a,a=h.1a;if(g!==5||a!==5){R P}O e=1b;1h(O d=0;d<g;d++){if(K.sU(b[d],h)){e=1d;1F}}1h(O d=0;d<a;d++){if(K.sU(h[d],b)){e=1d;1F}}1h(O d=0;d<g-1;d++){if(e){1F}1h(O c=0;c<a-1;c++){O f=N.1c.B7(b[d],b[d+1],h[c],h[c+1]);if(f.1p==="N.1f.1D"){e=1d;1F}}}R e},sU:Q(f,d){1h(O e=1b,c=-1,a=d.1a,b=a-1;++c<a;b=c){((d[c].y<=f.y&&f.y<d[b].y)||(d[b].y<=f.y&&f.y<d[c].y))&&(f.x<(d[b].x-d[c].x)*(f.y-d[c].y)/(d[b].y-d[c].y)+d[c].x)&&(e=!e)}R e},fI:Q(a){N.7e.1g.fI.1j(K,1r);K.B6()},B3:Q(d){if(!(N.1c.4f(d))){d=[d]}if(!K.1i){R}K.1i.2f.7O=1d;1h(O c=0,a=d.1a;c<a;c++){if(c===(a-1)){K.1i.2f.7O=1b}O b=d[c];b.1i=K.1i;K.1i.3V(b,2q,{hH:1d})}},B6:Q(){O a=K.1i;if(!a){R}O b=K;a.7u=Q(d,c){N.1C.2X.1g.7u.1j(K,[d,c]);a.ej()};a.3V=Q(c,e,d){if(c.1x.1p==="N.1f.d2"){R 1d}V{R N.1C.2X.1g.3V.1j(K,[c,e,d])}};a.ej=Q(c){a.2f.5z();N.1C.2X.1g.ej.1j(K,[c]);O d=b.B5(a.2z);O e=b.B4(d);b.B3(e);if((a.2f.1p==="N.1Z.6w")||(a.2f.1p==="N.1Z.b9")){a.2f.ap.W.3G="4m";a.2f.c0.W.3G="4m"}V{a.2f.66.W.3G="4m"}}},1p:"N.7e.d2"});N.1v.AT=N.1z(N.1v,{3R:P,98:1d,sS:P,sT:1b,B0:1b,kd:P,1o:Q(a){N.1v.1g.1o.1j(K,[a]);K.3R=[];K.kd={}},1m:Q(){N.1v.1g.1m.1j(K,1r);1h(O a,b=K.3R.1a-1;b>=0;b--){a=K.3R[b];if(a.1n){a.1n.un({2p:K.sQ,2a:K.sP})}N.1H.9F(a.bZ);a.bZ=P}K.kd=P},2p:Q(){if(N.1v.1g.2p.1j(K,1r)){O c;1h(O b=0,a=K.3R.1a;b<a;b++){c=K.3R[b];if(c===K.sS||(K.sT&&K.kd[c.id])){c.2p()}}if(K.sT===1d){K.sS=P}K.3y();R 1d}V{R 1b}},2a:Q(){if(N.1v.1g.2a.1j(K,1r)){O c;1h(O b=0,a=K.3R.1a;b<a;b++){c=K.3R[b];K.kd[c.id]=c.2a()}K.3y();R 1d}V{R 1b}},2H:Q(){N.1v.1g.2H.1j(K,1r);K.sR(K.3R);R K.1q},3y:Q(){1h(O b=K.1q.b8.1a,c=b-1;c>=0;c--){K.1q.2T(K.1q.b8[c])}K.1q.5N="";if(K.3I){1h(O c=0,a=K.3R.1a;c<a;c++){K.1q.1V(K.3R[c].bZ)}}},AW:Q(d){if(!K.3I){R 1b}if(d.2E===N.1v.B2){d.nT();R}if(d.2E===N.1v.B1){if(d.3I){d.2a()}V{d.2p()}R}if(K.B0&&d.3I){d.2a()}V{O e;1h(O b=0,a=K.3R.1a;b<a;b++){e=K.3R[b];if(e!==d&&(e.2E===N.1v.kc||e.2E==P)){e.2a()}}d.2p()}},AZ:Q(b){if(!(N.1c.4f(b))){b=[b]}K.3R=K.3R.b1(b);1h(O d=0,a=b.1a;d<a;d++){O c=1Q.2G("1q");c.3M=b[d].5M+"sO";b[d].bZ=c;if(b[d].8x!=""){b[d].bZ.8x=b[d].8x}N.1H.3m(b[d].bZ,"2U",N.2u.3E(K.AX,K,b[d]));N.1H.3m(b[d].bZ,"4F",N.2u.3E(K.AV,K,b[d]));N.1H.3m(b[d].bZ,"48",N.2u.59(N.1H.2K))}if(K.U){K.sR(b);K.3y()}},sR:Q(b){O d;1h(O c=0,a=b.1a;c<a;c++){d=b[c];if(d.98===1d){d.98=1b;K.U.kb(d);d.98=1d}V{K.U.kb(d);d.2a()}d.1n.on({2p:K.sQ,2a:K.sP})}},sQ:Q(){O a=K.bZ;a.3M=a.3M.4D(/sO$/,"AY")},sP:Q(){O a=K.bZ;a.3M=a.3M.4D(/AY$/,"sO")},AX:Q(b,a){N.1H.2K(a?a:2k.b7);K.AW(b)},AV:Q(b,a){N.1H.2K(a?a:2k.b7)},ka:Q(c,a){O d=(2t a.d1==="Q");O b=N.3Q.4V(K.3R,Q(e){R e[c]===a||(d&&a.d1(e[c]))});R b},MN:Q(a){R K.ka("2l",a)},AU:Q(a){R K.ka("1p",a)},1p:"N.1v.AT"});N.1v.k5=N.1z(N.1v,{nQ:P,nO:P,bV:1b,97:1d,bY:1b,k6:1b,bX:1b,hE:1b,5f:1b,fK:Q(){},cZ:Q(){},fJ:Q(){},2y:P,64:P,1i:P,1O:P,3F:P,nM:P,nS:1b,7N:"7d",1X:P,1o:Q(c,a){N.1v.1g.1o.1j(K,[a]);if(K.2y===P){K.2y=K}K.hB(c);O b={2U:K.ei,97:K.hF,6f:K.d0,4t:K.eh};K.3F=N.1c.1K(b,K.3F);K.1X={1J:S N.1Y.3k(K,K.1i,K.3F,{64:K.64,k9:K.nS})};if(K.5f){K.1X.5f=S N.1Y.k8(K,{7c:K.nK},{nR:"AS"})}},hB:Q(a){if(N.1c.4f(a)){K.1O=a;K.1i=S N.1C.2X.k7(K.id+"AR",{1O:a})}V{K.1i=a}},1m:Q(){if(K.3I&&K.1O){K.U.b6(K.1i)}N.1v.1g.1m.1j(K,1r);if(K.1O){K.1i.1m()}},2p:Q(){if(!K.3I){if(K.1O){K.U.fL(K.1i)}K.1X.1J.2p();if(K.5f&&K.1X.5f){K.1X.5f.2p()}}R N.1v.1g.2p.1j(K,1r)},2a:Q(){if(K.3I){K.1X.1J.2a();if(K.1X.5f){K.1X.5f.2a()}if(K.1O){K.U.b6(K.1i)}}R N.1v.1g.2a.1j(K,1r)},al:Q(b){O f=K.1O||[K.1i];O e,d;1h(O a=0;a<f.1a;++a){e=f[a];1h(O c=e.5Z.1a-1;c>=0;--c){d=e.5Z[c];if(!b||b.hG!==d){K.b5(d)}}}},ei:Q(b,a){if(!K.bX){O c=(N.1c.2S(b.1i.5Z,b)>-1);if(c){if(K.nP()){K.b5(b)}V{if(!K.ee()){K.al({hG:b});if(K.k6){K.cZ.4g(K.2y,b,a)}}}}V{if(!K.ee()){K.al({hG:b})}K.7d(b,a)}}},ee:Q(){R K.bV||(K.1X.1J.7b&&K.1X.1J.7b[K.nQ])},nP:Q(){R K.bY||(K.1X.1J.7b&&K.1X.1J.7b[K.nO])},hF:Q(a){if(!K.bX&&K.97){K.al()}},d0:Q(c,a){O b=c.1i;if(K.bX){if(K.hE){K.ef(c)}V{if(N.1c.2S(b.5Z,c)===-1){K.7d(c,a)}}}V{K.1i.U.6v.W.3G="4m"}},eh:Q(a){if(K.bX){if(K.hE){if(a.ao===K.id){if(a.7t&&a.7t!==K.id){2s a.ao;O b=K.U.nN(a.7t);if(b){b.ef(a)}}V{K.hC(a)}}}V{K.b5(a)}}V{K.1i.U.6v.W.3G=""}},ef:Q(c){O b=c.1i;if(b 1W N.1C.nL){R}O a=K.1n.1M("AQ",{1J:c});if(a!==1b){c.7t=c.ao;c.ao=K.id;O d=c.bW=N.1c.eg(K.nM);c.7N=K.7N;if(d&&!d.5k){if(c.W&&c.W.5k){d.5k=c.W.5k}}b.3V(c,d,{hD:1d});K.1n.1M("AP",{1J:c})}},hC:Q(b){O a=b.1i;if(a 1W N.1C.nL){R}if(b.7t==2q){2s b.ao}V{if(b.7t===K.id){2s b.7t}V{b.ao=b.7t;2s b.7t}}if(b.bW||b.bW==P){2s b.bW}b.7N="49";a.3V(b,b.W||b.1i.W||"49",{hD:1d});K.1n.1M("AO",{1J:b})},7d:Q(d,b){O a=K.fK.4g(K.2y,d);O c=d.1i;if(a!==1b){a=c.1n.1M("sN",{1J:d});if(a!==1b){c.5Z.1w(d);K.ef(d);if(!K.1X.1J.7M){K.1X.1J.7M=c.5Z[0]}c.1n.1M("sM",{1J:d,7b:b});K.cZ.4g(K.2y,d,b)}}},b5:Q(b){O a=b.1i;K.hC(b);N.1c.am(a.5Z,b);a.1n.1M("sL",{1J:b});K.fJ.4g(K.2y,b)},nK:Q(e){if(e 1W N.1U){O h=K.U.6M({x:e.1s,y:e.1L});O k=K.U.6M({x:e.1I,y:e.1t});O a=S N.1U(h.1P,h.1R,k.1P,k.1R);if(!K.ee()){K.al()}O j=K.bV;K.bV=1d;O d=K.1O||[K.1i];O f;1h(O b=0;b<d.1a;++b){f=d[b];1h(O c=0,g=f.2z.1a;c<g;++c){O m=f.2z[c];if(!m.cY()){5y}if(K.64==P||N.1c.2S(K.64,m.1x.1p)>-1){if(a.fA().6L(m.1x)){if(N.1c.2S(f.5Z,m)===-1){K.7d(m)}}}}}K.bV=j}},3a:Q(a){K.1X.1J.3a(a);if(K.5f){K.1X.5f.3a(a)}N.1v.1g.3a.1j(K,1r)},fI:Q(b){O a=K.3I;K.al();K.2a();if(K.1O){K.1i.1m();K.1O=P}K.hB(b);K.1X.1J.1i=K.1i;if(a){K.2p()}},1p:"N.1v.k5"});N.1v.sH=N.1z(N.1v,{2P:["ed","nI"],89:P,3F:P,sI:"AN",k3:1b,sJ:{MM:["dd"],ML:["mi","ft","in"],AN:["km","m"]},AL:e8,fF:P,ak:1b,nJ:1b,1o:Q(b,a){K.2P=N.1v.sH.1g.2P.b1(N.1v.1g.2P);N.1v.1g.1o.1j(K,[a]);O c={7c:K.nu,3l:K.AM};if(K.nJ){c.fH=K.sK}K.3F=N.1c.1K(c,K.3F);K.89=N.1c.1K({ak:K.ak},K.89);K.3s=S b(K,K.3F,K.89)},2a:Q(){K.k4();R N.1v.1g.2a.1j(K,1r)},8w:Q(){K.k4();K.3s.8w()},MK:Q(a){K.nJ=a;if(K.nJ){K.3F.fH=K.sK}V{2s K.3F.fH}},MJ:Q(b,a){O c=K.3I;if(c){K.2a()}K.3s=S b(K,K.3F,a);if(c){K.2p()}},nu:Q(a){K.k4();K.ed(a,"ed")},AM:Q(a,b){K.k4();b=b.1T();if(K.3s.fG(K.3s.7b)){K.ed(b,"nI")}V{K.fF=2k.6u(N.2u.3E(Q(){K.fF=P;K.ed(b,"nI","2U")},K),K.AL)}},sK:Q(a,c,b){if(b&&K.fF===P&&!K.3s.fG(K.3s.7b)){K.ed(c.1x,"nI","3x")}},k4:Q(){if(K.fF!==P){2k.6t(K.fF);K.fF=P}},ed:Q(e,b,d){O c,a;if(e.1p.2S("2n")>-1){c=K.AJ(e);a=1}V{c=K.AK(e);a=2}K.1n.1M(b,{ed:c[0],2N:c[1],88:a,1x:e,2E:d})},AK:Q(f){O b=K.sJ[K.sI];O e,d;1h(O c=0,a=b.1a;c<a;++c){e=b[c];d=K.94(f,e);if(d>1){1F}}R[d,e]},94:Q(f,a){O b,c;if(K.k3){b=f.fE(K.U.5Y());c="m"}V{b=f.94();c=K.U.bU()}O e=N.fD[a];if(e){O d=N.fD[c];b*=1k.2Y((d/e),2)}R b},AJ:Q(f){O b=K.sJ[K.sI];O e,d;1h(O c=0,a=b.1a;c<a;++c){e=b[c];d=K.ec(f,e);if(d>1){1F}}R[d,e]},ec:Q(f,a){O b,c;if(K.k3){b=f.nH(K.U.5Y());c="m"}V{b=f.ec();c=K.U.bU()}O e=N.fD[a];if(e){O d=N.fD[c];b*=(d/e)}R b},1p:"N.1v.sH"});N.1v.sD=N.1z(N.1v,{2P:["AG","AE","AI"],hA:b4.hA,3E:1d,sF:1b,nG:P,1o:Q(a){K.2P=N.1v.sD.1g.2P.b1(N.1v.1g.2P);K.nG={};N.1v.1g.1o.1j(K,[a])},1m:Q(){K.2a();N.1v.1g.1m.1j(K,1r)},2p:Q(){if(!K.hA){K.1n.1M("AI");R 1b}if(N.1v.1g.2p.1j(K,1r)){if(K.sF){K.sG=K.hA.MI(N.2u.3E(K.sE,K),N.2u.3E(K.5W,K),K.nG)}V{K.AF()}R 1d}R 1b},2a:Q(){if(K.3I&&K.sG!==P){K.hA.MH(K.sG)}R N.1v.1g.2a.1j(K,1r)},sE:Q(b){O a=S N.3i(b.AH.MG,b.AH.MF).3K(S N.3g("4E:9E"),K.U.5Y());if(K.3E){K.U.5X(a)}K.1n.1M("AG",{2v:b,3l:S N.1f.1D(a.1P,a.1R)})},AF:Q(){if(!K.3I||K.sF){R 1b}K.hA.ME(N.2u.3E(K.sE,K),N.2u.3E(K.5W,K),K.nG);R 1d},5W:Q(a){K.1n.1M("AE",{77:a})},1p:"N.1v.sD"});N.6d=N.1z({5j:0,1o:Q(a){N.1c.1K(K,a)},1T:Q(){O fC=nC(K.1p);R S fC(N.1c.1K({},K))},1p:"N.6d"});N.6d.1D=N.1z(N.6d,{1o:Q(a){N.6d.1g.1o.1j(K,1r)},1p:"N.6d.1D"});N.6d.sC=N.1z(N.6d,{1o:Q(a){N.6d.1g.1o.1j(K,1r)},1p:"N.6d.sC"});N.6d.3T=N.1z(N.6d,{1o:Q(a){N.6d.1g.1o.1j(K,1r)},1p:"N.6d.3T"});N.6d.sB=N.1z(N.6d,{1o:Q(a){N.6d.1g.1o.1j(K,1r)},1p:"N.6d.sB"});N.6d.sA=N.1z(N.6d,{1o:Q(a){N.6d.1g.1o.1j(K,1r)},1p:"N.6d.sA"});N.b3={5x:P,AC:"en",7K:Q(){if(!N.b3.5x){N.b3.AD()}R N.b3.5x},AD:Q(b){O d;if(!b){b=(N.93.2l==="hz")?b4.MD:b4.MC}O c=b.4U("-");c[0]=c[0].eb();if(2t N.b3[c[0]]==="6q"){d=c[0]}if(c[1]){O a=c[0]+"-"+c[1].hy();if(2t N.b3[a]==="6q"){d=a}}if(!d){d=N.b3.AC}N.b3.5x=d},4c:Q(b,a){O d=N.b3[N.b3.7K()];O c=d&&d[b];if(!c){c=b}if(a){c=N.6K.5L(c,a)}R c}};N.bT=N.b3.4c;N.4d=N.1z({1B:P,bR:P,bS:P,1a:P,2C:P,8v:P,hx:3,nF:P,nE:P,4B:P,1o:Q(a){if(!a){R 1b}O b=K;if(N.1c.4f(a)){b.bR=a;b.1a=a.1a;b.8v=b.1a;if(b.1a==1){b.1B=a[0]}V{b.bS=2g(1k.nD()*b.1a);b.1B=a[b.bS]}}V{b.8v=1;b.1B=a}if(N.1c.4f(a)&&!b.Ax()){b.1B=a[0];b.8v=1}b.4B=N.1c.4B(b.1B)},1m:Q(){O a=K;if(N.1c.4f(a.bR)){a.bR=P;a.bS=P;a.1a=P;a.8v=P}a.1B=P;a.2C=P;a.nF=P;a.nE=P;a.4B=P},8m:Q(b){O c=K;b.1B=b.1B||c.1B;b.4B=c.4B;if(N.8u.9C){O a=b.1B.aU(b.1B.1a-1,b.1B.1a);if(b.1B.2S("?")>-1&&a==="?"){b.1B+=N.8u.9C.jU()}V{if(b.1B.2S("?")>-1&&a!=="?"){b.1B+="&"+N.8u.9C.jU()}V{b.1B+="?"+N.8u.9C.jU()}}}c.Ay();c.nF=b.6H;c.nE=b.5W;b.2y=c;b.6H=c.AB;b.5W=c.AA;c.2C=b;N.1c.sz(c.2C)},AB:Q(a){O b=K;b.nF(a)},AA:Q(a){O b=K;if(b.8v>0){b.8v--;b.Az()}V{b.nE(a)}},Az:Q(){O d=K,b=d.2C.1B,c=/^6s:\\/\\/([a-z]{9}|(\\d+\\.){3}\\d+):\\d{0,4}/;d.bS=2g(1k.nD()*d.1a);d.1B=d.bR[d.bS];b=b.4D(c,c.fB(d.1B)[0]);O a=N.1c.4B(b);if(a){if(b.2S(".5I")>0){b=b.4D(/.5I/,".5J")}}V{if(!(b.2S(".5I")>0)){b=b.4D(/.5J/,".5I")}}d.2C.1B=b;d.2C.4B=a;N.1c.sz(d.2C)},Ay:Q(){O a=K;if(a.k2){if(a.8v>a.hx){if(a.k2>a.hx){a.8v=a.hx}V{a.8v=a.k2}}V{if(a.k2<a.8v){a.8v=a.k2}}}V{if(a.8v>a.hx){a.8v=a.hx}}a.8v--},Ax:Q(){O a=K;if(a.1p=="N.1l.MB"||a.1p=="N.1l.MA"){R 1b}R 1d},1p:"N.4d"});N.1l.At=N.1z(N.4d,{2P:["56","5H"],1B:P,4B:P,1o:Q(b,a){if(!b){R 1b}if(a){N.1c.1K(K,a)}O c=K;c.1n=S N.4l(c,P,c.2P,1d);if(c.2F 1W 78){c.1n.on(c.2F)}c.1B=b;c.4B=N.1c.4B(c.1B)},1m:Q(){N.4d.1g.1m.1j(K,1r);O a=K;a.2P=P;if(a.1n){a.1n.1m();a.1n=P}if(a.2F){a.2F=P}},8n:Q(){O c=K;O b=/^6s:\\/\\/([a-z]{9}|(\\d+\\.){3}\\d+):\\d{0,4}\\/Mz\\/My/,a=b.fB(c.1B)[0]+"/Mx.5J";if(!c.4B){a=a.4D(/.5J/,".5I")}N.1c.sz({1B:a,6p:"bO",2y:c,4B:c.4B,6H:c.Aw,5W:c.Au})},Aw:Q(3r){O me=K;O 1B,ea={},bR=[],re=/^6s:\\/\\/([a-z]{9}|(\\d+\\.){3}\\d+):\\d{0,4}/,bS=re.fB(me.1B)[0].1a,Av=me.1B.9D(bS);if(3r.7a==4&&3r.b2==cW){ea=nC(3r.hw)}V{if(3r.5V){ea=3r}V{me.1n.1M("56",[me.1B]);R}}if(57.1a==0){me.1n.1M("56",[me.1B])}V{1h(O i=0,nB=ea.1a;i<nB;i++){1B="6s://"+ea[i].Mw+Av;bR.1w(1B)}me.1n.1M("56",bR)}},Au:Q(a){O b=K;b.1n.1M("56",[b.1B])},1p:"N.1l.At"});N.5h=N.1z({nA:P,1o:Q(a){K.nA=a},1m:Q(){K.nA=P},1p:"N.5h"});N.8l=N.1z({5x:P,nz:P,1o:Q(c,b){O a=K;a.5x=c;a.nz=b},1m:Q(){O a=K;a.5x=P;a.nz=P},1p:"N.8l"});N.8l.2A=Q(a){if(!a){R}R S N.8l(a.5x,a.nz)};N.9z=N.1z(N.5h,{77:P,1o:Q(a,c){N.5h.1g.1o.1j(K,[c]);O b=K;b.77=a},1m:Q(){N.5h.1g.1m.1j(K);O a=K;if(a.77){a.77.1m();a.77=P}},1p:"N.9z"});N.1l.8s=N.1z({id:0,W:P,b0:P,5K:P,2E:P,5i:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.id=P;a.W=P;a.b0=P;a.5K=P;a.2E=P;a.5i=P},fA:Q(){O b=K,a=b.2E;5U(a){1N N.1l.8t.cX:R b.sx();1N N.1l.8t.e6:R b.As();1N N.1l.8t.sy:R b.Aq();1N N.1l.8t.k0:R b.Ap();1N N.1l.8t.Mv:R b.sx();1N N.1l.8t.Mu:R b.Ar();1N N.1l.8t.Mt:R b.Ao()}},sx:Q(){O e=K,f=e.b0||[],c=e.5K||[],b=f.1a;if(b>0){if(b===1){R S N.1f.1D(c[0].x,c[0].y)}V{1h(O d=0,a=[];d<b;d++){a.1w(S N.1f.1D(c[d].x,c[d].y))}R S N.1f.8k(a)}}V{R P}},As:Q(){O f=K,g=f.b0||[],c=f.5K||[],b=g.1a;if(b>0){if(b===1){1h(O e=0,a=[];e<g[0];e++){a.1w(S N.1f.1D(c[e].x,c[e].y))}if(a[0].3w(a[g[0]-1])){R S N.1f.4s(a)}V{R S N.1f.2n(a)}}V{1h(O e=0,h=[];e<b;e++){1h(O d=0,a=[];d<g[e];d++){a.1w(S N.1f.1D(c[d].x,c[d].y))}h.1w(S N.1f.2n(a));c.6c(0,g[e])}R S N.1f.83(h)}}V{R P}},Ar:Q(){O h=K,c=h.b0||[],k=h.5K||[],g=c.1a;if(g>0){if(g===1){1h(O d=0,a=[];d<c[0];d++){a.1w(S N.1f.1D(k[d].x,k[d].y,k[d].2E))}if(a[0].3w(a[c[0]-1])){O f=N.1f.2n.k1(a);R S N.1f.Ms(f)}V{O f=N.1f.2n.k1(a);R S N.1f.2n(f)}}V{1h(O d=0,e=[];d<g;d++){1h(O b=0,a=[];b<c[d];b++){a.1w(S N.1f.1D(k[b].x,k[b].y))}O f=N.1f.2n.k1(a);e.1w(S N.1f.2n(f));k.6c(0,c[d])}R S N.1f.83(e)}}V{R P}},Aq:Q(){O a=K;R S N.1l.jy.2A(a)},Ap:Q(){O m=K,f=[],e=m.b0||[],o=m.5K||[],l=e.1a;if(l>0){O p=S 3Q();1h(O g=0,q=0,a=[];g<l;g++){1h(O d=0;d<e[g];d++){a.1w(S N.1f.1D(o[q+d].x,o[q+d].y))}q+=e[g];O h=S N.1f.4s(a);if(N.1l.8s.sv(h.1y)>0){f.1w(S N.1f.4s(a))}V{p.1w(S N.1f.3T([S N.1f.4s(a)]))}if(g==l-1){O n=p.1a;if(!!n){p[n-1].1y=p[n-1].1y.b1(f)}V{1h(O c=0,b=f.1a;c<b;c++){p.1w(S N.1f.3T([f[c]]))}}}a=[]}R S N.1f.8W(p)}V{R P}},Ao:Q(){O m=K,f=m.b0||[],o=m.5K||[],l=f.1a;if(l>0){O p=S 3Q();1h(O g=0,q=0,a=[];g<l;g++){1h(O e=0;e<f[g];e++){a.1w(S N.1f.1D(o[q+e].x,o[q+e].y))}q+=f[g];O h=N.1f.2n.k1(a);if(N.1l.8s.sv(h.1y)>0){ny.1w(Mr)}V{O b=S N.1f.3T(h);p.1w(b)}if(g==l-1){O n=p.1a;if(!!n){p[n-1].1y=p[n-1].1y.b1(ny)}V{1h(O d=0,c=ny.1a;d<c;d++){p.1w(S N.1f.3T([ny[d]]))}}}a=[]}R S N.1f.8W(p)}V{R P}},1p:"N.1l.8s"});N.1l.8s.2A=Q(a){if(!a){R}R S N.1l.8s({id:a.id,W:N.1l.dY.2A(a.W),b0:a.b0,5K:a.5K,3U:a.3U,1a:a.1a,An:a.An,Am:a.Am,2E:a.2E})};N.1l.8s.ho=Q(p){if(!p){R}O a=0,g=[],r=[],o=P,t=p.1y,n=p.1p,m={hu:p.sw};if(!2x(p.id)){a=p.id}if(n!="N.1f.4s"&&n!="N.1f.2n"&&(p 1W N.1f.8k||p 1W N.1f.83)){O c=t.1a;1h(O h=0;h<c;h++){O s=t[h].55().1a;g.1w(s);1h(O f=0;f<s;f++){r.1w(S N.1f.1D(t[h].55()[f].x,t[h].55()[f].y))}}o=(n=="N.1f.8k")?N.1l.8t.cX:N.1l.8t.e6}V{if(p 1W N.1f.8W){O c=t.1a;1h(O h=0;h<c;h++){O q=t[h],l=q.1y,b=l.1a;1h(O f=0;f<b;f++){O s=l[f].55().1a+1;g.1w(s);1h(O e=0;e<s-1;e++){r.1w(S N.1f.1D(l[f].55()[e].x,l[f].55()[e].y))}r.1w(S N.1f.1D(l[f].55()[0].x,l[f].55()[0].y))}}o=N.1l.8t.k0}V{if(p 1W N.1f.3T){O c=t.1a;1h(O h=0;h<c;h++){O s=t[h].55().1a+1;g.1w(s);1h(O f=0;f<s-1;f++){r.1w(S N.1f.1D(t[h].55()[f].x,t[h].55()[f].y))}r.1w(S N.1f.1D(t[h].55()[0].x,t[h].55()[0].y))}o=N.1l.8t.k0}V{O d=p.55().1a;1h(O f=0;f<d;f++){r.1w(S N.1f.1D(p.55()[f].x,p.55()[f].y))}if(p 1W N.1f.4s){r.1w(S N.1f.1D(p.55()[0].x,p.55()[0].y));d++}g.1w(d);o=(p 1W N.1f.1D)?N.1l.8t.cX:N.1l.8t.e6}}}R S N.1l.8s({id:a,W:P,b0:g,5K:r,2E:o,5i:m})};N.1l.8s.sv=Q(c){O d=c.1a;if(d<3){R 0}O b=c[0].y*(c[d-1].x-c[1].x);c.1w(c[0]);1h(O a=1;a<d;a++){b+=c[a].y*(c[a-1].x-c[a+1].x)}R b*0.5};N.1l.jS=N.1z({jY:P,jX:P,1x:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.jY=P;a.jX=P;if(a.1x){a.1x.1m();a.1x=P}},zL:Q(){O g,b,f,a={},e=K,d;g=e.jY;b=e.jX;1h(O c in g){a[g[c]]=b[c]}if(e.1x){f=e.1x.fA()}d=S N.3k.2X(f,a);if(e.1x&&e.1x.id){d.jZ=e.1x.id}R d},1p:"N.1l.jS"});N.1l.jS.2A=Q(a){O b=K,c=P;if(!a){R}c=a.1x;if(c){c=N.1l.8s.2A(c)}R S N.1l.jS({jY:a.jY,jX:a.jX,1x:c})};N.1l.Ad=N.1z({Al:P,su:P,Ak:P,Aj:P,Ai:P,Ah:P,Ag:P,nx:P,Af:P,Ae:P,nw:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.Al=P;a.su=P;a.Ak=P;a.Aj=P;a.Ai=P;a.Ah=P;a.Ag=P;a.nx=P;a.Af=P;a.Ae=P;a.nw=P},1p:"N.1l.Ad"});N.1l.s9=N.1z({Ac:P,Ab:P,Aa:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.Ac=P;a.Ab=P;a.Aa=P},3P:Q(){O a={};a=N.1c.bM(a,K);R a},1p:"N.1l.s9"});N.1l.A4=N.1z({nv:P,A9:P,A8:P,A7:P,A6:P,2l:P,A5:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;if(a.nv){a.nv.1m();a.nv=P}a.A9=P;a.A8=P;a.A7=P;a.A6=P;a.2l=P;a.A5=P},1p:"N.1l.A4"});N.1l.sp=N.1z(N.5h,{3r:P,1o:Q(a,c){N.5h.1g.1o.1j(K,[c]);O b=K;b.3r=a},1m:Q(){N.5h.1g.1m.1j(K);O a=K;if(a.3r){a.3r.1m();a.3r=P}},1p:"N.1l.sp"});N.1l.A2=N.1z({1x:P,aZ:N.1l.A3.st,5i:P,1o:Q(b,a){if(!b){R}K.1x=b;if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.1x=P;a.aZ=P;a.5i=P},1p:"N.1l.A2"});N.1l.jV=N.1z({e9:P,3H:P,aZ:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.e9=P;a.3H=P;a.aZ=P},1p:"N.1l.jV"});N.1l.jV.2A=Q(a){if(!a){R}R S N.1l.jV({e9:a.e9,3H:a.3H,aZ:a.aZ})};N.1l.zZ=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,4a:P,sr:N.1l.sq.ss,1o:Q(b,a){N.4d.1g.1o.1j(K,[b]);if(a){N.1c.1K(K,a)}O c=K;c.1n=S N.4l(c,P,c.2P,1d);if(c.2F 1W 78){c.1n.on(c.2F)}},1m:Q(){N.4d.1g.1m.1j(K,1r);O a=K;a.2P=P;if(a.1n){a.1n.1m();a.1n=P}if(a.2F){a.2F=P}if(a.4a){a.4a.1m();a.4a=P}a.sr=P},8n:Q(b){if(!b){R}O f=K,g=b.1x,d=0,e=P,a=P,c=P;if(!g){R}c=f.1B.8X(f.1B.1a-1,1);if(f.sr===N.1l.sq.jW){if(f.4B){f.1B+=((c==="/")?"e9.5J?":"/e9.5J?")}V{f.1B+=((c==="/")?"e9.5I?":"/e9.5I?")}}V{if(f.4B){f.1B+=((c==="/")?"3H.5J?":"/3H.5J?")}V{f.1B+=((c==="/")?"3H.5I?":"/3H.5I?")}}O k=N.1l.8s.ho(g);if(!k){R}d=k.b0[0];e=k.5K.6c(0,d);O i,h,j;if(b.5i){if(2t(b.5i)==="6q"){h=b.5i.hv;i=\'{"hu"\'+h.aU(h.2S(":"),h.1a)+"}"}V{if(2t(b.5i)==="aY"){i=\'{"hu"\'+b.5i.aU(b.5i.2S(":"),b.5i.1a)+"}"}}j={A1:N.1c.7q(e),aZ:b.aZ,5i:i}}V{j={A1:N.1c.7q(e),aZ:b.aZ}}f.8m({6p:"bO",3J:j,2y:f,6H:f.nu,5W:f.A0})},nu:Q(b){O d=K,c=P,a=P;b=N.1c.6o(b);a=N.1l.jV.2A(b);d.4a=a;c=S N.1l.sp(a,b);d.1n.1M("56",c)},A0:Q(b){O e=K,d=P,a=P,c=P;b=N.1c.6o(b);d=b.77;if(!d){R}a=N.8l.2A(d);c=S N.9z(a,b);e.1n.1M("5H",c)},1p:"N.1l.zZ"});N.1l.jT=N.1z({3D:P,2c:P,6J:P,7L:P,bQ:P,58:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.3D=P;a.2c=P;a.6J=P;a.7L=P;a.bQ=P;a.58=P},1p:"N.1l.jT"});N.1l.jT.2A=Q(a){if(!a||!a.5i){R}O c=P;if(!a.5i.zY){O b=P}V{O d=a.5i.zY;b=d.Mq.Mp.Mo;c=a.5i.hu}R S N.1l.jT({3D:a.3D,2c:a.2c,6J:a.6J,7L:a.7L,bQ:a.5i.bQ,58:b,zX:c})};N.1l.sn=N.1z(N.5h,{3r:P,1o:Q(a,c){N.5h.1g.1o.1j(K,[c]);O b=K;b.3r=a},1m:Q(){N.5h.1g.1m.1j(K);O a=K;if(a.3r){a.3r.1m();a.3r=P}},1p:"N.1l.sn"});N.1l.nt=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,2Q:P,4a:P,1o:Q(c,b){N.4d.1g.1o.1j(K,1r);if(b){N.1c.1K(K,b)}O d=K;d.1n=S N.4l(d,P,d.2P,1d);d.2F&&d.1n.on(d.2F);d.1B+=d.4B?".5J":".5I";if(d.2Q){if(2t d.2Q==="aY"){d.2Q=S N.3g(d.2Q)}O a=d.2Q.7K().4U(":");if(a 1W 3Q&&a.1a===2){d.1B+=\'?5i={"hu":\'+a[1]+"}"}}},1m:Q(){N.4d.1g.1m.1j(K,1r);O a=K;a.2P=P;if(a.1n){a.1n.un(a.2F);a.1n.92=P;a.1n.1m();a.1n=P;a.2F=P}if(a.4a){a.4a.1m();a.4a=P}},8n:Q(){O b=K;if(2t Mn==="2q"){O a={6p:"bO",2y:b,6H:b.so,5W:b.sl};b.8m(a)}V{b.1B=b.1B.4D(/.5I/,".5J");O c=b.1B;if(N.8u.9C){c+=c.2S("?")>-1?"&":"?";c+=N.8u.9C.jU()}Mm.Ml({1B:c,2E:"bO"}).Mk(Q(d){b.so(d)},Q(d){b.sl(d)})}},so:Q(b){O g=K,f=P,e=P,d=P,a=P;b=N.1c.6o(b);if(!b.5x||(b.5x&&((b.5x>=cW&&b.5x<e8)||b.5x==0||b.5x===Mj))){O c=N.1l.jT.2A(b);g.4a=c;f=S N.1l.sn(c,b);g.1n&&g.1n.1M("56",f)}V{d=b;if(!d){R}a=N.8l.2A(d);e=S N.9z(a,b);g.1n.1M("5H",e)}},sl:Q(b){O e=K,d=P,a=P,c=P;b=N.1c.6o(b);if(b.5x){d=b}V{d=b.77}if(!d){R}a=N.8l.2A(d);c=S N.9z(a,b);e.1n.1M("5H",c)},1p:"N.1l.nt"});N.1l.sk=N.1z({ns:P,nr:P,nq:P,fz:P,np:P,1o:Q(a){if(!a){R}N.1c.1K(K,a)},1m:Q(){O a=K;a.ns=P;a.nr=P;a.nq=P;a.fz=P;a.np=P},zW:Q(){O a="";a+=\'"ns":\'+K.ns+",";a+=\'"nr":\'+K.nr+",";a+=\'"nq":\'+K.nq+",";if(K.fz){a+=\'"fz": "\'+K.fz+\'",\'}a+=\'"np":\'+K.np;a="{"+a+"}";R a},1p:"N.1l.sk"});N.1l.zV=N.1z({aj:P,2c:P,cV:P,e7:P,4T:1d,e3:0,e4:P,1o:Q(a){if(!a){R}N.1c.1K(K,a)},1m:Q(){O a=K;a.aj=P;a.2c=P;a.cV=P;a.e7=P;a.4T=1d;a.e3=0;a.e4=P},zU:Q(){O l="";l+=\'"aj":"\'+K.aj+\'",\';if(K.cV&&K.cV.1a){O h=[];O a=K.cV.1a;1h(O c=0;c<a;c++){h.1w(\'"\'+K.cV[c]+\'"\')}O g="["+h.6b(",")+"]";l+=\'"cV":\'+g+","}if(K.aj==="Mi"&&K.2c){l+=\'"2c":{"9B":{"x":\'+K.2c.1s+\',"y":\'+K.2c.1L+\'},"aW":{"x":\'+K.2c.1I+\',"y":\'+K.2c.1t+"}},"}if(K.e7&&K.e7.1a){O f=[];O e=K.e7.1a;1h(O b=0;b<e;b++){O k=S N.1l.sk();k=K.e7[b];f.1w(k.zW())}O d="["+f.6b(",")+"]";d=\'"Mh":\'+d+",";d+=\'"e3":\'+K.e3+",";d+=\'"e4":\'+K.e4;d="{"+d+"}";l+=\'"Mf":\'+d}l="{"+l+"}";R l},1p:"N.1l.zV"});N.1l.zT=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,4a:P,4T:P,1o:Q(c,b){N.4d.1g.1o.1j(K,[c]);if(b){N.1c.1K(K,b)}O d=K,a;d.1n=S N.4l(d,P,d.2P,1d);if(d.2F 1W 78){d.1n.on(d.2F)}if(!d.1B){R}a=d.1B.8X(d.1B.1a-1,1);if(d.4B){d.1B+=(a==="/")?"e5.5J?":"/e5.5J?"}V{d.1B+=(a==="/")?"e5.5I?":"/e5.5I?"}},1m:Q(){N.4d.1g.1m.1j(K,1r);O a=K;a.2P=P;if(a.1n){a.1n.1m();a.1n=P}if(a.2F){a.2F=P}if(a.4a){a.4a.1m();a.4a=P}a.4T=P},8n:Q(c){if(!c){R}O a=K,b;a.4T=c.4T;b=c.zU();if(a.4T){a.1B+="4T="+a.4T}a.8m({6p:"hj",57:b,2y:a,6H:a.ng,5W:a.nf})},ng:Q(a){O c=K,b=P,d=P;a=N.1c.6o(a);if(c.4T){d=N.1l.bP.2A(a)}V{d=S N.1l.bP();if(a.8p){d.fo=S N.1U(a.8p.1s,a.8p.1L,a.8p.1I,a.8p.1t)}d.cU=N.1l.fn.2A(a)}c.4a=d;b=S N.1l.jG(d,a);c.1n.1M("56",b)},nf:Q(b){O e=K,d=P,a=P,c=P;b=N.1c.6o(b);d=b.77;if(!d){R}a=N.8l.2A(d);c=S N.9z(a,b);e.1n.1M("5H",c)},hp:Q(a){R S N.1l.87({aj:a.aj,2c:a.2c,cV:a.cV,e7:a.e7,4T:a.4T})},1p:"N.1l.zT"});N.1l.87=N.1z({ne:P,5i:P,e4:ht,nd:N.1l.8t.e6,nc:N.1l.zS.sj,hq:P,e3:0,dV:10,nh:1b,1o:Q(a){if(!a){R}N.1c.1K(K,a)},1m:Q(){O c=K;c.ne=P;c.e4=P;c.nd=P;c.nc=P;if(c.hq){1h(O b=0,d=c.hq,a=d.1a;b<a;b++){d[b].1m()}c.hq=P}c.e3=P;c.dV=P;c.nh=P;c.5i=P},1p:"N.1l.87"});N.1l.zO=N.1z({fz:P,2l:P,8o:P,nn:P,zR:P,zQ:P,zP:P,hs:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O e=K;e.fz=P;e.2l=P;if(e.8o){1h(O c=0,d=e.8o,a=d.1a;c<a;c++){d[c].1m()}e.8o=P}if(e.nn){1h(O c=0,b=e.nn,a=b.1a;c<a;c++){b[c].1m()}e.nn=P}e.zR=P;e.zQ=P;e.zP=P;e.hs=P},1p:"N.1l.zO"});N.1l.zN=N.1z(N.1l.87,{4T:1d,1o:Q(a){N.1l.87.1g.1o.1j(K,1r);if(!a){R}N.1c.1K(K,a)},1m:Q(){N.1l.87.1g.1m.1j(K,1r);O a=K;a.4T=P},1p:"N.1l.zN"});N.1l.zM=N.1z(N.1l.87,{4T:1d,2c:P,1o:Q(a){N.1l.87.1g.1o.1j(K,1r);if(!a){R}N.1c.1K(K,a)},1m:Q(){N.1l.87.1g.1m.1j(K,1r);O a=K;a.4T=P;if(a.2c){a.2c=P}},1p:"N.1l.zM"});N.1l.jR=N.1z({nm:P,nl:P,hs:P,nk:P,2z:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O d=K;d.nm=P;d.nl=P;d.hs=P;d.nk=P;if(d.2z){1h(O b=0,c=d.2z,a=c.1a;b<a;b++){c[b].1m()}d.2z=P}},1p:"N.1l.jR"});N.1l.jR.2A=Q(e){if(!e){R}O d=P,f=P;if(e.2z){f=[];1h(O c=0,b=e.2z,a=b.1a;c<a;c++){d=N.1l.jS.2A(b[c]).zL();f.1w(d)}}R S N.1l.jR({nm:e.nm,nl:e.nl,hs:e.hs,nk:e.nk,2z:f})};N.1l.fn=N.1z({5V:P,dW:P,id:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.5V=P;a.dW=P;a.id=P},1p:"N.1l.fn"});N.1l.fn.2A=Q(a){if(!a){R}R S N.1l.fn({5V:a.5V,dW:a.dW,id:a.ag})};N.1l.bP=N.1z({nj:P,ni:P,fo:P,fw:P,cU:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O d=K;d.nj=P;d.ni=P;d.fo=P;if(d.fw){1h(O c=0,b=d.fw,a=b.1a;c<a;c++){b[c].1m()}d.fw=P}if(d.cU){d.cU.1m();d.cU=P}},1p:"N.1l.bP"});N.1l.bP.2A=Q(d){if(!d){R}O b=P;if(d.fw){b=[];1h(O c=0,e=d.fw,a=e.1a;c<a;c++){b.1w(N.1l.jR.2A(e[c]))}}R S N.1l.bP({nj:d.nj,ni:d.ni,fo:d.fo,fw:b,cU:d.cU})};N.1l.jG=N.1z(N.5h,{3r:P,1o:Q(a,c){N.5h.1g.1o.1j(K,[c]);O b=K;b.3r=a},1m:Q(){N.5h.1g.1m.1j(K);O a=K;if(a.3r){a.3r.1m();a.3r=P}},1p:"N.1l.jG"});N.1l.91=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,4a:P,4T:1b,1o:Q(c,b){N.4d.1g.1o.1j(K,[c]);if(b){N.1c.1K(K,b)}O d=K,a;d.1n=S N.4l(d,P,d.2P,1d);if(d.2F 1W 78){d.1n.on(d.2F)}a=d.1B.8X(d.1B.1a-1,1);if(d.4B){d.1B+=(a==="/")?"e5.5J?":"/e5.5J?"}V{d.1B+=(a==="/")?"e5.5I?":"/e5.5I?"}},1m:Q(){N.4d.1g.1m.1j(K,1r);O a=K;a.2P=P;if(a.1n){a.1n.1m();a.1n=P}if(a.2F){a.2F=P}if(a.4a){a.4a.1m();a.4a=P}a.4T=P},8n:Q(d){if(!d){R}O b=K,a=P,c=P;b.4T=d.4T;c=b.jQ(d);if(b.4T){b.1B+="4T="+b.4T}V{a=d.nh;if(a){b.1B+="nh="+a}}b.8m({6p:"hj",57:c,2y:b,6H:b.ng,5W:b.nf})},ng:Q(a){O c=K,b=P,d=P;a=N.1c.6o(a);if(c.4T){d=N.1l.bP.2A(a)}V{d=S N.1l.bP();if(a.8p){d.fo=S N.1U(a.8p.1s,a.8p.1L,a.8p.1I,a.8p.1t)}d.cU=N.1l.fn.2A(a)}c.4a=d;b=S N.1l.jG(d,a);c.1n.1M("56",b)},nf:Q(b){O e=K,d=P,a=P,c=P;b=N.1c.6o(b);d=b.77;if(!d){R}a=N.8l.2A(d);c=S N.9z(a,b);e.1n.1M("5H",c)},hp:Q(a){R S N.1l.87({ne:a.ne,e4:a.e4,nd:a.nd,nc:a.nc,hq:a.hq,e3:a.e3,5i:a.5i,dV:a.dV})},1p:"N.1l.91"});N.1l.zK=N.1z(N.1l.91,{1o:Q(b,a){N.1l.91.1g.1o.1j(K,1r)},1m:Q(){N.1l.91.1g.1m.1j(K,1r)},jQ:Q(d){O b=K,c="",a=P;a=b.hp(d);c+="\'aj\':\'Me\',\'jP\':";c+=N.1c.7q(a);c="{"+c+"}";R c},1p:"N.1l.zK"});N.1l.zJ=N.1z(N.1l.91,{1o:Q(b,a){N.1l.91.1g.1o.1j(K,1r)},1m:Q(){N.1l.91.1g.1m.1j(K,1r)},jQ:Q(e){O c=K,d="",a=P,b=e.2c;a=c.hp(e);d+="\'aj\':\'Md\',\'jP\':";d+=N.1c.7q(a);d+=",\'2c\': {\'aW\':{\'y\':"+b.1t+",\'x\':"+b.1I+"},\'9B\':{\'y\':"+b.1L+",\'x\':"+b.1s+"}}";d="{"+d+"}";R d},1p:"N.1l.zJ"});N.1l.zH=N.1z(N.1l.87,{4T:1d,1x:P,nb:N.1l.zI.fv,1o:Q(a){N.1l.87.1g.1o.1j(K,1r);if(!a){R}N.1c.1K(K,a)},1m:Q(){O a=K;N.1l.87.1g.1m.1j(a,1r);a.4T=P;a.1x=P;a.nb=P},1p:"N.1l.zH"});N.1l.zG=N.1z(N.1l.91,{1o:Q(b,a){N.1l.91.1g.1o.1j(K,1r)},1m:Q(){N.1l.91.1g.1m.1j(K,1r)},jQ:Q(f){O c=K,e="",a=P,d=f.1x,b=N.1l.8s.ho(d);a=c.hp(f);e+="\'aj\':\'Mc\',\'jP\':";e+=N.1c.7q(a)+",\'1x\':"+N.1c.7q(b)+",\'nb\':"+N.1c.7q(f.nb);e="{"+e+"}";R e},1p:"N.1l.zG"});N.1l.zF=N.1z(N.1l.87,{3H:0,1x:P,si:P,4T:1d,1o:Q(a){N.1l.87.1g.1o.1j(K,1r);if(!a){R}N.1c.1K(K,a)},1m:Q(){N.1l.87.1g.1m.1j(K,1r);O a=K;a.4T=P;a.3H=P;a.si=P;if(a.1x){a.1x.1m();a.1x=P}},1p:"N.1l.zF"});N.1l.zE=N.1z(N.1l.91,{1o:Q(b,a){N.1l.91.1g.1o.1j(K,1r)},1m:Q(){N.1l.91.1g.1m.1j(K,1r)},jQ:Q(e){O c=K,d="",a=P,a=c.hp(e);O b=N.1l.8s.ho(e.1x);d+=e.si?"\'aj\':\'Mb\',\'jP\':":"\'aj\':\'Ma\',\'jP\':";d+=N.1c.7q(a);d+=",\'1x\':"+N.1c.7q(b)+",\'3H\':"+e.3H;d="{"+d+"}";R d},1p:"N.1l.zE"});N.1l.sh=N.1z(N.5h,{3r:P,1o:Q(a,c){N.5h.1g.1o.1j(K,[c]);O b=K;b.3r=a},1m:Q(){N.5h.1g.1m.1j(K);O a=K;if(a.3r){a.3r.1m();a.3r=P}},1p:"N.1l.sh"});N.1l.sg=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,4a:P,1o:Q(b,a){N.4d.1g.1o.1j(K,1r);O c=K;if(a){N.1c.1K(c,a)}c.1n=S N.4l(c,P,c.2P,1d);if(c.2F 1W 78){c.1n.on(c.2F)}},1m:Q(){N.4d.1g.1m.1j(K,1r);O a=K;a.2P=P;a.1n=P;a.2F=P;if(a.4a){a.4a.1m();a.4a=P}},8n:Q(){if(!K.1B){R}O c=K,b;O a=c.1B.8X(c.1B.1a-1,1);c.1B=c.1B+((a==="/")?"ai":"/ai")+(K.4B?".5J?":".5I?");c.8m({6p:"bO",2y:c,6H:c.zD,5W:c.zC})},zD:Q(a){O d=K,c,b;a=N.1c.6o(a);c=N.1l.jO.2A(a);d.4a=c;b=S N.1l.sh(c,a);d.1n.1M("56",b)},zC:Q(b){O d=K,c=P,a=P,e=P;b=N.1c.6o(b);c=b.77;if(!c){R}a=N.8l.2A(c);e=S N.9z(a,b);d.1n.1M("5H",e)},1p:"N.1l.sg"});N.1l.jO=N.1z({jN:P,2l:P,aX:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.jN=P;a.2l=P;a.aX=P},1p:"N.1l.jO"});N.1l.jO.2A=Q(e){if(!e||!e[0]){R}e=e[0];O c=S N.1l.jO();if(e.jN){c.jN=e.jN}if(e.aX){c.aX=[];1h(O d=0,b=e.aX,a=b.1a;d<a;d++){c.aX[d]=b[d]}}if(e.2l){c.2l=e.2l}R c};N.1l.7s=N.1z({8Z:7J,aV:0,9A:0,1o:Q(c,b,a){if(!c&&c!=0){K.8Z=7J}V{K.8Z=c}if(!b&&b!=0){K.aV=0}V{K.aV=b}if(!a&&a!=0){K.9A=0}V{K.9A=a}},1m:Q(){O a=K;a.8Z=P;a.aV=P;a.9A=P},1p:"N.1l.7s"});N.1l.7s.2A=Q(c){if(!c){R}O b=S N.1l.7s();O e=7J;if(c.8Z!==P){e=6r(c.8Z)}b.8Z=e;O d=0;if(c.aV!==P){d=6r(c.aV)}b.aV=d;O a=0;if(c.9A!==P){a=6r(c.9A)}b.9A=a;R b};N.1l.dY=N.1z({fu:P,na:1b,fs:P,e2:P,n9:0,n8:0,n7:0,n6:4b,n5:0,fr:P,n4:0,8r:1,n3:0,n2:1,n1:-1,1o:Q(a){O b=K;b.fu=S N.1l.7s(7J,7J,7J);b.fs=S N.1l.7s(7J,0,0);b.fr=S N.1l.7s(0,0,0);if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;if(a.fu){a.fu.1m();a.fu=P}a.na=P;if(a.fs){a.fs.1m();a.fs=P}a.e2=P;a.n9=P;a.n8=P;a.n7=P;a.n6=P;a.n5=P;if(a.fr){a.fr.1m();a.fr=P}a.n4=P;a.8r=P;a.n3=P;a.n2=P;a.n1=P},3P:Q(){O a={};a=N.1c.bM(a,K);R a},1p:"N.1l.dY"});N.1l.dY.2A=Q(a){if(!a){R}R S N.1l.dY({fu:N.1l.7s.2A(a.fu),na:a.na,fs:N.1l.7s.2A(a.fs),e2:a.e2,n9:a.n9,n8:a.n8,n7:a.n7,n6:a.n6,n5:a.n5,fr:N.1l.7s.2A(a.fr),n4:a.n4,8r:a.8r,n3:a.n3,n2:a.n2,n1:a.n1})};N.1l.mZ=N.1z({zA:N.1l.zB.sf,fq:P,fp:P,zz:1b,s8:1d,zy:6,zx:0,79:M9,zw:"M8 M7 M6",zv:1b,n0:1b,zu:0,jM:1b,zt:1b,zs:1b,sa:0,zr:1b,8q:0,1o:Q(a){O b=K;b.fq=S N.1l.7s(7J,7J,7J);b.fp=S N.1l.7s(0,0,0);if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.zA=P;if(a.fq){a.fq.1m();a.fq=P}if(a.fp){a.fp.1m();a.fp=P}a.zz=P;a.s8=P;a.zy=P;a.zx=P;a.79=P;a.zw=P;a.zv=P;a.n0=P;a.zu=P;a.jM=P;a.zt=P;a.zs=P;a.sa=P;a.zr=P;a.8q=P},1p:"N.1l.mZ"});N.1l.mZ.fl=Q(b){O a=S N.1l.mZ(b);N.1c.M5(a,b);a.fq=N.1l.7s.2A(b.fq);a.fp=N.1l.7s.2A(b.fp);R a};N.1l.mY=N.1z({5x:P,jL:P,1o:Q(a){if(!a){R}N.1c.1K(K,a)},1m:Q(){O a=K;a.5x=P;a.jL=P},2A:Q(b){O a=S N.1l.mY();if(b){if(b.5x!=P){a.5x=b.5x}if(b.jL){a.jL=b.jL}}R a},1p:"N.1l.mY"});N.1l.mX=N.1z({jK:P,5x:P,jJ:P,2l:P,jI:P,hn:P,1o:Q(a){if(!a){R}N.1c.1K(K,a)},1m:Q(){O a=K;a.jK=P,a.5x=P,a.jJ=P,a.2l=P,a.jI=P,a.hn=P},2A:Q(a){O e=S N.1l.mX();if(a){if(a.jK){e.jK=a.jK}if(a.5x!=P){e.5x=a.5x}if(a.jJ){e.jJ=a.jJ}if(a.2l){e.2l=a.2l}if(a.jI){e.jI=a.jI}if(a.hn){O b=S N.1l.mY();O d=[];1h(O c in a.hn){d.1w(b.2A(a.hn[c]))}e.hn=d}}R e},1p:"N.1l.mX"});N.1l.se=N.1z({jH:P,1o:Q(a){if(!a){R}N.1c.1K(K,a)},1m:Q(){O a=K;a.jH=P},2A:Q(b){if(b==P){R P}O a=S N.1l.se();O e=[];O d=S N.1l.mX();1h(O c in b){e.1w(d.2A(b[c]))}a.jH=e;R a},1p:"N.1l.se"});N.1l.zo=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,3r:P,1o:Q(b,a){N.4d.1g.1o.1j(K,[b]);if(a){N.1c.1K(K,a)}O c=K;c.1n=S N.4l(c,P,c.2P,1d);if(c.2F 1W 78){c.1n.on(c.2F)}},1m:Q(){N.4d.1g.1m.1j(K,1r);N.1c.4C(K)},8n:Q(){O b=K,c="bO",a=b.1B.8X(b.1B.1a-1,1);if(!b.jE){b.1B+=(a==="/")?"":"/";b.1B+=b.4B?"jH.5J?":"jH.5I?"}V{b.1B+=b.4B?".5J?":".5I?"}b.8m({6p:c,3J:P,2y:b,6H:b.zq,5W:b.zp})},zq:Q(a){O c=K,b=P,d=P;a=N.1c.6o(a);if(c.4T){d=N.1l.bP.2A(a)}V{d=S N.1l.bP();if(a.8p){d.fo=S N.1U(a.8p.1s,a.8p.1L,a.8p.1I,a.8p.1t)}d.cU=N.1l.fn.2A(a)}c.4a=d;b=S N.1l.jG(d,a);c.1n.1M("56",b)},zp:Q(b){O e=K,d=P,a=P,c=P;b=N.1c.6o(b);d=b.77;if(!d){R}a=N.8l.2A(d);c=S N.9z(a,b);e.1n.1M("5H",c)},1p:"N.1l.zo"});N.1l.zl=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,4a:P,jE:1b,1o:Q(b,a){N.4d.1g.1o.1j(K,[b]);if(a){N.1c.1K(K,a)}O c=K;c.1n=S N.4l(c,P,c.2P,1d);if(c.2F 1W 78){c.1n.on(c.2F)}},1m:Q(){N.4d.1g.1m.1j(K,1r);N.1c.4C(K)},8n:Q(){O b=K,c="bO",a=b.1B.8X(b.1B.1a-1,1);if(!b.jE){b.1B+=(a==="/")?"":"/";b.1B+=b.4B?"1O.5J?":"1O.5I?"}V{b.1B+=b.4B?".5J?":".5I?"}b.8m({6p:c,3J:P,2y:b,6H:b.zn,5W:b.zm})},zn:Q(b){O e=K,d,c,f,a=0;b=N.1c.6o(b);c=N.1c.M4({},b);d=!!c&&c.1a>0;f=d?c[0].bL.1O:P;a=f?f.1a:0;K.sd(a,f);e.4a=c[0];O g=S N.1l.rW(c[0],b);e.1n.1M("56",g)},sd:Q(a,f){O e=K,b;if(a){1h(O c=0;c<a;c++){if(f[c].bL&&f[c].bL.1O&&f[c].bL.1O.1a>0){K.sd(f[c].bL.1O.1a,f[c].bL.1O)}V{O d=f[c].rY;5U(d){1N"M3":b=S N.1l.s1();b.2A(f[c]);f[c]=b;1F;1N"mU":b=S N.1l.ah();b.2A(f[c]);f[c]=b;1F;1N"M2":b=S N.1l.4w();b.2A(f[c]);f[c]=b;1F;1N"M1":b=S N.1l.2X();b.2A(f[c]);f[c]=b;1F;1N"sc":1F;1N"sb":1F}}}}},zm:Q(b){O e=K,d=P,a=P,c=P;b=N.1c.6o(b);d=b.77;if(!d){R}a=N.8l.2A(d);c=S N.9z(a,b);e.1n.1M("5H",c)},1p:"N.1l.zl"});N.1l.bN=N.1z({2c:P,M0:P,mV:P,2l:P,LZ:P,bL:P,2E:P,6I:P,1o:Q(a){a=a?a:{};N.1c.1K(K,a)},1m:Q(){O a=K;N.1c.4C(a)},2A:Q(c){c=c?c:{};N.1c.1K(K,c);O a=K.2c;if(a){K.2c=S N.1U(a.9B.x,a.9B.y,a.aW.x,a.aW.y)}},3P:Q(){O a={};a=N.1c.bM(a,K);if(a.2c){if(a.2c.3P){a.2c=a.2c.3P()}}R a},1p:"N.1l.bN"});N.1l.fm=N.1z(N.1l.bN,{LY:P,4Q:P,4R:P,LX:P,sa:P,LW:P,LV:P,cT:P,e1:P,1o:Q(a){a=a||{};N.1l.bN.1g.1o.1j(K,[a])},1m:Q(){N.1l.bN.1g.1m.1j(K,1r);N.1c.4C(K)},2A:Q(a){N.1l.bN.1g.2A.1j(K,[a])},3P:Q(){O a=N.1l.bN.1g.3P.1j(K,1r);R a},1p:"N.1l.fm"});N.1l.6a=N.1z(N.1l.fm,{e0:P,hk:P,8o:P,LU:P,rY:P,1o:Q(a){a=a||{};N.1l.fm.1g.1o.1j(K,[a])},2A:Q(c){N.1l.fm.1g.2A.1j(K,[c]);if(K.e0){K.e0=S N.1l.s0(K.e0)}if(K.8o&&K.8o.1a){O a=[];1h(O b=0;b<K.8o.1a;b++){a[b]=S N.1l.s9(K.8o[b])}K.8o=a}},1m:Q(){N.1l.fm.1g.1m.1j(K,1r);N.1c.4C(K)},3P:Q(){O b=N.1l.fm.1g.3P.1j(K,1r);if(b.8o){O c=[];1h(O a=0;a<b.8o.1a;a++){if(b.8o[a].3P){c[a]=b.8o[a].3P()}}b.8o=c}if(b.e0){if(b.e0.3P){b.e0=b.e0.3P()}}R b},1p:"N.1l.6a"});N.1l.ah=N.1z(N.1l.6a,{mT:P,zj:P,LT:P,jF:P,zi:P,86:P,LS:P,LR:P,s8:P,dZ:P,hm:P,LQ:P,LP:P,LO:P,1o:Q(a){a=a||{};N.1l.6a.1g.1o.1j(K,[a])},1m:Q(){N.1l.6a.1g.1m.1j(K,1r);N.1c.4C(K)},2A:Q(f){N.1l.6a.1g.2A.1j(K,[f]);if(K.hm){K.hm=S N.1l.7s(K.hm.8Z,K.hm.aV,K.hm.9A)}if(K.jF){O a=[],c;1h(O e in K.jF){c=K.jF[e];a.1w(S N.1l.7s(c.8Z,c.aV,c.9A))}K.jF=a}if(K.86){K.86=S zk.1l.dY(K.86)}if(K.dZ){K.dZ=S zk.1l.dY(K.dZ)}if(K.jD){O g=[],b;1h(O d in K.jD){b=K.jD[d];g.1w(S N.1l.rZ({rX:d,4S:b}))}K.mT=g}2s K.jD},3P:Q(){O a=N.1l.6a.1g.3P.1j(K,1r);if(a.86){if(a.86.3P){a.86=a.86.3P()}}if(a.dZ){if(a.dZ.3P){a.dZ=a.dZ.3P()}}R a},1p:"N.1l.ah"});N.1l.4w=N.1z(N.1l.6a,{zj:P,LN:P,zi:P,LM:P,mW:P,hl:P,LL:P,1o:Q(a){a=a||{};N.1l.6a.1g.1o.1j(K,[a])},1m:Q(){N.1l.6a.1g.1m.1j(K,1r);N.1c.4C(K)},2A:Q(a){N.1l.6a.1g.2A.1j(K,[a]);if(K.hl){K.hl=S N.1l.7s(K.hl.8Z,K.hl.aV,K.hl.9A)}},3P:Q(){O a=N.1l.6a.1g.3P.1j(K,1r);R a},1p:"N.1l.4w"});N.1l.s1=N.1z(N.1l.6a,{85:P,cS:P,1o:Q(a){a=a||{};N.1l.6a.1g.1o.1j(K,[a])},1m:Q(){N.1l.6a.1g.1m.1j(K,1r);N.1c.4C(K)},2A:Q(b){N.1l.6a.1g.2A.1j(K,[b]);O a=K.85;O c=a&&a.2E;5U(c){1N"s7":K.85=N.1l.LK.fl(a);1F;1N"s6":K.85=N.1l.LJ.fl(a);1F;1N"s5":K.85=N.1l.LI.fl(a);1F;1N"s4":K.85=N.1l.LH.fl(a);1F;1N"s3":K.85=N.1l.LG.fl(a);1F;1N"s2":K.85=N.1l.LF.fl(a);1F}if(K.cS){K.cS=S N.3i(K.cS.x,K.cS.y)}},3P:Q(){O a=N.1l.6a.1g.3P.1j(K,1r);if(a.cS){if(a.cS.3P){a.cS=a.cS.3P()}}if(a.85){if(a.85.3P){a.85=a.85.3P()}}R a},1p:"N.1l.s1"});N.1l.2X=N.1z(N.1l.6a,{W:P,1o:Q(a){a=a||{};N.1l.6a.1g.1o.1j(K,[a])},1m:Q(){N.1l.6a.1g.1m.1j(K,1r);N.1c.4C(K)},2A:Q(b){N.1l.6a.1g.2A.1j(K,[b]);O a=K.W;if(a){K.W=S N.1l.dY(a)}},3P:Q(){O a=N.1l.6a.1g.3P.1j(K,1r);if(a.W){if(a.W.3P){a.W=a.W.3P()}}R a},1p:"N.1l.2X"});N.1l.s0=N.1z({2c:P,LE:P,mV:P,LD:P,LC:P,2l:P,5i:P,LB:P,2E:P,1o:Q(c){c=c||{};N.1c.1K(K,c);O a=K.2c;if(a){K.2c=S N.1U(a.9B.x,a.9B.y,a.aW.x,a.aW.y)}},1m:Q(){N.1c.4C(K)},3P:Q(){O a={};a=N.1c.bM(a,K);if(a.2c){if(a.2c.3P){a.2c=a.2c.3P()}}R a},1p:"N.1l.s0"});N.1l.zg=N.1z({Lz:1d,Ly:1d,Lx:1b,Lw:1d,Lv:1b,Lu:1b,Lt:0,Ls:0,1o:Q(a){a=a||{};N.1c.1K(K,a)},1m:Q(){N.1c.4C(K)},2A:Q(a){N.1l.bN.1g.2A.1j(K,[a])},3P:Q(){O a=N.1l.bN.1g.3P.1j(K,1r);R a},7r:Q(){O b=N.1l.bN.1g.3P.1j(K,1r);O c="{";1h(O a in b){if(b.dX(a)){c+="\'"+a+"\':"+b[a]+","}}c=c.8X(0,c.1a-1);c+="}";R c},1p:"N.1l.zg"});N.1l.rZ=N.1z({rX:P,4S:P,1o:Q(a){a=a||{};N.1c.1K(K,a);O b=K,d=b.4S;if(d){b.4S=S N.1l.7s(d.8Z,d.aV,d.9A)}},1m:Q(){N.1c.4C(K)},3P:Q(){O a={};a=N.1c.bM(a,K);R a},1p:"N.1l.rZ"});N.1l.ze=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,4a:P,aT:P,jE:1b,1o:Q(b,a){N.4d.1g.1o.1j(K,[b]);if(a){N.1c.1K(K,a)}O c=K;c.1n=S N.4l(c,P,c.2P,1d);if(c.2F 1W 78){c.1n.on(c.2F)}},1m:Q(){N.4d.1g.1m.1j(K,1r);N.1c.4C(K)},8n:Q(d){O m,k=[],n=K,a="",e;if(!d){R}e=n.1B.8X(n.1B.1a-1,1);n.1B+=(e==="/")?"":"/";if(n.jE){n.1B+="mR/"+n.aT;a="jB"}V{n.1B+="mR";a="hj"}n.1B+=n.4B?".5J?":".5I?";O h=d.bL.1O,l=h.1a;1h(O g in h){if(h[g].rY==="mU"){O c={};O b=h[g].mT;1h(O f in b){O o=b[f].rX;c[o]=b[f].4S}}h[g].jD=c;2s h[g].mT}1h(O g=0;g<l;g++){if(h[g].zf){k.1w(h[g].zf())}V{k.1w(h[g])}}m=N.1c.1K(m,d);m.bL={1O:k};m.6q=P;O p=N.1c.7q([m]);n.8m({6p:a,57:p,2y:n,6H:n.hi,5W:n.fi})},hi:Q(a){O b=K,d;a=N.1c.6o(a);d=N.1l.hh.2A(a);O c=d.5V;if(c){O e=S N.1l.mO(d,a);b.4a=d;b.1n.1M("56",e)}},fi:Q(b){O e=K,d=P,a=P,c=P;b=N.1c.6o(b);d=b.77;if(!d){R}a=N.8l.2A(d);c=S N.9z(a,b);e.1n.1M("5H",c)},1p:"N.1l.ze"});N.1l.rW=N.1z(N.5h,{3r:P,1o:Q(a,c){N.5h.1g.1o.1j(K,[c]);O b=K;b.3r=a},1m:Q(){N.5h.1g.1m.1j(K,1r);O a=K;if(a.3r){N.1c.4C(a.3r);a.3r=P}},1p:"N.1l.rW"});N.1l.mO=N.1z(N.5h,{3r:P,1o:Q(a,c){N.5h.1g.1o.1j(K,[c]);O b=K;b.3r=a},1m:Q(){N.5h.1g.1m.1j(K,1r);O a=K;if(a.3r){a.3r=P}},1p:"N.1l.mO"});N.1l.hh=N.1z({5V:P,ag:P,dW:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.5V=P;a.ag=P;a.dW=P},1p:"N.1l.hh"});N.1l.hh.2A=Q(a){if(!a){R}R S N.1l.hh({5V:a.5V,ag:a.ag,dW:a.dW})};N.1l.zd=N.1z({8Y:P,rV:P,hk:P,mS:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.8Y=P;a.rV=P;a.hk=P},7q:Q(){O b="{";b+=\'"2E":"mQ",\';O a=[];if(K.8Y){a.1w(\'"2l":"\'+K.8Y+\'"\');a.1w(\'"6I":\'+K.rV)}if(K.hk){a.1w(\'"hk":"\'+K.hk+\'"\')}if(K.4R||K.4R==0){a.1w(\'"4R":\'+K.4R)}if(K.4Q||K.4Q==0){a.1w(\'"4Q":\'+K.4Q)}if(K.mS){a.1w(\'"mS":\'+N.1c.7q(K.mS))}b+=a;b+="}";R b},1p:"N.1l.zd"});N.1l.zc=N.1z({fk:P,dV:15,aT:P,1o:Q(a){O b=K;b.fk=[];if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.fk=P;a.dV=P;a.aT=P},7q:Q(){O d="{";d+=\'"1O":[\';O b=[];1h(O c=0,a=K.fk.1a;c<a;c++){b.1w(K.fk[c].7q())}d+=b;d+="]";d+="}";R d},1p:"N.1l.zc"});N.1l.jC=N.1z({5V:P,ag:P,1o:Q(a){if(a){N.1c.1K(K,a)}},1m:Q(){O a=K;a.5V=P;a.ag=P},1p:"N.1l.jC"});N.1l.jC.2A=Q(a){if(!a){R}R S N.1l.jC({5V:a.5V,ag:a.ag})};N.1l.rT=N.1z(N.5h,{3r:P,1o:Q(a,c){N.5h.1g.1o.1j(K,[c]);O b=K;b.3r=a},1m:Q(){N.5h.1g.1m.1j(K,1r);O a=K;if(a.3r){a.3r=P}},1p:"N.1l.rT"});N.1l.z9=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,4a:P,fj:P,mP:P,1o:Q(b,a){N.4d.1g.1o.1j(K,[b]);if(a){N.1c.1K(K,a)}O c=K;c.1n=S N.4l(c,P,c.2P,1d);if(c.2F 1W 78){c.1n.on(c.2F)}c.mP=b},1m:Q(){N.4d.1g.1m.1j(K,1r);N.1c.4C(K)},8n:Q(e){O c=[],b=K,f="hj";if(!e){R}b.1B=b.mP;O a=b.1B.8X(b.1B.1a-1,1);b.1B+=(a==="/")?"":"/";if(e.aT==P){b.1B+="mR";b.1B+=b.4B?".5J?":".5I?";b.fj=e;b.8m({6p:f,2y:b,6H:b.zb,5W:b.fi})}V{b.1B+="mR/"+e.aT;b.1B+=b.4B?".5J?":".5I?";b.1B+="Lr=1d&Lq="+e.aT+"&dV="+e.dV.7r();O d="[{";d+=\'"2E":"mQ",\';if(e.fk!=P&&e.fk.1a>0){d+=\'"bL":\'+e.7q()}d+=\',"6I":\'+1d+",";d+=\'"2l":"\'+K.za(K.mP)+\'"\';d+="}]";b.8m({6p:"jB",57:d,2y:b,6H:b.hi,5W:b.fi})}},zb:Q(a){O b=K;a=N.1c.6o(a);if(a.5V){b.fj.aT=a.ag}b.8n(b.fj)},za:Q(b){O d=b;if(d.dU(d.1a-1)==="/"){d=d.8X(0,d.1a-1)}O a=d.rU("/");O c=d.aU(a+1,d.1a);R c},hi:Q(a){O b=K,e;a=N.1c.6o(a);e=N.1l.jC.2A(a);O d=e.5V;if(d){O c=S N.1l.rT(e,a);b.4a=e;if(c.3r!=P&&b.fj!=P){c.3r.ag=b.fj.aT;b.4a.ag=b.fj.aT}b.1n.1M("56",c)}},fi:Q(b){O e=K,d=P,a=P,c=P;b=N.1c.6o(b);d=b.77;if(!d){R}a=N.8l.2A(d);c=S N.9z(a,b);e.1n.1M("5H",c)},1p:"N.1l.z9"});N.1l.z8=N.1z(N.4d,{2P:["56","5H"],1n:P,2F:P,4a:P,aT:P,1o:Q(b,a){N.4d.1g.1o.1j(K,[b]);if(a){N.1c.1K(K,a)}O c=K;c.1n=S N.4l(c,P,c.2P,1d);if(c.2F 1W 78){c.1n.on(c.2F)}},1m:Q(){N.4d.1g.1m.1j(K,1r);N.1c.4C(K)},8n:Q(c){O b=K;if(!c){R}b.1B+=b.4B?".5J":".5I";O a=N.1c.7q(c);b.8m({6p:"jB",57:a,2y:b,6H:b.hi,5W:b.fi})},hi:Q(a){O b=K,d;a=N.1c.6o(a);d=N.1l.hh.2A(a);O c=d.5V;if(c){O e=S N.1l.mO(d,a);b.4a=d;b.1n.1M("56",e)}},fi:Q(b){O e=K,d=P,a=P,c=P;b=N.1c.6o(b);d=b.77;if(!d){R}a=N.8l.2A(d);c=S N.9z(a,b);e.1n.1M("5H",c)},1p:"N.1l.z8"});N.dT=N.1z({cR:[],9y:z7,fh:1b,hf:0,he:0,z6:["z0"],1n:P,1o:Q(d,c,b,a){if(a&&a.9y){K.z3(a.9y)}K.z2(d);K.z5(c);K.z4(b);K.jA(a);K.1n=S N.4l(K,P,K.z6)},on:Q(){K.3I=1d},hg:Q(){K.3I=1b},Lp:Q(){K.3I?K.hg():K.on()},z5:Q(a){if(!2x(a)){if(a>K.9y){a=K.9y}K.hf=a}V{K.hf=N.dT.rR}},z4:Q(a){if(!2x(a)){if(a>K.9y){a=K.9y}K.he=a}V{K.he=N.dT.rR}},z3:Q(a){if(!2x(a)){K.9y=a}V{K.9y=N.dT.rQ}},z2:Q(a){if(a&&a.1a>0){K.cR=a}V{K.hg()}},jA:Q(a){a.Lo?K.on():K.hg();a.9y?K.9y=a.9y:K.9y=N.dT.rQ},jz:Q(n){if(K.3I){O g=n;O o=1k.3f(K.hf,K.he);O a=o*K.2r();O q=S N.1f.1D(n.1P,n.1R);O b=q;1h(O h=0,l=K.cR.1a;h<l;h++){O m=K.cR[h];if(m 1W N.1C.2X&&m.3j){1h(O f=0,e=m.2z.1a;f<e;f++){O r=m.2z[f];O p=r.1x;if(r.7I!==N.69.bK&&r.mN(n,a,a)){5U(p.1p){1N"N.1f.1D":1N"N.1l.z1":b=K.mM(p,q);1F;1N"N.1f.8k":1h(O c=0,d=p.1y.1a;c<d;c++){b=K.mM(p.1y[c],q);if(!b.3w(q)){1F}}1F;1N"N.1f.2n":1N"N.1l.jy":b=K.mK(p,q);1F;1N"N.1f.83":1h(O c=0,d=p.1y.1a;c<d;c++){b=K.mK(p.1y[c],q);if(!b.3w(q)){1F}}1F;1N"N.1f.3T":b=K.rS(p,q);1F;1N"N.1f.8W":1h(O c=0,d=p.1y.1a;c<d;c++){b=K.rS(p.1y[c],q);if(!b.3w(q)){1F}}1F;49:1F}}g=S N.3i(b.x,b.y);if(!b.3w(q)){R g}}}}K.1n.1M("z0",{Ln:q,3r:b});R g}V{R n}},mM:Q(d,a){O b=K.2r();O c=K.hf*b;O e=d.74(a);if(e<c){R d}R a},mK:Q(g,j){O f=K.2r();O b=K.he*f;O e=g.55();1h(O c=0,d=e.1a;c<d;c++){O h=K.mM(e[c],j);if(!h.3w(j)){R h}}O k=g.74(j,{mL:1d});O a=k.3H;if(a<b){R S N.1f.1D(k.x0,k.y0)}R j},rS:Q(b,a){R K.mK(b,a)},2r:Q(){O b;1h(O a=0;a<K.cR.1a;a++){if(K.cR[a].U){b=K.cR[a].U.2r();1F}}if(b==2q){b=K.cR[0].2r()}R b},1m:Q(){K.hg();2s K.cR;2s K.hf;2s K.he},1p:"N.dT"});N.dT.rR=5;N.dT.rQ=rP;',62,3728,'||||||||||||||||||||||||||||||||||||||||||||||this|||SuperMap|var|null|function|return|new||map|else|style||||||||||||||length|false|Util|true||Geometry|prototype|for|layer|apply|Math|REST|destroy|events|initialize|CLASS_NAME|div|arguments|left|top|canvas|Control|push|geometry|components|Class|width|url|Layer|Point|height|break|size|Event|right|feature|extend|bottom|triggerEvent|case|layers|lon|document|lat|resolutions|clone|Bounds|appendChild|instanceof|handlers|Handler|Renderer||||display|||||||deactivate|baseLayer|bounds|||renderer|parseInt|element|setAttributeNS|fill|window|name|hitContext|LineString|stroke|activate|undefined|getResolution|delete|typeof|Function|position|round|isNaN|scope|features|fromJson|Pixel|options|Style|type|eventListeners|createElement|draw|Element|opacity|stop|none|Size|units|moveTo|EVENT_TYPES|projection|180|indexOf|removeChild|click|parentNode|hitDetection|Vector|pow|png||root|||||||||setMap|maxExtent|tileSize|absolute|offset|max|Projection|anchor|LonLat|visibility|Feature|point|observe|callback|layerContainerDiv|add|ovmap|result|handler|parseFloat|last|grid|equals|move|redraw|viewPortDiv|mapObject|scales|imgDiv|scale|bind|callbacks|cursor|distance|active|params|transform|getWidth|className|abs|timerId|toServerJSONObject|Array|controls|dragging|Polygon|center|drawFeature|labelAlign|start|Popup|line||tile|getExtent|||||useCanvas|mousedown|default|lastResult|100|translate|ServiceBase||isArray|call|fontSize|auto|maxResolution|minResolution|Events|pointer|_|mouseup|mousemove|down|dpi|LinearRing|out|graphics|min|Image|strokeWidth|getHeight|pointRadius|padding|isInTheSameDomain|reset|replace|EPSG|dblclick|getZoom|fillOpacity|applyDefaults|radius|graphicName|graphic|getImagesLocation|register|icon|CanvasLayer|maxScale|minScale|color|returnContent|split|filter|while|ratio|clearRect|contentDiv|||extent||addClass|getVertices|processCompleted|data|datumAxis|bindAsEventListener|Canvas|img|getSize|zoom|zoomBox|box|minimizeDiv|ServiceEventArgs|prjCoordSys|zIndex|label|globalAlpha|rotate|getLonLatFromViewPortPx|src|image|lonlat|sqrt|drag|touch|maximizeDiv|Tile|restrictedExtent|code|continue|clear|Collection|silent|wrapDateLine|passEventToSlider|displayProjection|layersDiv|numZoomLevels|processFailed|jsonp|json|points|format|displayClass|innerHTML|setCanvasStyle|getCenterLonLat|getContext|popup|isBaseLayer|Google|switch|succeed|failure|setCenter|getProjectionObject|selectedFeatures|||||geometryTypes||container|frame||State|UGCSubLayer|join|splice|Symbolizer||over|angle|beginPath|graphicHeight|graphicWidth|getBounds|getElement|extentRectangle|number|transformResult|method|object|Number|http|clearTimeout|setTimeout|eventsDiv|SVG|styles|count|origin|setSize|NONE|sliderBarWidth|started|touches|20037508|canvasContext|success|visible|viewBounds|String|intersects|getLonLatFromPixel|nodeFactory|attributes|update|externalGraphic|closeDiv|unregister|drawLinearRing|polygon|sliderBarHeight|dragControl|pan|interval|control||minExtent||imageDiv|distanceTo|||error|Object|fontWeight|readyState|evt|done|select|Strategy|fontStyle|labelYOffset|labelXOffset|getLocalXY|fillColor|loadend|context|createDiv|body|termsOfUse|_object|toJSON|toString|ServerColor|_prevHighlighter|addFeatures|resolution|moveend|createUniqueID|strokeStyle|throw|leftTop|changelayer|resize|documentDrag|pane|maps|lastImage|markers|state|255|getCode|viewer|lastFeature|renderIntent|locked|sin|fillStyle|defaultStyle|setHitContextStyle|olv|addComponent|vertices|stopDown|inRange|buttons|google||proj|minPx|MultiLineString||theme|dashStyle|QueryParameters|order|handlerOptions|fontFamily|fontColor|getViewPortPxFromLonLat|rules||drawn|pinchZoom|dragPan|_timeoutId|Date|MultiPoint|ServiceException|request|processAsync|joinItems|customResult|rotation|lineWidth|ServerGeometry|GeometryType|Credential|totalTimes|cancel|title|cos|labelRotation|strokeColor|symbolizer|hidden|blocks|groupDiv|createAlphaImageDiv|getElementById|getOptions|drawImage|sort|showSlider|changebaselayer|ModifyFeature|mode|virtualVertices|modified|doubleClick|touchstart|border|dragHandler|layersID|paddingForPopups|MultiPolygon|substr|layerName|red||QueryService|listeners|Browser|getArea|||clickout|autoActivate|text|getCentroid|closePath|lineTo|relativePosition|setExtent|strategies|tempIndex|pop|getMaxExtent|path|_style|href|slider|selectControl|radiusHandle|getNumZoomLevels|touchmove|getStyle|RESOLUTION_PROPERTIES|changeDy|changeDx|mapStatus|backupCanvas|aniCanvas|maxTolerance|ServiceFailedEventArgs|blue|leftBottom|CREDENTIAL|slice|4326|stopObservingElement|LABEL_ALIGN|font|destroyFeatures|calculateBounds|graphicYOffset|graphicXOffset|overflow|setOpacity|removeMap|removeFeatures|drawGeometry|intersectsBounds|Rectangle|rendererRoot|firstChild|removeComponent|clearBounds|createElementWithStyle|removeClass|clientY|floor|pixelTolerance|unload|stopObserving|mapDiv|getZoomForResolution|getResolutionForZoom|sphericalMercator|cache|getCachedCenter|memoryImg|singleTile|newImgTag|isLoading|headers|observers|newResourceID|Grid|tilesets|queryMode|persist|unselectAll|removeItem||_lastHighlighter|vectorRoot|000000|minZoomLevel|strokeDashstyle|strokeOpacity|load|loadstart|lineCap|Gradient|hide|styleMap|zoomChanged|moveByPx|begin|pendingRedraw|isLeftClick|clientX|getCenter|standalone|mouseDown|baseLayersDiv|dataLayersDiv|mouseout|mini|mapLevel|lastUp|marker|buffer|_attempts|inclusive|resourceID|substring|green|rightTop|tileVersions|string|unit|parts|concat|status|Lang|navigator|unselect|removeLayer|event|childNodes|VML|bsInfo|LABEL_FACTOR|normal|maxZoomLevel||strokeLinecap|containsBounds|property|setLineDash|rightBottom|0px||getLayerPxFromLonLat|supported|renderPath|Elements|complete||onreadystatechange|catch|try|preventDefault|target|dragHandle||rectPxBounds|getProjection|triggerCallback|Z_INDEX_BASE|finalize|white|poweredBy|HTTPRequest|viewRequestID|maxPx|popups|DELETE|subLayers|copyAttributes|UGCLayer|GET|QueryResult|coordUnit|urls|index|i18n|getUnits|multiple|_selectStyle|hover|toggle|panel_div|textRoot|contains|setAttribute|solid|protocol|refresh|calculateInRange|pointsLength|shadowDiv|transitionObj|scrollLeft||isFirstDraw|drawPoint|hitCanvas|globalCompositeOperation|selectFeatures||restore|save|symbol|onselectstart|||isFilled|com|defs|outer|selectedGraphics||lastGraphic|bcg|updateAttribution|||snap|Drag|layerOptions|eTop|zoomOut|divEvents|zoomStopHeight|divLevel|_addButton|stoppedDown|passesTolerance|onLoadEnd|clipRegion|backBufferTimerId|baseCanvas|Easing|Request|toFloat|snapLayers|themeElementPosition|overlapDisplayed|resourceInfo|chartLayerNames|200|POINT|getVisibility|onSelect|overFeature|test|GeoText|fontOpacity|_geometryClass|_featureId|setStyle|value|lineJoin|render|arc||pointerEvents||onMapResize|Graphic|getPixelFromLonLat|hitOverflow|cachedSymbolBounds|drawText|sector|graphicTitle|worldBounds|Curve||componentTypes|containsPoint|parent|tilesversion|attribution|removelayer|vertex|UPDATE|mouseover||inputElem|eBottom|includeXY|div_zoombar_three|backgroundColor|Map|keyMask|kinetic|handle|pinching|isApp|modifyFeature|lastDown|serverResolutions|EventPane|getTime|redirect|firstInView|updateSize|panTween|Snap|charAt|holdTime|newResourceLocation|hasOwnProperty|ServerStyle|solidStyle|datasetInfo|overlapDisplayedOptions|fillGradientMode|startRecord|expectCount|queryResults|LINE|chartQueryFilterParameters|300|area|obj|toLowerCase|getLength|measure|multipleSelect|highlight|cloneObject|outFeature|clickFeature|drawFeatures|measureText|LABEL_ID_SUFFIX|||symbolizers|radius1|lineDash|colorStops|match|1238|positionBlocks|show|lastResolution|256|hitCanvasBack|backCanvas|drawRectangle|polygonCanvas|drawPolygon|drawLineString|MAX_PIXEL|org|indexer|ElementsIndexer|containsLonLat|addlayer|setVisibility|setBaseLayer|organizer|multi|controlSkinBlue|dataLbl|layerStates|log|zoomIn|mouseDragStart|touchend|rightclick|redoStack|clearTimer|getEventInfo|selectUrl|getTileUrl|inverseMercator|setGMapVisibility|initResolutions|tileOrigin|getScaleFromResolutionDpi|calculateResolutions|resolutionsFromScales|alwaysInRange|addEventType|initGriddedTiles|timeoutID|step|gutter|allOverlays|documentElement|extensions|keydown|setLayerFailed|lastparams|layerStatusList|fromObj|UGCMapLayer|ResourceInfo|customResponse|foreColor|backColor|lineColor|fillForeColor||fillBackColor|INTERSECT|recordsets|||attributeFilter|toGeometry|exec|Type|INCHES_PER_UNIT|getGeodesicArea|delayedTrigger|freehandMode|modify|setLayer|onUnselect|onBeforeSelect|addLayer|offsetX|fillText|IS_GECKO|end|visibilitychanged|Filter|createSymbolizer|setTransform|not|graphicOpacity|relative|imageSize|panMapIfOutOfView|Anchored|contentSize|getLonLatFromLayerPx|getFeatureIdFromEvent|Error|eraseFeatures|unrenderedFeatures|isFixed|lastCanvasPosition|eraseGeometry|lastBounds|hitContextBack|featureDx|polygonContext|onload|resetCanvas|drawCircle|createNode|getShortString||translationParameters|getZIndex|maxZIndex|sides|enable|tilesetsIndex|sliderWidth|infWidth|defaultPosition|base|getParameters|INSERT|minimizeControl|switcher|baseLbl|SKIN|zoomTo|alphaHack|div_zoombar|levelsDesc|slideFactor|minRectSize|double|unloadDestroy|fallThrough|delta|version|cursorCSS|msGesture|oldOnselectstart|setZIndex|destroyFeature|Path|getCurrentPointIndex|delay|rightclickTimerId|UNKNOWN|Marker|3857|children|lng|getZoomForExtent|getResolutionFromScaleDpi|setTileSize|SimpleCachedLayer|TiledDynamicRESTLayer|backBuffer|lefttop|contentHTML|movestart|calculateOffset|getResolutionFromScale|transforms|DONE|UNSENT|issue|centerLonLat|lineTolerance|pointTolerance|off|SetLayersInfoResult|setLayerComplted|POST|displayFilter|transparentColor|specialColor|attributeFields|fromGeometry|getQueryParameters|queryParams||fields|100000|epsgCode|projCode|responseText|POLLING_TIMES|toUpperCase|msie|geolocation|initLayer|unhighlight|isSelected|highlightOnly|clickoutFeature|except|isNewAdd|shift|labelSelect|response|temporary|miterLimit|maxSize|minSize|autoSize|moveRoot|which|TypeError|firstLoad|sketchcomplete|featuremodified|16777216|londingimgs|drawImageScaleFactor|getViewPortPxFromLayerPx|backCanvasContext|userAgent|clientWidth|False|shape|block|xmlns|remove|indices|unshift|getSortedSegments|1000|removePoint||addPoint||Format|smButton|hasClass|sliderBarEvents|infDiv|tileWidth|changeElements||btnWidth|createBtn|TilesVersionControl|location|||getParameterString|updateLink|_sketch|pixel|deleteCodes|lastPixel|dragstart|finishGeometry|maximizeControl|BLUE|checked|PanZoomBar|getSlideFactor|panright|panleft|pandown|panup|getComputedStyle|defaultView|currentStyle|fractionalZoom|offsets|sliderEvents|showCompass|device|attachEvent|wComp|hComp|rectEvents|stopDouble|lastXy|isIESingleTouch|contextmenu|checkModifiers|snapAngle|getSketch|destroyPersistedFeature|lastTouchPx|modifyDOMElement|LatLng|displayed|dragPanMapObject|forwardMercator|layerType|onLoadStart|removeTileMonitoringHooks|addTileMonitoringHooks|drawCanvasTile|fixPosition|erase|prjStr1|getMapStatusService|memoryKeys|redrawCanvas|scheduleMoveGriddedTiles|useHighSpeed|transitionEffect|baseCanvasCtx|backupCtx|layerAlphaHack|defaults|maxZoom|minZoom|XMLHttpRequest|_listeners|proxy|Route|beginSnap|setOptions|PUT|SetLayerResult|colorDictionary|isTempLayers|colors|QueryEventArgs|chartFeatureInfoSpecs|primitive|localName|acronym|required|shadow|metaData|TilesetsResult|queryParameters|getJsonParameters|Recordset|ServerFeature|MapServiceResult|getUrlParameters|MeasureResult|AREA|fieldValues|fieldNames|fid|REGION|createLineEPS|times|geodesic|cancelDelay|SelectFeature|repeat|RootContainer|Box|allowClickTwice|getControlsBy|addControl|TYPE_TOOL|activeState|offsetY|getRotatedLocation|mozMeasureText|mozDrawText|middle|textAlign|1em|getLabelInfo||viewLabels|Rule|drawHitDetectionCanvas|createCanvasContext2D|spaceAngle|360|RadialGradient|LinearGradient|isShowShadow|shadowContainerDiv|contentDisplayClass|getContentDivPadding|getFeatureFromEvent|displayInLayerSwitcher|removeText|geometryType|restoreCanvas|sketchmodified|drawGraphic|source|externalGraphicCount|externalGraphicSource|trim|longdashdot|longdash|dashdot|dash|dot|MAX_VALUE|nowrap|alpha|rect|Microsoft|isStroked|getElementsByTagName|isComplexSymbol|symbolMetrics|inValidRange|getComponentsString|svg|toFixed|www|BACKGROUND_ID_SUFFIX|backgroundGraphic|IndexingMethods|edge|limitSigDigs|addPointEPS|atan2|changElementsStyle||changeTilesVersion|elementLefts|sliderHeight|cHeight|120|virtualStyle|smDragDown|create|ignoreEvent|timeOut||button|clearLayersArray|zoomOutLink|zoomInLink|_pan_innerImage|SuperMap_Control_PanZoomBar_Zoombar||deltaY|zoomStart|zoomBarDrag|divClick|gif|Click|baseLayerChanged|showToggle|maximized|layerContainerOrigin|lastTouches|PinchZoom|currentCenter|pinchOrigin|wheel|animate|eventListener|KEY_EVENTS|wheelListener|boxOffsets|documentEvents|setLayerZIndex|handleMapEvents|stopUp|getGeometry|drawingHole|registerPriority|createFeature|first|BROWSER_EVENTS|removePopup|unrenderedGraphics|900913|getMapContainer|SphericalMercator|FixedZoomLevels|RESOLUTIONS|nullTransform|Tianditu|zOffset|Baidu|getXYZ|CanvasImage|CloudLayer|mapName|mergeNewParams||getScaleForZoom|isZoomming|shouldDraw||_moveGriddedTiles|moveGriddedTiles|shiftRow|shiftColumn|isFirstLoad|createBackBuffer|fadingTimer|numLoadingTiles1|gridResolution||ceil|backBufferp|aniCtx|showTile|getScaleFromResolution|updateSizeDestroy|easeOut|xml|Content|OPENED|_headers|open|scrolls|extensionCount|eventTypes|_eventCacheID|time|snapLine|details|snapPoint|atPoint|SetLayersInfoEventArgs|mapUrl|UGC|tempLayersSet|fieldValuesDisplayFilter|colorDictionarys|GRID|description|transparent|ChartFeatureInfoSpec|ChartAttributeSpec|ServerTextStyle|italic|markerSymbolID|markerSize|markerAngle|lineSymbolID|fillSymbolID|fillOpaqueRate|fillGradientOffsetRatioY|fillGradientOffsetRatioX|fillGradientAngle|fillBackOpaque|spatialQueryMode|queryOption|networkType|customParams|queryError|queryComplete|returnCustomResult|currentCount|totalCount|fieldTypes|fieldCaptions|datasetName|linkItems||chartFeatureInfoSpecCode|isQueryRegion|isQueryLine|isQueryPoint|MapService|measureComplete|datasourceConnectionInfo|user|password|CCWArray|errorMsg|originResult|len|eval|random|_processFailed|_processSuccess|geolocationOptions|getGeodesicLength|measurepartial|immediate|selectBox|AnimatorVector|selectStyle|getControl|toggleKey|toggleSelect|multipleKey|boxDivClassName|allowSelectTheSameFeature|trigger|getLabelPxBoundsByLabel|textContent|baseline|lastChild|getPxBoundsMode|isStyleChange|styleGroups|groupField|ee9900|merge|abort|getMapBounds|resFactor|evaluate|maxScaleDenominator|createLiteral|minScaleDenominator|StyleMap|Clover|propertyStyles|addPropertyStyles|Framed||imageSrc|629|fixedRelativePosition|isAlphaImage|createImage|calculateNewPx||updateRelativePosition|with|transition|Canvas2|vertexmodified|afterfeaturemodified|beforefeaturemodified|eraseGraphics|labelMap|calculateFeatureDx|destination|valid|drawNamedSymbol|circle|drawExternalGraphic|android|featureIdToHex|importSymbol|setNodeDimension|clientHeight|1px|inherit|flip|nodeTypeCompare|_rotation|RADIAL|LINEAR|getNodeType|namespaces|viewBox|getAttributeNS|getPosition|implementation|span|srcElement|graphicZIndex|537|007|833|822|981|161|labelWTmp|LTypeArc|calculatePointsFBZN|atan|factorial|distanceToSegment|segmentsIntersect|WKT||getPressedButton|handleBrowserEvent|handleEventResult|buttonElement|buttonClick|popInfDiv|sliderBarDragStart|background||getOrCreateLinks|observed|separator|ArgParser|configureLayers|RESIZE|RESHAPE|_index|vertexRenderIntent|resetVertices|_originalGeometry||Keyboard|redo|undo|insertDirectionLength|insertDeltaXY|insertXY|ascending|controlSkinWhite|dataLayers|baseLayers|outsideViewport|topInUnits|zoomToMaxExtent|action|mouseOverLevel|crop|moveZoomBar|zoomBarUp|isSingleTouch|zoomBarDown|zoomend|div_zoombar_one|blank|setRectPxBounds|stopSingle|addLayers|maxRatio|minRatio|9e9e9e|defaultDblClick|defaultClick|pinchZoomOptions|dragPanOptions|DragPan|updateContainerOrigin|zoomWheelEnabled|zoomBoxEnabled|centerPixelOffset|panned|enableKinetic|zoomToExtent|mousewheel|mousePosition|opera|removeBox|irregular|fixedRadius|smDefault|True|zoomDuration|isMultiTouch|dragend|timeoutId|setEvent|getLayerIndex|Overlay|maxVertices||delayedCall|Bing|quadKey|_blank|space|Data|openstreetmap|getMapObjectPixelFromXY|getMapObjectLonLatFromLonLat|getLatitudeFromMapObjectLonLat|getLongitudeFromMapObjectLonLat|1100|GLatLng|dragObject|getMapObjectCenter|3392|num|33554432|calculateResolutionsLevel|getURL|tileOriginPx|supportCanvas|isDrawn|3427892|upperCaseObject|getFullRequestString|LocalStoragePlugin|cordova|getTileSize|bufferImgCount|drawCanvasTile2|inZoom|addTile|setFirstInView|lastZoom|removeBackBuffer|useAnimation|tileOriginCorner|canvasImage|idx|positionImage|renderTile|backBufferTile||removeBackBufferDelay|numLoadingTiles||backBufferResolution|setUrl|aniFinish|modifyAlphaImageDiv|panIntoView|Icon|STDDEVIATION||CROSS|IDENTITY|RIGHT|LEFT|ELLIPSE|SQUAREROOT||LOGARITHM|WITHIN|CONTAIN|Tween|clearMouseCache|Expo|Proj4js|defData|async|_data|send|withCredentials|setRequestHeader|detachEvent|scrollTop|clearMouseListener|eventHandler|clearInterval|duration|finish|playing|500|MAX_TOLERANCE|DEFAULT_TOLERANCE|snapPolygon|SetLayersStatusEventArgs|lastIndexOf|isVisible|GetLayersInfoEventArgs|elevation|ugcLayerType|ColorDictionary|DatasetInfo|ServerTheme|RANGE|GRADUATEDSYMBOL|DOTDENSITY|GRAPH|UNIQUE|LABEL|sizeFixed|JoinItem|opaqueRate|WMS|WFS|handleLayers|ChartFeatureInfoSpecsResult|BASELINECENTER|TilesetsService|TilesetsEventArgs|isNearest|ATTRIBUTEANDGEOMETRY|ChartQueryFilterParameter|getMapStatusError||MapServiceEventArgs|getMapStatusCompleted|MeasureEventArgs|MeasureMode|measureMode|DISTANCE|METER|connect|IsClockWise|SRID|toGeoPoint|LINEM|committer|Text|Raster|Line|Geolocate|geolocate|watch|watchId|Measure|displaySystem|displaySystemUnits|measureImmediate|featureunselected|featureselected|beforefeatureselected|ItemInactive|iconOff|iconOn|addControlsToMap|defaultControl|saveState|isPointInPoly|aspectH|aspectW|rotationBounds|mozTextStyle|textBaseline||||serif|sans|LABEL_VFACTOR|LABEL_VSHIFT|_geometry|weight|family|getLabelPxBoundsByText|calculateLabelBounds|isOverLay|isAvoid|12px|read|BBOX|autoDestroy|getScale|addRules|drawSector||SYMBOLIZER_PREFIXES|findPropertyStyles|createLiterals|defaultsPerSymbolizer|applySymbolizer||338|631|updateBlocks|setBorder|setBackgroundColor|calculateRelativePosition|updatePosition|keepInMap|collectRoots|resetRoots|handleChangeLayer|getRenderLayerId|getDataExtent|getFeatureBy|isPlottingGeometry|isMultiPlotting|featuresremoved|featureGridList|useCanvas2|afterAdd|renderers|sketchstarted|vertexremoved|featureadded|beforefeatureadded|getImageData|16777215|backCanvasPosition|getPointBounds|LABEL_SHIFT|symbolCache|getLayer|drawSurface|drawLine|createRoot|createRenderRoot|nodeName|coordsize|coordorigin|fillcolor|postDraw|DXImageTransform|progid|graphicRotate|_options|featureId|applyDefaultSymbolizer|StopOpacity|StopColor|createDefs|createGradient|clipLine|insertBefore|onclick|hasFeature|redrawNode|_boundsBottom||Z_ORDER||getNextElement||compare|350|polygonType|angel|mutual|splitWith|6378137|rad|calculateCircle|LTypeCurve|GetBezierGap|InciseBezier|05|POSITIVE_INFINITY|tolerance|distVincenty|tag|toShortString|setBounds|fromWKT|mouse|tilesVersionReduceLink|tilesVersionAddLink|sliderMouseDown|sliderBarUp|sliderBarDrag|sliderBarDown|domEvents|sliderBar|getTilesetsInf|Attribution|Permalink|argParserClass|ROTATE|setFeatureState|unselectFeature|||beforeSelectFeature|keyboard|DragFeature|featureCallbacks|onComplete|onDrag|onStart|Over|DrawFeature|insertDeflectionLength|LayerSwitcher|isMouseDown|minimize|showControls|updateMap|getBarLen|bottomInUnits|bottomOutUnits|topOutUnits|maxWidth|minus|zoommaxextent|zoomout|removeButtons|maxextent|doubleClickLevel|forceFixedZoomLevel|pagePosition|_removeZoomBar|divEventLevel|slideRatio|getOverviewPxFromLonLat|getLonLatFromOverviewPx|panTo|updateMapToRect|updateRectToMap|resolutionFactor|single|createMap|redrawAllLayers|getCenterPixel|baseLayerDraw|emptyString|granularity|isIEMultipTouch|MSGestureEnd|applyTransform|pinchDone|containerOrigin|pinchMove|pinchStart|Pinch|Navigation|wheelChange|MouseWheel|ZoomBox|dblrightclick|handleRightClicks|MOD_SHIFT|Kinetic|geometryTypeMatches||getGraphicFromEvent|cumulative|wheelZoom|scroll|getPropertyValue|snapToggle|createGeometry|shiftKey|getDistance|MSPointerUp|MSPointerDown|_docUp|_docMove|removeDocumentEvents|adjustXY|cur|cursors|mouseLeft|lastMoveEvt|dragmove|moveLayerToTop|stopClick|enforceTopology|finalizeInteriorRing|restoreFeature|holeModifier|freehand|freehandToggle|handleDouble|handleSingle|labelOutlineWidth|labelOutlineColor|visiblePainted|hoverPointUnit|hoverPointRadius|hoverStrokeWidth|hoverStrokeOpacity|hoverStrokeColor|hoverFillOpacity|hoverFillColor|destroyPopup|destroyMarker|onScreen|popupClass|removeMarker|Graphics|graphicsremoved|drawGraphics|113|syr|mkt|comp|live|ditu|tiles|dynamic|OSM|repositionTimer||||repositionListener|addListenerOnce|setMapObjectCenter|getMapObjectPixelFromMapObjectLonLat|getMapObjectLonLatFromMapObjectPixel|getDiv|9999px|resized|repositionMapElements|loadMapObject|_resized|getWarningHTML|removeGMapElements|_dragging|MAX_ZOOM_LEVEL|MIN_ZOOM_LEVEL|getMapObjectLonLatFromOLLonLat|getOLLonLatFromMapObjectLonLat|addTransform|vec|getMemoryImg|Markers|drawMarker|urlTemplate|urlAppend|cacheEnabled|getValue|DEFAULT_PARAMS|getStatusFailed|layerInitialized|||getStatusSucceed|strServiceUrl|storageType|getTileOrigin|lenColumn|lenRow|mapStyle|drawImgData|tileOptions|tileClass|tileLoadingDelay|applyBackBuffer|initSingleTile|getTilesBounds|Animal|sdcardPath|useCORS|displayImage|loadTileImage|reload|getBoundsFromBaseLayer|reproject|canvasType|clearGrid|removeExcessTiles|tileloaded|backBufferLonLat||||SUPPORTED_TRANSITIONS|triggerAnimal|onImageLoad|getImageSize|imageOffset|displayOutsideMaxExtent|fixPadding|_oldOverflow|closeOnMove|restricted|isValidZoomLevel|isValidLonLat|forceZoomChange|eachStep|panMethod|addControlToMap|getBy|getLayersBy|degrees|titleRegEx|__func|statusText|responseXML|tagName|getResponseHeader|timeStamp|cancelable|bubbles|_aborted|stopPropagation||removeEventListener|addEventListener|onabort|application|onsend|onopen|LOADING|HEADERS_RECEIVED|wrapped|config|hasScrollEvent|func|boolean|_removeElementObservers|useCapture|observer|deceleration|theta|tick|easeInOut|easeIn|easing|values|receive|cannot|fromArray|camelize|toISOString|snapping|PointWithMeasure|setSnapLayers|setMaxTolerance|setLineTolerance|setPointTolerance|eventType|Infinity|SetLayerInfoService|SetLayerStatusService|getMapName|createTempLayerComplete|SetLayerStatusParameters|LayerStatus|SetLayersInfoService|toJsonObject|OverlapDisplayedOptions||contrast|brightness|SupweMap|GetLayersInfoService|getLayerFailed|getLayerComplted|ChartFeatureInfoSpecsService|getFeatureFailed|getFeatureComplted|underline|outline|strikeout|italicAngle|bold|fontName|fontWidth|fontHeight|backOpaque|align|TextAlignment|findFacilityError|findFacilityComplete|QueryByDistanceService|QueryByDistanceParameters|QueryByGeometryService|QueryByGeometryParameters|SpatialQueryMode|QueryByBoundsService|QueryBySQLService|toFeature|QueryByBoundsParameters|QueryBySQLParameters|FilterParameter|groupBy|orderBy|ids|QueryOption|ChartQueryService|getVariablesJson|ChartQueryParameters|toJson|prjCode|coordSystem|MeasureService|measureError|point2Ds|MeasureParameters|Unit|LinkItem|primaryKeys|linkFilter|linkFields|foreignTable|foreignKeys|joinType|joinFilter|foreignTableName|DatasourceConnectionInfo|server|readOnly|OpenLinkTable|exclusive|engineType|driver|dataBase|alias|minM|maxM|toGeoRegionEPS|toGeoRegion|toGeoLinem|toGeoLineEPS|toGeoLine|ServiceUrls|getServiceUrlsFailed|urlService|getServiceUrlsCompleted|isServiceSupportPolling|calculatePollingTimes|ajaxPolling|getUrlFailed|getUrlCompleted|defaultCode|setCode|locationfailed|getCurrentLocation|locationupdated|coords|locationuncapable|getBestLength|getBestArea|partialDelay|measurePartial|metric|featureunhighlighted|featurehighlighted|beforefeaturehighlighted|_container|smHandlerBoxSelectFeature|Panel|getControlsByClass|onDoubleClick|activateControl|onClick|ItemActive|addControls|allowDepress|TYPE_TOGGLE|TYPE_BUTTON|addLabels|getDrawnLabels|setlabelsStyle|overWriteFunctions|lineIntersection|isQuadrilateralOverLap|getAvoidInfo|rows|tspan|_tspan_|central|dominant|addTmpFuncForRenderer|calculateLabelBounds2|getLabelPxLocation|_isGeoTextStrategyStyle|Fixed|preload|Logical|Spatial|createFilter|triggerRead|invalidBounds|elseFilter|Comparison|extendDefault|RegularShape|HitClover|Circle|Stroke|linejoin||Fill|setColorStops|getSymbolizerPrefix|setDefaultStyle|FramedCloud|subject|330|createShadowFromPopup|createBlocks|oppositeQuadrant|determineQuadrant|getFeatureById|associated|some|but|destroyed|you|means|usually|This|called|removeBackground|clipFeature|removeAllFeatures||featuresadded|beforefeaturesadded|displayError|rendererOptions|assignRenderer|featuresGridColumn|featureresize|featurerotate|featuremove|getGraphicIdFromEvent|graphicIdToHex|addLabel|localToMap|Vector_|283185307179586|fillRect|screen|320|butt|CanvasGradient|Animal2|textbox|group|unselectable|strokecolor|_image|imagedata|focus|oval|urn|_radialGradient|_linearGradient|visiblepainted|cloneNode|xlinkns|firefox|node|drawGeometryNode|backgroundGraphicZIndex|backgroundYOffset||backgroundXOffset|redrawBackgroundNode|insert|yOrdering|Z_ORDER_Y_ORDER|Z_ORDER_DRAWING_ORDER|determineZIndex|exists|164|763||426|462|949|519|339|494|604|373|756|215|301|250|defaultSymbolizer|textC|charCodeAt|getTextCount|getTextWidth|getLabelPxSize|createRegularPolygon|createLineArc|005|combSort|BEZ|calculatePointsFBZ3|createBezier3|calculatePointsFBZ2|lines|splitWithSegment|addComponents|SelectGraphic|graphicunselected|graphicselected|beforegraphicselected|outGraphic|overGraphic|ChangeTilesVersion|onTilesVersionClick|setInf|lastTilesVersion|nextTilesVersion|sliderBarDragStartX|sliderDown|2px|margin|createPopInf|createInf|createSlider|createCenter|tilesVersionAdd|tilesVersionCenter|tilesVersionReduce|tilesVersionCenterLink|setTileWidth|template|createParams|DRAG|collectRadiusHandle|collectDragHandle|collectVertices|keyCode|handleKeypress|dragComplete|dragVertex|dragStart|selectFeature|snappingOptions|onLeave|doneDragging|upFeature|moveFeature|downFeature|onEnter|dragCallbacks|featureAdded|mouseUp|SuperMap_Control_MaximizeDiv|maximize|_layersDiv|minimizeControlCT|minimizeControlT|loadContents|borderWidth|3px|layerSwitcher|disabled|onInputClick|labelSpan|backgroundImage||checkRedraw|ScaleLine|getGeodesicPixelSize|isImperialUnits|Zoom|onZoomClick|30px|34px|zoomOutClassName|zoomInClassName|plus|zoomin|buttonDown|_removeButton|btnMouseOut|btnMouseOver|mouseOutLevel|_buttonLabel|startTop|levels|Opera|zoombar|zoombar_center|zoombar_glide|_addZoomBar|KeyboardDefaults|KEY_DOWN|KEY_UP|KEY_RIGHT|KEY_LEFT|defaultKeyPress|OverviewMap|getMapBoundsFromRectBounds|getRectBoundsFromMapBounds|ExtentRectangle|minRectDisplayClass|mapDivClick|rectDrag|mapOptions|updateOverview|isSuitableOverview|autoPan|MaximizeButton|overView|borderLeftColor|borderTopColor|updateLayers|MousePosition|suffix|prefix|numDigits|formatOutput|TouchNavigation|clickHandlerOptions|containerOriginCanvas|MSdone|MSmove|MSstart|wheelDown|wheelUp|defaultDblRightClick|mouseWheelOptions|zoomBoxKeyMask|panMapDone|panMap|panMapStart|kineticInterval|alwaysZoom|Active|LeftBottom|RightBottom|RightTop|LeftTop|Mode|allowSelection|removeControl|handleKeyEvent|DOMMouseScroll|detail|wheelDelta|onWheelEvent|getBoxOffsets|smDrawBox|endBox|moveBox|9999|startBox|RegularPolygon|calculateAngle|modifyGeometry|getPinchData|MSGestureChange|MSGestureStart|pointerup|pointerdown|MSGesture|addDocumentEvents|Pan|removeTimeout|moveLayerBack|clickTolerance|EVENTMAP|returnValue|singleTouch|doubleTouchTolerance|geometryClone|Hover|stopMove|dblclickTolerance|passesDblclickTolerance|getTouchDistance|queuePotentialClick|delayedRightCall|isRightClick|unregisterMouseListeners|MOD_ALT|MOD_CTRL|66cccc|createPopup|createMarker|getGraphicBy|getGraphicById|removeAllGraphics|addGraphics|removeGraphics|destroyGraphics|graphicsadded|152|305|611|1222|2445|4891|9783|19567|OpenStreetMap|removeListener|getBoundsZoomLevel|getMapObjectZoomFromMapObjectBounds|animationEnabled|getMapObjectBoundsFromOLBounds|gmnoprint|olLayerGoogleV3|olLayerGooglePoweredBy|olLayerGoogleCopyright|DEFAULTS|getContainer|checkResize|GEvent|getDragObject|GMap2|getYFromMapObjectPixel|getXFromMapObjectPixel|getMapObjectZoom|initMercatorParameters|40625|getMapObjectZoomFromOLZoom|getOLZoomFromMapObjectZoom|getMapObjectPixelFromOLPixel|getOLPixelFromMapObjectPixel|smoothDragPan|loadWarningMessage|projectInverse|projectForward|102100|102113|exp|tan|156543|ter|setTiandituParam|isLabel|tianditu|addMemoryImg|Canvas_|clearMarkers|changeURL|clipRegionEnabled|clearMemoryImg|000131072|000065536|000032768|000016384|000008192|000004096|000002048|000001024|12e|56e|28e|getTileUrlByBounds|loadError|calculateDpi|getAppStatusSucceed|bmp|adjustBounds|drawCanvasIE|addtile|getAnimationValue|file|setNotFirstInView|IMAGE_RELOAD_ATTEMPTS|onErrorFunction|onLoadFunction|anonymous|crossOrigin|onLoadsaveUrlFunction|getMethodName|startTransition|isBackBuffer|getServerResolution|tilelat|tilelon|tileoffsetlat|tileoffsetlon|tileoffsety|tileoffsetx|calculateGridLayout|100px|URL_HASH_FACTOR|animalEnd|execZoomTo|useBlankTile|isEquivalentUrl|removeImgDiv|initImgDiv|maxGetUrlLength|BORDER|OPACITY|COLOR|HEIGHT|WIDTH|ondblclick|onmouseout|onmouseup|onmousemove|onmousedown|registerEvents|addCloseBox|_contentDivPadding|_onImgLoad|registerImageListeners|setContentHTML|disableFirefoxOverflowHack|defaultIcon|nodeType|EXP2|EXP1|SPHERICAL|GAUSSIAN|EXPONENTIAL|UniversalKriging|SimpleKriging|KRIGING|QUADTREE|KDTREE_FIXED_RADIUS|KDTREE_FIXED_COUNT|UBIT32|UBIT24|UBIT8|UBIT4|UBIT1|DOUBLE|SINGLE|BIT64|BIT32|BIT16|VARIANCE|SUM|MIN|MAX|AVERAGE|CUSTOM|RGB|CMYK|NO_SUBWAY|SUBWAY|BUS|MIN_DISTANCE|LESS_WALK|LESS_TRANSFER|LESS_TIME|RECORDSET_ONLY|DATASET_ONLY|DATASET_AND_RECORDSET|ISOREGION|ISOLINE|POLISH|BSPLINE|XOR|UNION|ERASE|CLIP|ROUND|FLAT|END|BACK|AHEAD|OPTIONALCENTER|NULL|FIXEDCENTER|MIDDLE|WEST|SOURTH|NORTH|EAST|OMIT|NEWLINE|TRIANGLE|ROUNDRECT|RECT|MARKER|DIAMOND|NORMAL|SQUARE|CONICAL|MIDDLERIGHT|MIDDLECENTER|MIDDLELEFT|BOTTOMRIGHT|BOTTOMCENTER|BOTTOMLEFT|BASELINERIGHT|BASELINELEFT|TOPRIGHT|TOPCENTER|TOPLEFT|TERRAIN|SPECTRUM|QUANTILE|EQUALINTERVAL|CUSTOMINTERVAL|CONSTANT|YAXES|ALL|STEP|STACK_BAR3D|STACK_BAR|ROSE3D|ROSE|RING|PIE3D|PIE|BAR3D|BAR|VALUE|PERCENT|CAPTION_VALUE|CAPTION_PERCENT|CAPTION|UDB|SQLPLUS|SDBPLUS|ORACLEPLUS|OGC|IMAGEPLUGINS|RADIAN|MINUTE|SECOND|FOOT|DECIMETER|INCH|CENTIMETER|MILLIMETER|DEGREE|YARD|MILE|KILOMETER|TOUCH|OVERLAP|DISJOINT|LEFTJOIN|INNERJOIN|GEOMETRY|ATTRIBUTE|TEXT|CIRCLE|leftTolerance|rightTolerance|addOptions|clean|removed|added|TILE_HEIGHT|TILE_WIDTH|getLayerPxFromViewPortPx|centerLayerContainer|panDuration|panRatio|zoomFinished|offsetHeight|getCurrentSize|setLayerIndex|resetLayersZIndex|preremovelayer|preaddlayer|BaseLayer|smMap|link|CRS|ActiveXObject|readystatechange|dispatchEvent|_async|handleEvent|setCredentials|getAllResponseHeaders|XMLSerializer|onunload|OPTIONS|HEAD|TYPE|CONTENT|runCallbacks|requestUrl|URL_SPLIT_REGEX|ProxyHost|DEFAULT_CONFIG|getMousePosition|attachToElement|unloadCache|KHTML|Safari|Konqueror|appVersion|keypress|setInterval|speed|threshold|nbPoints|Quad|Linear|invalid|play|INTERVAL|fromString|RegExp|decimalSeparator|thousandsSeparator|isNumeric|numberRegEx|tokenRegEx|orgin|actived|switchSnap|reference|elementRemain|verticalOverlappedSpaceSize|horizontalOverlappedSpaceSize|allowThemeGraphOverlap|allowThemeGraduatedSymbolOverlap|allowTextAndPointOverlap|allowTextOverlap|allowPointWithTextDisplay|allowPointOverlap||tableName|isReadOnly|encodeType|dataSourceName|ThemeRange|ThemeGraduatedSymbol|ThemeDotDensity|ThemeGraph|ThemeUnique|ThemeLabel|transparentColorTolerance|displayBandIndexes|colorSpaceType|verticalSpacing|specialValueTransparent|specialValue|horizontalSpacing|gridType|colorGradientType|representationField|symbolScale|symbolScalable|minVisibleGeometrySize|completeLineSymbolDisplayed|queryable|caption|VECTOR|IMAGE|THEME|JSONClone|copy|Roman|New|Times|400|DistanceQuery|FindNearest|SpatialQuery|BoundsQuery|SqlQuery|chartQueryParameters||chartQueryParams|ChartBoundsQuery|304|then|xhr|WinJS|Windows|axis|spheroid|datum|linearRing|LineRing|REGIONEPS|LINEEPS|POINTEPS|address|proxyservers|services|iserver|EditFeaturesService|ThemeService|language|userLanguage|getCurrentPosition|latitude|longitude|clearWatch|watchPosition|updateHandler|setImmediate|english|geographic|getControlsByName|getComputedTextLength|filters|AND|noAbort|force|FeatureId|EQUAL_TO|addUniqueValueRules|eAngle|sAngle|CANVAS|array|parameters|two|than|more|must|isDefault|corner|SuperMapDivimgCorner|SuperMapDiv|SuperMapShadowDiv|845|1175|331|1187|cloud|660|1200|105|678|359|679|106|682|263|683|632|736|1276|smFramedCloudPopupContent|_FrameDecorationImg_|_FrameDecorationDiv_|preFeatureInsert|onFeatureInsert|getFeaturesByAttribute|getFeatureByFid|_clip_|clipGeometryRect|should|component|updateDimensions|featuresGrid|unitsHeight||unitsWidth|featuresGridRow|reportError|featureremoved|beforefeaturesremoved|beforefeatureremoved|Graphic_|forDisplay|endCol|startCol|endRow|startRow|clearFeatures|xor|rgb|isModify|toClearFeatures|setResolution|featuresIds|inset|whiteSpace|innerText|_textbox|_vmlRoot|BasicImage|expand|SizingMethod|M22|M21|M12|M11|Matrix|sizingMethod|AlphaImageLoader|interactive|dashstyle|flat|endcap|_stroke|stroked|atmost|aspect|fillOpacity2|opacity2|fillColor2|color2|focusposition|gradientradial|gradient|_fill|filled|inline|behavior|addRule|createStyleSheet|vml|microsoft|schemas|hanging|radialGradient|linearGradient|isUnicode|evenodd|rule|_defs|_svgRoot|createElementNS|dasharray|linecap|nextSibling|preserveAspectRatio|polyline|BasicStructure|w3c|SVG11|15000|xlink|1999|2000|correspondingUseElement|backgroundHeight|backgroundWidth|zIndexing|_root|_label|_background|clover|triangle|square|cross|321|231|303|277|423|397|469|379|star|enC|cnC|getBoundsByText|Bspline|createBsplinesurface|Triangle|lineLength|createRegularPolygonTriangle|createRegularPolygonCurve|createLineCurve|acos|createCloseCardinal|calculateCardinalPoints|createBezierN|createBezier|createBezier2|createBezier1|createBspline|Smooth|cubicTension|lanczosFilterSize|mirror|clip|lanczos|createCurve|simplify||inner|removeComponents|write|extendBounds|smNoSelect|inf_bottom|inf_right|inf|inf_left|5px|sliderbar|tileservision|slider2|slider1|reduce|160|isElement|finishSketch|drawGraphicObject|PlottingLayer|layerSwitcherContent|SuperMap_Control_MinimizeDiv|171|Overlays|Base|borderColor|minimizeDivWhite|maximizeDivWhite|layerSwitcherHR|layersDivWhite|onLayerClick|gray|off_b|on_b|defaultChecked|_baseLayers|_input_|input|reverse|Layers|LayersDiv|onButtonClick|buttonclick|000001|Bottom|Top|smControlZoomOut|smControlZoomIn|getLinkStyle|east|west|south|north|div_zoom_name|sm_|zoombarThree|zoomBar|zoombarOne|getDoms|imageSources|4c4c4c|centered|zoomStopWidth|189|109|107|187|MinimizeButton|SuperMap_Control_minimizeDiv|Container|overviewMap|RectReplacement|smaller|Arial|moz|webkit|enableZoomWheel|disableZoomWheel|enableZoomBox|disableZoomBox|oncontextmenu|WHITE|smControlNoSelect|setPosition|keyup|black|smHandlerBoxZoomBox|flag|gesture|pointerId|addPointer|pointerType|PanDown|pause|MOD_NONE|altKey|ctrlKey|toState|Delete|Update|Insert|Unknown|popupContentHTML|popupSize|_popup|AnchoredBubble|getGraphicsByAttribute|aftergraphicmodified|graphicmodified|beforegraphicmodified|graphicremoved|beforegraphicsremoved|beforegraphicremoved|graphicadded|beforegraphicsadded|beforegraphicadded|5971642833948135|194328566789627|388657133579254|777314267158508|554628534317017|109257068634033|218514137268066|43702827453613|87405654907226|74811309814453|4962261962891|9924523925781|9849047851562|9698095703125|939619140625|87923828125|7584765625|39135|516953125|78271|BingMap|bing|idle|LatLngBounds|setMapTypeId|tilesloaded|10000002|1000000|1000001|center_changed|streetViewControl|scrollwheel|disableDoubleClickZoom|draggable|keyboardShortcuts|disableDefaultUI|mapTypeId|_GMapContainer|ROADMAP|MapTypeId|GPoint|fromLatLngToContainerPixel|fromContainerPixelToLatLng|GSize|moveBy|GLatLngBounds|setMapType|addListener|isLoaded|addMapType|getMapTypes|_GMap2Container|G_NORMAL_MAP|googleWarning|getNorthEast|getSouthWest|getOLBoundsFromMapObjectBounds|API|Maps|Unsupported|705522537231445e||000001341104507446289|00000268220901489257|00000536441802978515|00001072883605957031|00002145767211914062|00004291534423828125|0000858306884765625|000171661376953125|00034332275390625|0006866455078125|001373291015625|00274658203125|0054931640625|010986328125|02197265625|0439453125|087890625|17578125|3515625|703125|yellow|7px|_warning|darkblue|BROWSER_NAME|_EventPane|03390625|0339|degree|cta|cia|cva|DataServer|0254|scaler|20150815|udt|onlinelabel|bdimg|online|baidu|offsetXY|addMarker|meter|597164283477938|19432856695588|38865713391175|77731426782351|55462853564701|109257071294|218514142588|4370282851761|874056570352|748113140704|496226281409|99245256282|98490512563|96981025127|93962050254|8792410051|cloudLayerAttr|web|quanguo|FileService|supermapcloud|desc|tileversion|tileImage|savaconfig|visibleScalesEnabled|visibleScales|layerContext|getconfig|jpg|usesCanvas|putImageData|trnasitionObj|bufferContext||getsdcard|sdcard|File|5000|isTooBigCanvas|filtered|canvasFilter|onerror|base64|jpeg|10000|getImgFromLocal_|getMilliseconds|getSeconds|getMinutes|getHours|getDate|getMonth|getFullYear|getImg|toExponential|hideBackBuffer|filterProgress|reprojectionProgress|zoomOffset|getServerZoom|appropriate|getTileBounds|smBackBuffer|_bb|smBackBufferpp|_pp|getTileData|2500|_olSalt|AniCtx|AniCanvas|callee|safari|checkImgURL|crossorigin|removeAttribute|smTileImage|_loadEvent|IFrame|getCanvasContext|Tile_|smPopupCloseBox|_close|getSafeContentSize|_onImageLoad|containerElement|getRenderedDimensions|class|_contentDiv|_GroupDiv|smPopupContent|olPopup|inflate|getLonLat|SM_icon_|Exponent|VariogramMode|InterpolationAlgorithmType|SearchMode|PixelFormat|StatisticMode|LayerType|ColorSpaceType|GridType|TransferPreference|TransferTactic|ADD|EditType|DataReturnMode|SurfaceAnalystMethod|SmoothMethod|OverlayOperationType|BufferEndType|TurnType|SupplyCenterType|SideType|DirectionType|LabelOverLengthMode|LabelBackShape|RIGHT_TOP_TO_LEFT_BOTTOM|RT_TO_LB|RIGHT_BOTTOM_TO_LEFT_TOP|RB_TO_LT|LEFT_TOP_TO_RIGHT_BOTTOM|LT_TO_RB|LEFT_BOTTOM_TO_RIGHT_TOP|LB_TO_RT|ALONG_LINE_NORMAL|AlongLineDirection|FillGradientMode|YELLOWWHITE|YELLOW_WHITE|YELLOWRED|YELLOW_RED|YELLOWGREEN|YELLOW_GREEN|YELLOWBLUE|YELLOW_BLUE|YELLOWBLACK|YELLOW_BLACK|REDWHITE|RED_WHITE|REDBLACK|RED_BLACK||RAINBOW|RAIN_BOW|PINKWHITE|PINK_WHITE|PINKRED|PINK_RED|PINKBLUE|PINK_BLUE|PINKBLACK|PINK_BLACK|GREENWHITE|GREEN_WHITE|GREENRED|GREEN_RED|GREENORANGEVIOLET|GREEN_ORANGE_VIOLET|GREENBLUE|GREEN_BLUE|GREENBLACK|GREEN_BLACK|CYANWHITE|CYAN_WHITE|CYANGREEN|CYAN_GREEN|CYANBLUE|CYAN_BLUE|CYANBLACK|CYAN_BLACK|BLUEWHITE|BLUE_WHITE|BLUERED|BLUE_RED|BLUEBLACK|BLUE_BLACK|BLACKWHITE|BLACK_WHITE|ColorGradientType|ThemeType|RangeMode|GraduatedMode|GraphAxesTextDisplayMode|ThemeGraphType|ThemeGraphTextFormat|EngineType|SpatialRelationType|JoinType|setIsBaseLayer|setName|ltr|dir|metadata|loadcancel|zoomToScale|getMaxResolution|adjustZoom|offsetWidth|removeAllPopup|addPopup|raiseLayer|getNumLayers|smLayerDiv|layerAlreadyAdded|getLayersByClass|getLayersByName|head|css|stylesheet|rel|item|layerContainerShadowDiv|_SuperMap_Container|_events|smMapViewport|_SuperMap_ViewPort|touchAction|Map_|isIEMultipeTouch|clearmarkers|removemarker|addmarker|popupclose|popupopen|1250|750|525|325|crs|def|ogc|srsCode|Proj|parsererror|parseError|loadXML|validateOnParse|XMLDOM|initEvent|eventPhase|currentTarget|serializeToString|track|trace|priority|XMLHTTP|MSIE|controllers|createUrlObject|encodeURIComponent|port|hostname|clientTop|clientLeft|getViewportElement|iPhone|extension|blur|eventCacheID_|findElement|cancelBubble|KEY_DELETE|KEY_ESC|KEY_RETURN|KEY_TAB|KEY_BACKSPACE|KEY_SPACE|asin|0155|token|leftbottom|rightbottom|righttop|getBoundingClientRect|static|toggleClass|setUTCHours|UTC|parse|getUTCMilliseconds|getUTCSeconds|getUTCMinutes|getUTCHours|getUTCDate|getUTCMonth|getUTCFullYear|Invalid|fromSize|containsPixel|toBBOX|toArray|Void|toPrecision|numericIf|startsWith'.split('|'),0,{}))



/***/ },
/* 6 */
/***/ function(module, exports) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * 所有的枚举类。
	 */

	/**
	 *服务请求返回结果数据类型
	 *  GEOJSON: "GEOJSON",
	 *  ISERVER: "ISERVER"
	 */
	Format = {
	    GEOJSON: "GEOJSON",
	    ISERVER: "ISERVER"
	};

	/**
	 * Constant: GeometryType
	 * {Object} 几何对象枚举类。
	 * 该类定义了一系列几何对象类型。
	 *
	 * LINE: "LINE",
	 *
	 * LINEM: "LINEM",
	 *
	 * POINT: "POINT",
	 *
	 * REGION: "REGION",
	 *
	 * ELLIPSE: "ELLIPSE",
	 *
	 * CIRCLE: "CIRCLE",
	 *
	 * TEXT: "TEXT",
	 *
	 * UNKNOWN: "UNKNOWN".
	 */
	GeometryType = {
	    LINE: "LINE",
	    LINEM: "LINEM",
	    POINT: "POINT",
	    REGION: "REGION",
	    ELLIPSE: "ELLIPSE",
	    CIRCLE: "CIRCLE",
	    TEXT: "TEXT",
	    UNKNOWN: "UNKNOWN"
	};

	/**
	 * Constant: QueryOption
	 * {Object} 查询结果类型枚举类。
	 * 该类描述查询结果返回类型，包括只返回属性、只返回几何实体以及返回属性和几何实体。
	 *
	 * ATTRIBUTE: "ATTRIBUTE",
	 *
	 * ATTRIBUTEANDGEOMETRY: "ATTRIBUTEANDGEOMETRY",
	 *
	 * GEOMETRY: "GEOMETRY".
	 */
	QueryOption = {
	    ATTRIBUTE: "ATTRIBUTE",
	    ATTRIBUTEANDGEOMETRY: "ATTRIBUTEANDGEOMETRY",
	    GEOMETRY: "GEOMETRY"
	};

	/**
	 * Constant: JoinType
	 * {Object} 关联查询时的关联类型常量。
	 * 该类定义了两个表之间的连接类型常量，决定了对两个表之间进行连接查询时，查询结果中得到的记录的情况。
	 *
	 * INNERJOIN: "INNERJOIN",
	 *
	 * LEFTJOIN: "LEFTJOIN".
	 */
	JoinType = {
	    INNERJOIN: "INNERJOIN",
	    LEFTJOIN: "LEFTJOIN"
	};


	/**
	 * Constant: SpatialQueryMode
	 * {Object} 空间查询模式枚举类。
	 * 该类定义了空间查询操作模式常量。
	 *
	 * CONTAIN: "CONTAIN",
	 *
	 * CROSS: "CROSS",
	 *
	 * DISJOINT: "DISJOINT",
	 *
	 * IDENTITY: "IDENTITY",
	 *
	 * INTERSECT: "INTERSECT",
	 *
	 * NONE: "NONE",
	 *
	 * OVERLAP: "OVERLAP",
	 *
	 * TOUCH: "TOUCH",
	 *
	 * WITHIN: "WITHIN".
	 */
	SpatialQueryMode = {
	    CONTAIN: "CONTAIN",
	    CROSS: "CROSS",
	    DISJOINT: "DISJOINT",
	    IDENTITY: "IDENTITY",
	    INTERSECT: "INTERSECT",
	    NONE: "NONE",
	    OVERLAP: "OVERLAP",
	    TOUCH: "TOUCH",
	    WITHIN: "WITHIN"
	};

	/**
	 * Constant: SpatialRelationType
	 * {Object} 数据集对象间的空间关系枚举类。
	 * 该类定义了数据集对象间的空间关系类型常量。
	 *
	 * 包含关系
	 * CONTAIN: "CONTAIN",
	 *
	 * 相交关系
	 * INTERSECT: "INTERSECT",
	 *
	 * 被包含关系
	 * WITHIN: "WITHIN"。
	 */
	SpatialRelationType = {
	    CONTAIN: "CONTAIN",
	    INTERSECT: "INTERSECT",
	    WITHIN: "WITHIN"
	};

	/**
	 * Constant: MeasureMode
	 * {Object} 量算模式枚举类。
	 * 该类定义了两种测量模式：距离测量和面积测量。
	 *
	 * DISTANCE: "DISTANCE",
	 *
	 * AREA: "AREA".
	 */
	MeasureMode = {
	    DISTANCE: "DISTANCE",
	    AREA: "AREA"
	};

	/**
	 * Constant: Unit
	 * {Object} 距离单位枚举类。
	 * 该类定义了一系列距离单位类型。
	 *
	 * METER: "METER",
	 *
	 * KILOMETER: "KILOMETER",
	 *
	 * MILE: "MILE",
	 *
	 * YARD: "YARD",
	 *
	 * DEGREE: "DEGREE",
	 *
	 * MILLIMETER: "MILLIMETER",
	 *
	 * CENTIMETER: "CENTIMETER",
	 *
	 * INCH: "INCH",
	 *
	 * DECIMETER: "DECIMETER",
	 *
	 * FOOT: "FOOT",
	 *
	 * SECOND: "SECOND",
	 *
	 * MINUTE: "MINUTE",
	 *
	 * RADIAN: "RADIAN".
	 */
	Unit = {
	    METER: "METER",
	    KILOMETER: "KILOMETER",
	    MILE: "MILE",
	    YARD: "YARD",
	    DEGREE: "DEGREE",
	    MILLIMETER: "MILLIMETER",
	    CENTIMETER: "CENTIMETER",
	    INCH: "INCH",
	    DECIMETER: "DECIMETER",
	    FOOT: "FOOT",
	    SECOND: "SECOND",
	    MINUTE: "MINUTE",
	    RADIAN: "RADIAN"
	};

	/**
	 * Constant: EngineType
	 * {Object} 数据源引擎类型枚举类。
	 *
	 * IMAGEPLUGINS: "IMAGEPLUGINS",
	 *
	 * OGC: "OGC",
	 *
	 * ORACLEPLUS: "ORACLEPLUS",
	 *
	 * SDBPLUS: "SDBPLUS",
	 *
	 * SQLPLUS: "SQLPLUS",
	 *
	 * UDB: "UDB"。
	 */
	EngineType = {
	    IMAGEPLUGINS: "IMAGEPLUGINS",
	    OGC: "OGC",
	    ORACLEPLUS: "ORACLEPLUS",
	    SDBPLUS: "SDBPLUS",
	    SQLPLUS: "SQLPLUS",
	    UDB: "UDB"
	};

	/**
	 * Constant: ThemeGraphTextFormat
	 * {Object } 统计专题图文本显示格式枚举类。
	 *
	 * CAPTION: "CAPTION",
	 *
	 * CAPTION_PERCENT: "CAPTION_PERCENT",
	 *
	 * CAPTION_VALUE: "CAPTION_VALUE",
	 *
	 * PERCENT: "PERCENT",
	 *
	 * VALUE: "VALUE".
	 */
	ThemeGraphTextFormat = {
	    CAPTION: "CAPTION",
	    CAPTION_PERCENT: "CAPTION_PERCENT",
	    CAPTION_VALUE: "CAPTION_VALUE",
	    PERCENT: "PERCENT",
	    VALUE: "VALUE"
	};

	/**
	 * Constant: ThemeGraphType
	 * {Object} 统计专题图类型枚举类。
	 *
	 * AREA: "AREA",
	 *
	 * BAR: "BAR",
	 *
	 * BAR3D: "BAR3D",
	 *
	 * LINE: "LINE",
	 *
	 * PIE: "PIE",
	 *
	 * PIE3D: "PIE3D",
	 *
	 * POINT: "POINT",
	 *
	 * RING: "RING",
	 *
	 * ROSE: "ROSE",
	 *
	 * ROSE3D: "ROSE3D",
	 *
	 * STACK_BAR: "STACK_BAR",
	 *
	 * STACK_BAR3D: "STACK_BAR3D",
	 *
	 * STEP: "STEP".
	 */
	ThemeGraphType = {
	    AREA: "AREA",
	    BAR: "BAR",
	    BAR3D: "BAR3D",
	    LINE: "LINE",
	    PIE: "PIE",
	    PIE3D: "PIE3D",
	    POINT: "POINT",
	    RING: "RING",
	    ROSE: "ROSE",
	    ROSE3D: "ROSE3D",
	    STACK_BAR: "STACK_BAR",
	    STACK_BAR3D: "STACK_BAR3D",
	    STEP: "STEP"
	};

	/**
	 * Constant: GraphAxesTextDisplayMode
	 * {Object} 统计专题图坐标轴文本显示模式。
	 * ALL: "ALL", 显示全部文本
	 *
	 * NONE: "NONE", 没有显示
	 *
	 * YAXES: "YAXES". 显示Y轴的文本
	 */
	GraphAxesTextDisplayMode = {
	    ALL: "ALL",
	    NONE: "NONE",
	    YAXES: "YAXES"
	};

	/**
	 * Constant: GraduatedMode
	 * {Object} 专题图分级模式枚举类。 CONSTANT: "CONSTANT",
	 *
	 * LOGARITHM: "LOGARITHM",
	 *
	 * SQUAREROOT: "SQUAREROOT".
	 */
	GraduatedMode = {
	    CONSTANT: "CONSTANT",
	    LOGARITHM: "LOGARITHM",
	    SQUAREROOT: "SQUAREROOT"
	};

	/**
	 * Constant: RangeMode
	 * {Object} 范围分段专题图分段方式枚举类。
	 *
	 * CUSTOMINTERVAL: "CUSTOMINTERVAL",
	 *
	 * EQUALINTERVAL: "EQUALINTERVAL",
	 *
	 * LOGARITHM: "LOGARITHM",
	 *
	 * QUANTILE: "QUANTILE",
	 *
	 * SQUAREROOT: "SQUAREROOT",
	 *
	 * STDDEVIATION: "STDDEVIATION".
	 */
	RangeMode = {
	    CUSTOMINTERVAL: "CUSTOMINTERVAL",
	    EQUALINTERVAL: "EQUALINTERVAL",
	    LOGARITHM: "LOGARITHM",
	    QUANTILE: "QUANTILE",
	    SQUAREROOT: "SQUAREROOT",
	    STDDEVIATION: "STDDEVIATION"
	};

	/**
	 * Constant: ThemeType
	 * {Object} 专题图类型枚举类。
	 *
	 * DOTDENSITY: "DOTDENSITY",
	 *
	 * GRADUATEDSYMBOL: "GRADUATEDSYMBOL",
	 *
	 * GRAPH: "GRAPH",
	 *
	 * LABEL: "LABEL",
	 *
	 * RANGE: "RANGE",
	 *
	 * UNIQUE: "UNIQUE".
	 */
	ThemeType = {
	    DOTDENSITY: "DOTDENSITY",
	    GRADUATEDSYMBOL: "GRADUATEDSYMBOL",
	    GRAPH: "GRAPH",
	    LABEL: "LABEL",
	    RANGE: "RANGE",
	    UNIQUE: "UNIQUE"
	};

	/**
	 * Constant: ColorGradientType
	 * {Object} 渐变颜色枚举类。
	 *
	 * BLACK_WHITE: "BLACKWHITE",
	 *
	 * BLUE_BLACK: "BLUEBLACK",
	 *
	 * BLUE_RED : "BLUERED",
	 *
	 * BLUE_WHITE: "BLUEWHITE",
	 *
	 * CYAN_BLACK: "CYANBLACK",
	 *
	 * CYAN_BLUE: "CYANBLUE",
	 *
	 * CYAN_GREEN: "CYANGREEN",
	 *
	 * CYAN_WHITE: "CYANWHITE",
	 *
	 * GREEN_BLACK: "GREENBLACK",
	 *
	 * GREEN_BLUE: "GREENBLUE",
	 *
	 * GREEN_ORANGE_VIOLET: "GREENORANGEVIOLET",
	 *
	 * GREEN_RED: "GREENRED",
	 *
	 * GREEN_WHITE: "GREENWHITE",
	 *
	 * PINK_BLACK: "PINKBLACK",
	 *
	 * PINK_BLUE: "PINKBLUE",
	 *
	 * PINK_RED: "PINKRED",
	 *
	 * PINK_WHITE: "PINKWHITE",
	 *
	 * RAIN_BOW: "RAINBOW",
	 *
	 * RED_BLACK: "REDBLACK",
	 *
	 * RED_WHITE: "REDWHITE",
	 *
	 * SPECTRUM: "SPECTRUM",
	 *
	 * TERRAIN: "TERRAIN",
	 *
	 * YELLOW_BLACK: "YELLOWBLACK",
	 *
	 * YELLOW_BLUE: "YELLOWBLUE",
	 *
	 * YELLOW_GREEN: "YELLOWGREEN",
	 *
	 * YELLOW_RED: "YELLOWRED",
	 *
	 * YELLOW_WHITE: "YELLOWWHITE".
	 */
	ColorGradientType = {
	    BLACK_WHITE: "BLACKWHITE",
	    BLUE_BLACK: "BLUEBLACK",
	    BLUE_RED: "BLUERED",
	    BLUE_WHITE: "BLUEWHITE",
	    CYAN_BLACK: "CYANBLACK",
	    CYAN_BLUE: "CYANBLUE",
	    CYAN_GREEN: "CYANGREEN",
	    CYAN_WHITE: "CYANWHITE",
	    GREEN_BLACK: "GREENBLACK",
	    GREEN_BLUE: "GREENBLUE",
	    GREEN_ORANGE_VIOLET: "GREENORANGEVIOLET",
	    GREEN_RED: "GREENRED",
	    GREEN_WHITE: "GREENWHITE",
	    PINK_BLACK: "PINKBLACK",
	    PINK_BLUE: "PINKBLUE",
	    PINK_RED: "PINKRED",
	    PINK_WHITE: "PINKWHITE",
	    RAIN_BOW: "RAINBOW",
	    RED_BLACK: "REDBLACK",
	    RED_WHITE: "REDWHITE",
	    SPECTRUM: "SPECTRUM",
	    TERRAIN: "TERRAIN",
	    YELLOW_BLACK: "YELLOWBLACK",
	    YELLOW_BLUE: "YELLOWBLUE",
	    YELLOW_GREEN: "YELLOWGREEN",
	    YELLOW_RED: "YELLOWRED",
	    YELLOW_WHITE: "YELLOWWHITE"
	};

	/**
	 * Constant: TextAlignment
	 * {Object} 文本对齐枚举类。
	 *
	 * TOPLEFT: "TOPLEFT",
	 *
	 * TOPCENTER: "TOPCENTER",
	 *
	 * TOPRIGHT: "TOPRIGHT",
	 *
	 * BASELINELEFT: "BASELINELEFT",
	 *
	 * BASELINECENTER: "BASELINECENTER",
	 *
	 * BASELINERIGHT: "BASELINERIGHT",
	 *
	 * BOTTOMLEFT: "BOTTOMLEFT",
	 *
	 * BOTTOMCENTER: "BOTTOMCENTER",
	 *
	 * BOTTOMRIGHT: "BOTTOMRIGHT",
	 *
	 * MIDDLELEFT: "MIDDLELEFT",
	 *
	 * MIDDLECENTER: "MIDDLECENTER",
	 *
	 * MIDDLERIGHT: "MIDDLERIGHT".
	 */
	TextAlignment = {
	    TOPLEFT: "TOPLEFT",
	    TOPCENTER: "TOPCENTER",
	    TOPRIGHT: "TOPRIGHT",
	    BASELINELEFT: "BASELINELEFT",
	    BASELINECENTER: "BASELINECENTER",
	    BASELINERIGHT: "BASELINERIGHT",
	    BOTTOMLEFT: "BOTTOMLEFT",
	    BOTTOMCENTER: "BOTTOMCENTER",
	    BOTTOMRIGHT: "BOTTOMRIGHT",
	    MIDDLELEFT: "MIDDLELEFT",
	    MIDDLECENTER: "MIDDLECENTER",
	    MIDDLERIGHT: "MIDDLERIGHT"
	};

	/**
	 * Constant: FillGradientMode
	 * {Object} 渐变填充风格的渐变类型枚举类。
	 *
	 * NONE: "NONE",
	 *
	 * LINEAR: "LINEAR",
	 *
	 * RADIAL: "RADIAL",
	 *
	 * CONICAL: "CONICAL",
	 *
	 * SQUARE: "SQUARE".
	 */
	FillGradientMode = {
	    NONE: "NONE",
	    LINEAR: "LINEAR",
	    RADIAL: "RADIAL",
	    CONICAL: "CONICAL",
	    SQUARE: "SQUARE"
	};

	/**
	 * Constant: AlongLineDirection
	 * {Object} 标签沿线标注方向枚举类。
	 *
	 * NORMAL: "ALONG_LINE_NORMAL",
	 *
	 * LB_TO_RT: "LEFT_BOTTOM_TO_RIGHT_TOP",
	 *
	 * LT_TO_RB: "LEFT_TOP_TO_RIGHT_BOTTOM",
	 *
	 * RB_TO_LT: "RIGHT_BOTTOM_TO_LEFT_TOP",
	 *
	 * RT_TO_LB: "RIGHT_TOP_TO_LEFT_BOTTOM".
	 */
	AlongLineDirection = {
	    NORMAL: "ALONG_LINE_NORMAL",
	    LB_TO_RT: "LEFT_BOTTOM_TO_RIGHT_TOP",
	    LT_TO_RB: "LEFT_TOP_TO_RIGHT_BOTTOM",
	    RB_TO_LT: "RIGHT_BOTTOM_TO_LEFT_TOP",
	    RT_TO_LB: "RIGHT_TOP_TO_LEFT_BOTTOM"
	};

	/**
	 * Constant: LabelBackShape
	 * {Object} 标签专题图中标签背景的形状枚举类。
	 *
	 * DIAMOND: "DIAMOND",
	 *
	 * ELLIPSE: "ELLIPSE",
	 *
	 * MARKER: "MARKER",
	 *
	 * NONE: "NONE",
	 *
	 * RECT: "RECT",
	 *
	 * ROUNDRECT: "ROUNDRECT",
	 *
	 * TRIANGLE: "TRIANGLE".
	 */
	LabelBackShape = {
	    DIAMOND: "DIAMOND",
	    ELLIPSE: "ELLIPSE",
	    MARKER: "MARKER",
	    NONE: "NONE",
	    RECT: "RECT",
	    ROUNDRECT: "ROUNDRECT",
	    TRIANGLE: "TRIANGLE"
	};

	/**
	 * Constant: LabelOverLengthMode
	 * {Object} 标签专题图中超长标签的处理模式枚举类。
	 *
	 * NEWLINE: "NEWLINE",
	 *
	 * NONE: "NONE",
	 *
	 * OMIT: "OMIT".
	 */
	LabelOverLengthMode = {
	    NEWLINE: "NEWLINE",
	    NONE: "NONE",
	    OMIT: "OMIT"
	};

	/**
	 * Constant: DirectionType
	 * {Object} 网络分析中方向枚举类。
	 * 在行驶引导子项中使用。
	 *
	 * EAST: "EAST",
	 *
	 * NONE: "NONE",
	 *
	 * NORTH: "NORTH",
	 *
	 * SOURTH: "SOURTH",
	 *
	 * WEST: "WEST".
	 */
	DirectionType = {
	    EAST: "EAST",
	    NONE: "NONE",
	    NORTH: "NORTH",
	    SOURTH: "SOURTH",
	    WEST: "WEST"
	};


	/**
	 * Constant: SideType
	 * {Object} 行驶位置枚举类。
	 * 表示在行驶在路的左边、右边或者路上的枚举,该类用在行驶导引子项类中。
	 *
	 * LEFT: "LEFT",
	 *
	 * MIDDLE: "MIDDLE",
	 *
	 * NONE: "NONE",
	 *
	 * RIGHT: "RIGHT".
	 */
	SideType = {
	    LEFT: "LEFT",
	    MIDDLE: "MIDDLE",
	    NONE: "NONE",
	    RIGHT: "RIGHT"
	};

	/**
	 * Constant: SupplyCenterType
	 * {Object} 资源供给中心类型枚举类。
	 * 该枚举类定义了网络分析中资源中心点的类型，主要用于资源分配和选址分区。
	 * 资源供给中心点的类型包括非中心，固定中心和可选中心。固定中心用于资源分配分析； 固定中心和可选中心用于选址分析；非中心在两种网络分析时都不予考虑。
	 *
	 * FIXEDCENTER: "FIXEDCENTER",
	 *
	 * NULL: "NULL",
	 *
	 * OPTIONALCENTER: "OPTIONALCENTER".
	 */
	SupplyCenterType = {
	    FIXEDCENTER: "FIXEDCENTER",
	    NULL: "NULL",
	    OPTIONALCENTER: "OPTIONALCENTER"
	};

	/**
	 * Constant: TurnType
	 * {Object} 转弯方向枚举类。
	 * 用在行驶引导子项类中，表示转弯的方向。
	 *
	 * AHEAD: "AHEAD",
	 *
	 * BACK: "BACK",
	 *
	 * END: "END",
	 *
	 * LEFT: "LEFT",
	 *
	 * NONE: "NONE",
	 *
	 * RIGHT: "RIGHT".
	 */
	TurnType = {
	    AHEAD: "AHEAD",
	    BACK: "BACK",
	    END: "END",
	    LEFT: "LEFT",
	    NONE: "NONE",
	    RIGHT: "RIGHT"
	};

	/**
	 * Constant: BufferEndType
	 * {Object} 缓冲区分析BufferEnd类型。
	 *
	 * FLAT: "FLAT",
	 *
	 * ROUND: "ROUND".
	 */
	BufferEndType = {
	    FLAT: "FLAT",
	    ROUND: "ROUND"
	};

	/**
	 * Constant: OverlayOperationType
	 * {Object} 叠加分析类型枚举。
	 *
	 * CLIP: "CLIP",
	 *
	 * ERASE: "ERASE",
	 *
	 * IDENTITY: "IDENTITY",
	 *
	 * INTERSECT: "INTERSECT",
	 *
	 * UNION: "UNION",
	 *
	 * UPDATE: "UPDATE",
	 *
	 * XOR: "XOR".
	 */
	OverlayOperationType = {
	    CLIP: "CLIP",
	    ERASE: "ERASE",
	    IDENTITY: "IDENTITY",
	    INTERSECT: "INTERSECT",
	    UNION: "UNION",
	    UPDATE: "UPDATE",
	    XOR: "XOR"
	};

	/**
	 * Constant: SmoothMethod
	 * {Object} 光滑方法枚举类。
	 * 用于从Grid 或DEM数据生成等值线或等值面时对等值线或者等值面的边界线进行平滑处理的方法。
	 *
	 * BSPLINE: "BSPLINE",
	 *
	 * POLISH: "POLISH".
	 */
	SmoothMethod = {
	    BSPLINE: "BSPLINE",
	    POLISH: "POLISH"
	};

	/**
	 * Constant: SurfaceAnalystMethod
	 * {Object} 表面分析方法枚举类。
	 * 通过对数据进行表面分析，能够挖掘原始数据所包含的信息，使某些细节明显化，易于分析。
	 *
	 * ISOLINE: "ISOLINE",
	 *
	 * ISOREGION: "ISOREGION".
	 */
	SurfaceAnalystMethod = {
	    ISOLINE: "ISOLINE",
	    ISOREGION: "ISOREGION"
	};
	/**
	 * Constant: DataReturnMode
	 * {Object} 数据返回模式枚举类。
	 * 该枚举类用于指定空间分析返回结果模式,包含返回数据集标识和记录集、只返回数据集标识(数据集名称@数据源名称)及只返回记录集三种模式。
	 *
	 * DATASET_AND_RECORDSET: "DATASET_AND_RECORDSET",
	 *
	 * DATASET_ONLY: "DATASET_ONLY",
	 *
	 * RECORDSET_ONLY: "RECORDSET_ONLY".
	 */
	DataReturnMode = {
	    DATASET_AND_RECORDSET: "DATASET_AND_RECORDSET",
	    DATASET_ONLY: "DATASET_ONLY",
	    RECORDSET_ONLY: "RECORDSET_ONLY"
	};

	/**
	 * Constant: EditType
	 * {Object} 要素集更新模式枚举类。
	 * 该枚举类用于指定数据服务中要素集更新模式,包含添加要素集、更新要素集和删除要素集。
	 *
	 * ADD: "add",
	 *
	 * UPDATE: "update",
	 *
	 * DELETE: "delete".
	 */
	EditType = {
	    ADD: "add",
	    UPDATE: "update",
	    DELETE: "delete"
	};

	/**
	 * Constant: TransferTactic
	 * {Object} 公交换乘策略枚举类。
	 * 该枚举类用于指定公交服务中要素集更新模式,包含添加要素集、更新要素集和删除要素集。
	 *
	 * LESS_TIME: "LESS_TIME",
	 *
	 * LESS_TRANSFER: "LESS_TRANSFER",
	 *
	 * LESS_WALK: "LESS_WALK",
	 *
	 * MIN_DISTANCE: "MIN_DISTANCE"
	 */
	TransferTactic = {
	    LESS_TIME: "LESS_TIME",
	    LESS_TRANSFER: "LESS_TRANSFER",
	    LESS_WALK: "LESS_WALK",
	    MIN_DISTANCE: "MIN_DISTANCE"
	};

	/**
	 * Constant: TransferPreference
	 * {Object} 公交换乘策略枚举类。
	 * 该枚举类用于指定交通换乘服务中设置地铁优先、公交优先、不乘地铁、无偏好等偏好设置。
	 *
	 * BUS: "BUS",
	 *
	 * SUBWAY: "SUBWAY",
	 *
	 * NO_SUBWAY: "NO_SUBWAY",
	 *
	 * NONE: "NONE"
	 */
	TransferPreference = {
	    BUS: "BUS",
	    SUBWAY: "SUBWAY",
	    NO_SUBWAY: "NO_SUBWAY",
	    NONE: "NONE"
	};

	/**
	 * Constant: GridType
	 * {Object} 地图背景格网类型枚举类。
	 *
	 * CROSS: "CROSS",
	 *
	 * GRID: "GRID",
	 *
	 * POINT: "POINT"
	 */
	GridType = {
	    CROSS: "CROSS",
	    GRID: "GRID",
	    POINT: "POINT"
	};

	/**
	 * Constant: ColorSpaceType
	 * {Object} 色彩空间枚举。
	 * 由于成色原理的不同，决定了显示器、投影仪这类靠色光直接合成颜色的颜色设备和打印机、
	 * 印刷机这类靠使用颜料的印刷设备在生成颜色方式上的区别。
	 * 针对上述不同成色方式，SuperMap 提供两种色彩空间，
	 * 分别为 RGB 和 CMYK。RGB 主要用于显示系统中，CMYK 主要用于印刷系统中。
	 *
	 * CMYK: "CMYK",
	 *
	 * RGB: "RGB"
	 */
	ColorSpaceType = {
	    CMYK: "CMYK",
	    RGB: "RGB"
	};

	/**
	 * Constant: LayerType
	 * {Object} 图层类型。
	 *
	 * UGC: "UGC",
	 *
	 * WMS: "WMS"
	 *
	 * WFS: "WFS",
	 *
	 * CUSTOM: "CUSTOM"
	 */
	LayerType = {
	    UGC: "UGC",
	    WMS: "WMS",
	    WFS: "WFS",
	    CUSTOM: "CUSTOM"

	};

	/**
	 * Constant: StatisticMode
	 * {Object} 字段统计方法类型。
	 *
	 * AVERAGE: "AVERAGE", 统计所选字段的平均值
	 *
	 * MAX: "MAX", 统计所选字段的最大值
	 *
	 * MIN: "MIN", 统计所选字段的最小值
	 *
	 * STDDEVIATION: "STDDEVIATION", 统计所选字段的标准差
	 *
	 * SUM: "SUM", 统计所选字段的总和
	 *
	 * VARIANCE: "VARIANCE", 统计所选字段的方差
	 */
	StatisticMode = {
	    AVERAGE: "AVERAGE",
	    MAX: "MAX",
	    MIN: "MIN",
	    STDDEVIATION: "STDDEVIATION",
	    SUM: "SUM",
	    VARIANCE: "VARIANCE"
	};

	/**
	 * Constant: PixelFormat
	 * {Object} 栅格与影像数据存储的像素格式枚举类。
	 *
	 * BIT16: "BIT16", 每个像元用16个比特(即2个字节)表示
	 *
	 * BIT32: "BIT32", 每个像元用32个比特(即4个字节)表示
	 *
	 * BIT64: "BIT64", 每个像元用64个比特(即8个字节)表示，只提供给栅格数据集使用
	 *
	 * SINGLE: "SINGLE", 每个像元用4个字节来表示，只提供给栅格数据集使用
	 *
	 * DOUBLE: "DOUBLE", 每个像元用8个字节来表示，只提供给栅格数据集使用
	 *
	 * UBIT1: "UBIT1", 每个像元用1个比特表示
	 *
	 * UBIT4: "UBIT4", 每个像元用4个比特来表示
	 *
	 * UBIT8: "UBIT8", 每个像元用8个比特(即1个字节)来表示
	 *
	 * UBIT24: "UBIT24", 每个像元用24个比特(即3个字节)来表示
	 *
	 * UBIT32: "UBIT32", 每个像元用32个比特(即4个字节)来表示
	 */
	PixelFormat = {
	    BIT16: "BIT16",
	    BIT32: "BIT32",
	    BIT64: "BIT64",
	    SINGLE: "SINGLE",
	    DOUBLE: "DOUBLE",
	    UBIT1: "UBIT1",
	    UBIT4: "UBIT4",
	    UBIT8: "UBIT8",
	    UBIT24: "UBIT24",
	    UBIT32: "UBIT32"
	};

	/**
	 * Constant: SearchMode
	 * {Object} 内插时使用的样本点的查找方式枚举
	 *
	 * KDTREE_FIXED_COUNT: "KDTREE_FIXED_COUNT", 使用 KDTREE 的固定点数方式查找参与内插分析的点
	 *
	 * KDTREE_FIXED_RADIUS: "KDTREE_FIXED_RADIUS", 使用 KDTREE 的定长方式查找参与内插分析的点
	 *
	 * NONE: "NONE", 不进行查找，使用所有的输入点进行内插分析
	 *
	 * QUADTREE: "QUADTREE", 使用 QUADTREE 方式查找参与内插分析的点，仅对样条（RBF）插值和普通克吕金（Kriging）有用
	 */
	SearchMode = {
	    KDTREE_FIXED_COUNT: "KDTREE_FIXED_COUNT",
	    KDTREE_FIXED_RADIUS: "KDTREE_FIXED_RADIUS",
	    NONE: "NONE",
	    QUADTREE: "QUADTREE"
	};

	/**
	 * Constant: InterpolationAlgorithmType
	 * {Object} 插值分析的算法的类型
	 *
	 * KRIGING: "KRIGING", 普通克吕金插值法
	 *
	 * SimpleKriging: "SimpleKriging", 简单克吕金插值法
	 *
	 * UniversalKriging: "UniversalKriging", 泛克吕金插值法
	 */
	InterpolationAlgorithmType = {
	    KRIGING: "KRIGING",
	    SimpleKriging: "SimpleKriging",
	    UniversalKriging: "UniversalKriging"
	};

	/**
	 * Constant: VariogramMode
	 * {Object} 克吕金（Kriging）插值时的半变函数类型枚举
	 *
	 * EXPONENTIAL: "EXPONENTIAL", 指数函数（Exponential Variogram Mode）
	 *
	 * GAUSSIAN: "GAUSSIAN",  高斯函数（Gaussian Variogram Mode）
	 *
	 * SPHERICAL: "SPHERICAL", 球型函数（Spherical Variogram Mode）
	 */
	VariogramMode = {
	    EXPONENTIAL: "EXPONENTIAL",
	    GAUSSIAN: "GAUSSIAN",
	    SPHERICAL: "SPHERICAL"
	};

	/**
	 * Constant: Exponent
	 * {Object} 定义了泛克吕金（UniversalKriging）插值时样点数据中趋势面方程的阶数
	 *
	 * EXP1: "EXP1", 阶数为1
	 *
	 * EXP2: "EXP2", 阶数为2
	 */
	Exponent = {
	    EXP1: "EXP1",
	    EXP2: "EXP2"
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.Format.JSON
	 * 安全的读写JSON的解析类。使用<SuperMap.Format.JSON> 构造函数创建新实例。
	 *
	 * Inherits from:
	 *  - <SuperMap.Format>
	 */
	__webpack_require__(8);

	SuperMap.Format.JSON = SuperMap.Class(SuperMap.Format, {

	    /**
	     * APIProperty: indent
	     * {String} 用于格式化输出，indent字符串会在每次缩进的时候使用一次；
	     */
	    indent: "    ",

	    /**
	     * APIProperty: space
	     * {String} 用于格式化输出，space字符串会在名值对的":"后边添加。
	     */
	    space: " ",

	    /**
	     * APIProperty: newline
	     * {String} 用于格式化输出, newline字符串会用在每一个名值对或数组项末尾。
	     */
	    newline: "\n",

	    /**
	     * Property: level
	     * {Integer} 用于格式化输出, 表示的是缩进级别。
	     */
	    level: 0,

	    /**
	     * Property: pretty
	     * {Boolean} 是否在序列化的时候使用额外的空格控制结构。在 <write> 方法中使用
	     * 默认值为false。
	     */
	    pretty: false,

	    /**
	     * Property: nativeJSON
	     * {Boolean} 判断浏览器是否原生支持JSON格式数据；
	     */
	    nativeJSON: (function () {
	        return !!(window.JSON && typeof JSON.parse === "function" && typeof JSON.stringify === "function");
	    })(),

	    /**
	     * Constructor: SuperMap.Format.JSON
	     * 创建一个新的JSON解析器。
	     *
	     * Parameters:
	     * options - {Object} 选项对象，其属性会被直接设置到JSON实例。
	     */

	    /**
	     * APIMethod: read
	     * 将一个符合json结构的字符串进行解析。
	     *
	     * Parameters:
	     * json - {String} 符合json结构的字符串。
	     * filter - {Function} 过滤方法，最终结果的每一个键值对都会调用该过滤方法，
	     * 并在对应的值的位置替换成该方法返回的值。
	     *
	     * Returns:
	     * {Object} 对象，数组，字符串或数字。
	     */
	    read: function (json, filter) {
	        var object;
	        if (this.nativeJSON) {
	            try {
	                object = JSON.parse(json, filter);
	            }
	            catch (e) {
	                // Fall through if the regexp test fails.
	            }
	        } else try {
	            /**
	             * Parsing happens in three stages. In the first stage, we run the
	             *     text against a regular expression which looks for non-JSON
	             *     characters. We are especially concerned with '()' and 'new'
	             *     because they can cause invocation, and '=' because it can
	             *     cause mutation. But just to be safe, we will reject all
	             *     unexpected characters.
	             */
	            if (/^[\],:{}\s]*$/.test(json.replace(/\\["\\\/bfnrtu]/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

	                /**
	                 * In the second stage we use the eval function to compile the
	                 *     text into a JavaScript structure. The '{' operator is
	                 *     subject to a syntactic ambiguity in JavaScript - it can
	                 *     begin a block or an object literal. We wrap the text in
	                 *     parens to eliminate the ambiguity.
	                 */
	                object = eval('(' + json + ')');

	                /**
	                 * In the optional third stage, we recursively walk the new
	                 *     structure, passing each name/value pair to a filter
	                 *     function for possible transformation.
	                 */
	                if (typeof filter === 'function') {
	                    function walk(k, v) {
	                        if (v && typeof v === 'object') {
	                            for (var i in v) {
	                                if (v.hasOwnProperty(i)) {
	                                    v[i] = walk(i, v[i]);
	                                }
	                            }
	                        }
	                        return filter(k, v);
	                    }

	                    object = walk('', object);
	                }
	            }
	        } catch (e) {
	            // Fall through if the regexp test fails.
	        }

	        if (this.keepData) {
	            this.data = object;
	        }

	        return object;
	    },

	    /**
	     * APIMethod: write
	     * 序列化一个对象到一个符合JSON格式的字符串。
	     *
	     * Parameters:
	     * value - {String} 需要被序列化的对象，数组，字符串，数字，布尔值。
	     * pretty - {Boolean} 是否使用换行和缩进来控制输出。默认值为false。
	     *
	     * Returns:
	     * {String} 符合JSON格式的字符串。
	     */
	    write: function (value, pretty) {
	        this.pretty = !!pretty;
	        var json = null;
	        var type = typeof value;
	        if (this.serialize[type]) {
	            try {
	                json = (!this.pretty && this.nativeJSON) ?
	                    JSON.stringify(value) :
	                    this.serialize[type].apply(this, [value]);
	            } catch (err) {
	                //SuperMap.Console.error("Trouble serializing: " + err);
	            }
	        }
	        return json;
	    },

	    /**
	     * Method: writeIndent
	     * 根据缩进级别输出一个缩进字符串。
	     *
	     * Returns:
	     * {String} 一个适当的缩进字符串。
	     */
	    writeIndent: function () {
	        var pieces = [];
	        if (this.pretty) {
	            for (var i = 0; i < this.level; ++i) {
	                pieces.push(this.indent);
	            }
	        }
	        return pieces.join('');
	    },

	    /**
	     * Method: writeNewline
	     * 在格式化输出模式情况下输出代表新一行的字符串。
	     *
	     * Returns:
	     * {String} 代表新的一行的字符串。
	     */
	    writeNewline: function () {
	        return (this.pretty) ? this.newline : '';
	    },

	    /**
	     * Method: writeSpace
	     * 在格式化输出模式情况下输出一个代表空格的字符串。
	     *
	     * Returns:
	     * {String} A space.
	     */
	    writeSpace: function () {
	        return (this.pretty) ? this.space : '';
	    },

	    /**
	     * Property: serialize
	     * Object with properties corresponding to the serializable data types.
	     *     Property values are functions that do the actual serializing.
	     */
	    serialize: {
	        /**
	         * Method: serialize.object
	         * Transform an object into a JSON string.
	         *
	         * Parameters:
	         * object - {Object} The object to be serialized.
	         *
	         * Returns:
	         * {String} A JSON string representing the object.
	         */
	        'object': function (object) {
	            // three special objects that we want to treat differently
	            if (object == null) {
	                return "null";
	            }
	            if (object.constructor === Date) {
	                return this.serialize.date.apply(this, [object]);
	            }
	            if (object.constructor === Array) {
	                return this.serialize.array.apply(this, [object]);
	            }
	            var pieces = ['{'];
	            this.level += 1;
	            var key, keyJSON, valueJSON;

	            var addComma = false;
	            for (key in object) {
	                if (object.hasOwnProperty(key)) {
	                    // recursive calls need to allow for sub-classing
	                    keyJSON = SuperMap.Format.JSON.prototype.write.apply(this,
	                        [key, this.pretty]);
	                    valueJSON = SuperMap.Format.JSON.prototype.write.apply(this,
	                        [object[key], this.pretty]);
	                    if (keyJSON != null && valueJSON != null) {
	                        if (addComma) {
	                            pieces.push(',');
	                        }
	                        pieces.push(this.writeNewline(), this.writeIndent(),
	                            keyJSON, ':', this.writeSpace(), valueJSON);
	                        addComma = true;
	                    }
	                }
	            }

	            this.level -= 1;
	            pieces.push(this.writeNewline(), this.writeIndent(), '}');
	            return pieces.join('');
	        },

	        /**
	         * Method: serialize.array
	         * Transform an array into a JSON string.
	         *
	         * Parameters:
	         * array - {Array} The array to be serialized
	         *
	         * Returns:
	         * {String} A JSON string representing the array.
	         */
	        'array': function (array) {
	            var json;
	            var pieces = ['['];
	            this.level += 1;

	            for (var i = 0, len = array.length; i < len; ++i) {
	                // recursive calls need to allow for sub-classing
	                json = SuperMap.Format.JSON.prototype.write.apply(this,
	                    [array[i], this.pretty]);
	                if (json != null) {
	                    if (i > 0) {
	                        pieces.push(',');
	                    }
	                    pieces.push(this.writeNewline(), this.writeIndent(), json);
	                }
	            }

	            this.level -= 1;
	            pieces.push(this.writeNewline(), this.writeIndent(), ']');
	            return pieces.join('');
	        },

	        /**
	         * Method: serialize.string
	         * Transform a string into a JSON string.
	         *
	         * Parameters:
	         * string - {String} The string to be serialized
	         *
	         * Returns:
	         * {String} A JSON string representing the string.
	         */
	        'string': function (string) {
	            // If the string contains no control characters, no quote characters, and no
	            // backslash characters, then we can simply slap some quotes around it.
	            // Otherwise we must also replace the offending characters with safe
	            // sequences.    
	            var m = {
	                '\b': '\\b',
	                '\t': '\\t',
	                '\n': '\\n',
	                '\f': '\\f',
	                '\r': '\\r',
	                '"': '\\"',
	                '\\': '\\\\'
	            };
	            if (/["\\\x00-\x1f]/.test(string)) {
	                return '"' + string.replace(/([\x00-\x1f\\"])/g, function (a, b) {
	                        var c = m[b];
	                        if (c) {
	                            return c;
	                        }
	                        c = b.charCodeAt();
	                        return '\\u00' +
	                            Math.floor(c / 16).toString(16) +
	                            (c % 16).toString(16);
	                    }) + '"';
	            }
	            return '"' + string + '"';
	        },

	        /**
	         * Method: serialize.number
	         * Transform a number into a JSON string.
	         *
	         * Parameters:
	         * number - {Number} The number to be serialized.
	         *
	         * Returns:
	         * {String} A JSON string representing the number.
	         */
	        'number': function (number) {
	            return isFinite(number) ? String(number) : "null";
	        },

	        /**
	         * Method: serialize.boolean
	         * Transform a boolean into a JSON string.
	         *
	         * Parameters:
	         * bool - {Boolean} The boolean to be serialized.
	         *
	         * Returns:
	         * {String} A JSON string representing the boolean.
	         */
	        'boolean': function (bool) {
	            return String(bool);
	        },

	        /**
	         * Method: serialize.object
	         * Transform a date into a JSON string.
	         *
	         * Parameters:
	         * date - {Date} The date to be serialized.
	         *
	         * Returns:
	         * {String} A JSON string representing the date.
	         */
	        'date': function (date) {
	            function format(number) {
	                // Format integers to have at least two digits.
	                return (number < 10) ? '0' + number : number;
	            }

	            return '"' + date.getFullYear() + '-' +
	                format(date.getMonth() + 1) + '-' +
	                format(date.getDate()) + 'T' +
	                format(date.getHours()) + ':' +
	                format(date.getMinutes()) + ':' +
	                format(date.getSeconds()) + '"';
	        }
	    },

	    CLASS_NAME: "SuperMap.Format.JSON"
	});

	module.exports = function (options) {
	    return new SuperMap.Format.JSON(options);
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.Format
	 * 读写各种格式的格式类基类。其子类应该包含并实现read和write方法。
	 */
	__webpack_require__(4);

	SuperMap.Format = SuperMap.Class({

	    /**
	     * Property: options
	     * {Object} A reference to options passed to the constructor.
	     */
	    options: null,

	    /**
	     * APIProperty: externalProjection
	     * {<SuperMap.Projection>} 当设置了externalProjection和internalProjection参数，
	     *     format类会重新对其读到的或写出的几何图形进行投影。externalProjection
	     *     是read操作读到或write操作写出的投影内容。为了能够重新投影，针对某
	     *     一个投影的transformation方法必须是有效的。同时，我们可以使用proj4js
	     *     或自定义的transformation方法来进行支持。查看{<SuperMap.Projection.addTransform>}
	     *     以获取更多的信息。
	     */
	    externalProjection: null,

	    /**
	     * APIProperty: internalProjection
	     * {<SuperMap.Projection>}  当设置了externalProjection和internalProjection参数，
	     *     format类会重新对其读到的或写出的几何图形进行投影。internalProjection
	     *     是read操作返回或传给write操作的投影内容。为了能够重新投影，针对某
	     *     一个投影的transformation方法必须是有效的。同时，我们可以使用proj4js
	     *     或自定义的transformation方法来进行支持。查看{<SuperMap.Projection.addTransform>}
	     *     以获取更多的信息。
	     */
	    internalProjection: null,

	    /**
	     * APIProperty: data
	     * {Object} 当 <keepData> 属性设置为true，这是传递给<read>操作的要被
	     *      解析的字符串。
	     */
	    data: null,

	    /**
	     * APIProperty: keepData
	     * {Object} 保持最近读到的数据的引用（通过 <data> 属性）。默认值是false。
	     */
	    keepData: false,

	    /**
	     * Constructor: SuperMap.Format
	     * 直接实例化这个类没有实际作用，可以通过实例化其子类来进行操作。
	     *
	     * Parameters:
	     * options - {Object} 选项对象，其属性会被直接设置到format实例。
	     *
	     * Valid options:
	     * keepData - {Boolean} 如果设置为true， <data> 属性会指向被解析的对象。
	     *     （例如json或xml数据对象）。
	     *
	     * Returns:
	     * 返回 <SuperMap.Format> 实例。
	     */
	    initialize: function (options) {
	        SuperMap.Util.extend(this, options);
	        this.options = options;
	    },

	    /**
	     * APIMethod: destroy
	     * 销毁该格式类，释放相关资源。
	     */
	    destroy: function () {
	    },

	    /**
	     * Method: read
	     * Read data from a string, and return an object whose type depends on the
	     * subclass.
	     *
	     * Parameters:
	     * data - {string} Data to read/parse.
	     *
	     * Returns:
	     * Depends on the subclass
	     */
	    read: function (data) {
	    },

	    /**
	     * Method: write
	     * Accept an object, and return a string.
	     *
	     * Parameters:
	     * object - {Object} Object to be serialized
	     *
	     * Returns:
	     * {String} A string representation of the object.
	     */
	    write: function (object) {
	    },

	    CLASS_NAME: "SuperMap.Format"
	});

	module.exports = function (options) {
	    return new SuperMap.Format(options);
	};


/***/ },
/* 9 */
/***/ function(module, exports) {

	L.Projection = {};

	NonProjection = L.Class.extend({
	    initialize: function (bounds) {
	        this.b = bounds;
	    },
	    project: function (latlng) {
	        return new L.Point(latlng.lng, latlng.lat);
	    },

	    unproject: function (point) {
	        return new L.LatLng(point.y, point.x);
	    },

	    bounds: this.b
	});
	L.supermap.NonProjection = function (bounds) {
	    return new NonProjection(bounds)
	}
	module.exports = L.supermap.NonProjection;
	NonEarthCRS = L.Class.extend({
	    includes: L.CRS,

	    initialize: function (options) {
	        if (options.origin) {
	            this.transformation =
	                new L.Transformation(1, options.origin.x,
	                    -1, options.origin.y);
	        }
	        this.projection = L.supermap.NonProjection(options.bounds);
	        this.bounds = options.bounds;
	        this.origin = options.origin;
	        this.resolutions = options.resolutions;
	    },

	    scale: function (zoom) {
	        if (!this.resolutions || this.resolutions.length === 0) {
	            var width = Math.max(this.bounds.getSize().x, this.bounds.getSize().y);
	            var defaultScale = 1 / (width / 256);
	            return defaultScale * Math.pow(2, zoom);
	        }
	        return 1 / this.resolutions[zoom];
	    },

	    zoom: function (scale) {
	        if (!this.resolutions || this.resolutions.length === 0) {
	            var width = Math.max(this.bounds.getSize().x, this.bounds.getSize().y);
	            var defaultScale = 1 / (width / 256);
	            return scale / defaultScale;
	        }
	        for (var i = 0; i < this.resolutions.length; i++) {
	            if (1 / this.resolutions == scale) {
	                return i
	            }
	        }
	        return -1;
	    },

	    distance: function (latlng1, latlng2) {
	        var dx = latlng2.lng - latlng1.lng,
	            dy = latlng2.lat - latlng1.lat;

	        return Math.sqrt(dx * dx + dy * dy);
	    },

	    infinite: true
	});
	L.supermap = L.supermap || {};
	L.supermap.NonEarthCRS = function (options) {
	    return new NonEarthCRS(options)
	}
	module.exports = L.supermap.NonEarthCRS;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: MapService
	 * 地图信息服务类
	 * 用法：
	 *      L.superMap.mapService(url,{
	 *            projection:projection
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(11);
	__webpack_require__(12);

	MapService = ServiceBase.extend({
	    options: {
	        projection: null
	    },
	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	        L.setOptions(this, options);
	        var projection = "3857";
	        if (options && options.projection && options.projection === "4326") {
	            projection = "4326";
	        }
	        this.options.projection = new SuperMap.Projection(projection);

	    },

	    getMapStatus: function () {
	        var me = this;
	        var getMapStatusService = new SuperMap.REST.MapService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }, projection: me.options.projection
	        });
	        getMapStatusService.processAsync();
	        return me;
	    }
	});

	L.supermap.mapService = function (url, options) {
	    return new MapService(url, options);
	};

	module.exports = L.supermap.mapService;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: ServiceBase
	 * 服务基类
	 */
	__webpack_require__(2);

	ServiceBase = L.Evented.extend({
	    options: {
	        url: null
	    },
	    initialize: function (url, options) {
	        this.options.url = url;
	        L.setOptions(this, options);
	    },

	    processCompleted: function (serverResult) {
	        this.fire('complete', {result: serverResult.result});

	    },
	    processFailed: function (failedResult) {
	        var error = failedResult.error ? failedResult.error : failedResult;
	        this.fire('failed', {error: error});
	        console.log(error.errorMsg);
	    }
	});

	module.exports = function (url, options) {
	    return new ServiceBase(url, options);
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.MapService
	 * 地图信息服务类 。
	 * 该类负责将从客户端指定的服务器上获取该服务器提供的地图信息
	 * 结果保存在一个object对象中，对象包含一个属性result为iServer返回的json对象
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);

	SuperMap.REST.MapService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * APIProperty: projection
	     * {<SuperMap.Projection>} or {<String>}
	     * 根据投影参数获取地图状态信息。
	     */
	    projection: null,


	    /**
	     * Constructor: SuperMap.REST.MapService
	     * 地图信息服务类构造函数 。
	     *
	     * 例如：
	     * (start code)
	     * var myMapService = new SuperMap.REST.MapService(url, {
	     * eventListeners:{
	     *     "processCompleted": MapServiceCompleted, 
	     *       "processFailed": MapServiceFailed
	     *       }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
	     * options - {Object} 参数 。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	        var me = this;

	        me.url += me.isInTheSameDomain ? ".json" : ".jsonp";

	        if (me.projection) {
	            if (typeof me.projection === "string") {
	                me.projection = new SuperMap.Projection(me.projection);
	            }

	            var arr = me.projection.getCode().split(":");
	            if (arr instanceof Array && arr.length === 2) {
	                me.url += "?prjCoordSys={\"epsgCode\":" + arr[1] + "}";
	            }
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        var me = this;
	        if (me.events) {
	            me.events.un(me.eventListeners);
	            me.events.listeners = null;
	            me.events.destroy();
	            me.events = null;
	            me.eventListeners = null;
	        }
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的设置的参数传递到服务端，与服务端完成异步通讯。
	     *
	     */
	    processAsync: function () {
	        var me = this;
	        if (typeof Windows === "undefined") {
	            var option = {
	                method: "GET",
	                scope: me,
	                success: me.serviceProcessCompleted,
	                failure: me.serviceProcessFailed
	            };
	            me.request(option);
	        } else {
	            me.url = me.url.replace(/.jsonp/, ".json");
	            var urlWithToken = me.url;
	            if (SuperMap.Credential.CREDENTIAL) {
	                urlWithToken += urlWithToken.indexOf("?") > -1 ? "&" : "?";
	                urlWithToken += SuperMap.Credential.CREDENTIAL.getUrlParameters();
	            }
	            WinJS.xhr({
	                url: urlWithToken,
	                type: "GET"
	            }).then(function (result) {
	                me.serviceProcessCompleted(result);
	            }, function (error) {
	                me.serviceProcessFailed(error);
	            });
	        }
	    },

	    /**
	     * Method: getMapStatusCompleted
	     * 获取地图状态完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    serviceProcessCompleted: function (result) {
	        var me = this;
	        result = SuperMap.Util.transformResult(result);
	        if (!result.code || (result.code && ((result.code >= 200 && result.code < 300) || result.code == 0 || result.code === 304))) {
	            me.events && me.events.triggerEvent("processCompleted", {result: result});
	        }
	        //在没有tonken是返回的是200，但是其实是没有权限，所以这里也应该是触发失败事件
	        else {
	            me.events.triggerEvent("processFailed", result);
	        }
	    },

	    CLASS_NAME: "SuperMap.REST.MapService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.MapService(url, options);
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.ServiceBase
	 * Core服务基类
	 */
	__webpack_require__(4);
	SuperMap.ServiceBase = SuperMap.Class({

	    /**
	     * Constant: EVENT_TYPES
	     * {Array(String)}
	     * 此类支持的事件类型
	     * - *processCompleted* 服务端返回信息成功触发该事件 。
	     * - *processFailed* 服务端返回信息失败触发该事件 。
	     */
	    EVENT_TYPES: ["processCompleted", "processFailed"],

	    /**
	     * APIProperty: events
	     * {<SuperMap.Events>} 处理所有事件的对象，支持 processCompleted 、processFailed 两种事件
	     * 服务端成功返回地图信息结果时触发 processCompleted 事件，服务端返回信息结果时触发 processFailed 事件。
	     */
	    events: null,

	    /**
	     * APIProperty: eventListeners
	     * {Object} 听器对象，在构造函数中设置此参数（可选），对 MapService 支持的两个事件 processCompleted 、processFailed 进行监听，
	     * 相当于调用 SuperMap.Events.on(eventListeners)。
	     */
	    eventListeners: null,

	    /**
	     * APIProperty: url
	     * {String|Array} 服务访问地址或者服务访问地址数组。
	     *
	     ** Examples:
	     * (start code)
	     * var url1 = "http://localhost:8090/iserver/services/map-world/rest/maps/World";
	     * var url2 = ["http://192.168.17.168:8090/iserver/services/map-world/rest/maps/World",
	     *            "http://192.168.17.169:8091/iserver/services/map-world/rest/maps/World"];
	     * (end)*
	     */
	    url: null,

	    /**
	     * Property: urls
	     * {Array} 服务访问地址数组。
	     */
	    urls: null,

	    /**
	     * Property: token
	     * {Array} 服务访问token。
	     */
	    token: null,


	    /**
	     * Property: index
	     * {Int} 服务访问地址在数组中的位置。
	     */
	    index: null,

	    /**
	     * Property: length
	     * {String} 服务访问地址数组长度。
	     */
	    length: null,

	    /**
	     * Property: options
	     * {Object} 请求参数。
	     */
	    options: null,

	    /**
	     * Property: totalTimes
	     * {Int} 实际请求失败次数。
	     */
	    totalTimes: null,

	    /**
	     * Property: POLLING_TIMES
	     * {Int} 默认请求失败次数。
	     */
	    POLLING_TIMES: 3,

	    /**
	     * Property: _processSuccess
	     * {Function} 请求参数中成功回调函数。
	     */
	    _processSuccess: null,

	    /**
	     * Property: _processFailed
	     * {Function} 请求参数中失败回调函数。
	     */
	    _processFailed: null,


	    /**
	     * Property: isInTheSameDomain
	     * {Boolean}
	     */
	    isInTheSameDomain: null,

	    initialize: function (url, options) {
	        if (!url) {
	            return false;
	        }
	        var me = this;

	        if (SuperMap.Util.isArray(url)) {
	            me.urls = url;
	            me.length = url.length;
	            me.totalTimes = me.length;
	            if (me.length == 1) {
	                me.url = url[0];
	            } else {
	                me.index = parseInt(Math.random() * me.length);
	                me.url = url[me.index];
	            }
	        } else {
	            me.totalTimes = 1;
	            me.url = url;
	        }

	        if (SuperMap.Util.isArray(url) && !me.isServiceSupportPolling()) {
	            me.url = url[0];
	            me.totalTimes = 1;
	        }

	        options = options || {};

	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }

	        me.isInTheSameDomain = SuperMap.Util.isInTheSameDomain(me.url);

	        me.events = new SuperMap.Events(me, null, me.EVENT_TYPES, true);
	        if (me.eventListeners instanceof Object) {
	            me.events.on(me.eventListeners);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (SuperMap.Util.isArray(me.urls)) {
	            me.urls = null;
	            me.index = null;
	            me.length = null;
	            me.totalTimes = null;
	        }
	        me.url = null;
	        me.token = null;
	        me.options = null;
	        me._processSuccess = null;
	        me._processFailed = null;
	        me.isInTheSameDomain = null;

	        me.EVENT_TYPES = null;
	        if (me.events) {
	            me.events.destroy();
	            me.events = null;
	        }
	        if (me.eventListeners) {
	            me.eventListeners = null;
	        }
	    },

	    /**
	     * APIMethod: request
	     * 该方法用于向服务发送请求。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * method - {String} 请求方式，包括GET，POST，PUT， DELETE。
	     * url - {String}  发送请求的地址。
	     * params - {Object} 作为查询字符串添加到url中的一组键值对，
	     *     此参数只适用于GET方式发送的请求。
	     * data - {String } 发送到服务器的数据。
	     * success - {Function} 请求成功后的回调函数。
	     * failure - {Function} 请求失败后的回调函数。
	     * scope - {Object} 如果回调函数是对象的一个公共方法，设定该对象的范围。
	     * isInTheSameDomain - {Boolean} 请求是否在当前域中。
	     */
	    request: function (options) {
	        var me = this;
	        options.url = options.url || me.url;
	        options.isInTheSameDomain = me.isInTheSameDomain;
	        //为url添加安全认证信息片段
	        if (me.token) {
	            //当url中含有?，并且?在url末尾的时候直接添加token *网络分析等服务请求url会出现末尾是?的情况*
	            //当url中含有?，并且?不在url末尾的时候添加&token
	            //当url中不含有?，在url末尾添加?token
	            var endStr = options.url.substring(options.url.length - 1, options.url.length);
	            if (options.url.indexOf("?") > -1 && endStr === "?") {
	                options.url += me.createUrlTokenParameter();
	            } else if (options.url.indexOf("?") > -1 && endStr !== "?") {
	                options.url += "&" + me.createUrlTokenParameter();
	            } else {
	                options.url += "?" + me.createUrlTokenParameter();
	            }
	        }
	        me.calculatePollingTimes();
	        me._processSuccess = options.success;
	        me._processFailed = options.failure;
	        options.scope = me;
	        options.success = me.getUrlCompleted;
	        options.failure = me.getUrlFailed;
	        me.options = options;
	        SuperMap.Util.committer(me.options);
	    },

	    /**
	     * Method: getUrlTokenParameter
	     * url中添加token。
	     */
	    createUrlTokenParameter: function () {
	        return (this.token) ? "token=" + this.token : "";
	    },

	    /**
	     * Method: getUrlCompleted
	     * 请求成功后执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    getUrlCompleted: function (result) {
	        var me = this;
	        me._processSuccess(result);
	    }
	    ,

	    /**
	     * Method: getUrlFailed
	     * 请求失败后执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    getUrlFailed: function (result) {
	        var me = this;
	        if (me.totalTimes > 0) {
	            me.totalTimes--;
	            me.ajaxPolling();
	        } else {
	            me._processFailed(result);
	        }
	    }
	    ,

	    /**
	     * Method: ajaxPolling
	     * 请求失败后，如果剩余请求失败次数不为0，重新获取url发送请求
	     */
	    ajaxPolling: function () {
	        var me = this,
	            url = me.options.url,
	            re = /^http:\/\/([a-z]{9}|(\d+\.){3}\d+):\d{0,4}/;
	        me.index = parseInt(Math.random() * me.length);
	        me.url = me.urls[me.index];
	        url = url.replace(re, re.exec(me.url)[0]);
	        var isInTheSameDomain = SuperMap.Util.isInTheSameDomain(url);
	        if (isInTheSameDomain) {
	            if (url.indexOf(".jsonp") > 0) {
	                url = url.replace(/.jsonp/, ".json");
	            }
	        } else {
	            if (!(url.indexOf(".jsonp") > 0)) {
	                url = url.replace(/.json/, ".jsonp");
	            }
	        }
	        me.options.url = url;
	        me.options.isInTheSameDomain = isInTheSameDomain;
	        SuperMap.Util.committer(me.options);
	    }
	    ,

	    /**
	     * Method: calculatePollingTimes
	     * 计算剩余请求失败执行次数。
	     */
	    calculatePollingTimes: function () {
	        var me = this;
	        if (me.times) {
	            if (me.totalTimes > me.POLLING_TIMES) {
	                if (me.times > me.POLLING_TIMES) {
	                    me.totalTimes = me.POLLING_TIMES;
	                } else {
	                    me.totalTimes = me.times;
	                }
	            } else {
	                if (me.times < me.totalTimes) {
	                    me.totalTimes = me.times;
	                }
	            }

	        } else {
	            if (me.totalTimes > me.POLLING_TIMES) {
	                me.totalTimes = me.POLLING_TIMES;
	            }
	        }
	        me.totalTimes--;
	    }
	    ,

	    /**
	     * Method: isServiceSupportPolling
	     * 判断服务是否支持轮询。
	     */
	    isServiceSupportPolling: function () {
	        var me = this;
	        return !(
	            me.CLASS_NAME == "SuperMap.REST.ThemeService" ||
	            me.CLASS_NAME == "SuperMap.REST.EditFeaturesService"
	        );
	    },

	    /**
	     * Method: processCompleted
	     * 状态完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    serviceProcessCompleted: function (result) {
	        result = SuperMap.Util.transformResult(result);
	        this.events.triggerEvent("processCompleted", {result: result});
	    },

	    /**
	     * Method: getMapStatusError
	     * 状态失败，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    serviceProcessFailed: function (result) {
	        result = SuperMap.Util.transformResult(result);
	        this.events.triggerEvent("processFailed", result);
	    },
	    CLASS_NAME: "SuperMap.ServiceBase"
	})
	;

	module.exports = function (url, options) {
	    return new SuperMap.ServiceBase(url, options);
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class:QueryService
	 * 地图查询服务类
	 * 提供：范围查询，SQL查询，几何查询，距离查询
	 * 用法：
	 *      L.superMap.queryService(url).queryByBounds{
	 *           filter:{name:name},
	 *           bounds:bounds
	 *      }.on("complete",function(result){
	 *          //doSomething
	 *      }).on("failed",function(result){
	 *          //doSomething
	 *      });
	 */
	__webpack_require__(4);
	__webpack_require__(15);
	__webpack_require__(23);
	__webpack_require__(25);
	__webpack_require__(27);
	__webpack_require__(11);

	QueryService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    /**
	     * 地图bounds查询服务
	     * @param params:
	     *     <QueryByBoundsParameters>
	     * @param resultFormat
	     */
	    queryByBounds: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var queryService = new SuperMap.REST.QueryByBoundsService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });

	        queryService.processAsync(param);
	        return me;
	    },

	    /**
	     * 地图距离查询服务
	     * @param params:
	     *     <QueryByDistanceParameters>
	     * @param resultFormat
	     */
	    queryByDistance: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var queryByDistanceService = new SuperMap.REST.QueryByDistanceService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });

	        queryByDistanceService.processAsync(param);
	        return me;
	    },

	    /**
	     * 地图SQL查询服务
	     * @param params:
	     *     <QueryBySQLParameters>
	     * @param resultFormat
	     */
	    queryBySQL: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var queryBySQLService = new SuperMap.REST.QueryBySQLService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });

	        queryBySQLService.processAsync(param);
	        return me;
	    },

	    /**
	     * 地图几何查询服务
	     * @param params:
	     *     <QueryByGeometryParameters>
	     * @param resultFormat
	     */
	    queryByGeometry: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var queryByGeometryService = new SuperMap.REST.QueryByGeometryService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });

	        queryByGeometryService.processAsync(param);
	        return me;
	    },

	    _processParams: function (params) {
	        if (!params) {
	            return {};
	        }
	        params.returnContent = (params.returnContent == null) ? true : params.returnContent;
	        if (params.queryParams && !L.Util.isArray(params.queryParams)) {
	            params.queryParams = [params.queryParams];
	        }

	        if (params.bounds && params.bounds instanceof L.LatLngBounds) {
	            params.bounds = new SuperMap.Bounds(
	                params.bounds.getSouthWest().lng,
	                params.bounds.getSouthWest().lat,
	                params.bounds.getNorthEast().lng,
	                params.bounds.getNorthEast().lat
	            );
	        }

	        if (params.geometry) {
	            if (params.geometry instanceof L.Point) {
	                params.geometry = new SuperMap.Geometry.Point(params.geometry.x, params.geometry.y);
	            } else {
	                params.geometry = L.Util.toSuperMapGeometry(params.geometry);
	            }
	        }

	        return params;
	    },
	    _processFormat: function (resultFormat) {
	        return (resultFormat) ? resultFormat : Format.GEOJSON;
	    }
	});

	L.supermap.queryService = function (url, options) {
	    return new QueryService(url, options);
	};

	module.exports = L.supermap.queryService;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。
	 */

	/**
	 * Class: SuperMap.REST.QueryByBoundsService
	 * Bounds 查询服务类。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.QueryService>
	 */
	__webpack_require__(16);
	__webpack_require__(22);
	SuperMap.REST.QueryByBoundsService = SuperMap.Class(SuperMap.REST.QueryService, {

	    /**
	     * Constructor: SuperMap.REST.QueryByBoundsService
	     * Bounds 查询服务类构造函数。
	     *
	     * 例如：
	     * (start end)
	     * var myQueryByBoundsService = new SuperMap.REST.QueryByBoundsService(url, {
	     *     eventListeners: {
	     *         "processCompleted": queryCompleted,
	     *		   "processFailed": queryError
	     *		   }
	     * });
	     * function queryCompleted(object){//todo};
	     * function queryError(object){//todo};
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如访问World Map服务，只需将url设为：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.QueryService.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.QueryService.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * Method: getJsonParameters
	     * 将查询参数转化为 JSON 字符串。
	     * 在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds 等）。
	     *
	     * Parameters:
	     * params - {<QueryByBoundsParameters>} Bounds 查询参数。
	     *
	     * Returns:
	     * {Object} 转化后的 JSON 字符串。
	     */
	    getJsonParameters: function (params) {
	        var me = this,
	            jsonParameters = "",
	            qp = null,
	            bounds = params.bounds;
	        qp = me.getQueryParameters(params);
	        jsonParameters += "'queryMode':'BoundsQuery','queryParameters':";
	        jsonParameters += SuperMap.Util.toJSON(qp);
	        jsonParameters += ",'bounds': {'rightTop':{'y':" + bounds.top + ",'x':" + bounds.right + "},'leftBottom':{'y':" + bounds.bottom + ",'x':" + bounds.left + "}}";
	        jsonParameters = "{" + jsonParameters + "}";
	        return jsonParameters;
	    },

	    CLASS_NAME: "SuperMap.REST.QueryByBoundsService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.QueryByBoundsService(url, options);
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。
	 */

	/**
	 * Class: SuperMap.REST.QueryService
	 * 查询服务基类。
	 * 结果保存在一个object对象中，对象包含一个属性result为iServer返回的json对象
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(3);
	__webpack_require__(13);
	__webpack_require__(17);
	SuperMap.REST.QueryService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Property: returnContent
	     * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的URI。
	     */
	    returnContent: false,

	    /**
	     *  Property: format
	     *  {String} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
	     *  参数格式为"ISERVER","GEOJSON",GEOJSON
	     */
	    format: Format.GEOJSON,

	    /**
	     * Constructor: SuperMap.REST.QueryService
	     * 查询服务基类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.QueryService(url, {
	     *     eventListeners: {
	     *	       "processCompleted": queryCompleted, 
	     *		   "processFailed": queryError
	     *		   }
	     * };
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务地址。请求地图查询服务的 URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	        var me = this, end;
	        if (!me.url) {
	            return;
	        }
	        if (options && options.format) {
	            me.format = options.format.toUpperCase();
	        }

	        end = me.url.substr(me.url.length - 1, 1);

	        // TODO 待iServer featureResul资源GeoJSON表述bug修复当使用以下注释掉的逻辑
	        // if (this.format==="geojson" && me.isInTheSameDomain) {
	        //     me.url += (end == "/") ? "featureResults.geojson?" : "/featureResults.geojson?";
	        // } else {
	        //     me.url += (end == "/") ? "featureResults.jsonp?" : "/featureResults.jsonp?";
	        // }
	        if (me.isInTheSameDomain) {
	            me.url += (end === "/") ? "queryResults.json?" : "/queryResults.json?";
	        } else {
	            me.url += (end === "/") ? "queryResults.jsonp?" : "/queryResults.jsonp?";
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.returnContent = null;
	        me.format = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<QueryParameters>} 查询参数。
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this,
	            returnCustomResult = null,
	            jsonParameters = null;
	        me.returnContent = params.returnContent;
	        jsonParameters = me.getJsonParameters(params);
	        if (me.returnContent) {
	            me.url += "returnContent=" + me.returnContent;
	        } else {
	            //仅供三维使用 获取高亮图片的bounds
	            returnCustomResult = params.returnCustomResult;
	            if (returnCustomResult) {
	                me.url += "returnCustomResult=" + returnCustomResult;
	            }
	        }
	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: queryComplete
	     * 查询完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    serviceProcessCompleted: function (result) {
	        var me = this, queryResult;
	        result = SuperMap.Util.transformResult(result);
	        if (result && result.recordsets && me.format === Format.GEOJSON) {
	            queryResult = [];
	            for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
	                if (recordsets[i].features) {
	                    var geoJSONFormat = new SuperMap.Format.GeoJSON();
	                    var feature = JSON.parse(geoJSONFormat.write(recordsets[i].features));
	                    queryResult.push(feature);
	                }
	            }

	        } else {
	            queryResult = result;
	        }
	        me.events.triggerEvent("processCompleted", {result: queryResult});
	    },

	    /**
	     * Method: getQueryParameters
	     * 将 JSON 对象表示的查询参数转化为 QueryParameters 对象。
	     *
	     * Parameters:
	     * params - {Object} JSON 字符串表示的查询参数。
	     *
	     * Returns:
	     * {<QueryParameters>} 返回转化后的 QueryParameters 对象。
	     */
	    getQueryParameters: function (params) {
	        return new QueryParameters({
	            customParams: params.customParams,
	            expectCount: params.expectCount,
	            networkType: params.networkType,
	            queryOption: params.queryOption,
	            queryParams: params.queryParams,
	            startRecord: params.startRecord,
	            prjCoordSys: params.prjCoordSys,
	            holdTime: params.holdTime
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.QueryService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.QueryService(url, options);
	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: QueryParameters
	 * 查询参数基类。
	 * 距离查询、SQL 查询、几何地物查询等各自的参数均继承此类。
	 */
	__webpack_require__(4);
	__webpack_require__(18);
	QueryParameters = SuperMap.Class({

	    /**
	     * APIProperty: customParams
	     * {String} 自定义参数，供扩展使用。
	     */
	    customParams: null,

	    /**
	     * Property: prjCoordSys
	     * {Object} 自定义参数，供isueprmap提供的动态投影查询扩展使用。如 {"epsgCode":3857}
	     */
	    prjCoordSys: null,

	    /**
	     * APIProperty: expectCount
	     * {Number} 期望返回结果记录个数，默认返回100000条查询记录，
	     * 如果实际不足100000条则返回实际记录条数。
	     */
	    expectCount: 100000,

	    /**
	     * APIProperty: networkType
	     * {<GeometryType>} 网络数据集对应的查询类型，
	     * 分为点和线两种类型，默认为线几何对象类型，即GeometryType.LINE。
	     */
	    networkType: GeometryType.LINE,

	    /**
	     * APIProperty: queryOption
	     * {<QueryOption>} 查询结果类型枚举类。
	     * 该类描述查询结果返回类型，包括只返回属性、
	     * 只返回几何实体以及返回属性和几何实体。
	     */
	    queryOption: QueryOption.ATTRIBUTEANDGEOMETRY,

	    /**
	     * APIProperty: queryParams
	     * {Array(<FilterParameter>)} 查询过滤条件参数数组。
	     * 该类用于设置查询数据集的查询过滤参数。
	     */
	    queryParams: null,

	    /**
	     * APIProperty: startRecord
	     * {Number} 查询起始记录号，默认值为0。
	     */
	    startRecord: 0,

	    /**
	     * APIProperty: holdTime
	     * {Number} 资源在服务端保存的时间。默认为10（分钟）。
	     */
	    holdTime: 10,

	    /**
	     * Property: returnCustomResult
	     * {Boolean} 仅供三维使用。
	     */
	    returnCustomResult: false,

	    /**
	     * Constructor: QueryParameters
	     * 查询参数基类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * customParams - {String} 自定义参数，供扩展使用。
	     * expectCount - {Number} 期望返回结果记录个数。
	     * networkType - {<GeometryType>} 网络数据集对应的查询类型。
	     * queryOption - {<QueryOption>} 查询结果类型枚举类。
	     * queryParams -  {Array(<FilterParameter>)} 查询过滤条件参数数组。
	     * startRecord - {Number} 查询起始记录号。
	     * holdTime - {Number} 资源在服务端保存的时间。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.customParams = null;
	        me.expectCount = null;
	        me.networkType = null;
	        me.queryOption = null;
	        if (me.queryParams) {
	            for (var i = 0, qps = me.queryParams, len = qps.length; i < len; i++) {
	                qps[i].destroy();
	            }
	            me.queryParams = null;
	        }
	        me.startRecord = null;
	        me.holdTime = null;
	        me.returnCustomResult = null;
	        me.prjCoordSys = null;
	    },

	    CLASS_NAME: "QueryParameters"
	});
	module.exports = function (options) {
	    return new QueryParameters(options);
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP * 本程序只能在有效的授权许可下使用。 * 未经许可，不得以任何手段擅自使用或传播。*//** * Class: FilterParameter * 查询过滤条件参数类。 * 该类用于设置查询数据集的查询过滤参数。 */__webpack_require__(4);__webpack_require__(19);__webpack_require__(20);FilterParameter = SuperMap.Class({        /**      * APIProperty: attributeFilter     * {String} 属性过滤条件。     * 相当于 SQL 语句中的 WHERE 子句，其格式为：WHERE <条件表达式>，     * attributeFilter 就是其中的“条件表达式”。     * 该字段的用法为 attributeFilter = "过滤条件"。     * 例如，要查询字段 fieldValue 小于100的记录，设置 attributeFilter = "fieldValue < 100"；     * 要查询字段 name 的值为“酒店”的记录，设置 attributeFilter = "name like '%酒店%'"，等等。      */    attributeFilter: null,    /**      * APIProperty: name     * {String} 查询数据集名称或者图层名称，根据实际的查询对象而定，必设属性。     * 一般情况下该字段为数据集名称，但在进行与地图相关功能的操作时，     * 需要设置为图层名称（图层名称格式：数据集名称@数据源别名）。     * 因为一个地图的图层可能是来自于不同数据源的数据集，     * 而不同的数据源中可能存在同名的数据集，     * 使用数据集名称不能唯一的确定数据集，     * 所以在进行与地图相关功能的操作时，该值需要设置为图层名称。      */    name: null,        /**      * APIProperty: joinItems     * {Array(<JoinItem>)} 与外部表的连接信息 JoinItem 数组。      */    joinItems: null,        /**      * APIProperty: linkItems     * {Array(<LinkItem>)} 与外部表的关联信息 LinkItem 数组。      */    linkItems: null,        /**      * APIProperty: ids     * {Array(String)} 查询 id 数组，即属性表中的 SmID 值。       */    ids: null,        /**      * APIProperty: orderBy     * {String} 查询排序的字段,orderBy的字段须为数值型的。     * 相当于 SQL 语句中的 ORDER BY 子句，其格式为：ORDER BY <列名>，     * 列名即属性表中每一列的名称，列又可称为属性，在 SuperMap 中又称为字段。     * 对单个字段排序时，该字段的用法为 orderBy = "字段名"；     * 对多个字段排序时，字段之间以英文逗号进行分割，用法为 orderBy = "字段名1, 字段名2"。     * 例如，现有一个国家数据集，它有两个字段分别为“SmArea”和“pop_1994”，     * 分别表示国家的面积和1994年的各国人口数量。      * 如果要按照各国人口数量对记录进行排序，则 orderBy = "pop_1994"；          * 如果要以面积和人口进行排序，则 orderBy = "SmArea, pop_1994"。      */    orderBy: null,        /**      * APIProperty: groupBy     * {String} 查询分组条件的字段。     * 相当于 SQL 语句中的 GROUP BY 子句，其格式为：GROUP BY <列名>，     * 列名即属性表中每一列的名称，列又可称为属性，在 SuperMap 中又称为字段。     * 对单个字段分组时，该字段的用法为 groupBy = "字段名"；     * 对多个字段分组时，字段之间以英文逗号进行分割，用法为 groupBy = "字段名1, 字段名2"。     * 例如，现有一个全球城市数据集，该数据集有两个字段分别为“Continent”和“Country”，     * 分别表示某个城市所属的洲和国家。     * 如果要按照国家对全球的城市进行分组， 可以设置 groupBy = "Country"；     * 如果以洲和国家对城市进行分组，设置 groupBy = "Continent, Country"。      */    groupBy: null,    /**      * APIProperty: fields     * {Array(String)} 查询字段数组，如果不设置则使用系统返回的所有字段。     */    fields: null,        /**     * Constructor: FilterParameter     * 查询过滤条件参数类构造函数。     *     * Parameters:     * options - {Object} 参数。     *     * Allowed options properties:     * attributeFilter - {String} 属性过滤条件。     * name - {String} 查询数据集名称或者图层名称。     * joinItems - {Array(<JoinItem>)} 与外部表的连接信息 JoinItem 数组。     * linkItems - {Array(<LinkItem>)} 与外部表的关联信息 LinkItem 数组。      * ids - {Array(String)} 查询 id 数组，即属性表中的 SmID 值。         * orderBy - {String} 查询排序的字段, orderBy 的字段须为数值型的。     * groupBy - {String} 查询分组条件的字段。     * fields - {Array(String)} 查询字段数组。     */    initialize: function(options) {        if (options) {            SuperMap.Util.extend(this, options);        }    },    /**     * APIMethod: destroy     * 释放资源，将引用资源的属性置空。       */    destroy: function() {        var me = this;        me.attributeFilter = null;        me.name = null;        if (me.joinItems) {            for (var i = 0,joinItems = me.joinItems,len = joinItems.length; i < len; i++) {                joinItems[i].destroy();            }            me.joinItems = null;        }        if (me.linkItems) {            for (var i = 0,linkItems = me.linkItems,len = linkItems.length; i < len; i++) {                linkItems[i].destroy();            }            me.linkItems = null;        }        me.ids = null;        me.orderBy = null;        me.groupBy = null;        me.fields = null;    },        CLASS_NAME: "FilterParameter"});module.exports = function (options) {    return new FilterParameter(options);};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: JoinItem
	 * 连接信息类。
	 * 该类用于矢量数据集与外部表的连接。外部表可以为另一个矢量数据集（其中纯属性数据集中
	 * 没有空间几何信息）所对应的 DBMS 表，也可以是用户自建的业务表。需要注意的是，矢
	 * 量数据集与外部表必须属于同一数据源。表之间的联系的建立有两种方式，一种是连接
	 * （join），一种是关联（link）。连接，实际上是依据相同的字段将一个外部表追加到指定的表；
	 * 而关联是基于一个相同的字段定义了两个表格之间的联系，但不是实际的追加。用于连接两个表
	 * 的字段的名称不一定相同，但类型必须一致。当两个表格之间建立了连接，通过对主表进行操作，
	 * 可以对外部表进行查询，制作专题图以及分析等。当两个表格之间是一对一或多对一的关系时，
	 * 可以使用 join 连接。当为多对一的关系时，允许指定多个字段之间的关联。
	 *
	 * (注意：
	 * JoinItem 目前支持左连接和内连接，不支持全连接和右连接，UDB 引擎不支持内连接。
	 * 并且用于建立连接的两个表必须在同一个数据源下。
	 * )
	 */
	__webpack_require__(4);
	JoinItem = SuperMap.Class({
	    
	    /** 
	     * APIProperty: foreignTableName
	     * {String} 外部表的名称。
	     * 如果外部表的名称是以“表名@数据源名”命名方式，则该属性只需赋值表名。
	     * 例如：外部表 Name@changchun，Name 为表名，changchun 为数据源名称，则该属性的赋值应为：Name。 
	     */
	    foreignTableName: null,
	    
	    /** 
	     * APIProperty: joinFilter 
	     * {String} 矢量数据集与外部表之间的连接表达式，即设定两个表之间关联的字段。
	     * 例如，将房屋面数据集（Building）的 district 字段与房屋拥有者的纯属性数据集（Owner）的 region 字段相连接，
	     * 两个数据集对应的表名称分别为 Table_Building 和 Table_Owner，
	     * 则连接表达式为 Table_Building.district = Table_Owner.region。
	     * 当有多个字段相连接时，用 AND 将多个表达式相连。 
	     */
	    joinFilter: null,
	    
	    /** APIProperty: joinType
	     * {<JoinType>} 两个表之间连接类型。
	     * 连接类型决定了对两个表进行连接查询后返回的记录的情况。 
	     */
	    joinType: null,
	    
	    /**
	     * Constructor: JoinItem
	     * 连接信息类构造函数。
	     *
	     * 设置将TableB连接TableA的连接信息，即建立JoinItem 类并设置其属性，
	     * 当执行TableA的查询操作时，系统将根据连接条件及查询条件，将满足条件
	     * 的TableA中的内容与满足条件的TableB中的内容构成一个查询结果表，并
	     * 这个查询表保存在内存中，需要获取结果时，再从内存中取出相应的内容。
	     *
	     * 下面以SQL查询说明joinItem的使用方法：
	     * (start code)
	     *   function queryBySQL() {         
	     *       // 设置与外部表的连接信息
	     *       var joinItem = new JoinItem({ 
	     *           foreignTableName: "foreignTable", 
	     *           joinFilter: "foreignTable.CONTINENT = Countries.CONTINENT", 
	     *           joinType: "LEFTJOIN" 
	     *       })
	     *       var queryParam, queryBySQLParams, queryBySQLService;
	     *       // 设置查询参数，在查询参数中添加joinItem关联条件信息
	     *       queryParam = new FilterParameter({
	     *            name: "Countries@World",
	     *            joinItems: [joinItem]
	     *         }),
	     *       queryBySQLParams = new QueryBySQLParameters({
	     *             queryParams: [queryParam]
	     *         }),
	     *       queryBySQLService = new QueryBySQLService(url, {
	     *             eventListeners: { "processCompleted": processCompleted, "processFailed": processFailed}
	     *         });
	     *       queryBySQLService.processAsync(queryBySQLParams);
	     *  }
	     *  function processCompleted(queryEventArgs) {//todo}
	     *  function processFailed(e) {//todo}
	     * (end)
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * foreignTableName - {String} 外部表的名称。
	     * joinFilter - {String} 矢量数据集与外部表之间的连接表达式，即设定两个表之间关联的字段。
	     * joinType - {<JoinType>} 两个表之间连接类型。
	     */
	    initialize: function(options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。 
	     */
	    destroy: function() {
	        var me = this;
	        me.foreignTableName = null;
	        me.joinFilter = null;
	        me.joinType = null;
	    },
	    
	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function(){
	        var dataObj = {};
	        dataObj = SuperMap.Util.copyAttributes(dataObj, this);
	        //joinFilter基本是个纯属性对象，这里不再做转换
	        return dataObj;
	    },
	    
	    CLASS_NAME: "JoinItem"
	});
	module.exports = function (options) {
	    return new JoinItem(options);
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP * 本程序只能在有效的授权许可下使用。 * 未经许可，不得以任何手段擅自使用或传播。*//** * Class: LinkItem * 关联信息类。 * 该类用于矢量数据集与外部表的关联。 外部表是另一个数据集（其中纯属性数据集中没有空间几何信息）中的 DBMS 表， * 矢量数据集与外部表可以属于不同的数据源，但数据源类型目前只支持SQL Server和Oracle类型。 使用LinkItem时， * 空间数据和属性数据必须满足关联条件，即主空间数据集与外部属性表之间存在关联字段。 * LinkItem 只支持左连接，UDB、PostgreSQL 和 DB2 数据源不支持 LinkItem; * 另外，用于建立关联关系的两个表可以不在同一个数据源下。 * * (注意： * 1. 使用 LinkItem 的约束条件为：空间数据和属性数据必须有关联条件，即主空间数据集与外部属性表之间存在关联字段； * 2. 使用外关联表制作专题图时，所关联的字段必须设置表名，例如，如果所关联的字段为BaseMap_R数据集的SmID，就要写成BaseMap_R.SMID。) * */__webpack_require__(4);__webpack_require__(21);LinkItem = SuperMap.Class({        /**      * APIProperty: datasourceConnectionInfo     * {<DatasourceConnectionInfo>} 关联的外部数据源信息 。      */    datasourceConnectionInfo: null,        /**      * APIProperty: foreignKeys     * {Array(String)} 主空间数据集的外键。      */    foreignKeys: null,        /**      * APIProperty: foreignTable     * {String} 关联的外部属性表的名称，目前仅支持 Supermap 管理的表，即另一个矢量数据集所对应的 DBMS 表。     */    foreignTable: null,        /**      * APIProperty: linkFields     * {Array(String)} 欲保留的外部属性表的字段。如果不设置字段或者设置的字段在外部属性表中不存在的话则不返     * 回任何外部属性表的属性信息。如果欲保留的外部表字段与主表字段存在同名，则还需要指定一个不存在字段名作为外部表的字段别名。     */    linkFields: null,        /**      * APIProperty: linkFilter     * {String} 与外部属性表的连接条件。       */    linkFilter: null,        /**      * APIProperty: name     * {String} 此关联信息对象的名称。        */    name: null,        /**      * APIProperty: primaryKeys     * {Array(String)} 需要关联的外部属性表的主键。        */    primaryKeys: null,        /**     * Constructor: LinkItem     * 关联信息类构造函数。     *     * 设置将TableB关联到TableA的关联信息，即建立LinkItem类并设置其属性，     * TableA与TableB是通过主表（TableA）的外键（LinkItem类的 ForeignKey 属性）      * 和副表（TableB）的主键（LinkItem类的 PrimaryKey 属性）实现关联的，     * 当执行TableA的查询操作时，系统将根据关联信息中的过滤条件及查询条件，分别查询TableA      * 与TableB中满足条件的内容，TableA的查询结果与TableB的查询结果分别作为      * 独立的两个结果表保存在内存中，当需要获取结果时，SuperMap将对两个结果进行拼接并返回，     * 因此，进行关联查询时，查询参数中的返回字段一定要有关联条件中的外键，     * 否则无法根据外键的值获取副表中的关联字段值，副表中的字段值将返回 null。     * 在应用层看来，连接和关联操作很相似。     *       * 下面以SQL查询说明linkitem的使用方法：     * (start code)     *  function queryBySQL() {     *      // 设置关联的外部数据库信息,alias表示数据库别名     *      var dc = new DatasourceConnectionInfo({     *          dataBase: "RelQuery",     *          server: "192.168.168.39",     *          user: "sa",     *          password: "map",     *          driver: "SQL Server",     *          connect: true,     *          OpenLinkTable: false,     *          alias: "RelQuery",     *          engineType: EngineType.SQLPLUS,     *          readOnly: false,     *          exclusive: false     *      });     *     // 设置关联信息     *      var linkItem = new LinkItem({     *          datasourceConnectionInfo: dc,     *          foreignKeys: ["name"],     *          foreignTable: "Pop_2011",     *          linkFields: ["SmID as Pid","pop"],     *          name: "link",     *          primatryKeys: ["name"],     *      });     *      // 设置查询参数，在查询参数中添加linkItem关联条件信息     *      var queryParam, queryBySQLParams, queryBySQLService;     *      queryParam = new FilterParameter({     *          name: "Province@RelQuery",     *          fields: ["SmID","name"],     *          attributeFilter: "SmID<7",     *          linkItems: [linkItem]     *       }),      *      queryBySQLParams = new QueryBySQLParameters({     *           queryParams: [queryParam]     *              }),      *      queryBySQLService = new QueryBySQLService(url, {     *          eventListeners: {     *              "processCompleted": processCompleted,     *              "processFailed": processFailed     *              }     *      });     *      queryBySQLService.processAsync(queryBySQLParams);     *  }     *  function processCompleted(queryEventArgs) {//todo}     *  function processFailed(e) {//todo}     * (end)     *      * Parameters:     * options - {Object} 参数。     *     * Allowed options properties:     * datasourceConnectionInfo - {<DatasourceConnectionInfo>} 关联的外部数据源信息。      * foreignKeys - {Array(String)} 主空间数据集的外键。     * foreignTable - {String} 关联的外部属性表的名称。     * linkFields - {Array(String)} 欲保留的外部属性表的字段。     * linkFilter - {String} 与外部属性表的连接条件。       * name - {String} 此关联信息对象的名称。     * primaryKeys - {Array(String)} 需要关联的外部属性表的主键。     */    initialize: function(options) {        if (options) {            SuperMap.Util.extend(this, options);        }    },    /**     * APIMethod: destroy     * 释放资源，将引用资源的属性置空。      */    destroy: function() {        var me = this;        if (me.datasourceConnectionInfo) {            me.datasourceConnectionInfo.destroy();            me.datasourceConnectionInfo = null;        }        me.foreignKeys = null;        me.foreignTable = null;        me.linkFields = null;        me.linkFilter = null;        me.name = null;        me.primaryKeys = null;    },        CLASS_NAME: "LinkItem"});module.exports = function (options) {    return new LinkItem(options);};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: DatasourceConnectionInfo
	 * 数据源连接信息类。
	 * 该类包括了进行数据源连接的所有信息，如所要连接的服务器名称、数据库名称、用户名以及密码等。
	 * 当保存为工作空间时， 工作空间中的数据源的连接信息都将存储到工作空间文件中。对于不同类型的
	 * 数据源，其连接信息有所区别。所以在使 用该类所包含的成员时，请注意该成员所适用的数据源类型。
	 * 对于从数据源对象中返回的数据连接信息对象，只有 connect 方法可以被修改，其 他内容是不可以被修改的。
	 * 对于用户创建的数据源连接信息对象，其内容都可以修改。
	 */
	__webpack_require__(4);
	DatasourceConnectionInfo = SuperMap.Class({

	    /**
	     * APIProperty: alias
	     * {String} 数据源别名。
	     */
	    alias: null,

	    /**
	     * APIProperty: connect
	     * {Boolean} 数据源是否自动连接数据。
	     */
	    connect: null,

	    /**
	     * APIProperty: dataBase
	     * {String} 数据源连接的数据库名。
	     */
	    dataBase: null,

	    /**
	     * APIProperty: driver
	     * {String} 使用 ODBC(Open Database Connectivity，开放数据库互连)的数据库的驱动程序名。
	     * 其中，对于SQL Server 数据库与 iServer 发布的 WMTS 服务，此为必设参数。
	     * 对于SQL Server 数据库，它使用 ODBC 连接，所设置的驱动程序名为 "SQL Server" 或 "SQL Native Client"；
	     * 对于 iServer 发布的 WMTS 服务，设置的驱动名称为 "WMTS"。
	     */
	    driver: null,

	    /**
	     * APIProperty: engineType
	     * {<EngineType>} 数据源连接的引擎类型。
	     */
	    engineType: null,

	    /**
	     * APIProperty: exclusive
	     * {Boolean} 是否以独占方式打开数据源。
	     */
	    exclusive: null,

	    /**
	     * APIProperty: OpenLinkTable
	     * {Boolean} 是否把数据库中的其他非 SuperMap 数据表作为 LinkTable 打开。
	     */
	    OpenLinkTable: null,

	    /**
	     * APIProperty: password
	     * {String} 登录数据源连接的数据库或文件的密码。
	     */
	    password: null,

	    /**
	     * APIProperty: readOnly
	     * {Boolean} 是否以只读方式打开数据源。
	     */
	    readOnly: null,

	    /**
	     * APIProperty: server
	     * {String} 数据库服务器名、文件名或服务地址。
	     * 1.对于SDB和UDB文件，为其文件的绝对路径。注意：当绝对路径的长度超过UTF-8编码格式的260字节长度，该数据源无法打开。
	     * 2.对于Oracle数据库，其服务器名为其TNS服务名称。
	     * 3.对于SQL Server数据库，其服务器名为其系统的DSN(Database Source Name)名称。
	     * 4.对于PostgreSQL数据库，其服务器名为“IP:端口号”，默认的端口号是 5432。
	     * 5.对于DB2数据库，已经进行了编目，所以不需要进行服务器的设置。
	     * 6.对于 Kingbase 数据库，其服务器名为其 IP 地址。
	     * 7.对于GoogleMaps数据源，其服务器地址，默认设置为“http://maps.google.com”，且不可更改。
	     * 8.对于SuperMapCould数据源，为其服务地址。
	     * 9.对于MAPWORLD数据源，为其服务地址，默认设置为“http://www.tianditu.cn”，且不可更改。
	     * 10.对于OGC和REST数据源，为其服务地址。
	     */
	    server: null,

	    /**
	     * APIProperty: user
	     * {String} 登录数据库的用户名。
	     */
	    user: null,

	    /**
	     * Constructor: DatasourceConnectionInfo
	     * 数据源连接信息类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * alias - {String} 数据源别名。
	     * connect - {Boolean} 数据源是否自动连接数据。
	     * dataBase - {String} 数据源连接的数据库名。
	     * driver - {String} 使用 ODBC(Open Database Connectivity，开放数据库互连)的数据库的驱动程序名。
	     * engineType - {<EngineType>} 数据源连接的引擎类型。
	     * exclusive - {Boolean} 是否以独占方式打开数据源。
	     * OpenLinkTable - {Boolean} 是否把数据库中的其他非 SuperMap 数据表作为 LinkTable 打开。
	     * password - {String} 登录数据源连接的数据库或文件的密码。
	     * readOnly - {Boolean} 是否以只读方式打开数据源。
	     * server - {String} 数据库服务器名或 SDB 文件名。
	     * user - {String} 登录数据库的用户名。
	     */
	    initialize: function (options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.alias = null;
	        me.connect = null;
	        me.dataBase = null;
	        me.driver = null;
	        me.engineType = null;
	        me.exclusive = null;
	        me.OpenLinkTable = null;
	        me.password = null;
	        me.readOnly = null;
	        me.server = null;
	        me.user = null;
	    },

	    CLASS_NAME: "DatasourceConnectionInfo"
	});
	module.exports = function (options) {
	    return new DatasourceConnectionInfo(options);
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: QueryByBoundsParameters
	 * Bounds 查询参数类。
	 * 该类用于设置 Bounds 查询的相关参数。
	 *
	 * Inherits from:
	 *  - <QueryParameters>
	 */
	__webpack_require__(4);
	__webpack_require__(17);
	__webpack_require__(18);
	QueryByBoundsParameters = SuperMap.Class(QueryParameters, {

	    /**
	     * APIProperty: returnContent
	     * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。
	     * 如果为 true，则直接返回新创建资源，即查询结果的表述。
	     * 为 false，则返回的是查询结果资源的 URI。默认为 true。
	     */
	    returnContent: true,

	    /**
	     * APIProperty: bounds
	     * {<SuperMap.Bounds>} 指定的查询范围。
	     */
	    bounds: null,

	    /**
	     * Constructor: QueryByBoundsParameters
	     * Bounds 查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * customParams - {String} 自定义参数，供扩展使用。
	     * expectCount - {Integer} 期望返回结果记录个数。
	     * networkType - {<GeometryType>} 网络数据集对应的查询类型。
	     * queryOption - {<QueryOption>} 查询结果类型枚举类。
	     * queryParams -  {Array(<FilterParameter>)} 查询过滤条件参数数组。
	     * startRecord - {Integer} 查询起始记录号。
	     * holdTime - {Integer} 资源在服务端保存的时间。
	     * returnContent - {Boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。
	     * bounds - {<SuperMap.Bounds>} 指定的查询范围。
	     */
	    initialize: function (options) {
	        QueryParameters.prototype.initialize.apply(this, arguments);
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        QueryParameters.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.returnContent = null;
	        if (me.bounds) {
	            me.bounds = null;
	        }

	    },

	    CLASS_NAME: "QueryByBoundsParameters"
	});
	module.exports = function (options) {
	    return new QueryByBoundsParameters(options);
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.QueryByDistanceService
	 * Distance查询服务类。
	 * 
	 * Inherits from:
	 *  - <SuperMap.REST.QueryService>
	 */
	__webpack_require__(16);
	__webpack_require__(24);
	SuperMap.REST.QueryByDistanceService = SuperMap.Class(SuperMap.REST.QueryService, {

	    /**
	     * Constructor: SuperMap.REST.QueryByDistanceService
	     * Distance查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)	
	     * var myQueryByDistService = new SuperMap.REST.QueryByDistanceService(url, {
	     *     eventListeners: {
	     *         "processCompleted": queryCompleted, 
	     *		   "processFailed": queryError
	     *		   }
	     * });
	     * function queryCompleted(object){//todo};
	     * function queryError(object){//todo};
	     * (end)
	     * 
	     * Parameters:
	     * url - {String} 服务的访问地址。如访问World Map服务，只需将url设为：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function(url, options) {
	        SuperMap.REST.QueryService.prototype.initialize.apply(this, arguments);
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function() {
	        SuperMap.REST.QueryService.prototype.destroy.apply(this, arguments);
	    },
	    
	    /**
	     * Method: getJsonParameters
	     * 将查询参数转化为 JSON 字符串。
	     * 在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds等）。
	     *
	     * Parameters:
	     * params - {<QueryByDistanceParameters>} 
	     *
	     * Returns:
	     * {Object} 转化后的 JSON 字符串。
	     */
	    getJsonParameters: function (params) {
	        var me = this,
	            jsonParameters = "",
	            qp = null,
	        qp = me.getQueryParameters(params);
	        var sg = SuperMap.REST.ServerGeometry.fromGeometry(params.geometry);

	        jsonParameters += params.isNearest ? "'queryMode':'FindNearest','queryParameters':" : "'queryMode':'DistanceQuery','queryParameters':";
	        jsonParameters += SuperMap.Util.toJSON(qp);
	        jsonParameters += ",'geometry':" + SuperMap.Util.toJSON(sg) + ",'distance':" + params.distance;
	        jsonParameters = "{" + jsonParameters + "}";
	        return jsonParameters;
	    },
	    
	    CLASS_NAME: "SuperMap.REST.QueryByDistanceService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.QueryByDistanceService(url, options);
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP * 本程序只能在有效的授权许可下使用。 * 未经许可，不得以任何手段擅自使用或传播。*/ /** * Class: QueryByDistanceParameters * Distance 查询参数类。 * 该类用于设置 Distance 查询的相关参数。 * * Inherits from: *  - <QueryParameters>  */__webpack_require__(4);__webpack_require__(17);QueryByDistanceParameters = SuperMap.Class(QueryParameters, {    /**     * APIProperty: distance     * {Number} 查询距离，默认为0，单位与所查询图层对应的数据集单位相同。     * 当查找最近地物时，该属性无效。     */    distance: 0,    /**     * APIProperty: geometry     * {<Object>} 用于查询的地理对象，必设属性。     */    geometry: null,    /**     * APIProperty: isNearest     * {Boolean} 是否为最近距离查询。     * 建议该属性与 expectCount （继承自 QueryParameters）属性联合使用。     * 当该属性为 true 时，即表示查找最近地物，如果查询结果数大于期望返回的结果记录数（expectCount），     * 则查找结果为查询总记录中距离中心最近的expectCount个地物。     * 当该属性为不为 true 时，如果查询结果数大于期望返回的结果记录数（expectCount），     * 则查找结果为从查询总记录中随机抽取的expectCount个地物。     * 目前查询结果不支持按远近距离排序。     */    isNearest: null,    /**      * APIProperty: returnContent     * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。     * 如果为 true，则直接返回新创建资源，即查询结果的表述。     * 为 false，则返回的是查询结果资源的 URI。默认为 true。       */    returnContent: true,        /**     * Constructor: QueryByDistanceParameters     * Distance 查询参数类构造函数。     *     * Parameters:     * options - {Object} 参数。     *     * Allowed options properties:     * customParams - {String} 自定义参数，供扩展使用。       * distance - {Number} 查询距离。     * expectCount - {Integer} 期望返回结果记录个数。     * geometry - {<Object>} 用于查询的几何对象。     * holdTime - {Integer} 资源在服务端保存的时间。     * isNearest - {Boolean} 是否为最近距离查询。     * networkType - {<GeometryType>} 网络数据集对应的查询类型。     * queryOption - {<QueryOption>} 查询结果类型枚举类。     * queryParams -  {Array(<FilterParameter>)} 查询过滤条件参数数组。     * startRecord - {Integer} 查询起始记录号。     * returnContent - {Boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。     */    initialize: function(options) {        QueryParameters.prototype.initialize.apply(this, arguments);        if (!options) {            return;        }        SuperMap.Util.extend(this, options);    },        /**     * APIMethod: destroy     * 释放资源，将引用资源的属性置空。     */    destroy: function() {        QueryParameters.prototype.destroy.apply(this, arguments);         var me = this;        me.returnContent = null;        me.distance = null;        me.isNearest = null;        if (me.geometry) {            me.geometry.destroy();            me.geometry = null;        }    },        CLASS_NAME: "QueryByDistanceParameters"});module.exports = function (options) {    return new QueryByDistanceParameters(options);};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.QueryBySQLService
	 * SQL 查询服务类。在一个或多个指定的图层上查询符合 SQL 条件的空间地物信息。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.QueryService> 
	 */
	__webpack_require__(16);
	__webpack_require__(26);
	SuperMap.REST.QueryBySQLService = SuperMap.Class(SuperMap.REST.QueryService, {

	    /**
	     * Constructor: SuperMap.REST.QueryBySQLService
	     * SQL 查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var queryParam = new SuperMap.REST.FilterParameter({
	     *     name: "Countries@World.1",
	     *     attributeFilter: "Pop_1994>1000000000 and SmArea>900"
	     * });
	     * var queryBySQLParams = new SuperMap.REST.QueryBySQLParameters({
	     *     queryParams: [queryParam]
	     * });
	     * var myQueryBySQLService = new SuperMap.REST.QueryBySQLService(url, {eventListeners: {
	     *     "processCompleted": queryCompleted, 
	     *     "processFailed": queryError
	     *	   }
	     * });
	     * queryBySQLService.processAsync(queryBySQLParams);
	     * function queryCompleted(object){//todo};
	     * function queryError(object){//todo};
	     * (end)	 
	     * 
	     * Parameters:
	     * url - {String} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function(url, options) {
	        SuperMap.REST.QueryService.prototype.initialize.apply(this, arguments);
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。  
	     */
	    destroy: function() {
	        SuperMap.REST.QueryService.prototype.destroy.apply(this, arguments); 
	    },
	    
	    /**
	     * Method: getJsonParameters
	     * 将查询参数转化为 JSON 字符串。
	     * 在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds等）。
	     *
	     * Parameters:
	     * params - {<SuperMap.REST.QueryBySQLParameters>} 
	     *
	     * Returns:
	     * {Object} 转化后的 JSON 字符串。
	     */
	    getJsonParameters: function(params) {
	        var me = this,
	            jsonParameters = "",
	            qp = null;
	        qp = me.getQueryParameters(params);
	        jsonParameters += "'queryMode':'SqlQuery','queryParameters':";
	        jsonParameters += SuperMap.Util.toJSON(qp);
	        jsonParameters = "{" + jsonParameters + "}";
	        return jsonParameters;
	    },
	    
	    CLASS_NAME: "SuperMap.REST.QueryBySQLService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.QueryBySQLService(url, options);
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP * 本程序只能在有效的授权许可下使用。 * 未经许可，不得以任何手段擅自使用或传播。*//** * Class: QueryBySQLParameters * SQL 查询参数类。 * 该类用于设置 SQL 查询的相关参数。 * * Inherits from: *  - <QueryParameters> */__webpack_require__(4);__webpack_require__(17);QueryBySQLParameters = SuperMap.Class(QueryParameters, {    /**     * APIProperty: returnContent     * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。     * 如果为 true，则直接返回新创建资源，即查询结果的表述。     * 为 false，则返回的是查询结果资源的 URI。默认为 true。     */    returnContent: true,    /**     * Constructor: QueryBySQLParameters     * SQL 查询参数类构造函数。     *     * Parameters:     * options - {Object} 参数。     *     * Allowed options properties:     * customParams - {String} 自定义参数，供扩展使用。     * expectCount - {Integer} 期望返回结果记录个数。     * networkType - {<GeometryType>} 网络数据集对应的查询类型。     * queryOption - {<QueryOption>} 查询结果类型枚举类。     * queryParams -  {Array(<FilterParameter>)} 查询过滤条件参数数组。     * startRecord - {Integer} 查询起始记录号。     * holdTime - {Integer} 资源在服务端保存的时间。     * returnContent - {Boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。     */    initialize: function (options) {        QueryParameters.prototype.initialize.apply(this, arguments);        if (!options) {            return;        }        SuperMap.Util.extend(this, options);    },    /**     * APIMethod: destroy     * 释放资源，将引用资源的属性置空。     */    destroy: function () {        QueryParameters.prototype.destroy.apply(this, arguments);        var me = this;        me.returnContent = null;    },    CLASS_NAME: "QueryBySQLParameters"});module.exports = function (options) {    return new QueryBySQLParameters(options);};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.QueryByGeometryService
	 * Geometry 查询服务类。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.QueryService>
	 */
	__webpack_require__(16);
	__webpack_require__(28);
	SuperMap.REST.QueryByGeometryService = SuperMap.Class(SuperMap.REST.QueryService, {

	    /**
	     * Constructor: SuperMap.REST.QueryByGeometryService
	     * Geometry 查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myQueryByGeometryService = new SuperMap.REST.QueryByGeometryService(url, {
	    *     eventListeners: {
	    *	      "processCompleted": queryCompleted, 
	    *		  "processFailed": queryError
	    *		  }
	    * });
	     * function queryCompleted(object){//todo};
	     * function queryError(object){//todo};
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.QueryService.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.QueryService.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * Method: getJsonParameters
	     * 将查询参数转化为 JSON 字符串。
	     * 在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds等）。
	     *
	     * Parameters:
	     * params - {<QueryByGeometryParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的 JSON 字符串。
	     */
	    getJsonParameters: function (params) {
	        var me = this,
	            jsonParameters = "",
	            qp = null,
	            geometry = params.geometry,
	            sg = SuperMap.REST.ServerGeometry.fromGeometry(geometry);
	        qp = me.getQueryParameters(params);
	        jsonParameters += "'queryMode':'SpatialQuery','queryParameters':";
	        jsonParameters += SuperMap.Util.toJSON(qp) + ",'geometry':" + SuperMap.Util.toJSON(sg) + ",'spatialQueryMode':" + SuperMap.Util.toJSON(params.spatialQueryMode);
	        jsonParameters = "{" + jsonParameters + "}";
	        return jsonParameters;
	    },

	    CLASS_NAME: "SuperMap.REST.QueryByGeometryService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.QueryByGeometryService(url, options);
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/
	 
	/**
	 * Class: QueryByGeometryParameters
	 * Geometry 查询参数类。
	 * 该类用于设置 Geometry查询的相关参数。
	 *
	 * Inherits from:
	 *  - <QueryParameters> 
	 */
	__webpack_require__(4);
	__webpack_require__(17);
	QueryByGeometryParameters = SuperMap.Class(QueryParameters, {

	    /** 
	     * APIProperty: returnContent
	     * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。
	     * 如果为 true，则直接返回新创建资源，即查询结果的表述。
	     * 为 false，则返回的是查询结果资源的 URI。默认为 true。  
	     */
	    returnContent: true,
	    
	    /**
	     * APIProperty: geometry
	     * {Object} 用于查询的几何对象。
	     */
	    geometry: null,
	    
	    /**
	     * APIProperty: spatialQueryMode
	     * {<SpatialQueryMode>} 空间查询模式。
	     */
	    spatialQueryMode: SpatialQueryMode.INTERSECT,
	    
	    /**
	     * Constructor: QueryByGeometryParameters
	     * Geometry 查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * customParams - {String} 自定义参数，供扩展使用。  
	     * expectCount - {Integer} 期望返回结果记录个数。
	     * networkType - {<GeometryType>} 网络数据集对应的查询类型。
	     * queryOption - {<QueryOption>} 查询结果类型枚举类。
	     * queryParams -  {Array(<FilterParameter>)} 查询过滤条件参数数组。
	     * startRecord - {Integer} 查询起始记录号。
	     * holdTime - {Integer} 资源在服务端保存的时间。
	     * returnContent - {Boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。
	     * geometry - {Object} 用于查询的几何对象。
	     * spatialQueryMode - {<SpatialQueryMode>} 空间查询模式。
	     */
	    initialize: function(options) {
	        QueryParameters.prototype.initialize.apply(this,arguments);
	        if (!options){
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。  
	     */
	    destroy: function() {
	        var me = this;
	        QueryParameters.prototype.destroy.apply(me, arguments); 
	        me.returnContent = null;
	        me.geometry = null;
	        me.spatialQueryMode = null;        
	    },
	    
	    CLASS_NAME: "QueryByGeometryParameters"
	});
	module.exports = function (options) {
	    return new QueryByGeometryParameters(options);
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class:ChartQueryService
	 * 海图查询服务
	 * 用法：
	 *      L.superMap.chartQueryService(url).queryChart()
	 *      .on("complete",function(result){
	 *          //doSomething
	 *      }).on("failed",function(result){
	 *          //doSomething
	 *      });
	 */
	__webpack_require__(4);
	__webpack_require__(30);
	__webpack_require__(11);

	ChartQueryService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    /**
	     * @param params
	     * <ChartQueryParameters>
	     * @param resultFormat
	     */
	    queryChart: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var chartQueryService = new SuperMap.REST.ChartQueryService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });

	        chartQueryService.processAsync(param);
	        return me;
	    },
	    _processParams: function (params) {
	        if (!params) {
	            return {};
	        }
	        params.returnContent = (params.returnContent == null) ? true : params.returnContent;
	        if (params.chartQueryFilterParameters && !L.Util.isArray(params.chartQueryFilterParameters)) {
	            params.chartQueryFilterParameters = [params.chartQueryFilterParameters];
	        }

	        if (params.bounds && params.bounds instanceof L.LatLngBounds) {
	            params.bounds = new SuperMap.Bounds(
	                params.bounds.getSouthWest().lng,
	                params.bounds.getSouthWest().lat,
	                params.bounds.getNorthEast().lng,
	                params.bounds.getNorthEast().lat
	            );
	        }
	    },
	    _processFormat: function (resultFormat) {
	        return (resultFormat) ? resultFormat : Format.GEOJSON;
	    }
	});

	L.supermap.chartQueryService = function (url, options) {
	    return new ChartQueryService(url, options);
	};

	module.exports = L.supermap.chartQueryService;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.ChartQueryService
	 *      海图查询服务类。该类负责将海图查询所需参数（ChartQueryParameters）传递至服务端，并获取服务端的返回结果。
	 *      用户可以通过两种方式获取查询结果:
	 *      1.通过 AsyncResponder 类获取（推荐使用）；
	 *      2.通过监听 QueryEvent.PROCESS_COMPLETE 事件获取。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(3);
	__webpack_require__(13);
	__webpack_require__(31);
	SuperMap.REST.ChartQueryService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Property: returnContent
	     * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的URI。
	     */
	    returnContent: null,

	    /**
	     *  Property: format
	     *  {String} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
	     *  参数格式为"ISERVER","GEOJSON",GEOJSON
	     */
	    format: Format.GEOJSON,
	    /**
	     * Constructor: SuperMap.REST.ChartQueryService
	     * 获取图层信息服务类构造函数。
	     *
	     * Parameters:
	     * url - {String} 地图查询服务访问地址。如："http://192.168.168.35:8090/iserver/services/map-ChartW/rest/maps/海图"。
	     * options - {Object} 参数。
	     *
	     * 示例:
	     * 下面示例显示了如何进行海图属性查询：
	     * (start code)
	     * var nameArray = ["GB4X0000_52000"];
	     * var chartQueryFilterParameter = new ChartQueryFilterParameter({
	     *       isQueryPoint:true,
	     *        isQueryLine:true,
	     *        isQueryRegion:true,
	     *        attributeFilter:"SmID<10",
	     *        chartFeatureInfoSpecCode:1
	     *    });
	     *
	     * var chartQueryParameters = new ChartQueryParameters({
	     *        queryMode:"ChartAttributeQuery",
	     *        chartLayerNames:nameArray,
	     *        returnContent:true,
	     *        chartQueryFilterParameters:[chartQueryFilterParameter]
	     *    });
	     *
	     * var chartQueryService = new SuperMap.REST.ChartQueryService(url);
	     *
	     * chartQueryService.events.on({
	     *        "processCompleted":processCompleted,
	     *        "processFailed":processFailed
	     *    });
	     * chartQueryService.processAsync(chartQueryParameters);
	     * (end)
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        options = options || {};
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	        var me = this, end;
	        if (options && options.format) {
	            me.format = options.format.toUpperCase();
	        }

	        if (!me.url) {
	            return;
	        }
	        end = me.url.substr(me.url.length - 1, 1);

	        // TODO 待iServer featureResul资源GeoJSON表述bug修复当使用以下注释掉的逻辑
	        // if (me.format==="geojson" && me.isInTheSameDomain) {
	        //     me.url += (end == "/") ? "featureResults.geojson?" : "/featureResults.geojson?";
	        // } else {
	        //     me.url += (end == "/") ? "featureResults.jsonp?" : "/featureResults.jsonp?";
	        // }
	        if (me.isInTheSameDomain) {
	            me.url += (end === "/") ? "queryResults.json?" : "/queryResults.json?";
	        } else {
	            me.url += (end === "/") ? "queryResults.jsonp?" : "/queryResults.jsonp?";
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     *
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        me.returnContent = null;
	        me.format = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 使用服务地址 URL 实例化 ChartQueryService 对象。
	     *
	     * Parameters:
	     * params - {<ChartQueryParameters>} 查询参数。
	     */
	    processAsync: function (params) {
	        //todo重点需要添加代码的地方
	        if (!params) {
	            return;
	        }
	        var me = this, jsonParameters;
	        me.returnContent = params.returnContent;
	        jsonParameters = params.getVariablesJson();
	        if (me.returnContent) {
	            me.url += "returnContent=" + me.returnContent;
	        }
	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: queryComplete
	     * 查询完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    serviceProcessCompleted: function (result) {
	        var me = this, queryResult;
	        result = SuperMap.Util.transformResult(result);
	        if (result && result.recordsets && me.format === Format.GEOJSON) {
	            queryResult = [];
	            for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
	                if (recordsets[i].features) {
	                    var geoJSONFormat = new SuperMap.Format.GeoJSON();
	                    var feature = JSON.parse(geoJSONFormat.write(recordsets[i].features));
	                    queryResult.push(feature);
	                }
	            }

	        } else {
	            queryResult = result;
	        }
	        me.events.triggerEvent("processCompleted", {result: queryResult});
	    },

	    /**
	     * Method: getQueryParameters
	     * 将 JSON 对象表示的查询参数转化为 QueryParameters 对象。
	     *
	     * Parameters:
	     * params - {Object} JSON 字符串表示的查询参数。
	     *
	     * Returns:
	     * {<chartQueryFilterParameters>}
	     */
	    getQueryParameters: function (params) {
	        return new QueryParameters({
	            queryMode: params.queryMode,
	            bounds: params.bounds,
	            chartLayerNames: params.chartLayerNames,
	            chartQueryFilterParameters: params.chartQueryFilterParameters,
	            returnContent: params.returnContent
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.ChartQueryService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.ChartQueryService(url, options);
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ChartQueryParameters
	 *     海图查询参数类，该类用于设置海图查询时的相关参数，海图查询分为海图属性
	 *     查询和海图范围查询两类，通过属性queryMode指定查询模式。必设属性有：
	 *     queryMode、chartLayerNames、chartQueryFilterParameters。当进行海图范围查询时，必设属性还包括bounds。
	 */
	__webpack_require__(4);
	__webpack_require__(32);
	ChartQueryParameters = SuperMap.Class({

	    /**
	     * APIProperty: queryMode
	     * {String}  海图查询模式类型，SuperMap iClient for JavaScript对海图支持两种
	     *     查询方式：海图属性查询（"ChartAttributeQuery"）和海图空间查询
	     *     （"ChartBoundsQuery"） 。
	     */
	    queryMode: null,

	    /**
	     * APIProperty: bounds
	     * {<SuperMap.Bounds>}  海图查询范围。
	     */
	    bounds: null,

	    /**
	     * APIProperty: chartLayerNames
	     * {Array(String)} 查询的海图图层的名称。
	     */
	    chartLayerNames: null,

	    /**
	     * APIProperty: chartQueryFilterParameters
	     * {Array <ChartQueryFilterParameter>} 海图查询过滤参数。
	     *      包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字
	     *      段过滤条件。
	     */
	    chartQueryFilterParameters: null,

	    /**
	     * Property: returnContent
	     * {Boolean} 获取或设置是返回查询结果记录集 recordsets，还是返回查询结果的
	     *      资源 resourceInfo。默认为 true，表示返回 recordsets。
	     *
	     *  note: Recordsets 和 ResourceInfo 都存储在查询结果类 QueryResult 中。
	     *  当
	     *  (start code)
	     *  ReturnContent = true
	     *  (end)
	     *  表示返回查询记录集，这时
	     *  查询结果存储在
	     *  (start code)
	     *      QueryResult.Recordsets
	     *  (end)
	     *  中，而
	     *  (start code)
	     *      QueryResult.ResourceInfo
	     *  (end)
	     *  为空；当
	     *  (start code)
	     *      ReturnContent = false
	     *  (end)
	     *  时，表示返回查询结果资源，这时查询结果存储在
	     *  (start code)
	     *      QueryResult.ResourceInfo
	     *  (end)
	     *  中，而
	     *  (start code)
	     *      QueryResult.Recordsets
	     *  (end)
	     *  为空。
	     */
	    returnContent: true,

	    /**
	     * APIProperty: startRecord
	     * {Number} 查询起始记录位置，默认为0。
	     */
	    startRecord: 0,

	    /**
	     * APIProperty: expectCount
	     * {Number} 期望查询结果返回的记录数，该值大于0。
	     */
	    expectCount: null,

	    /**
	     * Constructor: ChartQueryParameters
	     *  初始化 ChartQueryParameters 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * queryMode - {String}  海图查询模式类型，SuperMap iClient for JavaScript对
	     *     海图支持两种查询方式：海图属性查询（"ChartAttributeQuery"）和海图空
	     *     间查询（"ChartBoundsQuery"） 。
	     * bounds - {<SuperMap.Bounds>}  海图查询范围。
	     * chartLayerNames - {Array(String)} 查询的海图图层的名称。
	     * chartQueryFilterParameters - {Array <ChartQueryFilterParameter>}
	     *      海图查询过滤参数。包括：物标代码、物标可应用对象的选择（是否查询点、
	     *      线或面）、属性字段过滤条件。
	     * returnContent - {Boolean} 获取或设置是返回查询结果记录集 recordsets，还
	     *       是返回查询结果的资源 resourceInfo。默认为 true，表示返回 recordsets。
	     * startRecord - {Number} 查询起始记录位置，默认为0。
	     * expectCount - {Number} 期望查询结果返回的记录数，该值大于0。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.queryMode = null;
	        me.bounds = null;
	        me.chartLayerNames = null;
	        me.chartQueryFilterParameters = null;
	        me.returnContent = true;
	        me.startRecord = 0;
	        me.expectCount = null;
	    },

	    /**
	     * Method: getVariablesJson
	     * 将属性信息转换成能够被服务识别的JSON格式字符串。
	     */
	    getVariablesJson: function () {
	        var json = "";

	        json += "\"queryMode\":\"" + this.queryMode + "\",";

	        if (this.chartLayerNames && this.chartLayerNames.length) {
	            var chartLayersArray = [];
	            var layerLength = this.chartLayerNames.length;
	            for (var i = 0; i < layerLength; i++) {
	                chartLayersArray.push("\"" + this.chartLayerNames[i] + "\"");
	            }
	            var layerNames = "[" + chartLayersArray.join(",") + "]";
	            json += "\"chartLayerNames\":" + layerNames + ",";
	        }

	        if (this.queryMode === "ChartBoundsQuery" && this.bounds) {
	            json += "\"bounds\":" + "{" + "\"leftBottom\":" + "{" + "\"x\":" + this.bounds.left + "," +
	                "\"y\":" + this.bounds.bottom + "}" + "," + "\"rightTop\":" + "{" + "\"x\":" + this.bounds.right + "," +
	                "\"y\":" + this.bounds.top + "}" + "},";
	        }

	        if (this.chartQueryFilterParameters && this.chartQueryFilterParameters.length) {
	            var chartParamArray = [];
	            var chartLength = this.chartQueryFilterParameters.length;
	            for (var j = 0; j < chartLength; j++) {
	                var chartQueryFilterParameter = new ChartQueryFilterParameter();
	                chartQueryFilterParameter = this.chartQueryFilterParameters[j];
	                chartParamArray.push(chartQueryFilterParameter.toJson());
	            }
	            var chartParamsJson = "[" + chartParamArray.join(",") + "]";
	            chartParamsJson = "\"chartQueryParams\":" + chartParamsJson + ",";
	            chartParamsJson += "\"startRecord\":" + this.startRecord + ",";
	            chartParamsJson += "\"expectCount\":" + this.expectCount;
	            chartParamsJson = "{" + chartParamsJson + "}";
	            json += "\"chartQueryParameters\":" + chartParamsJson;
	        }
	        json = "{" + json + "}";
	        return json;
	    },

	    CLASS_NAME: "ChartQueryParameters"
	});
	module.exports = function (options) {
	    return new ChartQueryParameters(options);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ChartQueryFilterParameter
	 *      海图查询过滤参数类，用于设置海图查询的过滤参数。包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。
	 */
	__webpack_require__(4);
	ChartQueryFilterParameter = SuperMap.Class({

	    /**
	     * APIProperty: isQueryPoint
	     * {Boolean} 是否查询点。
	     */
	    isQueryPoint: null,

	    /**
	     * APIProperty: isQueryLine
	     * {Boolean} 是否查询线。
	     */
	    isQueryLine: null,

	    /**
	     * APIProperty: isQueryRegion
	     * {Boolean} 是否查询面。
	     */
	    isQueryRegion: null,

	    /**
	     * APIProperty: attributeFilter
	     * {String} 属性字段过滤条件。
	     */
	    attributeFilter: null,

	    /**
	     * APIProperty: chartFeatureInfoSpecCode
	     * {Number} 查询的物标代号。
	     */
	    chartFeatureInfoSpecCode: null,

	    /**
	     * Constructor: ChartQueryFilterParameter
	     * 初始化 ChartQueryFilterParameter 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * isQueryPoint - {Boolean} 是否查询点。
	     * isQueryLine  - {Boolean} 是否查询线。
	     * isQueryRegion  - {Boolean} 是否查询面。
	     * isQueryLine  - {Boolean} 是否查询点。
	     * attributeFilter - {String} 属性字段过滤条件。
	     * chartFeatureInfoSpecCode - {Number} 查询的物标代号。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.isQueryPoint = null;
	        me.isQueryLine = null;
	        me.isQueryRegion = null;
	        me.attributeFilter = null;
	        me.chartFeatureInfoSpecCode = null;
	    },

	    /**
	     * Method: toJson
	     * 将属性信息转化成JSON格式字符串。
	     */
	    toJson: function () {
	        var json = "";
	        json += "\"isQueryPoint\":" + this.isQueryPoint + ",";
	        json += "\"isQueryLine\":" + this.isQueryLine + ",";
	        json += "\"isQueryRegion\":" + this.isQueryRegion + ",";
	        if (this.attributeFilter) {
	            json += "\"attributeFilter\": \"" + this.attributeFilter + "\",";
	        }
	        json += "\"chartFeatureInfoSpecCode\":" + this.chartFeatureInfoSpecCode;
	        json = "{" + json + "}";
	        return json;
	    },


	    CLASS_NAME: "ChartQueryFilterParameter"
	});
	module.exports = function (options) {
	    return new ChartQueryFilterParameter(options);
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class:TilesetsService
	 * 切片列表信息查询服务
	 * 用法：
	 *      L.superMap.tilesetsService(url).getTilesets()
	 *      .on("complete",function(result){
	 *          //doSomething
	 *      }).on("failed",function(result){
	 *          //doSomething
	 *      });
	 */
	__webpack_require__(34);
	__webpack_require__(11);

	TilesetsService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    getTilesets: function () {
	        var me = this;
	        var tilesetsService = new SuperMap.REST.TilesetsService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });

	        tilesetsService.processAsync();
	        return me;
	    }
	});

	L.supermap.tilesetsService = function (url, options) {
	    return new TilesetsService(url, options);
	};

	module.exports = L.supermap.tilesetsService;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.TilesetsService
	 * 切片列表信息查询服务类;即查询切片地图服务的切片列表，返回切片集名称、地图切片元数据信息、切片版本集信息
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);

	SuperMap.REST.TilesetsService = SuperMap.Class(SuperMap.ServiceBase, {


	    /**
	     * Constructor: SuperMap.REST.TilesetsService
	     * 切片列表信息查询服务类构造函数。
	     *
	     * Parameters:
	     * url - {String} 地图服务地址。URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{服务名}/rest/maps/map；
	     * 例如: "http://localhost:8090/iserver/services/test/rest/maps/tianlocal";
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     */
	    processAsync: function () {
	        if (!this.url) {
	            return;
	        }
	        var me = this;
	        var end = me.url.substr(me.url.length - 1, 1);

	        me.url = me.url + ((end === "/") ? "tilesets" : "/tilesets") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");

	        me.request({
	            method: "GET",
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.TilesetsService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.TilesetsService(url, options);
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: GetLayersInfoService
	 * 地图信息服务类
	 * 用法：
	 *      L.superMap.getLayersInfoService(url).getLayersInfo()
	 *        .on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(11);
	__webpack_require__(36);

	GetLayersInfoService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    getLayersInfo: function () {
	        var me = this;
	        var getLayersInfoService = new SuperMap.REST.GetLayersInfoService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        getLayersInfoService.processAsync();
	        return me;
	    },
	    processCompleted: function (layersInfoResult) {
	        var layersInfo,
	            result = layersInfoResult.result;
	        if (result && result.subLayers && result.subLayers.layers) {
	            layersInfo = result.subLayers.layers;
	        }
	        this.fire('complete', {result: layersInfo});
	    }
	});

	L.supermap.getLayersInfoService = function (url, options) {
	    return new GetLayersInfoService(url, options);
	};

	module.exports = L.supermap.getLayersInfoService;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.GetLayersInfoService
	 * 获取图层信息服务类。
	 * 该类负责将从客户端指定的服务器上获取该服务器提供的图层信息。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	SuperMap.REST.GetLayersInfoService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Property: isTempLayers
	     * {Boolean>} 当前url对应的图层是否是临时图层。
	     */
	    isTempLayers: false,

	    /**
	     * Constructor: SuperMap.REST.GetLayersInfoService
	     * 获取图层信息服务类构造函数。
	     *
	     * Parameters:
	     * url - {String} 与客户端交互的地图服务地址。请求地图服务,URL 应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
	     * 如 http://localhost:8090/iserver/services/map-world/rest/maps/World 。
	     * 如果查询临时图层的信息，请指定完成的url，包含临时图层ID信息，如：
	     * http://localhost:8090/iserver/services/map-world/rest/maps/World/tempLayersSet/resourceID
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     * isTempLayers - {Boolean} 当前url对应的图层是否是临时图层。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        SuperMap.Util.reset(this);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的更新参数传递到服务端。
	     *
	     */
	    processAsync: function () {
	        var me = this,
	            method = "GET",
	            end = me.url.substr(me.url.length - 1, 1);
	        if (!me.isTempLayers) {
	            me.url += (end === "/") ? '' : '/';
	            me.url += me.isInTheSameDomain ? "layers.json?" : "layers.jsonp?";
	        } else {
	            me.url += me.isInTheSameDomain ? ".json?" : ".jsonp?";
	        }
	        me.request({
	            method: method,
	            params: null,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getLayerComplted
	     * 编辑完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    serviceProcessCompleted: function (result) {
	        result = SuperMap.Util.transformResult(result);
	        result = (result && result.length > 0) ? result[0] : null;
	        this.events.triggerEvent("processCompleted", {result: result});
	    },

	    /**
	     * TODO 专题图时候可能会用到，先放在这
	     * Method: handleLayers
	     * 处理iserver 新增图层组数据 (subLayers.layers 中可能还会含有 subLayers.layers)
	     *
	     * Parameters:
	     * len - {Number} subLayers.layers的长度
	     * layers - {Array} subLayers.layers
	     */
	    handleLayers: function (len, layers) {
	        var me = this, tempLayer;
	        if (len) {
	            for (var i = 0; i < len; i++) {
	                if (layers[i].subLayers && layers[i].subLayers.layers && layers[i].subLayers.layers.length > 0) {
	                    this.handleLayers(layers[i].subLayers.layers.length, layers[i].subLayers.layers);
	                }
	                else {
	                    var type = layers[i].ugcLayerType;
	                    switch (type) {
	                        case 'THEME':
	                            tempLayer = new ServerTheme();
	                            tempLayer.fromJson(layers[i]);
	                            layers[i] = tempLayer;
	                            break;
	                        case 'GRID':
	                            tempLayer = new Grid();
	                            tempLayer.fromJson(layers[i]);
	                            layers[i] = tempLayer;
	                            break;
	                        case 'IMAGE':
	                            tempLayer = new Image();
	                            tempLayer.fromJson(layers[i]);
	                            layers[i] = tempLayer;
	                            break;
	                        case 'VECTOR':
	                            tempLayer = new Vector();
	                            tempLayer.fromJson(layers[i]);
	                            layers[i] = tempLayer;
	                            break;
	                    }
	                }

	            }
	        }
	    },

	    CLASS_NAME: "SuperMap.REST.GetLayersInfoService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GetLayersInfoService(url, options);
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: ChartFeatureInfoSpecsService
	 * 海图物标信息服务
	 * 用法：
	 *      L.superMap.chartFeatureInfoSpecsService(url)
	 *      .getChartFeatureInfo()
	 *      .on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(11);
	__webpack_require__(38);

	ChartFeatureInfoSpecsService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    getChartFeatureInfo: function () {
	        var me = this;
	        var chartFeatureInfoSpecsService = new SuperMap.REST.ChartFeatureInfoSpecsService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        chartFeatureInfoSpecsService.processAsync();
	        return me;
	    }
	});

	L.supermap.chartFeatureInfoSpecsService = function (url, options) {
	    return new ChartFeatureInfoSpecsService(url, options);
	};

	module.exports = L.supermap.chartFeatureInfoSpecsService;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.ChartFeatureInfoSpecsService
	 *      海图物标信息服务类，通过该服务类可以查询到服务端支持的所有海图物标信息。
	 *      用户可以通过两种方式获取查询结果：
	 *      一种是通过监听 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE 事件；
	 *      另一种是使用 AsyncResponder 类实现异步处理。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	SuperMap.REST.ChartFeatureInfoSpecsService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.ChartFeatureInfoSpecsService
	     *     使用地图（特指海图）服务地址 URL 初始化 ChartFeatureInfoSpecsService
	     *     类的新实例。
	     *
	     * Parameters:
	     * url - {String} 地图（特指海图）服务地址。
	     *     如："http://localhost:8090/iserver/services/map-ChartW/rest/maps/海图"。
	     *     发送请求格式类似于："http://localhost:8090/iserver/services/map-ChartW/rest/maps/海图/chartFeatureInfoSpecs.json"
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this,arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        SuperMap.Util.reset(this);
	    },

	    /**
	     * APIMethod: processAsync
	     *     根据地图（特指海图）服务地址与服务端完成异步通讯，获取物标信息。
	     *
	     * Note: 当查询物标信息成功时，将触发 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE
	     *     事件。用可以通过户两种方式获取图层信息:
	     *     1. 通过 AsyncResponder 类获取（推荐使用）；
	     *     2. 通过监听 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE 事件获取。
	     */
	    processAsync: function () {
	        var me = this, method = "GET",
	            end = me.url.substr(me.url.length - 1, 1);
	        if (!me.isTempLayers) {
	            me.url += (end === "/") ? '' : '/';
	            me.url += me.isInTheSameDomain ? "chartFeatureInfoSpecs.json?" : "chartFeatureInfoSpecs.jsonp?";
	        } else {
	            me.url += me.isInTheSameDomain ? ".json?" : ".jsonp?";
	        }
	        me.request({
	            method: method,
	            params: null,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.ChartFeatureInfoSpecsService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.ChartFeatureInfoSpecsService(url, options);
	};


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: SetLayersService
	 * 设置图层信息服服务类
	 * 用法：
	 *      L.superMap.setLayerService(url).setLayerInfo({
	 *         tempLayerID:xxx
	 *         layerPath:xxx,
	 *         resourceID:xxx,
	 *         layerInfo:layerInfo
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(11);
	__webpack_require__(40);
	__webpack_require__(41);
	__webpack_require__(42);

	SetLayerService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	        var end = me.options.url.substr(me.options.url.length - 1, 1);
	        me.options.url += (end === "/") ? '' : '/';
	    },

	    /**
	     * @param params:
	     *       tempLayerID,layerPath,resourceID
	     */
	    setLayerInfo: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this,
	            tempLayerID = params.tempLayerID,
	            layerPath = params.layerPath,
	            resourceID = params.resourceID,
	            layerInfoParams = params.layerInfo;
	        if (!tempLayerID || !layerPath || !resourceID) {
	            return;
	        }
	        var url = me.options.url.concat();
	        url += "tempLayersSet/" + tempLayerID + "/" + layerPath;

	        var setLayerInfoService = new SuperMap.REST.SetLayerInfoService(url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            resourceID: resourceID
	        });

	        setLayerInfoService.processAsync(layerInfoParams);
	        return me;
	    },


	    /**
	     * @param params:
	     *       layersInfo(iServer图层信息，可以从GetLayersInfoService得到)
	     *       tempLayerID,isTempLayers
	     */
	    setLayersInfo: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, layersInfoParam,
	            resourceID = params.resourceID,
	            isTempLayers = params.isTempLayers ? params.isTempLayers : false,
	            layersInfo = params.layersInfo;
	        if (!resourceID || !layersInfo) {
	            return;
	        }
	        layersInfoParam.subLayers = {};
	        layersInfoParam.subLayers.layers = layersInfo;
	        var setLayersInfoService = new SuperMap.REST.SetLayersInfoService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            resourceID: resourceID,
	            isTempLayers: isTempLayers
	        });

	        setLayersInfoService.processAsync(layersInfoParam);
	        return me;
	    },


	    /**
	     * @param params:
	     *     <SetLayerStatusParameters>
	     */
	    setLayerStatus: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this;

	        var setLayerStatusService = new SuperMap.REST.SetLayerStatusService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }

	        });

	        setLayerStatusService.processAsync(params);
	        return me;
	    }
	});

	L.supermap.setLayerService = function (url, options) {
	    return new SetLayerService(url, options);
	};

	module.exports = L.supermap.setLayerService;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.SetLayerInfoService
	 * 设置图层信息服务类。可以实现临时图层中子图层的修改
	 * 该类负责将图层设置参数传递到服务端，并获取服务端返回的结果信息。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	SuperMap.REST.SetLayerInfoService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * APIProperty: resourceID
	     * {String} 图层资源ID，临时图层的资源ID标记。
	     */
	    resourceID: null,


	    /**
	     * Constructor: SuperMap.REST.SetLayerInfoService
	     * 设置图层信息服务类构造函数。可以实现临时图层中子图层的修改。
	     *
	     * Parameters:
	     * url - {String} 与客户端交互的地图服务地址。请求地图服务,URL 应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}/tempLayersSet/{tempLayerID}/Rivers@World@@World"；
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	        this.resourceID = options.resourceID;
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        SuperMap.Util.reset(this);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的更新参数传递到服务端。
	     * Parameters:
	     * params - {Object} 修改后的图层资源信息。该参数可以使用获取图层信息服务 <SuperMap.REST.GetLayerInfoService>.result.subLayers.layers[i]
	     * 返回图层信息，然后对其属性进行修改来获取。
	     */
	    processAsync: function (params) {
	        var me = this;

	        if (!params) {
	            return;
	        }
	        me.url += me.isInTheSameDomain ? ".json" : ".jsonp";
	        var jsonParamsStr = SuperMap.Util.toJSON(params);
	        me.request({
	            method: "PUT",
	            data: jsonParamsStr,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.SetLayerInfoService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.SetLayerInfoService(url, options);
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.SetLayersInfoService
	 * 设置图层信息服务类。可以实现创建新的临时图层和对现有临时图层的修改，当 isTempLayers 为 false
	 * 的时候执行创建临时图层。当 isTempLayers 为 ture 并且临时图层资源 resourceID 被设置有效时执行
	 * 对临时图层的编辑。
	 * 该类负责将图层设置参数传递到服务端，并获取服务端返回的结果信息。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	SuperMap.REST.SetLayersInfoService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * APIProperty: resourceID
	     * {String} 图层资源ID，临时图层的资源ID标记。
	     */
	    resourceID: null,

	    /**
	     * APIProperty: isTempLayers
	     * {Boolean>} 当前url对应的图层是否是临时图层。
	     */
	    isTempLayers: false,

	    /**
	     * Constructor: SuperMap.REST.SetLayersInfoService
	     * 设置图层信息服务类构造函数。可以实现创建新的临时图层和对现有临时图层的修改。
	     *
	     * Parameters:
	     * url - {String} 与客户端交互的地图服务地址。请求地图服务,URL 应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * resourceID - {String} 图层资源ID，临时图层的资源ID标记。
	     * isTempLayers - {Boolean} 当前url对应的图层是否是临时图层。
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	        this.resourceID = options.resourceID;
	        this.isTempLayers = options.isTempLayers;
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        SuperMap.Util.reset(this);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的更新参数传递到服务端。
	     * Parameters:
	     * params - {Object} 修改后的图层资源信息。该参数可以使用获取图层信息服务<SuperMap.REST.GetLayerInfoService>.result.subLayers.layers
	     * 返回图层信息，然后对其属性进行修改来获取。
	     */
	    processAsync: function (params) {
	        var jsonParams,
	            subLayers = [],
	            me = this,
	            method = "",
	            end;
	        if (!params) {
	            return;
	        }
	        end = me.url.substr(me.url.length - 1, 1);
	        me.url += (end === "/") ? '' : '/';
	        //创建临时图层和设置修改临时图层信息对应不同的资源URL
	        if (me.isTempLayers) {
	            me.url += "tempLayersSet/" + me.resourceID;
	            method = "PUT";
	        } else {
	            me.url += "tempLayersSet";
	            method = "POST";
	        }
	        me.url += me.isInTheSameDomain ? ".json?" : ".jsonp?";
	        var layers = params.subLayers.layers,
	            len = layers.length;
	        for (var i in layers) {
	            if (layers[i].ugcLayerType === "GRID") {
	                var colorDictionary = {};
	                var colorDics = layers[i].colorDictionarys;
	                for (var j in colorDics) {
	                    var key = colorDics[j].elevation;
	                    colorDictionary[key] = colorDics[j].color;
	                }
	            }
	            layers[i].colorDictionary = colorDictionary;
	            delete layers[i].colorDictionarys;
	        }

	        for (var i = 0; i < len; i++) {
	            if (layers[i].toJsonObject) {
	                //将图层信息转换成服务端能识别的简单json对象
	                subLayers.push(layers[i].toJsonObject());
	            } else {
	                subLayers.push(layers[i]);
	            }
	        }
	        jsonParams = SuperMap.Util.extend(jsonParams, params);
	        jsonParams.subLayers = {"layers": subLayers};
	        jsonParams.object = null;
	        var jsonParamsStr = SuperMap.Util.toJSON([jsonParams]);
	        me.request({
	            method: method,
	            data: jsonParamsStr,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.SetLayersInfoService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.SetLayersInfoService(url, options);
	};


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.SetLayerStatusService
	 * 子图层显示控制服务类。
	 * 该类负责将子图层显示控制参数传递到服务端，并获取服务端返回的图层显示状态。
	 * 用户获取服务端返回的各子图层显示状态有两种方式：
	 * 一种是通过监听 SetLayerEvent.PROCESS_COMPLETE 事件；
	 * 一种是使用 AsyncResponder 类实现异步处理。
	 */
	__webpack_require__(13);
	__webpack_require__(43);
	SuperMap.REST.SetLayerStatusService = SuperMap.Class(SuperMap.ServiceBase, {

	    lastparams: null,

	    mapUrl: null,

	    /**
	     * Constructor: SuperMap.REST.SetLayerStatusService
	     * 子图层显示控制服务类构造函数。
	     *
	     * Parameters:
	     * url - {String} 地图服务访问地址。请求地图服务,URL 应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        var me = this;
	        SuperMap.ServiceBase.prototype.initialize.apply(me, arguments);
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	        me.mapUrl = url;
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        SuperMap.Util.reset(this);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的更新参数传递到服务端。
	     * Parameters:
	     * params - {Object} 修改后的图层资源信息。该参数可以使用获取图层信息服务 <SetLayerStatusParameters>
	     * 返回图层信息，然后对其属性进行修改来获取。
	     */
	    processAsync: function (params) {
	        var subLayers = [],
	            me = this,
	            method = "POST";
	        if (!params) {
	            return;
	        }

	        me.url = me.mapUrl;
	        var end = me.url.substr(me.url.length - 1, 1);
	        me.url += (end === "/") ? '' : '/';

	        if (params.resourceID == null) {
	            me.url += "tempLayersSet";
	            me.url += me.isInTheSameDomain ? ".json?" : ".jsonp?";

	            me.lastparams = params;

	            me.request({
	                method: method,
	                scope: me,
	                success: me.createTempLayerComplete,
	                failure: me.serviceProcessFailed
	            });
	        } else {
	            me.url += "tempLayersSet/" + params.resourceID;
	            me.url += me.isInTheSameDomain ? ".json?" : ".jsonp?";

	            me.url += "elementRemain=true&reference=" + params.resourceID + "&holdTime=" + params.holdTime.toString();

	            var jsonParameters = '[{';

	            jsonParameters += '"type":"UGC",';
	            if (params.layerStatusList != null && params.layerStatusList.length > 0) {
	                jsonParameters += '"subLayers":' + params.toJSON();
	            }
	            jsonParameters += ',"visible":' + true + ',';
	            jsonParameters += '"name":"' + this.getMapName(this.mapUrl) + '"';

	            jsonParameters += '}]';

	            me.request({
	                method: "PUT",
	                data: jsonParameters,
	                scope: me,
	                success: me.serviceProcessCompleted,
	                failure: me.serviceProcessFailed
	            });
	        }
	    },

	    /**
	     * Method: createTempLayerComplete
	     * 设置完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象，记录设置操作是否成功。
	     */
	    createTempLayerComplete: function (result) {
	        var me = this;
	        result = SuperMap.Util.transformResult(result);
	        if (result.succeed) {
	            me.lastparams.resourceID = result.newResourceID;
	        }

	        me.processAsync(me.lastparams);
	    },

	    getMapName: function (url) {
	        var mapUrl = url;
	        if (mapUrl.charAt(mapUrl.length - 1) === "/") {
	            mapUrl = mapUrl.substr(0, mapUrl.length - 1);
	        }
	        var index = mapUrl.lastIndexOf("/");
	        var mapName = mapUrl.substring(index + 1, mapUrl.length);
	        return mapName;
	    },

	    /**
	     * Method: setLayerCompleted
	     * 设置完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象，记录设置操作是否成功。
	     */
	    serviceProcessCompleted: function (result) {
	        var me = this;
	        result = SuperMap.Util.transformResult(result);
	        if (result != null && me.lastparams != null) {
	            result.newResourceID = me.lastparams.resourceID;
	        }
	        me.events.triggerEvent("processCompleted", {result: result});
	    },

	    CLASS_NAME: "SuperMap.REST.SetLayerStatusService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.SetLayerStatusService(url, options);
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SetLayerStatusParameters
	 * 子图层显示控制参数类。
	 * 该类存储了各子图层是否可见的状态。子图层显示控制功能只针对 TiledDynamicIServerLayer 和 DynamicIServerLayer 图层。
	 * 注意在 SuperMap iClient 系列产品中所说的图层与 SuperMap Deskpro 的地图对应，子图层与 SuperMap Deskpro 的图层对应。
	 */
	__webpack_require__(4);
	__webpack_require__(44);
	SetLayerStatusParameters = SuperMap.Class({

	    /**
	     * APIProperty: layerStatusList
	     * {Array<LayerStatus>} 获取或设置图层可见状态（LayerStatus）集合，必设属性。集合中的每个 LayerStatus 对象代表一个子图层的可视状态。
	     */
	    layerStatusList: null,

	    /**
	     * APIProperty: holdTime
	     * {Number} 获取或设置资源在服务端保存的时间。 默认为 15 分钟。
	     */
	    holdTime: 15,

	    /**
	     * APIProperty: resourceID
	     * {String} 获取或设置资源服务 ID 。非必设参数，如果设置该参数则会在指定的 TempLayer 进行图层的显示控制；如果不设置该参数，则会首先创建一个 TempLayer ，然后在新创建的 TempLayer 进行图层的显示控制。
	     */
	    resourceID: null,

	    /**
	     * Constructor: SetLayerStatusParameters
	     *
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * layerStatusList - {Array<LayerStatus>} 获取或设置图层可见状态（LayerStatus）集合，必设属性。集合中的每个 LayerStatus 对象代表一个子图层的可视状态。
	     * holdTime - {String} 获取或设置资源在服务端保存的时间。
	     * resourceID - {String} 获取或设置资源服务 ID。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.layerStatusList = [];
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.layerStatusList = null;
	        me.holdTime = null;
	        me.resourceID = null;
	    },

	    /**
	     * Method: toJSON
	     * 生成json。
	     */
	    toJSON: function () {
	        var json = '{';
	        json += '"layers":[';
	        var v = [];
	        for (var i = 0, len = this.layerStatusList.length; i < len; i++) {
	            v.push(this.layerStatusList[i].toJSON());
	        }

	        json += v;
	        json += ']';
	        json += '}';

	        return json;
	    },

	    CLASS_NAME: "SetLayerStatusParameters"
	});
	module.exports = function (options) {
	    return new SetLayerStatusParameters(options);
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: LayerStatus
	 * 子图层显示参数类.。
	 * 该类存储了各个子图层的名字和是否可见的状态。
	 *
	 */
	__webpack_require__(4);
	LayerStatus = SuperMap.Class({

	    /**
	     * APIProperty: layerName
	     * {String} 获取或设置图层名称。必设属性。。
	     */
	    layerName: null,

	    /**
	     * APIProperty: isVisible
	     * {Boolean} 获取或设置图层是否可见，true 表示可见。必设属性。
	     */
	    isVisible: null,

	    /**
	     * APIProperty: displayFilter
	     * {String} 图层显示 SQL 过滤条件，如 layerStatus.displayFilter = "smid < 10"，表示仅显示 smid 值小于 10 的对象。
	     */
	    displayFilter: null,

	    /**
	     * APIProperty: fieldValuesDisplayFilter
	     * {Object} 图层要素的显示和隐藏的过滤属性，其带有三个属性，分别是:values、fieldName、fieldValuesDisplayMode,他们的作用如下：
	     * values：{Array<Number>} - 就是要过滤的值；
	     * fieldName：{String} - 要过滤的字段名称 只支持数字类型的字段；
	     * fieldValuesDisplayMode：{String} 目前有两个DISPLAY/DISABLE。当为DISPLAY时，表示只显示以上设置的相应属性值的要素，否则表示不显示以上设置的相应属性值的要素
	     * */
	    fieldValuesDisplayFilter:null,

	    /**
	     * Constructor: LayerStatus
	     *
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * layerName - {String} 获取或设置图层名称。
	     * isVisible - {Boolean} 获取或设置图层是否可见，true 表示可见。
	     * displayFilter - {String} 图层显示 SQL 过滤条件。
	     */
	    initialize: function(options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function() {
	        var me = this;
	        me.layerName = null;
	        me.isVisible = null;
	        me.displayFilter = null;
	    },

	    /**
	     * Method: toJSON
	     * 生成对应的json。
	     */
	    toJSON:function(){
	        var json = '{';
	        json += '"type":"UGC",';
	        var v = [];
	        if (this.layerName) {
	            v.push('"name":"' + this.layerName + '"');
	            v.push('"visible":' + this.isVisible);
	        }

	        if (this.displayFilter) {
	            v.push('"displayFilter":"' + this.displayFilter + '"');
	        }

	        if(this.minScale||this.minScale==0){
	            v.push('"minScale":' + this.minScale );
	        }

	        if(this.maxScale||this.maxScale==0){
	            v.push('"maxScale":' + this.maxScale);
	        }

	        if(this.fieldValuesDisplayFilter){
	            v.push('"fieldValuesDisplayFilter":'+SuperMap.Util.toJSON(this.fieldValuesDisplayFilter));
	        }

	        json += v;
	        json += '}';

	        return json;
	    },

	    CLASS_NAME: "LayerStatus"
	});
	module.exports = function (options) {
	    return new LayerStatus(options);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: MeasureService
	 * 量算服务服务类
	 * 用法：
	 *      L.superMap.measureService(url).measureDistance({
	 *          geometry:xxx
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(11);
	__webpack_require__(46);

	MeasureService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);

	    },

	    /**
	     * @param params:
	     *      <MeasureParameters>
	     */
	    measureDistance: function (params) {
	        this.measure(params, 'DISTANCE');
	        return this;
	    },

	    /**
	     * @param params:
	     *       <MeasureParameters>
	     */
	    measureArea: function (params) {
	        this.measure(params, 'AREA');
	        return this;
	    },

	    /**
	     *
	     * @param params:<MeasureParameters>
	     * @param type:'DISTANCE'或'AREA'
	     */
	    measure: function (params, type) {
	        if (!params) {
	            return;
	        }
	        var me = this;
	        if (params.geometry) {
	            params.geometry = L.Util.toSuperMapGeometry(params.geometry);
	        }
	        var measureService = new SuperMap.REST.MeasureService(me.options.url, {
	            measureMode: type,
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        measureService.processAsync(params);
	        return me;
	    }
	});

	L.supermap.measureService = function (url, options) {
	    return new MeasureService(url, options);
	};

	module.exports = L.supermap.measureService;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.MeasureService
	 * 量算服务类。
	 * 该类负责将量算参数传递到服务端，并获取服务端返回的量算结果。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(47);
	SuperMap.REST.MeasureService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * APIProperty: measureMode
	     * {<MeasureMode>} 量算模式，包括距离量算模式和面积量算模式。默认值为：MeasureMode.DISTANCE 。
	     */
	    measureMode: MeasureMode.DISTANCE,

	    /**
	     * Constructor: SuperMap.REST.MeasureService
	     * 量算服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myMeasuerService = new SuperMap.REST.MeasureService(url, {
	     *      measureMode: MeasureMode.DISTANCE,
	     *      eventListeners:{
	     *          "processCompleted": measureCompleted
	     *      }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务访问的地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     * measureMode - {<MeasureMode>} 量算模式，包括距离量算模式和面积量算模式。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.measureMode = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的量算参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<MeasureParameters>} 量算参数。
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this,
	            geometry = params.geometry,
	            pointsCount = 0,
	            point2ds = null,
	            urlParameters = null,
	            end = null;
	        if (!geometry) {
	            return;
	        }
	        end = me.url.substr(me.url.length - 1, 1);
	        if (me.measureMode === MeasureMode.AREA) {
	            if (me.isInTheSameDomain) {
	                me.url += ((end === "/") ? "area.json?" : "/area.json?");
	            }
	            else {
	                me.url += ((end === "/") ? "area.jsonp?" : "/area.jsonp?");
	            }
	        } else {
	            if (me.isInTheSameDomain) {
	                me.url += ((end === "/") ? "distance.json?" : "/distance.json?");
	            }
	            else {
	                me.url += ((end === "/") ? "distance.jsonp?" : "/distance.jsonp?");
	            }
	        }
	        var serverGeometry = SuperMap.REST.ServerGeometry.fromGeometry(geometry);
	        if (!serverGeometry) {
	            return;
	        }
	        pointsCount = serverGeometry.parts[0];
	        point2ds = serverGeometry.points.splice(0, pointsCount);

	        var prjCoordSysTemp, prjCodeTemp, paramsTemp;
	        if (params.prjCoordSys) {
	            if (typeof (params.prjCoordSys) === "object") {
	                prjCodeTemp = params.prjCoordSys.projCode;
	                prjCoordSysTemp = '{"epsgCode"' + prjCodeTemp.substring(prjCodeTemp.indexOf(":"), prjCodeTemp.length) + "}";
	            }
	            else if (typeof (params.prjCoordSys) === "string") {
	                prjCoordSysTemp = '{"epsgCode"' + params.prjCoordSys.substring(params.prjCoordSys.indexOf(":"), params.prjCoordSys.length) + "}";
	            }
	            paramsTemp = {"point2Ds": SuperMap.Util.toJSON(point2ds), "unit": params.unit, "prjCoordSys": prjCoordSysTemp};
	        }
	        else {
	            paramsTemp = {"point2Ds": SuperMap.Util.toJSON(point2ds), "unit": params.unit};
	        }

	        me.request({
	            method: "GET",
	            params: paramsTemp,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });

	    },

	    CLASS_NAME: "SuperMap.REST.MeasureService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.MeasureService(url, options);
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: MeasureParameters
	 * 量算参数类。
	 * 客户端要量算的地物间的距离或某个区域的面积是一个 {<Object>}  类型的几何对象（{<Line>} 或 {<Polygon>}），
	 * 它将与指定的量算单位一起作为量算参数传到服务端。最终服务端将以指定单位返回得到的距离或面积。 
	 */
	__webpack_require__(4);
	MeasureParameters = SuperMap.Class({

	    /** 
	     * APIProperty: geometry
	     * {<Object>} 要量算的几何对象（{<Line>} 或 {<Polygon>}），必设属性。
	     */
	    geometry: null,
	    
	    /** 
	     * APIProperty: unit
	     * {<Unit>}  量算单位。默认单位：米，即量算结果以米为单位。
	     */
	    unit: Unit.METER,

	    /**
	     * APIProperty: projection
	     * {String} 在 MeasureParameters 的 options 中被设置，用来指定该量算操作所使用的投影。该项默认值为空。
	    */
	    prjCoordSys: null,

	    /**
	     * APIProperty: distanceMode
	     * {String} 在MeasureParameters的options中设置，用来指定量算的方式为按球面长度'Geodesic'或者平面长度'Planar'来计算，默认为'Geodesic'
	     * 
	     * Exampels:
	     * (start code)
	     * var param = new MeasureParameters(getmetry,{distanceMode:'Planar'});
	     * (end)
	     */
	     distanceMode: null,

	    /**
	     * Constructor: MeasureParameters
	     * 量算参数类构造函数。
	     *
	     * Parameters:
	     * geometry - {<Object>} 要量算的几何对象。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * unit - {<Unit>} 量算单位。  
	     */
	    initialize: function(geometry, options) {
	        if (!geometry) {
	            return;
	        }
	        this.geometry = geometry;
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。 
	     */
	    destroy: function() {
	        var me = this;
	        me.geometry = null;
	        me.unit = null;
	        me.prjCoordSys = null;
	    },
	    
	    CLASS_NAME: "MeasureParameters"
	});
	module.exports = function (geometry, options) {
	    return new MeasureParameters(geometry, options);
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: FieldStatisticService
	 * 字段查询服务类
	 * 用法：
	 *      L.superMap.getFieldsService(url,{
	 *            projection:projection
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(49);
	__webpack_require__(50);

	FieldStatisticService = FieldsServiceBase.extend({
	    options: {
	        fieldName: null,
	        /**
	         * <Array<StatisticMode>>
	         */
	        statisticMode: null
	    },
	    initialize: function (url, options) {
	        FieldsServiceBase.prototype.initialize.call(this, url, options);
	        this.options.fieldName = options.fieldName;
	        this.currentStatisticResult = {fieldName: options.fieldName};
	        this.options.statisticMode = options.statisticMode;
	        if (!options.statisticMode || (typeof options.statisticMode !== "Array")) {
	            this.options.statisticMode = SuperMap.REST.StatisticMode;
	        }
	    },

	    getFieldStatisticInfo: function () {
	        var me = this;
	        var modes = me.options.statisticMode;
	        //针对每种统计方式分别进行请求
	        for (var mode in modes) {
	            this.currentStatisticResult[modes[mode]] = null;
	            this._fieldStatisticRequest(modes[mode]);
	        }
	        return me;
	    },

	    _fieldStatisticRequest: function (statisticMode) {
	        var me = this, statisticService;
	        statisticService = new SuperMap.REST.FieldStatisticService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            datasource: me.options.dataSourceName,
	            dataset: me.options.dataSetName,
	            field: me.options.fieldName,
	            statisticMode: statisticMode
	        });
	        statisticService.processAsync();
	    },

	    processCompleted: function (fieldStatisticResult) {
	        var getAll = true,
	            result = fieldStatisticResult.result;
	        if (this.currentStatisticResult) {
	            if (null == this.currentStatisticResult[result.mode]) {
	                this.currentStatisticResult[result.mode] = result.result;
	            }
	        }
	        for (var mode in this.currentStatisticResult) {
	            if (null == this.currentStatisticResult[mode]) {
	                getAll = false;
	                break;
	            }
	        }
	        if (getAll) {
	            this.fire('complete', {result: this.currentStatisticResult});
	        }
	    }
	});

	L.supermap.fieldStatisticService = function (url, options) {
	    return new FieldStatisticService(url, options);
	};

	module.exports = L.supermap.fieldStatisticService;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: GetFieldsService
	 * 字段查询服务基类
	 * 用法：
	 *      L.superMap.getFieldsService(url,{
	 *            projection:projection
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(11);

	FieldsServiceBase = ServiceBase.extend({
	    options: {
	        url: null,
	        dataSourceName: null,
	        dataSetName: null
	    },
	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	        this.options.dataSourceName = options.dataSourceName;
	        this.options.dataSetName = options.dataSetName;
	        L.setOptions(this, url, options);
	    }
	});

	module.exports = function (url, options) {
	    return new FieldsServiceBase(url, options);
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.FieldStatisticService
	 * 字段查询统计服务类。用来完成对指定数据集指定字段的查询统计分析，即求平均值，最大值等。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);

	SuperMap.REST.FieldStatisticService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * APIProperty: datasource
	     * {String} 数据集所在的数据源名称。
	     */
	    datasource: null,

	    /**
	     * APIProperty: dataset
	     * {String} 数据集名称。
	     */
	    dataset: null,

	    /**
	     * APIProperty: field
	     * {String} 查询统计的目标字段名称。
	     */
	    field: null,

	    /**
	     * APIProperty: statisticMode
	     * {<StatisticMode>} 字段查询统计的方法类型。
	     */
	    statisticMode: null,

	    /**
	     * Constructor: SuperMap.REST.FieldStatisticService
	     * 字段查询统计服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.FieldStatisticService(url, {eventListeners: {
	     *     "processCompleted": fieldStatisticCompleted, 
	     *     "processFailed": fieldStatisticError
	     *     }，
	     *     datasource: "World",
	     *     dataset: "Countries",
	     *     field: "SmID",
	     *     statisticMode: StatisticMode.AVERAGE
	     * };
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/data-world/rest/data 即可。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     * datasource - {String} 数据集所在的数据源名称。
	     * dataset - {String} 数据集名称。
	     * field - {String} 查询统计的目标字段名称。
	     * statisticMode - {<StatisticMode>} 字段查询统计的方法类型。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.datasource = null;
	        me.dataset = null;
	        me.field = null;
	        me.statisticMode = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 执行服务，进行指定字段的查询统计。
	     */
	    processAsync: function () {
	        var me = this,
	            end = me.url.substr(me.url.length - 1, 1),
	            fieldStatisticURL = "datasources/" + me.datasource + "/datasets/" + me.dataset + "/fields/" + me.field + "/" + me.statisticMode;
	        if (me.isInTheSameDomain) {
	            me.url += (end == "/") ? fieldStatisticURL + ".json?" : "/" + fieldStatisticURL + ".json?";
	        } else {
	            me.url += (end == "/") ? fieldStatisticURL + ".jsonp?" : "/" + fieldStatisticURL + ".jsonp?";
	        }

	        me.request({
	            method: "GET",
	            data: null,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.FieldStatisticService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FieldStatisticService(url, options);
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: GetFeaturesService
	 * 数据集查询类。
	 * 提供：ID查询，范围查询，SQL查询，几何查询，bounds查询，缓冲区查询
	 * 用法：
	 *      L.superMap.getFeaturesService(url).getFeaturesByIDs({
	 *           dataSetNames:name,
	 *           IDs:IDs
	 *      }).on("complete",function(result){
	 *          //doSomething
	 *      }).on("failed",function(result){
	 *          //doSomething
	 *      });
	 */
	__webpack_require__(4);
	__webpack_require__(52);
	__webpack_require__(57);
	__webpack_require__(59);
	__webpack_require__(61);
	__webpack_require__(63);
	__webpack_require__(11);

	GetFeaturesService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    /**
	     * 数据集ID查询服务
	     * @param params:
	     *    <GetFeaturesByIDsParameters>
	     * @param resultFormat
	     */
	    getFeaturesByIDs: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var getFeaturesByIDsService = new SuperMap.REST.GetFeaturesByIDsService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        getFeaturesByIDsService.processAsync(param);
	        return me;

	    },
	    /**
	     * 数据集Bounds查询服务
	     * @param params:
	     *    <GetFeaturesByBoundsParameters>
	     * @param resultFormat
	     */
	    getFeaturesByBounds: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var getFeaturesByBoundsService = new SuperMap.REST.GetFeaturesByBoundsService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        getFeaturesByBoundsService.processAsync(param);
	        return me;
	    },
	    /**
	     * 数据集Buffer查询服务
	     * @param params:
	     *    <GetFeaturesByBufferParameters>
	     * @param resultFormat
	     */
	    getFeaturesByBuffer: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var getFeatureService = new SuperMap.REST.GetFeaturesByBufferService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        getFeatureService.processAsync(param);
	        return me;
	    },
	    /**
	     * 数据集SQL查询服务
	     * @param params:
	     *     <GetFeaturesBySQLParameters>
	     * @param resultFormat
	     */
	    getFeaturesBySQL: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var getFeatureBySQLService = new SuperMap.REST.GetFeaturesBySQLService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });

	        getFeatureBySQLService.processAsync(param);
	        return me;
	    },
	    /**
	     * 数据集几何查询服务类
	     * @param params:
	     *   <GetFeaturesByGeometryParameters>
	     * @param resultFormat
	     */
	    getFeaturesByGeometry: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var getFeaturesByGeometryService = new SuperMap.REST.GetFeaturesByGeometryService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        getFeaturesByGeometryService.processAsync(param);
	        return me;
	    },

	    _processParams: function (params) {
	        if (!params) {
	            return {};
	        }
	        params.returnContent = (params.returnContent == null) ? true : params.returnContent;
	        params.fromIndex = params.fromIndex ? params.fromIndex : 0;
	        params.toIndex = params.fromIndex ? params.fromIndex : -1;
	        if (params.bounds && params.bounds instanceof L.LatLngBounds) {
	            params.bounds = new SuperMap.Bounds(
	                params.bounds.getSouthWest().lng,
	                params.bounds.getSouthWest().lat,
	                params.bounds.getNorthEast().lng,
	                params.bounds.getNorthEast().lat
	            );
	        }
	        if (params.geometry) {
	            params.geometry = L.Util.toSuperMapGeometry(params.geometry);
	        }
	        return params;
	    },
	    _processFormat: function (resultFormat) {
	        return (resultFormat) ? resultFormat : Format.GEOJSON;
	    }
	});

	L.supermap.getFeaturesService = function (url, options) {
	    return new GetFeaturesService(url, options);
	};

	module.exports = L.supermap.getFeaturesService;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.GetFeaturesByIDsService
	 * 数据集ID查询服务类。
	 * 在数据集集合中查找指定 ID 号对应的空间地物要素。
	 *  
	 * Inherits from:
	 *  - <SuperMap.REST.GetFeaturesServiceBase>
	 */
	__webpack_require__(53);
	__webpack_require__(54);
	SuperMap.REST.GetFeaturesByIDsService = SuperMap.Class(SuperMap.REST.GetFeaturesServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.GetFeaturesByIDsService
	     * 数据集ID查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myGetFeaturesByIDsService = new SuperMap.REST.GetFeaturesByIDsService(url, {
	     *     eventListeners: {
	     *         "processCompleted": getFeatureCompleted, 
	     *         "processFailed": getFeatureError
	     *            }
	     *     });
	     * function getFeatureCompleted(object){//todo};
	     * function getFeatureError(object){//todo}
	     * (end)     
	     *
	     * Parameters:
	     * url - {String} 数据查询结果资源地址。请求数据服务中数据集查询服务，
	     * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；
	     * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function(url, options) {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.initialize.apply(this, arguments);
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。  
	     */
	    destroy: function() {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.destroy.apply(this, arguments);
	    },
	    
	    /**
	     * Method: getJsonParameters
	     * 将查询参数转化为 JSON 字符串。
	     * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry等）。
	     *
	     * Parameters:
	     * params - {<GetFeaturesByIDsParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的 JSON 字符串。
	     */
	    getJsonParameters: function(params) {
	        return  GetFeaturesByIDsParameters.toJsonParameters(params);
	    },
	    
	    CLASS_NAME: "SuperMap.REST.GetFeaturesByIDsService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GetFeaturesByIDsService(url, options);
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.GetFeaturesServiceBase
	 * 数据服务中数据集查询服务基类。
	 * 获取结果数据类型为Object。包含 result属性，result的数据格式根据format参数决定为GeoJSON或者iServerJSON
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */

	// TODO 待iServer featureResult GeoJSON表述bug修复当修改此类中TODO注释说明的地方
	__webpack_require__(3);
	__webpack_require__(13);

	SuperMap.REST.GetFeaturesServiceBase = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Property: returnContent
	     * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的URI。
	     *           如果为 true，则直接返回新创建资源，即查询结果的表述。
	     *           如果为 false，则返回的是查询结果资源的 URI。默认为 false。
	     */
	    returnContent: true,

	    /**
	     * Property: fromIndex
	     * {Integer} 查询结果的最小索引号。
	     *         默认值是0，如果该值大于查询结果的最大索引号，则查询结果为空。
	     */
	    fromIndex: 0,

	    /**
	     * Property: toIndex
	     * {Integer} 查询结果的最大索引号。
	     *         如果该值大于查询结果的最大索引号，则以查询结果的最大索引号为终止索引号。
	     */
	    toIndex: 19,

	    /**
	     * APIProperty: maxFeatures
	     * {Integer} 进行SQL查询时，用于设置服务端返回查询结果条目数量，默认为1000。
	     */
	    maxFeatures: null,

	    /**
	     *  Property: format
	     *  {String} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
	     *  参数格式为"ISERVER","GEOJSON",GEOJSON
	     */
	    format: Format.GEOJSON,

	    /**
	     * Constructor: SuperMap.REST.GetFeaturesServiceBase
	     * 数据集查询服务基类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.GetFeaturesServiceBase(url, {
	     *     eventListeners: {
	     *         "processCompleted": getFeatureCompleted, 
	     *         "processFailed": getFeatureError
	     *     }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 数据查询结果资源地址。请求数据服务中数据集查询服务，
	     * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；
	     * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        options = options || {};
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	        var me = this, end;
	        if (options && options.format) {
	            me.format = options.format.toUpperCase();
	        }

	        end = me.url.substr(me.url.length - 1, 1);
	        // TODO 待iServer featureResul资源GeoJSON表述bug修复当使用以下注释掉的逻辑
	        // if (me.format==="geojson" && me.isInTheSameDomain) {
	        //     me.url += (end == "/") ? "featureResults.geojson?" : "/featureResults.geojson?";
	        // } else {
	        //     me.url += (end == "/") ? "featureResults.jsonp?" : "/featureResults.jsonp?";
	        // }
	        if (me.isInTheSameDomain) {
	            me.url += (end == "/") ? "featureResults.json?" : "/featureResults.json?";
	        } else {
	            me.url += (end == "/") ? "featureResults.jsonp?" : "/featureResults.jsonp?";
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.returnContent = null;
	        me.fromIndex = null;
	        me.toIndex = null;
	        me.maxFeatures = null;
	        me.format = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<GetFeaturesParametersBase>} 查询参数。
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this,
	            jsonParameters = null,
	            firstPara = true;

	        me.returnContent = params.returnContent;
	        me.fromIndex = params.fromIndex;
	        me.toIndex = params.toIndex;
	        me.maxFeatures = params.maxFeatures;
	        if (me.returnContent) {
	            me.url += "returnContent=" + me.returnContent;
	            firstPara = false;
	        }
	        if (me.fromIndex != null && me.toIndex != null && !isNaN(me.fromIndex) && !isNaN(me.toIndex) && me.fromIndex >= 0 && me.toIndex >= 0 && !firstPara) {
	            me.url += "&fromIndex=" + me.fromIndex + "&toIndex=" + me.toIndex;
	        }

	        if (params.returnCountOnly) me.url += "&returnCountOnly=" + params.returnContent;
	        jsonParameters = me.getJsonParameters(params);
	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getFeatureComplete
	     * 查询完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    serviceProcessCompleted: function (result) {
	        var me = this, results;
	        results = result = SuperMap.Util.transformResult(result);
	        if (me.format === Format.GEOJSON && result.features) {
	            var geoJSONFormat = new SuperMap.Format.GeoJSON();
	            results = JSON.parse(geoJSONFormat.write(result.features));
	        }
	        me.events.triggerEvent("processCompleted", {result: results});
	    },

	    CLASS_NAME: "SuperMap.REST.GetFeaturesServiceBase"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GetFeaturesServiceBase(url, options);
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: GetFeaturesByIDsParameters
	 * ID 查询参数类。
	 *
	 * Inherits from:
	 *  - <GetFeaturesParametersBase>
	 */
	__webpack_require__(55);
	GetFeaturesByIDsParameters = SuperMap.Class(GetFeaturesParametersBase, {

	    /**
	     * Property: getFeatureMode
	     * {String} 数据集查询模式。
	     */
	    getFeatureMode: "ID",

	    /**
	     * APIProperty: IDs
	     * {Array(Integer)} 所要查询指定的元素ID信息。
	     */
	    IDs: null,

	    /**
	     * APIProperty: fields
	     * {Array(String)} 设置查询结果返回字段。
	     *                 当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。
	     *                 不设置即返回全部字段。
	     */
	    fields: null,

	    /**
	     * Constructor: GetFeaturesBySQLParameters
	     * SQL 查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * IDs - {Array(Integer)} 所要查询指定的元素ID信息。
	     * fields - {Array(String)} 设置查询结果返回字段。默认返回所有字段。
	     * dataSetNames - {Array(String)} 数据集集合中的数据集名称列表。
	     * returnContent - {Boolean} 是否直接返回查询结果。
	     * fromIndex - {Integer} 查询结果的最小索引号。
	     * toIndex - {Integer} 查询结果的最大索引号。
	     */
	    initialize: function (options) {
	        GetFeaturesParametersBase.prototype.initialize.apply(this, arguments);
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        GetFeaturesParametersBase.prototype.destroy.apply(me, arguments);
	        me.IDs = null;
	        me.getFeatureMode = null;
	        if (me.fields) {
	            while (me.fields.length > 0) {
	                me.fields.pop();
	            }
	            me.fields = null;
	        }
	    },
	    CLASS_NAME: "GetFeaturesByIDsParameters"
	});

	/**
	 * Function: GetFeaturesByIDsParameters.toJsonParameters
	 * 将<GetFeaturesByIDsParameters>对象参数转换为json字符串。
	 *
	 * Parameters:
	 * params - {<GetFeaturesByIDsParameters>} IDs查询参数。
	 *
	 * Returns:
	 * {String} 转化后的 json字符串。
	 */
	GetFeaturesByIDsParameters.toJsonParameters = function (params) {
	    var parasByIDs, filterParameter;

	    parasByIDs = {
	        datasetNames: params.datasetNames,
	        getFeatureMode: "ID",
	        ids: params.IDs
	    };
	    if (params.fields) {
	        filterParameter = new FilterParameter();
	        filterParameter.name = params.datasetNames;
	        filterParameter.fields = params.fields;
	        parasByIDs.queryParameter = filterParameter;
	    }
	    return SuperMap.Util.toJSON(parasByIDs);
	};
	module.exports = function (options) {
	    return new GetFeaturesByIDsParameters(options);
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: GetFeaturesParametersBase
	 * 数据服务中数据集查询参数基类。
	 */
	__webpack_require__(4);

	GetFeaturesParametersBase = SuperMap.Class({
	    /**
	     * APIProperty: datasetNames
	     * {Array(String)} 数据集集合中的数据集名称列表。
	     */
	    datasetNames: null,

	    /**
	     * APIProperty: returnContent
	     * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的URI。
	     *           如果为 true，则直接返回新创建资源，即查询结果的表述。
	     *           如果为 false，则返回的是查询结果资源的 URI。默认为 true。
	     */
	    returnContent: true,

	    /**
	     * APIProperty: fromIndex
	     * {Integer} 查询结果的最小索引号。
	     *           默认值是0，如果该值大于查询结果的最大索引号，则查询结果为空。
	     */
	    fromIndex: 0,

	    /**
	     * APIProperty: toIndex
	     * {Integer} 查询结果的最大索引号。
	     *           默认值是19，如果该值大于查询结果的最大索引号，则以查询结果的最大索引号为终止索引号。
	     */
	    toIndex: 19,

	    /**
	     * APIProperty: returnCountOnly
	     * {Boolean} 只返回查询结果的总数，默认为false。
	     */
	    returnCountOnly: false,

	    /**
	     * APIProperty: maxFeatures
	     * {Integer} 进行SQL查询时，用于设置服务端返回查询结果条目数量，默认为1000。
	     */
	    maxFeatures: null,

	    /**
	     * Constructor: GetFeaturesParametersBase
	     * SQL 查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * datasetNames - {Array(String)} 数据集集合中的数据集名称列表。
	     * returnContent - {<FilterParameter>} 是否直接返回查询结果。
	     * fromIndex - {Integer} 查询结果的最小索引号。
	     * toIndex - {Integer} 查询结果的最大索引号。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.datasetNames = null;
	        me.returnContent = null;
	        me.fromIndex = null;
	        me.toIndex = null;
	        me.maxFeatures = null;
	    },

	    CLASS_NAME: "GetFeaturesParametersBase"
	});
	module.export = function (options) {
	    return new GetFeaturesParametersBase(options);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56)(module)))

/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.GetFeaturesBySQLService
	 * 数据服务中数据集 SQL 查询服务类。
	 * 在一个或多个指定的图层上查询符合 SQL 条件的空间地物信息。
	 * 
	 * Inherits from:
	 *  - <SuperMap.REST.GetFeaturesServiceBase>
	 */
	__webpack_require__(53);
	__webpack_require__(58);
	SuperMap.REST.GetFeaturesBySQLService = SuperMap.Class(SuperMap.REST.GetFeaturesServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.GetFeaturesBySQLService
	     * SQL 查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)     
	     * var myGetFeaturesBySQLService = new SuperMap.REST.GetFeaturesBySQLService(url, {
	     *     eventListeners: {
	     *         "processCompleted": GetFeaturesCompleted, 
	     *         "processFailed": GetFeaturesError
	     *         }
	     * });
	     * function getFeaturesCompleted(object){//todo};
	     * function getFeaturesError(object){//todo};
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 数据查询结果资源地址。请求数据服务中数据集查询服务，
	     * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；
	     * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function(url, options) {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.initialize.apply(this, arguments);
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。  
	     */
	    destroy: function() {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.destroy.apply(this, arguments);
	    },
	    
	    /**
	     * Method: getJsonParameters
	     * 将查询参数转化为 JSON 字符串。
	     * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry等）。
	     *
	     * Parameters:
	     * params - {<GetFeaturesBySQLParameters>} 
	     *
	     * Returns:
	     * {Object} 转化后的 JSON 字符串。
	     */
	    getJsonParameters: function(params) {
	        return  GetFeaturesBySQLParameters.toJsonParameters(params);
	    },
	    
	    CLASS_NAME: "SuperMap.REST.GetFeaturesBySQLService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GetFeaturesBySQLService(url, options);
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: GetFeaturesBySQLParameters
	 * 数据服务中数据集SQL查询参数类。 
	 * 
	 * Inherits from:
	 *  - <GetFeaturesParametersBase> 
	 */
	__webpack_require__(55);
	__webpack_require__(18);
	GetFeaturesBySQLParameters = SuperMap.Class(GetFeaturesParametersBase, {
	    /** 
	     * Property: getFeatureMode
	     * {String} 数据集查询模式。
	     */
	    getFeatureMode: "SQL",
	    /** 
	     * APIProperty: queryParameter
	     * {<FilterParameter>} 查询过滤条件参数类。
	     */
	    queryParameter: null,
	        
	    /**
	     * Constructor: GetFeaturesBySQLParameters
	     * SQL 查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * queryParameter - {<FilterParameter>} 查询过滤条件参数。
	     * datasetNames - {Array(String)} 数据集集合中的数据集名称列表。  
	     * returnContent - {Boolean} 是否直接返回查询结果。
	     * fromIndex - {Integer} 查询结果的最小索引号。
	     * toIndex - {Integer} 查询结果的最大索引号。
	     */
	    initialize: function(options) {
	        GetFeaturesParametersBase.prototype.initialize.apply(this,arguments);
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        GetFeaturesParametersBase.prototype.destroy.apply(this,arguments);
	        var me = this;
	        me.getFeatureMode = null;
	        if(me.queryParameter) {
	            me.queryParameter.destroy();
	            me.queryParameter = null;
	        }
	    },
	    
	    CLASS_NAME:"GetFeaturesBySQLParameters"
	 });
	 /**
	 * Function: GetFeaturesBySQLParameters.toJsonParameters
	 * 将<GetFeaturesBySQLParameters>对象参数转换为json字符串。 
	 *
	 * Parameters:
	 * params - {<GetFeaturesBySQLParameters>} SQL查询参数。 
	 *
	 * Returns:
	 * {String} 转化后的 json字符串。
	 */
	 GetFeaturesBySQLParameters.toJsonParameters = function(params) {
	    var paramsBySql = {
	        datasetNames: params.datasetNames,
	        getFeatureMode:"SQL",
	        queryParameter:params.queryParameter
	    };
	    return SuperMap.Util.toJSON(paramsBySql);
	};
	module.exports = function (options) {
	    return new GetFeaturesBySQLParameters(options);
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.GetFeaturesByBoundsService
	 * 数据集范围查询服务类
	 * 查询与指定范围对象符合一定空间关系的矢量要素。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.GetFeaturesServiceBase>
	 */
	__webpack_require__(53);
	__webpack_require__(60);

	SuperMap.REST.GetFeaturesByBoundsService = SuperMap.Class(SuperMap.REST.GetFeaturesServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.GetFeaturesByBoundsService
	     * 数据集范围查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myGetFeaturesByBoundsService = new SuperMap.REST.GetFeaturesByBoundsService(url, {
	     *     eventListeners: {
	     *           "processCompleted": getFeatureCompleted, 
	     *           "processFailed": getFeatureError
	     *           }
	     * });
	     * function getFeatureCompleted(object){//todo};
	     * function getFeatureError(object){//todo}
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 数据查询结果资源地址。请求数据服务中数据集查询服务，
	     * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；
	     * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * Method: getJsonParameters
	     * 将查询参数转化为 JSON 字符串。
	     * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry,Bounds等）。
	     *
	     * Parameters:
	     * params - {<GetFeaturesByBoundsParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的 JSON 字符串。
	     */
	    getJsonParameters: function (params) {
	        return GetFeaturesByBoundsParameters.toJsonParameters(params);
	    },

	    CLASS_NAME: "SuperMap.REST.GetFeaturesByBoundsService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GetFeaturesByBoundsService(url, options);
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: GetFeaturesByBoundsParameters
	 * 数据集范围查询参数类。
	 * 该类用于设置数据集范围查询的相关参数。
	 *
	 * Inherits from:
	 *  - <GetFeaturesParametersBase>
	 */
	__webpack_require__(55);

	GetFeaturesByBoundsParameters = SuperMap.Class(GetFeaturesParametersBase, {

	    /**
	     * Property: getFeatureMode
	     * {String} 数据集查询模式。
	     * 范围查询有"BOUNDS"，"BOUNDS_ATTRIBUTEFILTER"两种,当用户设置attributeFilter时会自动切换到BOUNDS_ATTRIBUTEFILTER访问服务。
	     */
	    getFeatureMode: null,

	    /**
	     * APIProperty: bounds
	     * {<SuperMap.Bounds>} 用于查询的范围对象。
	     */
	    bounds: null,

	    /**
	     * APIProperty: fields
	     * {Array(String)} 设置查询结果返回字段。
	     *                 当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。
	     *                 不设置即返回全部字段。
	     */
	    fields: null,

	    /**
	     * APIProperty: attributeFilter
	     * {String} 范围查询属性过滤条件。
	     */
	    attributeFilter: null,

	    /**
	     * APIProperty: spatialQueryMode
	     * {<SpatialQueryMode>} 空间查询模式常量，必设参数，默认为CONTAIN。
	     */
	    spatialQueryMode: SpatialQueryMode.CONTAIN,

	    /**
	     * Constructor: GetFeaturesByBoundsParameters
	     * 范围空间查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * bounds - {<SuperMap.Bounds>} 用于查询的范围对象。
	     * attributeFilter - {String} 范围查询属性过滤条件。
	     * fields - {Array(String)} 设置查询结果返回字段。默认返回所有字段。
	     * spatialQueryMode - {<SpatialQueryMode>} 空间查询模式常量,必设参数。
	     * queryParameter - {<FilterParameter>} 查询过滤条件参数。
	     * datasetNames - {Array(String)} 数据集集合中的数据集名称列表。
	     * returnContent - {Boolean} 是否直接返回查询结果。
	     * fromIndex - {Integer} 查询结果的最小索引号。
	     * toIndex - {Integer} 查询结果的最大索引号。
	     */
	    initialize: function (options) {
	        this.getFeatureMode = GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS;
	        GetFeaturesParametersBase.prototype.initialize.apply(this, arguments);
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        GetFeaturesParametersBase.prototype.destroy.apply(me, arguments);
	        if (me.bounds) {
	            me.bounds.destroy();
	            me.bounds = null;
	        }
	        if (me.fields) {
	            while (me.fields.length > 0) {
	                me.fields.pop();
	            }
	            me.fields = null;
	        }
	        me.attributeFilter = null;
	        me.spatialQueryMode = null;
	        me.getFeatureMode = null;
	    },
	    CLASS_NAME: "GetFeaturesByBoundsParameters"
	});

	/**
	 * Function: GetFeaturesByBoundsParameters.toJsonParameters
	 * 将<GetFeaturesByBoundsParameters>对象参数转换为json字符串。
	 *
	 * Parameters:
	 * params - {<GetFeaturesByBoundsParameters>} 范围查询参数。
	 *
	 * Returns:
	 * {String} 转化后的 json字符串。
	 */
	GetFeaturesByBoundsParameters.toJsonParameters = function (params) {
	    var filterParameter,
	        bounds,
	        parasByBounds;

	    bounds = {
	        "leftBottom": {"x": params.bounds.left, "y": params.bounds.bottom},
	        "rightTop": {"x": params.bounds.right, "y": params.bounds.top}
	    };
	    parasByBounds = {
	        datasetNames: params.datasetNames,
	        getFeatureMode: GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS,
	        bounds: bounds,
	        spatialQueryMode: params.spatialQueryMode
	    };
	    if (params.fields) {
	        filterParameter = new FilterParameter();
	        filterParameter.name = params.datasetNames;
	        filterParameter.fields = params.fields;
	        parasByBounds.queryParameter = filterParameter;
	    }
	    if (params.attributeFilter) {
	        parasByBounds.attributeFilter = params.attributeFilter;
	        parasByBounds.getFeatureMode = GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS_ATTRIBUTEFILTER;
	    }

	    return SuperMap.Util.toJSON(parasByBounds);
	};

	GetFeaturesByBoundsParameters.getFeatureMode = {
	    "BOUNDS": "BOUNDS",
	    "BOUNDS_ATTRIBUTEFILTER": "BOUNDS_ATTRIBUTEFILTER"
	};

	module.exports = function (options) {
	    return new GetFeaturesByBoundsParameters(options);
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class:   SuperMap.REST.GetFeaturesByBufferService
	 * 数据服务中数据集缓冲区查询服务类。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.GetFeaturesServiceBase>
	 */
	__webpack_require__(53);
	__webpack_require__(62);
	SuperMap.REST.GetFeaturesByBufferService = SuperMap.Class(SuperMap.REST.GetFeaturesServiceBase, {

	    /**
	     * Constructor:   SuperMap.REST.GetFeaturesByBufferService
	     * 数据服务缓冲区查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myGetFeaturesByBufferService = new   SuperMap.REST.GetFeaturesByBufferService(url, {
	     *     eventListeners: {
	     *           "processCompleted": GetFeaturesCompleted, 
	     *           "processFailed": GetFeaturesError
	     *           }
	     * });
	     * function GetFeaturesCompleted(object){//todo};
	     * function GetFeaturesError(object){//todo};
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 数据查询结果资源地址。请求数据服务中数据集查询服务，
	     * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；
	     * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * Method: getJsonParameters
	     * 将查询参数转化为 JSON 字符串。
	     * 在本类中重写此方法，可以实现不同种类的查询（IDs, SQL, Buffer, Geometry等）。
	     *
	     * Parameters:
	     * params - {<GetFeaturesByBufferParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的 JSON 字符串。
	     */
	    getJsonParameters: function (params) {
	        return GetFeaturesByBufferParameters.toJsonParameters(params);
	    },

	    CLASS_NAME: "  SuperMap.REST.GetFeaturesByBufferService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GetFeaturesByBufferService(url, options);
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: GetFeaturesByBufferParameters
	 * 数据服务中数据集缓冲区查询参数类。 
	 * 
	 * Inherits from:
	 *  - <GetFeaturesParametersBase> 
	 */
	__webpack_require__(55);
	GetFeaturesByBufferParameters = SuperMap.Class(GetFeaturesParametersBase, {  
	    /** 
	     * APIProperty: bufferDistance
	     * {Number} buffer距离,单位与所查询图层对应的数据集单位相同。
	     */
	    bufferDistance: null,
	    
	    /** 
	     * APIProperty: queryParameter
	     * {String} 属性查询条件。
	     */
	    attributeFilter:null,
	    
	    /** 
	     * APIProperty: geometry
	     * {<Object>} 空间查询条件。
	     */
	    geometry:null,
	    
	    /** 
	     * APIProperty: fields
	     * {Array(String)} 设置查询结果返回字段。
	     *                 当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。
	     *                 不设置即返回全部字段。
	     */
	    fields:null,
	    
	    /**
	     * Constructor: GetFeaturesByBufferParameters
	     * 缓冲区查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * bufferDistance - {Number} buffer 距离，单位与所查询图层对应的数据集单位相同。
	     * attributeFilter - {String} 属性查询条件
	     * fields - {Array(String)} 设置查询结果返回字段。默认返回所有字段。
	     * geometry - {<Object>} 空间查询条件
	     * dataSetNames - {Array(String)} 数据集集合中的数据集名称列表。  
	     * returnContent - {Boolean} 是否直接返回查询结果。
	     * fromIndex - {Integer} 查询结果的最小索引号。
	     * toIndex - {Integer} 查询结果的最大索引号。
	     */
	    initialize: function(options) {
	        GetFeaturesParametersBase.prototype.initialize.apply(this,arguments);
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy:function () {
	        GetFeaturesParametersBase.prototype.destroy.apply(this,arguments);
	        var me = this;
	        me.bufferDistance = null;
	        me.attributeFilter = null;
	        if(me.fields) {
	            while(me.fields.length > 0) {            
	                me.fields.pop();
	            }
	            me.fields = null;
	        }
	        if(me.geometry) {
	            me.geometry.destroy();
	            me.geometry = null;
	        }
	    },
	    CLASS_NAME:"GetFeaturesByBufferParameters"
	});
	 /**
	 * Function: GetFeaturesResult.toJsonParameters
	 * 将<GetFeaturesByBufferParameters>对象参数转换为json字符串。 
	 *
	 * Parameters:
	 * params - {<GetFeaturesByBufferParameters>} SQL查询参数。 
	 *
	 * Returns:
	 * {String} 转化后的 json字符串。
	 */
	GetFeaturesByBufferParameters.toJsonParameters = function(params) {
	    var filterParameter,
	        paramsBySql,
	        geometry;
	        
	    geometry = SuperMap.REST.ServerGeometry.fromGeometry(params.geometry);
	    paramsBySql = {
	        datasetNames: params.datasetNames,
	        getFeatureMode: "BUFFER",
	        bufferDistance: params.bufferDistance,
	        geometry: geometry
	    };
	    if(params.fields) {
	        filterParameter = new FilterParameter();
	        filterParameter.name = params.datasetNames;
	        filterParameter.fields = params.fields;
	        paramsBySql.queryParameter = filterParameter;
	    }
	    if(params.attributeFilter) {
	        paramsBySql.attributeFilter = params.attributeFilter;
	        paramsBySql.getFeatureMode = "BUFFER_ATTRIBUTEFILTER";
	    }
	    return SuperMap.Util.toJSON(paramsBySql);
	};
	module.exports = function (options) {
	    return new GetFeaturesByBufferParameters(options);
	};

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.GetFeaturesByGeometryService
	 * 数据集几何查询服务类
	 * 查询与指定几何对象符合一定空间关系的矢量要素。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.GetFeaturesServiceBase>
	 */
	__webpack_require__(53);
	__webpack_require__(64);

	SuperMap.REST.GetFeaturesByGeometryService = SuperMap.Class(SuperMap.REST.GetFeaturesServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.GetFeaturesByGeometryService
	     * 数据集几何查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.GetFeaturesByGeometryService(url, {
	     *     eventListeners: {
	     *           "processCompleted": getFeatureCompleted, 
	     *           "processFailed": getFeatureError
	     *           }
	     * });
	     * function getFeatureCompleted(object){//todo};
	     * function getFeatureError(object){//todo}
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 数据查询结果资源地址。请求数据服务中数据集查询服务，
	     * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data；
	     * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data"
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.GetFeaturesServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * Method: getJsonParameters
	     * 将查询参数转化为 JSON 字符串。
	     * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry等）。
	     *
	     * Parameters:
	     * params - {<GetFeaturesByGeometryParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的 JSON 字符串。
	     */
	    getJsonParameters: function (params) {
	        return GetFeaturesByGeometryParameters.toJsonParameters(params);
	    },

	    CLASS_NAME: "SuperMap.REST.GetFeaturesByGeometryService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GetFeaturesByGeometryService(url, options);
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: GetFeaturesByGeometryParameters
	 * 数据集几何查询参数类。
	 * 该类用于设置数据集几何查询的相关参数。
	 *
	 * Inherits from:
	 *  - <GetFeaturesParametersBase>
	 */
	__webpack_require__(55);
	GetFeaturesByGeometryParameters = SuperMap.Class(GetFeaturesParametersBase, {

	    /**
	     * Property: getFeatureMode
	     * {String} 数据集查询模式。
	     * 几何查询有"SPATIAL"，"SPATIAL_ATTRIBUTEFILTER"两种,当用户设置attributeFilter时会自动切换到SPATIAL_ATTRIBUTEFILTER访问服务。
	     */
	    getFeatureMode: "SPATIAL",

	    /**
	     * APIProperty: geometry
	     * {<Object>} 用于查询的几何对象。
	     */
	    geometry: null,

	    /**
	     * APIProperty: fields
	     * {Array(String)} 设置查询结果返回字段。
	     *                 当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。
	     *                 不设置即返回全部字段。
	     */
	    fields: null,

	    /**
	     * APIProperty: attributeFilter
	     * {String} 几何查询属性过滤条件。
	     */
	    attributeFilter: null,

	    /**
	     * APIProperty: spatialQueryMode
	     * {<SpatialQueryMode>} 空间查询模式常量，必设参数，默认为CONTAIN。
	     */
	    spatialQueryMode: SpatialQueryMode.CONTAIN,

	    /**
	     * Constructor: GetFeaturesByGeometryParameters
	     * 几何空间查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * geometry - {<Object>} 用于查询的几何对象。
	     * attributeFilter - {String} 几何查询属性过滤条件。
	     * fields - {Array(String)} 设置查询结果返回字段。默认返回所有字段。
	     * spatialQueryMode - {<SpatialQueryMode>} 空间查询模式常量,必设参数。
	     * queryParameter - {<FilterParameter>} 查询过滤条件参数。
	     * datasetNames - {Array(String)} 数据集集合中的数据集名称列表。
	     * returnContent - {Boolean} 是否直接返回查询结果。
	     * fromIndex - {Integer} 查询结果的最小索引号。
	     * toIndex - {Integer} 查询结果的最大索引号。
	     */
	    initialize: function (options) {
	        GetFeaturesParametersBase.prototype.initialize.apply(this, arguments);
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        GetFeaturesParametersBase.prototype.destroy.apply(me, arguments);
	        if (me.geometry) {
	            me.geometry.destroy();
	            me.geometry = null;
	        }
	        if (me.fields) {
	            while (me.fields.length > 0) {
	                me.fields.pop();
	            }
	            me.fields = null;
	        }
	        me.attributeFilter = null;
	        me.spatialQueryMode = null;
	        me.getFeatureMode = null;
	    },
	    CLASS_NAME: "GetFeaturesByGeometryParameters"
	});

	/**
	 * Function: GetFeaturesByGeometryParameters.toJsonParameters
	 * 将<GetFeaturesByGeometryParameters>对象参数转换为json字符串。
	 *
	 * Parameters:
	 * params - {<GetFeaturesByGeometryParameters>} 几何查询参数。
	 *
	 * Returns:
	 * {String} 转化后的 json字符串。
	 */
	GetFeaturesByGeometryParameters.toJsonParameters = function (params) {
	    var filterParameter,
	        geometry,
	        parasByGeometry;

	    geometry = SuperMap.REST.ServerGeometry.fromGeometry(params.geometry);
	    parasByGeometry = {
	        datasetNames: params.datasetNames,
	        getFeatureMode: "SPATIAL",
	        geometry: geometry,
	        spatialQueryMode: params.spatialQueryMode
	    };
	    if (params.fields) {
	        filterParameter = new FilterParameter();
	        filterParameter.name = params.datasetNames;
	        filterParameter.fields = params.fields;
	        parasByGeometry.queryParameter = filterParameter;
	    }
	    if (params.attributeFilter) {
	        parasByGeometry.attributeFilter = params.attributeFilter;
	        parasByGeometry.getFeatureMode = "SPATIAL_ATTRIBUTEFILTER";
	    }

	    return SuperMap.Util.toJSON(parasByGeometry);
	};
	module.exports = function (options) {
	    return new GetFeaturesByGeometryParameters(options);
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: GetFieldsService
	 * 字段查询服务类
	 * 用法：
	 *      L.superMap.getFieldsService(url,{
	 *            projection:projection
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(49);
	__webpack_require__(66);

	GetFieldsService = FieldsServiceBase.extend({

	    initialize: function (url, options) {
	        FieldsServiceBase.prototype.initialize.call(this, url, options);
	    },

	    getFields: function () {
	        var me = this, getFieldsService;
	        getFieldsService = new SuperMap.REST.GetFieldsService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            datasource: me.options.dataSourceName,
	            dataset: me.options.dataSetName
	        });
	        getFieldsService.processAsync();
	        return me;
	    }
	});

	L.supermap.getFieldsService = function (url, options) {
	    return new GetFieldsService(url, options);
	};

	module.exports = L.supermap.getFieldsService;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.GetFieldsService
	 * 字段查询服务，支持查询指定数据集的中所有属性字段（field）的集合。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);

	SuperMap.REST.GetFieldsService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * APIProperty: datasource
	     * {String} 要查询的数据集所在的数据源名称。
	     */
	    datasource: null,

	    /**
	     * APIProperty: dataset
	     * {String} 要查询的数据集名称。
	     */
	    dataset: null,

	    /**
	     * Constructor: SuperMap.REST.GetFieldsService
	     * 字段查询服务构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.GetFieldsService(url, {eventListeners: {
	     *     "processCompleted": getFieldsCompleted, 
	     *     "processFailed": getFieldsError
	     *     },
	     *     datasource: "World",
	     *     dataset: "Countries"
	     * };
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/data-world/rest/data 即可。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     * datasource - {String}
	     * dataset - {String}
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.datasource = null;
	        me.dataset = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 执行服务，查询指定数据集的字段信息。
	     */
	    processAsync: function () {
	        var me = this,
	            end = me.url.substr(me.url.length - 1, 1),
	            datasetURL = "datasources/" + me.datasource + "/datasets/" + me.dataset;
	        if (me.isInTheSameDomain) {
	            me.url += (end == "/") ? datasetURL + "/fields.json?" : "/" + datasetURL + "/fields.json?";
	        } else {
	            me.url += (end == "/") ? datasetURL + "fields.jsonp?" : "/" + datasetURL + "/fields.jsonp?";
	        }

	        me.request({
	            method: "GET",
	            data: null,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.GetFieldsService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GetFieldsService(url, options);
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: EditFeaturesService
	 * 地物编辑服务类
	 * 用法：
	 *      L.superMap.editFeaturesService(url).editFeatures({
	 *          features:{},
	 *          editType:"add"
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */

	__webpack_require__(68);
	__webpack_require__(11);

	EditFeaturesService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    /**
	     * @param params:
	     *  <EditFeaturesParameters>
	     */
	    editFeatures: function (params) {
	        var me = this, param = me._processParams(params);
	        editFeatureService = new SuperMap.REST.EditFeaturesService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        editFeatureService.processAsync(param);
	        return me;
	    },

	    _processParams: function (params) {
	        if (!params) {
	            return {};
	        }
	        var me = this;
	        params.returnContent = (params.returnContent == null) ? false : params.returnContent;
	        params.isUseBatch = (params.isUseBatch == null) ? false : params.isUseBatch;

	        if (params.editType) {
	            params.editType = params.editType.toLowerCase();
	        }

	        if (params.features) {
	            var features = [];
	            if (L.Util.isArray(params.features)) {
	                params.features.map(function (feature) {
	                    features.push(me._createServerFeature(feature));
	                });
	            } else {
	                features.push(me._createServerFeature(params.features));
	            }
	            params.features = features;
	        }
	        return params;
	    },

	    _createServerFeature: function (geoFeature) {
	        var geoJSONFeature, feature = {}, fieldNames = [], fieldValues = [];
	        geoJSONFeature = geoFeature.toGeoJSON();
	        for (var key in geoJSONFeature.properties) {
	            fieldNames.push(key);
	            fieldValues.push(geoJSONFeature.properties[key]);
	        }
	        feature.fieldNames = fieldNames;
	        feature.fieldValues = fieldValues;
	        feature.geometry = L.Util.toSuperMapGeometry(geoJSONFeature);
	        return feature;
	    }
	});

	L.supermap.editFeaturesService = function (url, options) {
	    return new EditFeaturesService(url, options);
	};

	module.exports = L.supermap.editFeaturesService;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.EditFeaturesService
	 * 数据服务中数据集添加、更新、删除服务类。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(69);
	SuperMap.REST.EditFeaturesService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Property: returnContent
	     * {Boolean} 要素添加时，isUseBatch 不传或传为 false 的情况下有效。
	     *           true 表示直接返回新创建的要素的 ID 数组;false 表示返回创建的 featureResult 资源的 URI。默认不传时为 false。
	     */
	    returnContent: false,

	    /**
	     * Property: isUseBatch
	     * {Boolean} 是否使用批量添加要素功能，要素添加时有效。
	     *           批量添加能够提高要素编辑效率。
	     *           true 表示批量添加；false 表示不使用批量添加。默认不传时为 false。
	     */
	    isUseBatch: false,

	    /**
	     * Constructor: SuperMap.REST.EditFeaturesService
	     * 数据集编辑服务基类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.EditFeaturesService(url, {eventListeners: {
	     *     "processCompleted": editFeatureCompleted, 
	     *     "processFailed": editFeatureError
	     *       }
	     * };
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务端的数据服务资源地址。请求数据服务中数据集编辑服务，URL 应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/datasources/name/{数据源名}/datasets/name/{数据集名} 。
	     * 例如：http://localhost:8090/iserver/services/data-jingjin/rest/data/datasources/name/Jingjin/datasets/name/Landuse_R
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	        var me = this, end;
	        end = me.url.substr(me.url.length - 1, 1);
	        if (me.isInTheSameDomain) {
	            me.url += (end == "/") ? "features.json?" : "/features.json?";
	        } else {
	            me.url += (end == "/") ? "features.jsonp?" : "/features.jsonp?";
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.returnContent = null;
	        me.isUseBatch = null;
	        me.fromIndex = null;
	        me.toIndex = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的更新参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<EditFeaturesParameters>} 编辑要素参数。
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this,
	            method = "POST",
	            ids = "",
	            editType = params.editType,
	            jsonParameters = null;

	        me.returnContent = params.returnContent;
	        me.isUseBatch = params.isUseBatch;
	        jsonParameters = EditFeaturesParameters.toJsonParameters(params);
	        if (editType === EditType.DELETE) {
	            ids = SuperMap.Util.toJSON(params.IDs);
	            me.url += "ids=" + ids;
	            method = "DELETE";
	            jsonParameters = ids;
	        } else if (editType === EditType.UPDATE) {
	            method = "PUT";
	        } else {
	            if (me.isUseBatch) {
	                me.url += "isUseBatch=" + me.isUseBatch;
	                me.returnContent = false;
	            }
	            if (me.returnContent) {
	                me.url += "returnContent=" + me.returnContent;
	                method = "POST";
	            }
	        }

	        me.request({
	            method: method,
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.EditFeaturesService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.EditFeaturesService(url, options);
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: EditFeaturesParameters
	 * 数据服务中数据集添加、修改、删除参数类。 
	 */
	__webpack_require__(4);
	EditFeaturesParameters = SuperMap.Class({
	    /** 
	     * APIProperty: features
	     * {Array(Object)} 当前需要创建或者是修改的要素集。
	     */
	    features: null,
	    
	    /** 
	     * APIProperty: editType
	     * {<EditType>} 要素集更新类型(add、update、delete)，默认为 EditType.ADD.
	     */
	    editType: EditType.ADD,
	    
	    /** 
	     * APIProperty: IDs
	     * {Array(String) 或 Array(Integer)} 执行删除时要素集ID集合。
	     */
	    IDs: null,
	    
	    /** 
	     * APIProperty: returnContent
	     * {Boolean} 要素添加时，isUseBatch 不传或传为 false 的情况下有效。 
	     *           true 表示直接返回新创建的要素的 ID 数组;false 表示返回创建的 featureResult 资源的 URI。默认不传时为 false。
	     */
	    returnContent: false,
	    
	    /** 
	     * APIProperty: isUseBatch
	     * {Boolean} 是否使用批量添加要素功能，要素添加时有效。 
	     *           批量添加能够提高要素编辑效率。 
	     *           true 表示批量添加；false 表示不使用批量添加。默认不传时为 false。
	     */
	    isUseBatch: false,
	    
	    /**
	     * Constructor: EditFeaturesParameters
	     * 数据服务中数据集添加、修改、删除参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * features - {Array(Object)} 当前需要创建或者是修改的要素集。  
	     * returnContent - {Boolean} 是返回创建要素的ID数组还是返回featureResult资源的URI。
	     * editType - {<EditType>} POST动作类型(ADD、UPDATE、DELETE)，默认为 EditType.ADD。
	     * IDs - {Array(String) 或 Array(Integer)} 删除要素时的要素的ID数组。
	     */
	    initialize: function(options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy:function () {
	        var me = this;
	        me.features = null;
	        me.editType = null;
	        me.IDs = null;
	        me.returnContent = null;
	    },
	    
	    CLASS_NAME:"EditFeaturesParameters"
	});
	/**
	 * Function: EditFeaturesParameters.toJsonParameters
	 * 将 <EditFeaturesParameters> 对象参数转换为 json 字符串。 
	 *
	 * Parameters:
	 * params - {<EditFeaturesParameters>} 地物编辑参数。 
	 *
	 * Returns:
	 * {String} 转化后的 json字符串。
	 */
	EditFeaturesParameters.toJsonParameters = function(params) {
	    var geometry,
	        feature,
	        len,
	        features,
	        editType = params.editType;

	    if(editType === EditType.DELETE) {
	        if(params.IDs === null) return;
	        
	        features = {ids:params.IDs};
	    }else {
	        if(params.features === null) return; 
	        
	        len = params.features.length;
	        features = [];
	        for(var i = 0; i < len; i++) {
	            feature = params.features[i];
	            feature.geometry = SuperMap.REST.ServerGeometry.fromGeometry(feature.geometry);
	            features.push(feature);
	        }
	    }
	    
	    return SuperMap.Util.toJSON(features);
	};
	module.export = function (options) {
	    return new EditFeaturesParameters(options);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56)(module)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: GetGridCellInfosService
	 * 数据栅格查询服务
	 * 用法：
	 *      L.superMap.getGridCellInfosService(url).getGridCellInfos({
	 *            datasetName:xxx,dataSourceName:xxx,X:xxx,y:xxx
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(11);
	__webpack_require__(71);

	GetGridCellInfosService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },
	    /**
	     * @param params:
	     *    <GetGridCellInfosParameter>
	     */

	    getGridCellInfos: function (params) {
	        if (!params) {
	            return null;
	        }
	        var me = this;
	        var gridCellQueryService = new SuperMap.REST.GetGridCellInfosService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        gridCellQueryService.processAsync(params);
	        return me;
	    }
	});

	L.supermap.getGridCellInfosService = function (url, options) {
	    return new GetGridCellInfosService(url, options);
	};

	module.exports = L.supermap.getGridCellInfosService;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.GetGridCellInfosService
	 * 数据栅格查询服务，支持查询指定地理位置的栅格信息
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */

	__webpack_require__(13);
	__webpack_require__(72);
	SuperMap.REST.GetGridCellInfosService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * APIProperty: datasetName
	     * {String} 数据集名称。
	     */
	    datasetName: null,

	    /**
	     * APIProperty: dataSourceName
	     * {String} 数据源名称。
	     */
	    dataSourceName: null,

	    /**
	     * Property: dataSourceName
	     * {String} 数据集类型。
	     */
	    datasetType: null,

	    /**
	     * APIProperty: X
	     * {Number} 要查询的地理位置X轴
	     */
	    X: null,

	    /**
	     * APIProperty: X
	     * {Number} 要查询的地理位置Y轴
	     */
	    Y: null,

	    /**
	     * Constructor: SuperMap.REST.GetGridCellInfosService
	     * 字段查询服务构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.GetGridCellInfosService(url, {eventListeners: {
	     *     "processCompleted": queryCompleted,
	     *     "processFailed": queryError
	     *     }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 查询服务地址。例如: http://localhost:8090/iserver/services/data-jingjin/rest/data
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (!!options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        me.X = null;
	        me.Y = null;
	        me.datasetName = null;
	        me.dataSourceName = null;
	        me.datasetType = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 执行服务，查询数据集信息。
	     * Parameters:
	     * params - {<GetGridCellInfosParameter>} 查询参数。
	     */
	    processAsync: function (params) {
	        if (params) {
	            SuperMap.Util.extend(this, params);
	        }
	        var me = this;
	        var end = me.url.substr(me.url.length - 1, 1);
	        if (me.isInTheSameDomain) {
	            me.url += (end == "/") ? ("datasources/" + me.dataSourceName + "/datasets/" + me.datasetName + ".json") :
	                ("/datasources/" + me.dataSourceName + "/datasets/" + me.datasetName + ".json");
	        } else {
	            me.url += (end == "/") ? ("datasources/" + me.dataSourceName + "/datasets/" + me.datasetName + ".jsonp") :
	                ("/datasources/" + me.dataSourceName + "/datasets/" + me.datasetName + ".jsonp");
	        }

	        me.queryRequest(me.getDatasetInfoCompleted, me.getDatasetInfoFailed);
	    },

	    /**
	     * Method: queryRequest
	     * 执行服务，查询。
	     */
	    queryRequest: function (successFun, failedFunc) {
	        var me = this;
	        me.request({
	            method: "GET",
	            data: null,
	            scope: me,
	            success: successFun,
	            failure: failedFunc
	        });
	    },

	    /**
	     * Method: getDatasetInfoCompleted
	     * 数据集查询完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    getDatasetInfoCompleted: function (result) {
	        var me = this;
	        result = SuperMap.Util.transformResult(result);
	        me.datasetType = result.datasetInfo.type;
	        me.queryGridInfos();
	    },

	    /**
	     * Method: queryGridInfos
	     * 执行服务，查询数据集栅格信息信息。
	     */
	    queryGridInfos: function () {
	        var me = this,
	            re = /\.json/,
	            index = re.exec(me.url).index,
	            urlBack = me.url.substring(index),
	            urlFront = me.url.substring(0, me.url.length - urlBack.length);
	        if (me.datasetType == "GRID") {
	            me.url = urlFront + "/gridValue" + urlBack;
	        } else {
	            me.url = urlFront + "/imageValue" + urlBack;
	        }

	        if (me.X != null && me.Y != null) {
	            me.url += '?x=' + me.X + '&y=' + me.Y;
	        }
	        me.queryRequest(me.serviceProcessCompleted, me.serviceProcessFailed);
	    },

	    /**
	     * Method: getDatasetInfoFailed
	     * 数据集查询失败，执行此方法。
	     *
	     * Parameters:
	     * result -  {Object} 服务器返回的结果对象。
	     */
	    getDatasetInfoFailed: function (result) {
	        var me = this;
	        me.serviceProcessFailed(result);
	    },

	    CLASS_NAME: "SuperMap.REST.GetGridCellInfosService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GetGridCellInfosService(url, options);
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: GetGridCellInfosParameters
	 * 数据服务栅格查询参数类。
	 */
	__webpack_require__(4);
	GetGridCellInfosParameter = SuperMap.Class({
	    /**
	     * APIProperty: datasetName
	     * {String} 数据集名称。
	     */
	    datasetName: null,

	    /**
	     * APIProperty: dataSourceName
	     * {String} 数据源名称。
	     */
	    dataSourceName: null,

	    /**
	     * APIProperty: X
	     * {Number} 要查询的地理位置X轴
	     */
	    X: null,

	    /**
	     * APIProperty: X
	     * {Number} 要查询的地理位置Y轴
	     */
	    Y: null,

	    /**
	     * Constructor: GetGridCellInfosParameter
	     * SQL 查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * datasetName - {String} 数据集名称。
	     * dataSourceName - {String} 数据源名称
	     * X - {Integer} 要查询的地理位置X轴。
	     * Y - {Integer} 要查询的地理位置Y轴。
	     */
	    initialize: function(options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy:function () {
	        var me = this;
	        me.datasetName = null;
	        me.dataSourceName = null;
	        me.X = null;
	        me.Y = null;
	    },

	    CLASS_NAME:"GetGridCellInfosParameter"
	});
	module.export = function (options) {
	    return new GetGridCellInfosParameter(options);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56)(module)))

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: ThemeService
	 * 地图信息服务类
	 * 用法：
	 *      L.superMap.themeService(url,{
	 *            projection:projection
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(11);
	__webpack_require__(74);
	ThemeService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	        L.setOptions(this, options);
	    },

	    getThemeStatus: function (params) {
	        var me = this;
	        var themeService = new SuperMap.REST.ThemeService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        themeService.processAsync(params);
	        return me;
	    }
	});

	L.supermap.themeService = function (url, options) {
	    return new ThemeService(url, options);
	};

	module.exports = L.supermap.ThemeService;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.ThemeService
	 * 专题图服务类。
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(75);
	SuperMap.REST.ThemeService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.ThemeService
	     * 专题图服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myThemeService = new SuperMap.REST.ThemeService(url, {
	     *     eventListeners: {
	     *           "processCompleted": themeCompleted,
	     *           "processFailed": themeFailed
	     *           }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	        var end,
	            me = this;
	        end = me.url.substr(me.url.length - 1, 1);
	        if (me.isInTheSameDomain) {
	            me.url += (end === "/") ? "tempLayersSet.json?" : "/tempLayersSet.json?";
	        } else {
	            me.url += (end === "/") ? "tempLayersSet.jsonp?" : "/tempLayersSet.jsonp?";
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的专题图参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<ThemeParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this,
	            jsonParameters = null;
	        jsonParameters = me.getJsonParameters(params);
	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJsonParameters
	     * 将专题图参数参数转化为 JSON 字符串。
	     *
	     * Parameters:
	     * params - {<ThemeParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJsonParameters: function (parameter) {
	        var jsonParameters = "",
	            themeType = "",
	            themeObj = null,
	            filters = null,
	            orderBys = null,
	            fieldValuesDisplayFilter;
	        jsonParameters += "[{'type': 'UGC','subLayers': {'layers': [";
	        for (var themeID in parameter.themes) {
	            themeObj = parameter.themes[themeID];
	            var jsonTheme = SuperMap.Util.toJSON(themeObj);
	            jsonTheme = jsonTheme.slice(0, -1);

	            jsonParameters += "{'theme': " + jsonTheme + "},'type': 'UGC','ugcLayerType': 'THEME',";
	            filters = parameter.displayFilters;
	            if (filters && filters.length > 0) {
	                if (filters.length === 1) {
	                    jsonParameters += "'displayFilter':\"" + filters[0] + "\",";
	                } else {
	                    jsonParameters += "'displayFilter':\"" + filters[themeID] + "\",";
	                }
	            }
	            orderBys = parameter.displayOrderBy;
	            if (orderBys && orderBys.length > 0) {
	                if (orderBys.length === 1) {
	                    jsonParameters += "'displayOrderBy':'" + orderBys[0] + "',";
	                } else {
	                    jsonParameters += "'displayOrderBy':'" + orderBys[themeID] + "',";
	                }
	            }

	            fieldValuesDisplayFilter = parameter.fieldValuesDisplayFilter;
	            if (fieldValuesDisplayFilter) {
	                jsonParameters += "'fieldValuesDisplayFilter':" + SuperMap.Util.toJSON(fieldValuesDisplayFilter) + ",";
	            }

	            if (parameter.joinItems && parameter.joinItems.length > 0 && parameter.joinItems[themeID]) {
	                jsonParameters += "'joinItems':[" + SuperMap.Util.toJSON(parameter.joinItems[themeID]) + "],";
	            }
	            if (parameter.datasetNames && parameter.dataSourceNames) {
	                var datasetID = parameter.datasetNames[themeID] ? themeID : (parameter.datasetNames.length - 1);
	                var dataSourceID = parameter.dataSourceNames[themeID] ? themeID : (parameter.dataSourceNames.length - 1);
	                jsonParameters += "'datasetInfo': {'name': '" + parameter.datasetNames[datasetID] +
	                    "','dataSourceName': '" + parameter.dataSourceNames[dataSourceID] + "'}},";
	            } else {
	                jsonParameters += "},";
	            }
	        }
	        //去除多余的逗号
	        if (parameter.themes && parameter.themes.length > 0) {
	            jsonParameters = jsonParameters.substring(0, jsonParameters.length - 1);
	        }
	        jsonParameters += "]},";
	        var urlArray = this.url.split("/");
	        var jsonMapName = urlArray[urlArray.length - 2];

	        jsonParameters += "'name': '" + jsonMapName + "'}]";
	        return jsonParameters;
	    },

	    CLASS_NAME: "SuperMap.REST.ThemeService"
	});
	module.exports = function (url, options) {
	    return new SuperMap.REST.ThemeService(url, options);
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeParameters
	 * 专题图参数类
	 * 该类存储了制作专题所需的参数，包括数据源、数据集名称和专题图对象。
	 */
	__webpack_require__(4);
	__webpack_require__(19);
	__webpack_require__(76);
	__webpack_require__(81);
	__webpack_require__(85);
	__webpack_require__(91);
	__webpack_require__(102);
	__webpack_require__(104);
	__webpack_require__(106);
	__webpack_require__(108);

	ThemeParameters = SuperMap.Class({

	    /**
	     * APIProperty: datasetNames
	     * {Array(String)} 要制作专题图的数据集数组，必设。
	     */
	    datasetNames: null,

	    /**
	     * APIProperty: dataSourceNames
	     * {Array(String)} 要制作专题图的数据集所在的数据源数组，必设。
	     */
	    dataSourceNames: null,

	    /**
	     * APIProperty: joinItems
	     * {Array(<JoinItem>)} 设置与外部表的连接信息 JoinItem 数组。
	     * 使用此属性可以制作与外部表连接的专题图。
	     */
	    joinItems: null,

	    /**
	     * APIProperty: themes
	     * {Array(<Theme>)} 专题图对象列表。
	     * 该参数为实例化的各类专题图对象的集合。
	     */
	    themes: null,

	    /**
	     * APIProperty: displayFilters
	     * {Array(String)} 专题图属性过滤条件。
	     */
	    displayFilters: null,

	    /**
	     * APIProperty: displayOrderBy
	     * {Array(String)} 专题图对象生成符号叠加次序排序字段
	     */
	    displayOrderBys: null,

	    /**
	     * APIProperty: fieldValuesDisplayFilter
	     * {Object} 图层要素的显示和隐藏的过滤属性，其带有三个属性，分别是:values、fieldName、fieldValuesDisplayMode,他们的作用如下：
	     * values：{Array<Number>} - 就是要过滤的值；
	     * fieldName：{String} - 要过滤的字段名称 只支持数字类型的字段；
	     * fieldValuesDisplayMode：{String} 目前有两个DISPLAY/DISABLE。当为DISPLAY时，表示只显示以上设置的相应属性值的要素，否则表示不显示以上设置的相应属性值的要素
	     * */
	    fieldValuesDisplayFilter: null,

	    /**
	     * Constructor: ThemeParameters
	     * 专题图参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * datasetNames - {Array(String)} 要制作专题图的数据集数组。
	     * dataSourceNames - {Array(String)} 要制作专题图的数据集所在的数据源数组。
	     * joinItems - {Array(<JoinItem>)} 专题图外部表的连接信息 JoinItem 数组。
	     * themes - {Array(<Theme>)} 专题图对象列表。
	     */
	    initialize: function (options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.datasetNames = null;
	        me.dataSourceNames = null;
	        if (me.joinItems) {
	            for (var i = 0, joinItems = me.joinItems, len = joinItems.length; i < len; i++) {
	                joinItems[i].destroy();
	            }
	            me.joinItems = null;
	        }
	        if (me.themes) {
	            for (var i = 0, themes = me.themes, len = themes.length; i < len; i++) {
	                themes[i].destroy();
	            }
	            me.themes = null;
	        }
	    },

	    CLASS_NAME: "ThemeParameters"
	});

	module.exports = function (options) {
	    return new ThemeParameters(options);
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeDotDensity
	 * 点密度专题图。
	 * 点密度专题图用一定大小、形状相同的点表示现象分布范围、数量特征和分布密度。点的多少和所代表的意义由地图的内容确定。
	 * 点密度专题图利用图层的某一数值属性信息（专题值）映射为不同等级，每一级别使用不同数量或表现为密度的点符号来表示
	 * 该专题值在各个分区内的分布情况，体现不同区域的相对数量差异。多用于具有数量特征的地图上，
	 * 比如表示不同地区的粮食产量、GDP、人口等的分级，主要针对区域或面状的要素，因而，点密度专题图适用于面数据集。
	 *
	 * 注意：点密度专题图中点的分布是随机的，并不代表实际的分布位置。即使在相关设置完全相同的情况下，
	 * 每次制作出的专题图，点的数量相同，但点的位置都有差异。
	 *
	 * Inherits from:
	 *  - <Theme>
	 */
	__webpack_require__(4);
	__webpack_require__(77);
	__webpack_require__(79);
	ThemeDotDensity = SuperMap.Class(Theme, {

	    /**
	     * APIProperty: dotExpression
	     * {String} 创建点密度专题图的字段或字段表达式。点的数目或密集程度的来源。
	     */
	    dotExpression: null,

	    /**
	     * APIProperty: style
	     * {<ServerStyle>} 点密度专题图中点的风格。
	     */
	    style: null,

	    /**
	     * APIProperty: value
	     * {Number} 专题图中每一个点所代表的数值。
	     * 点值的确定与地图比例尺以及点的大小有关。地图比例尺越大，相应的图面范围也越大，
	     * 点相应就可以越多，此时点值就可以设置相对小一些。点形状越大，
	     * 点值相应就应该设置的小一些。点值过大或过小都是不合适的。
	     */
	    value: null,

	    /**
	     * Constructor: ThemeDotDensity
	     * 点密度专题图构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * dotExpression - {String} 创建点密度专题图的字段或字段表达式。
	     * style - {<ServerStyle>} 点密度专题图中点的风格。
	     * value - {String} 专题图中每一个点所代表的数值。
	     * memoryData - {<SuperMap.REST.ThemeMemoryData>} 专题图内存数据。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.style = new ServerStyle();
	        Theme.prototype.initialize.apply(this, ["DOTDENSITY", options]);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.dotExpression = null;
	        me.value = null;

	        if (me.style) {
	            me.style.destroy();
	            me.style = null;
	        }
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = {};
	        obj = SuperMap.Util.copyAttributes(obj, this);
	        if (obj.style) {
	            if (obj.style.toServerJSONObject) {
	                obj.style = obj.style.toServerJSONObject();
	            }
	        }
	        return obj;
	    },

	    CLASS_NAME: "ThemeDotDensity"
	});
	ThemeDotDensity.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeDotDensity();
	    SuperMap.Util.copy(res, obj);
	    res.style = ServerStyle.fromJson(obj.style);
	    return res;
	};

	module.exports = function (options) {
	    return new ThemeDotDensity(options);
	};


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ServerStyle
	 * 服务端矢量要素风格类
	 * 该类用于定义点状符号、线状符号、填充符号风格及其相关属性。
	 */
	__webpack_require__(4);
	__webpack_require__(78);
	ServerStyle = SuperMap.Class({

	    /**
	     * APIProperty: fillBackColor
	     * {<ServerColor>} 填充背景颜色。
	     * 当填充模式为渐变填充时，该颜色为填充终止色。默认为白色。
	     */
	    fillBackColor: null,

	    /**
	     * APIProperty: fillBackOpaque
	     * {Boolean} 背景是否不透明。
	     * false 表示透明。默认值为 false。
	     */
	    fillBackOpaque: false,

	    /**
	     * APIProperty: fillForeColor
	     * {<ServerColor>} 填充颜色。
	     * 当填充模式为渐变填充时，该颜色为填充起始颜色。默认为红色。
	     */
	    fillForeColor: null,

	    /**
	     * APIProperty: fillGradientMode
	     * {<FillGradientMode>} 渐变填充风格的渐变类型。
	     */
	    fillGradientMode: null,

	    /**
	     * APIProperty: fillGradientAngle
	     * {Number} 渐变填充的旋转角度。
	     * 单位为度，精确到0.1度，逆时针方向为正方向。
	     */
	    fillGradientAngle: 0,

	    /**
	     * APIProperty: fillGradientOffsetRatioX
	     * {Number} 渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。
	     * 它们的关系如下：设填充区域范围中心点的坐标为（x0, y0），填充中心点的坐标为（x, y），填充区域范围的宽度为 a，水平偏移百分比为 dx，则 x=x0 + a*dx/100。
	     */
	    fillGradientOffsetRatioX: 0,

	    /**
	     * APIProperty: fillGradientOffsetRatioY
	     * {Number} 填充中心点相对于填充区域范围中心点的垂直偏移百分比。
	     * 它们的关系如下：设填充区域范围中心点的坐标为（x0, y0），填充中心点的坐标为（x, y），填充区域范围的高度为 b，垂直偏移百分比为 dy，则 y=y0 + b*dx/100。
	     */
	    fillGradientOffsetRatioY: 0,

	    /**
	     * APIProperty: fillOpaqueRate
	     * {Number} 填充不透明度。
	     * 合法值为0--100的数值。其中为0表示完全透明；100表示完全不透明。赋值小于0时按照0处理，大于100时按照100处理。默认值为 100。
	     */
	    fillOpaqueRate: 100,

	    /**
	     * APIProperty: fillSymbolID
	     * {Integer} 填充符号的编码。
	     * 此编码用于唯一标识各普通填充风格的填充符号。关于填充符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
	     */
	    fillSymbolID: 0,

	    /**
	     * APIProperty: lineColor
	     * {<ServerColor>} 矢量要素的边线颜色。
	     * 默认为黑色。
	     */
	    lineColor: null,

	    /**
	     * APIProperty: lineSymbolID
	     * {Integer} 线状符号的编码。
	     * 此编码用于唯一标识各普通填充风格的填充符号，默认值为0。关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
	     */
	    lineSymbolID: 0,

	    /**
	     * APIProperty: lineWidth
	     * {Number} 边线的宽度。
	     * 单位为毫米，精度到0.1，默认值为1.0。
	     */
	    lineWidth: 1,

	    /**
	     * APIProperty: markerAngle
	     * {Number} 点状符号的旋转角度。
	     * 以度为单位，精确到0.1度，逆时针方向为正方向，默认值为0。
	     */
	    markerAngle: 0,

	    /**
	     * APIProperty: markerSize
	     * {Number} 点状符号的大小。
	     * 单位为毫米，精度为0.1，默认值为1.0。当该属性设置为0时，采用符号默认大小1.0显示。当该属性设置为非法值时，交由服务器默认处理。
	     */
	    markerSize: 1,

	    /**
	     * APIProperty: markerSymbolID
	     * {Integer} 点状符号的编码。
	     * 此编码用于唯一标识各点状符号。默认为 -1。关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
	     */
	    markerSymbolID: -1,

	    /**
	     * Constructor: ServerStyle
	     * 服务端矢量要素风格类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * fillBackColor - {<ServerColor>} 填充背景颜色。
	     * fillBackOpaque - {Boolean} 背景是否不透明。
	     * fillForeColor - {<ServerColor>} 填充颜色。
	     * fillGradientMode - {<FillGradientMode>} 渐变填充风格的渐变类型。
	     * fillGradientAngle - {Number} 渐变填充的旋转角度。
	     * fillGradientOffsetRatioX - {Number} 渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。
	     * fillGradientOffsetRatioY - {Number} 填充中心点相对于填充区域范围中心点的垂直偏移百分比。
	     * fillOpaqueRate - {Number} 填充不透明度。
	     * fillSymbolID - {Integer} 填充符号的编码。
	     * lineColor - {<ServerColor>} 矢量要素的边线颜色。
	     * lineSymbolID - {Integer} 线状符号的编码。
	     * lineWidth - {Number} 边线的宽度。
	     * markerAngle - {Number} 点状符号的旋转角度。
	     * markerSize - {Number} 点状符号的大小。
	     * markerSymbolID - {Integer} 点状符号的编码。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.fillBackColor = new ServerColor(255, 255, 255);
	        me.fillForeColor = new ServerColor(255, 0, 0);
	        me.lineColor = new ServerColor(0, 0, 0);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.fillBackColor) {
	            me.fillBackColor.destroy();
	            me.fillBackColor = null;
	        }
	        me.fillBackOpaque = null;

	        if (me.fillForeColor) {
	            me.fillForeColor.destroy();
	            me.fillForeColor = null;
	        }
	        me.fillGradientMode = null;
	        me.fillGradientAngle = null;
	        me.fillGradientOffsetRatioX = null;
	        me.fillGradientOffsetRatioY = null;
	        me.fillOpaqueRate = null;
	        me.fillSymbolID = null;
	        if (me.lineColor) {
	            me.lineColor.destroy();
	            me.lineColor = null;
	        }
	        me.lineSymbolID = null;
	        me.lineWidth = null;
	        me.markerAngle = null;
	        me.markerSize = null;
	        me.markerSymbolID = null;
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var styleObj = {};
	        styleObj = SuperMap.Util.copyAttributes(styleObj, this);
	        //暂时先忽略serverColor往Json的转换
	        return styleObj;
	    },

	    CLASS_NAME: "ServerStyle"

	});

	/**
	 * Function: ServerStyle.fromJson
	 * 将JSON对象转换为 ServerStyle 对象。
	 *
	 * Parameters:
	 * jsonObject - {Object} 要转换的 JSON 对象。
	 *
	 * Returns:
	 * {<ServerStyle>} 转化后的 ServerStyle 对象。
	 */
	ServerStyle.fromJson = function (jsonObject) {
	    if (!jsonObject) {
	        return;
	    }
	    return new ServerStyle({
	        fillBackColor: ServerColor.fromJson(jsonObject.fillBackColor),
	        fillBackOpaque: jsonObject.fillBackOpaque,
	        fillForeColor: ServerColor.fromJson(jsonObject.fillForeColor),
	        fillGradientMode: jsonObject.fillGradientMode,
	        fillGradientAngle: jsonObject.fillGradientAngle,
	        fillGradientOffsetRatioX: jsonObject.fillGradientOffsetRatioX,
	        fillGradientOffsetRatioY: jsonObject.fillGradientOffsetRatioY,
	        fillOpaqueRate: jsonObject.fillOpaqueRate,
	        fillSymbolID: jsonObject.fillSymbolID,
	        lineColor: ServerColor.fromJson(jsonObject.lineColor),
	        lineSymbolID: jsonObject.lineSymbolID,
	        lineWidth: jsonObject.lineWidth,
	        markerAngle: jsonObject.markerAngle,
	        markerSize: jsonObject.markerSize,
	        markerSymbolID: jsonObject.markerSymbolID
	    });
	};
	module.exports = function (options) {
	    return new ServerStyle(options);
	};


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ServerColor
	 * 颜色类
	 * 该类使用三原色（ RGB ）来表达颜色。
	 */
	__webpack_require__(4);
	ServerColor = SuperMap.Class({

	    /**
	     * APIProperty: red
	     * {Number} 获取或设置红色值,默认值为255。
	     */
	    red: 255,

	    /**
	     * APIProperty: green
	     * {Number} 获取或设置绿色值,默认值为0。
	     */
	    green: 0,

	    /**
	     * APIProperty: blue
	     * {Number} 获取或设置蓝色值,默认值为0。
	     */
	    blue: 0,

	    /**
	     * Constructor: ServerColor
	     * 颜色类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * red - {Number} 获取或设置红色值,默认值为255。
	     * green - {Number} 获取或设置绿色值,默认值为0。
	     * blue - {Number} 获取或设置蓝色值,默认值为0。
	     */
	    initialize: function (red, green, blue) {
	        if (!red && red != 0) {
	            this.red = 255;
	        }
	        else {
	            this.red = red;
	        }

	        if (!green && green != 0) {
	            this.green = 0;
	        }
	        else {
	            this.green = green;
	        }

	        if (!blue && blue != 0) {
	            this.blue = 0;
	        }
	        else {
	            this.blue = blue;
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.red = null;
	        me.green = null;
	        me.blue = null;
	    },
	    CLASS_NAME: "ServerColor"
	});

	/**
	 * Function: ServerColor.formJson
	 * 将JSON对象转化为ServerColor对象。
	 *
	 * Parameters: jsonObject - {Object} 要转换的JSON对象
	 *
	 * Returns:
	 * {< ServerColor> } 转化后的ServerColor对象。
	 */
	ServerColor.fromJson = function (jsonObject) {
	    if (!jsonObject) {
	        return;
	    }
	    var color = new ServerColor();
	    var red = 255;
	    if (jsonObject.red !== null) {
	        red = Number(jsonObject.red);
	    }
	    color.red = red;

	    var green = 0;
	    if (jsonObject.green !== null) {
	        green = Number(jsonObject.green);
	    }
	    color.green = green;

	    var blue = 0;
	    if (jsonObject.blue !== null) {
	        blue = Number(jsonObject.blue);
	    }
	    color.blue = blue;
	    return color;
	};
	module.exports = function (red, green, blue) {
	    return new ServerColor(red, green, blue);
	};


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: Theme
	 * 专题图基类。
	 */
	__webpack_require__(4);
	__webpack_require__(80);
	Theme = SuperMap.Class({

	    /**
	     * Property: memoryData
	     * {<ThemeMemoryData>} 专题图内存数据。
	     * 用内存数据制作专题图的方式与表达式制作专题图的方式互斥，前者优先级较高。
	     * 第一个参数代表专题值，即数据集中用来做专题图的字段或表达式的值；第二个参数代表外部值。在制作专题图时，会用外部值代替专题值来制作相应的专题图。
	     */
	    memoryData: null,

	    /**
	     * Property: type
	     * {String} 专题图类型。
	     */
	    type: null,

	    /**
	     * Constructor: Theme
	     * 专题图基类构造函数。
	     *
	     * Parameters:
	     * type - {String} 专题图类型。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * memoryData - {<ThemeMemoryData>} 专题图内存数据。
	     */
	    initialize: function (type, options) {
	        if (!type) {
	            return false;
	        }
	        this.type = type;
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.memoryData) {
	            me.memoryData.destroy();
	            me.memoryData = null;
	        }
	        me.type = null;
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        //return 子类实现
	        return;
	    },

	    CLASS_NAME: "Theme"
	});
	module.exports = function (type, options) {
	    return new Theme(type, options);
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeMemoryData
	 * 专题图内存数据类。
	 */
	__webpack_require__(4);
	ThemeMemoryData = SuperMap.Class({

	    /**
	     * Property: srcData
	     * {Array()} 原始值数组，该属性值将被 targetData 属性所指定的值替换掉，然后制作专题图，但数据库中的值并不会改变。
	     */
	    srcData: null,

	    /**
	     * Property: targetData
	     * {Array()} 外部值数组，即用于制作专题图的内存数据，设定该属性值后，会将 srcData 属性所指定的原始值替换掉制作专题图，但数据库中的值并不会改变。
	     */
	    targetData: null,

	    /**
	     * Constructor: ThemeMemoryData
	     * 专题图内存数据类构造函数。
	     *
	     * Parameters:
	     * srcData - {Array()} 原始值数组。
	     * targetData - {Array()} 外部值数组。
	     */
	    initialize: function (srcData, targetData) {
	        if (srcData) {
	            this.srcData = srcData;
	        }
	        if (targetData) {
	            this.targetData = targetData;
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.srcData = null;
	        me.targetData = null;
	    },

	    /**
	     * Method: toJSON
	     * 将 ThemeMemoryData 对象转化为json字符串。
	     *
	     * Returns:
	     * {String} 返回转换后的 JSON 字符串。
	     */
	    toJSON: function () {
	        if (this.srcData && this.targetData) {
	            var memoryDataStr = "";
	            var count = Math.min(this.srcData.length, this.targetData.length);
	            for (var i = 0; i < count; i++) {
	                memoryDataStr += "\'" + this.srcData[i] + "\':\'" + this.targetData[i] + "\',";
	            }
	            //去除多余的逗号
	            if (i > 0) {
	                memoryDataStr = memoryDataStr.substring(0, memoryDataStr.length - 1);
	            }
	            return "{" + memoryDataStr + "}";
	        } else {
	            return null;
	        }
	    },

	    CLASS_NAME: "ThemeMemoryData"
	});
	module.exports = function (srcData, targetData) {
	    return new ThemeMemoryData(srcData, targetData);
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGraduatedSymbol
	 * 等级符号专题图。
	 * 等级符号专题图是采用不同的形状、颜色和大小的符号，表示各自独立的、以整体概念显示的各个物体的数量与质量特征。通常，以符号的形状、
	 * 颜色和大小反映物体的特定属性；符号的形状与颜色表示质量特征，符号的大小表示数量特征。等级符号专题图多用于具有数量特征的地图上，
	 * 比如表示不同地区的粮食产量、GDP、人口等的分级，也就是说，用于制作等级符号专题图的专题变量类型为数值型。
	 *
	 * Inherits from:
	 * -<Theme>
	 */
	__webpack_require__(4);
	__webpack_require__(79);
	__webpack_require__(82);
	__webpack_require__(83);
	__webpack_require__(84);
	ThemeGraduatedSymbol = SuperMap.Class(Theme, {

	    /**
	     * APIProperty: baseValue
	     * { Number} 等级符号专题图的基准值，单位同专题变量的单位。
	     * 依据此值系统会自动根据分级方式计算其余值对应的符号大小，每个符号的显示大小等于 ThemeValueSection.positiveStyle（或 zeroStyle，negativeStyle）.markerSize * value / basevalue，
	     * 其中 value 是 expression 所指定字段对应的值经过分级计算之后的值。默认值为0，建议通过多次尝试设置该值才能达到较好的显示效果。
	     */
	    baseValue: 0,

	    /**
	     * APIProperty: expression
	     * {String} 用于创建等级符号专题图的字段或字段表达式，字段或字段表达式应为数值型。必设字段。
	     */
	    expression: null,

	    /**
	     * APIProperty: flow
	     * {<ThemeFlow>} 等级符号专题图符号流动显示与牵引线设置类。
	     * 通过该字段可以设置等级符号是否流动显示和牵引线风格。
	     */
	    flow: null,

	    /**
	     * APIProperty: graduatedMode
	     * {<GraduatedMode>} 等级符号专题图分级模式。
	     * 分级主要是为了减少制作等级符号专题图中数据大小之间的差异。如果数据之间差距较大，则可以采用对数或者平方根的分级方式来进行，
	     * 这样就减少了数据之间的绝对大小的差异，使得等级符号图的视觉效果比较好，同时不同类别之间的比较也是有意义的。
	     * 有三种分级模式：常数、对数和平方根，对于有值为负数的字段，在用对数或平方根方式分级时，默认对负数取正。
	     * 不同的分级模式用于确定符号大小的数值是不相同的：常数按照字段的原始数据进行；对数则是对每条记录对应的专题变量取自然对数；平方根则是对其取平方根，然后用最终得到的结果来确定其等级符号的大小。
	     * 默认值为 GraduatedMode.Constant。
	     */
	    graduatedMode: GraduatedMode.CONSTANT,

	    /**
	     * APIProperty: offset
	     * {<ThemeOffset>} 用于设置等级符号图相对于要素内点的偏移量。
	     */
	    offset: null,

	    /**
	     * APIProperty: style
	     * {<ThemeGraduatedSymbolStyle>} 用于设置等级符号图正负和零值显示风格。
	     */
	    style: null,

	    /**
	     * Constructor: ThemeGraduatedSymbol
	     * 等级符号专题图构造函数，用于创建 ThemeGraduatedSymbol类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * baseValue - {Number} 等级符号专题图的基准值，单位同专题变量的单位。
	     * expression - {String} 等级符号专题图的字段或字段表达式。
	     * flow - {<ThemeFlow>} 等级符号专题图符号流动显示与牵引线设置类。
	     * graduatedMode - {<GraduatedMode>} 等级符号专题图分级模式。
	     * offset - {<ThemeOffset>} 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。
	     * style - {<ThemeGraduatedSymbolStyle>} 用于设置等级符号图正负和零值显示风格。
	     * memoryData - {<ThemeMemoryData>} 专题图内存数据。
	     */
	    initialize: function (options) {
	        Theme.prototype.initialize.apply(this, ["GRADUATEDSYMBOL", options]);
	        var me = this;
	        me.flow = new ThemeFlow();
	        me.offset = new ThemeOffset();
	        me.style = new ThemeGraduatedSymbolStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        Theme.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.expression = null;
	        if (me.flow) {
	            me.flow.destroy();
	            me.flow = null;
	        }
	        me.graduatedMode = GraduatedMode.CONSTANT;
	        if (me.offset) {
	            me.offset.destroy();
	            me.offset = null;
	        }
	        if (me.style) {
	            me.style.destroy();
	            me.style = null;
	        }
	    },

	    /**
	     * Method: toJSON
	     * 将themeLabel对象转化为json字符串。
	     *
	     * Returns:
	     * {String} 返回转换后的 JSON 字符串。
	     */
	    toJSON: function () {
	        return SuperMap.Util.toJSON(this.toServerJSONObject());
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = new Object();
	        obj.type = this.type;
	        obj.memoryData = this.memoryData;
	        obj.baseValue = this.baseValue;
	        obj.expression = this.expression;
	        obj.graduatedMode = this.graduatedMode;
	        if (this.flow) {
	            obj.flowEnabled = this.flow.flowEnabled;
	            obj.leaderLineDisplayed = this.flow.leaderLineDisplayed;
	            obj.leaderLineStyle = this.flow.leaderLineStyle;
	        }
	        if (this.offset) {
	            obj.offsetFixed = this.offset.offsetFixed;
	            obj.offsetX = this.offset.offsetX;
	            obj.offsetY = this.offset.offsetY;
	        }
	        if (this.style) {
	            obj.negativeStyle = this.style.negativeStyle;
	            obj.negativeDisplayed = this.style.negativeDisplayed;
	            obj.positiveStyle = this.style.positiveStyle;
	            obj.zeroDisplayed = this.style.zeroDisplayed;
	            obj.zeroStyle = this.style.zeroStyle;
	        }
	        return obj;
	    },

	    CLASS_NAME: "ThemeGraduatedSymbol"
	});
	ThemeGraduatedSymbol.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeGraduatedSymbol();
	    SuperMap.Util.copy(res, obj);
	    res.flow = ThemeFlow.fromObj(obj);
	    res.offset = ThemeOffset.fromObj(obj);
	    res.style = ThemeGraduatedSymbolStyle.fromObj(obj);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeGraduatedSymbol(options);
	};


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeFlow
	 * 标签或符号流动显示和牵引线风格设置类。
	 * 通过该类可以设置专题图中符号是否流动显示、是否使用牵引线以及牵引线风格。
	 */
	__webpack_require__(4);
	__webpack_require__(77);
	ThemeFlow = SuperMap.Class({

	    /**
	     * APIProperty: flowEnabled
	     * {Boolean} 是否流动显示标签或符号。
	     * 对于标签专题图而言，对于跨越比较大的区域和线条状的几何对象，在一个地图窗口中不能完全显示的情况下，如果其标签位置比较固定，
	     * 在当前地图窗口中该对象的标签不可见，则需要通过平移地图来查看对象的标签信息。如果采用了流动显示的效果，在当前地图窗口中，对象即使是部分显示，
	     * 其标签也会显示在当前地图窗口中。当平移地图时，对象的标签会随之移动，以保证在当前地图窗口中部分或全部显示的对象其标签都可见，从而可以方便地查看各要素的标签信息。
	     */
	    flowEnabled: false,

	    /**
	     * APIProperty: leaderLineDisplayed
	     * {Boolean} 是否显示标签或符号和它标注的对象之间的牵引线。默认值为 false，即不显示标签或符号和它标注的对象之间的牵引线。
	     * 只有当 flowEnabled 为 true 时，牵引线才起作用。在当标签流动显示时，其位置不固定，由于牵引线始终指向要素的内点，
	     * 因而通过牵引线显示功能可以找到流动的标签或符号实际对应的要素。或者渲染符号偏移它所指向的对象时，图与对象之间可以采用牵引线进行连接。
	     */
	    leaderLineDisplayed: false,

	    /**
	     * APIProperty: leaderLineStyle
	     * {<ServerStyle>} 标签或符号与其标注对象之间牵引线的风格。
	     */

	    leaderLineStyle: null,
	    /**
	     * Constructor: ThemeFlow
	     * 标签或符号流动显示和牵引线风格设置类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * flowEnabled - {Boolean} 是否流动显示标签或符号。
	     * leaderLineDisplayed - {Boolean} 是否显示标签或符号和它标注的对象之间的牵引线。
	     * leaderLineStyle - {<ServerStyle>} 标签或符号与其标注对象之间牵引线的风格。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.leaderLineStyle = new ServerStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.flowEnabled = null;
	        me.leaderLineDisplayed = null;
	        if (me.leaderLineStyle) {
	            me.leaderLineStyle.destroy();
	            me.leaderLineStyle = null;
	        }
	    },

	    CLASS_NAME: "ThemeFlow"
	});
	ThemeFlow.fromObj = function (obj) {
	    if (!obj) {
	        return;
	    }
	    var res = new ThemeFlow();
	    SuperMap.Util.copy(res, obj);
	    res.leaderLineStyle = ServerStyle.fromJson(obj.leaderLineStyle);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeFlow(options);
	};


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeOffset
	 * 专题图中文本或符号相对于要素内点的偏移量设置类。
	 * 通过该类可以设置专题图中标记文本或符号的偏移量以及偏移量是否随地图缩放而改变。
	 */
	__webpack_require__(4);
	ThemeOffset = SuperMap.Class({

	    /**
	     * APIProperty: offsetFixed
	     * {Boolean} 当前专题图是否固定标记文本或符号的偏移量。所谓固定偏移量，则文本或符号的偏移量不随地图的缩放而变化。默认为 false，表示偏移量随地图的缩放而变化。
	     */
	    offsetFixed: false,

	    /**
	     * APIProperty: offsetX
	     * {String} 专题图中文本或符号相对于要素内点的水平偏移量。偏移量的单位为地图单位。
	     * 该偏移量的值为一个常量值或者字段表达式所表示的值，即如果字段表达式为 SmID，其中 SmID = 2，那么水平偏移量为2。
	     */
	    offsetX: "0.0",

	    /**
	     * APIProperty: offsetY
	     * {String} 专题图中文本或符号相对于要素内点的垂直偏移量。偏移量的单位为地图单位。
	     * 该偏移量的值为一个常量值或者字段表达式所表示的值，即如果字段表达式为 SmID，其中 SmID = 2，那么垂直偏移量为2。
	     */
	    offsetY: "0.0",
	    /**
	     * Constructor: ThemeOffset
	     * 专题图中文本或符号相对于要素内点的偏移量设置类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * offsetFixed - {Boolean} 当前专题图是否固定标记文本或符号的偏移量。
	     * offsetX - {String} 专题图中文本或符号相对于要素内点的水平偏移量。
	     * offsetY - {String} 专题图中文本或符号相对于要素内点的垂直偏移量。
	     */
	    initialize: function (options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.offsetFixed = null;
	        me.offsetX = null;
	        me.offsetY = null;
	    },

	    CLASS_NAME: "ThemeOffset"
	});
	ThemeOffset.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeOffset();
	    SuperMap.Util.copy(res, obj);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeOffset(options);
	};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGraduatedSymbolStyle
	 * 等级符号专题图正负零值显示风格类。
	 * 通过该类可以设置正值的显示风格，零值和或负值的显示风格以及是否显示零值和或负值对应的等级符号。
	 */
	__webpack_require__(4);
	__webpack_require__(77);
	ThemeGraduatedSymbolStyle = SuperMap.Class({
	    
	    /**
	     * APIProperty: negativeDisplayed
	     * {Boolean} 是否显示负值。默认为 false。
	     */
	    negativeDisplayed: false,
	    
	    /**
	     * APIProperty: negativeStyle
	     * {<ServerStyle>} 负值的等级符号风格。
	     */
	    negativeStyle: null,
	    
	    /**
	     * APIProperty: positiveStyle
	     * {<ServerStyle>}正值的等级符号风格。 
	     */
	    positiveStyle: null,
	    
	    /**
	     * APIProperty: zeroDisplayed
	     * {Boolean}  是否显示0值。默认为 false。 
	     */
	    zeroDisplayed: false, 
	    
	    /**
	     * APIProperty: zeroStyle
	     * {<ServerStyle>} 0值的等级符号风格。 
	     */
	    zeroStyle: null,
	    
	    /**
	     * Constructor: ThemeGraduatedSymbolStyle
	     * 等级符号专题图正负零值显示风格类构造函数，用于创建 ThemeGraduatedSymbolStyle 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * negativeDisplayed - {Boolean} 是否显示负值。默认为 false。
	     * negativeStyle - {<ServerStyle>} 负值的等级符号风格。
	     * positiveStyle - {<ServerStyle>}  正值的等级符号风格。
	     * zeroDisplayed - {Boolean} 是否显示0值。默认为 false。 
	     * zeroStyle - {<ServerStyle>} 0值的等级符号风格。  
	     */
	    initialize: function(options) {
	        var me = this;
	        me.negativeStyle = new ServerStyle();
	        me.positiveStyle = new ServerStyle();
	        me.zeroStyle = new ServerStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },
	    
	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function() {
	        var me = this;
	        me.negativeDisplayed = null;
	        me.negativeStyle = null;
	        me.positiveStyle = null;
	        me.zeroDisplayed = null;
	        me.zeroStyle = null;
	    },
	    
	    CLASS_NAME: "ThemeGraduatedSymbolStyle"
	});
	ThemeGraduatedSymbolStyle.fromObj = function(obj) {
	    if(!obj) return;
	    var res = new ThemeGraduatedSymbolStyle();
	    SuperMap.Util.copy(res, obj);
	    res.negativeStyle = ServerStyle.fromJson(obj.negativeStyle);
	    res.positiveStyle = ServerStyle.fromJson(obj.positiveStyle);
	    res.zeroStyle = ServerStyle.fromJson(obj.zeroStyle);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeGraduatedSymbolStyle(options);
	};


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGraph
	 * 统计专题图。
	 * 统计专题图通过为每个要素或记录绘制统计图来反映其对应的专题值的大小。它可同时表示多个字段属性信息，在区域本身与各区域之间形成横向和纵向的对比。
	 * 统计专题图多用于具有相关数量特征的地图上，比如表示不同地区多年的粮食产量、GDP、人口等，不同时段客运量、地铁流量等。允许一次分析多个数值型变量，
	 * 即可以将多个变量的值绘制在一个统计图上。目前提供的统计图类型有：面积图，阶梯图，折线图，点状图，柱状图，三维柱状图，饼图，三维饼图，玫瑰图，
	 * 三维玫瑰图，堆叠柱状图以及三维堆叠柱状图。下图为一幅渤海地区2000年城乡人口比例的统计专题图：
	 *
	 * Inherits from:
	 *  - <Theme>
	 */
	__webpack_require__(4);
	__webpack_require__(79);
	__webpack_require__(82);
	__webpack_require__(83);
	__webpack_require__(86);
	__webpack_require__(88);
	__webpack_require__(89);
	__webpack_require__(90);
	ThemeGraph = SuperMap.Class(Theme, {

	    /**
	     * APIProperty: barWidth
	     * {Number} 柱状专题图中每一个柱的宽度。使用地图坐标单位，默认值为0。
	     * 只有选择的统计图类型为柱状图（柱状图、三维柱状图、堆叠柱状图、三维堆叠柱状图）时，此项才可设置。
	     */
	    barWidth: 0,

	    /**
	     * APIProperty: flow
	     * {<ThemeFlow>} 统计专题图流动显示与牵引线设置。
	     * 通过该字段可以设置统计符号是否流动显示和牵引线风格。
	     */
	    flow: null,

	    /**
	     * APIProperty: graduatedMode
	     * {<GraduatedMode>} 统计图中地理要素的值与图表尺寸间的映射关系（常数、对数、平方根），即分级方式。
	     * 默认值为 GraduatedMode.Constant。
	     * 分级主要是为了减少制作统计专题图中数据大小之间的差异，使得统计图的视觉效果比较好，同时不同类别之间的比较也还是有意义的。
	     * 提供三种分级模式：常数、对数和平方根，对于有值为负数的字段，不可以采用对数和平方根的分级方式。不同的等级方式用于确定符号大小的数值是不相同的。
	     */
	    graduatedMode: GraduatedMode.Constant,

	    /**
	     * APIProperty: graphAxes
	     * {<ThemeGraphAxes>} 用于设置统计图中坐标轴样式相关信息，如坐标轴颜色、是否显示、坐标文本样式等。
	     */
	    graphAxes: null,

	    /**
	     * APIProperty: graphSize
	     * {<ThemeGraphSize>} 用于设置统计符号的最大最小尺寸。
	     */
	    graphSize: null,

	    /**
	     * APIProperty: graphSizeFixed
	     * {Boolean} 缩放地图时统计图符号是否固定大小。默认值为 false，即统计图符号将随地图缩放。
	     */
	    graphSizeFixed: false,

	    /**
	     * APIProperty: graphText
	     * {<ThemeGraphText>} 统计图上的文字是否可以见以及文字标注风格。
	     */
	    graphText: null,

	    /**
	     * APIProperty: graphType
	     * {<ThemeGraphType>} 统计专题图类型。SuperMap 提供了多种类型的统计图，
	     * 分别为面积图、阶梯图、折线图、点状图、柱状图、三维柱状图、饼图、三维饼图、玫瑰图、三维玫瑰图、堆叠柱状图、三维堆叠柱状图、环状图。默认为面积图。
	     */
	    graphType: ThemeGraphType.AREA,

	    /**
	     * APIProperty: graphAxesTextDisplayMode
	     * {<GraphAxesTextDisplayMode>}
	     * 统计专题图坐标轴文本显示模式 。默认值 GraphAxesTextDisplayMode.NONE。
	     */
	    graphAxesTextDisplayMode: GraphAxesTextDisplayMode.NONE,

	    /**
	     * APIProperty: items
	     * {Array(<ThemeGraphItem>)} 统计专题图子项集合。必设字段。
	     * 统计专题图可以基于多个变量，反映多种属性，即可以将多个专题变量的值绘制在一个统计图上。每一个专题变量对应的统计图即为一个专题图子项。
	     * 对于每个专题图子项可以为其设置标题、风格，甚至可以将该子项再制作成范围分段专题图。
	     */
	    items: null,

	    /**
	     * APIProperty: memoryKeys
	     * {Array(Integer)} 以内存数组方式制作专题图时的键数组。
	     * 键数组内的数值代表 SmID 值，它与 ThemeGraphItem 类中的值数组（ThemeGraphItem.memoryDoubleValues） 要关联起来应用。
	     * 键数组中数值的个数必须要与值数组的数值个数一致。值数组中的值将代替原来的专题值来制作统计专题图。
	     * 目前所有的专题图都支持以内存数组的方式制作专题图，但统计专题图与其他专题图指定内存数组的方式不同，
	     * 统计专题图使用 memoryKeys 指定内存数组，而其他专题图则使用 memoryData 来指定内存数组。
	     * (start code)
	     *  memoryKeys的使用方法如：
	     *   function addThemeGraph() {
	     *      removeTheme();
	     *        //创建统计专题图对象，ThemeGraph 必设 items。
	     *       //专题图参数 ThemeParameters 必设 theme（即以设置好的分段专题图对象）、dataSourceName 和 datasetName
	     *      var style1 = new ServerStyle({
	     *                   fillForeColor: new ServerColor(92,73,234),
	     *                   lineWidth: 0.1
	     *               }),
	     *               style2 = new ServerStyle({
	     *                   fillForeColor: new ServerColor(211,111,240),
	     *                   lineWidth: 0.1
	     *               }),
	     *               item1 = new ThemeGraphItem({
	     *                   memoryDoubleValues:[1.18,0.95,0.37,1.31,0.8,1.5],
	     *                  caption: "1992-1995人口增长率",
	     *                  graphExpression: "Pop_Rate95",
	     *                   uniformStyle: style1
	     *               }),
	     *               item2 = new ThemeGraphItem({
	     *               //以内存数组方式制作专题图时的值数组
	     *                   memoryDoubleValues:[2.71,0,0.74,3.1,2.2,3.5],
	     *                   caption: "1995-1999人口增长率",  //专题图子项的名称
	     *                   graphExpression: "Pop_Rate99",  //统计专题图的专题变量
	     *                   uniformStyle: style2      //统计专题图子项的显示风格
	     *               }),
	     *               themeGraph  = new ThemeGraph({
	     *               //以内存数组方式制作专题图时的键数组，键数组内的数值代表 SmID 值
	     *                    memoryKeys:[1,2,4,8,10,12],
	     *                   items: new Array(item1,item2),
	     *                   barWidth: 0.03,
	     *                    //统计图中地理要素的值与图表尺寸间的映射关系为平方根
	     *                   graduatedMode: GraduatedMode.SQUAREROOT,
	     *                   //graphAxes用于设置统计图中坐标轴样式相关信息
	     *                   graphAxes: new ThemeGraphAxes({
	     *                       axesDisplayed: true
	     *                   }),
	     *                   graphSize: new ThemeGraphSize({
	     *                       maxGraphSize: 1,
	     *                       minGraphSize: 0.35
	     *                   }),
	     *                   //统计图上的文字是否可以见以及文字标注风格
	     *                   graphText: new ThemeGraphText({
	     *                       graphTextDisplayed: true,
	     *                       graphTextFormat: ThemeGraphTextFormat.VALUE,
	     *                       graphTextStyle: new ServerTextStyle({
	     *                           sizeFixed: true,
	     *                           fontHeight: 9,
	     *                           fontWidth: 5
	     *                       })
	     *                   }),
	     *                   //统计专题图类型为三维柱状图
	     *                   graphType: ThemeGraphType.BAR3D
	     *               }),
	     * //专题图参数对象
	     *               themeParameters = new ThemeParameters({
	     *                   themes: [themeGraph],
	     *                   dataSourceNames: ["Jingjin"],
	     *                   datasetNames: ["BaseMap_R"]
	     *               }),
	     *    //与服务端交互
	     *               themeService=new SuperMap.REST.ThemeService(url, {
	     *                   eventListeners: {
	     *                       "processCompleted": ThemeCompleted,
	     *                        "processFailed": themeFailed
	     *                  }
	     *              });
	     *       themeService.processAsync(themeParameters);
	     *   }
	     * (end)
	     */
	    memoryKeys: null,

	    /**
	     * APIProperty: negativeDisplayed
	     * {Boolean} 专题图中是否显示属性为负值的数据。true 表示显示；默认为 false 即不显示。
	     */
	    negativeDisplayed: false,

	    /**
	     * APIProperty: offset
	     * {<ThemeOffset>} 用于设置统计图相对于要素内点的偏移量。
	     */
	    offset: null,

	    /**
	     * APIProperty: overlapAvoided
	     * {Boolean} 统计图是否采用避让方式显示。
	     * 1.对数据集制作统计专题图:当统计图采用避让方式显示时，如果 overlapAvoided 为 true，则在统计图重叠度很大的情况下，
	     * 会出现无法完全避免统计图重叠的现象；如果 overlapAvoided 为 false，会过滤掉一些统计图，从而保证所有的统计图均不重叠。
	     * 2.对数据集同时制作统计专题图和标签专题图：当统计图不显示子项文本时，标签专题图的标签即使和统计图重叠，两者也都可正常显示；
	     * 当统计图显示子项文本时，如果统计图中的子项文本和标签专题图中的标签不重叠，则两者均正常显示；如果重叠，则会过滤掉统计图的子项文本，只显示标签。
	     *
	     */
	    overlapAvoided: true,

	    /**
	     * APIProperty: roseAngle
	     * {Number} 统计图中玫瑰图或三维玫瑰图用于等分的角度，默认为0度，精确到0.1度。在角度为0或者大于360度的情况下均使用360度来等分制作统计图的字段数。
	     */
	    roseAngle: 0,

	    /**
	     * APIProperty: startAngle
	     * {Number} 饼状统计图扇形的起始角度。默认为0度，精确到0.1度，以水平方向为正向。只有选择的统计图类型为饼状图（饼图、三维饼图、玫瑰图、三维玫瑰图）时，此项才可设置。
	     */
	    startAngle: 0,


	    /**
	     * Constructor: ThemeGraph
	     * 统计专题图构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * barWidth - {Number} 柱状专题图中每一个柱的宽度。
	     * flow - {<ThemeFlow>} 统计专题图流动显示与牵引线设置。
	     * graduatedMode - {<GraduatedMode>} 统计图中地理要素的值与图表尺寸间的映射关系。
	     * graphAxes - {<ThemeGraphAxes>} 统计图中坐标轴样式相关信息。
	     * graphSize - {<ThemeGraphSize>} 统计符号的最大最小尺寸。
	     * graphSizeFixed - {Boolean} 缩放地图时统计图符号是否固定大小。
	     * graphText - {<ThemeGraphText>} 统计图上的文字是否可以见以及文字标注风格。
	     * graphType - {<ThemeGraphType>} 统计专题图类型。
	     * items - {Array(<ThemeGraphItem>)} 统计专题图子项集合。
	     * memoryKeys - {Array(Integer)} 以内存数组方式制作专题图时的键数组。
	     * negativeDisplayed - {Boolean} 专题图中是否显示属性为负值的数据。
	     * offset - {<ThemeOffset>} 统计图相对于要素内点的偏移量。
	     * overlapAvoided - {Boolean} 统计图是否采用避让方式显示。
	     * roseAngle - {Number} 统计图中玫瑰图或三维玫瑰图用于等分的角度。
	     * startAngle - {Number} 饼状统计图扇形的起始角度。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.flow = new ThemeFlow();
	        me.graphAxes = new ThemeGraphAxes();
	        me.graphSize = new ThemeGraphSize();
	        me.graphText = new ThemeGraphText();
	        me.offset = new ThemeOffset();
	        Theme.prototype.initialize.apply(this, ["GRAPH", options]);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        Theme.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.barWidth = null;
	        if (me.flow) {
	            me.flow.destroy();
	            me.flow = null;
	        }
	        me.graduatedMode = null;
	        if (me.graphAxes) {
	            me.graphAxes.destroy();
	            me.graphAxes = null;
	        }
	        if (me.graphSize) {
	            me.graphSize.destroy();
	            me.graphSize = null;
	        }
	        me.graphSizeFixed = null;
	        if (me.graphText) {
	            me.graphText.destroy();
	            me.graphText = null;
	        }
	        me.graphType = null;
	        if (me.items) {
	            for (var i = 0, items = me.items, len = items.length; i < len; i++) {
	                items[i].destroy();
	            }
	            me.items = null;
	        }
	        me.memoryKeys = null;
	        me.negativeDisplayed = null;
	        if (me.offset) {
	            me.offset.destroy();
	            me.offset = null;
	        }
	        me.overlapAvoided = null;
	        me.roseAngle = null;
	        me.startAngle = null;
	        me.graphAxesTextDisplayMode = null;
	    },

	    /**
	     * Method: toJSON
	     * 将ThemeGraph对象转化为json字符串。
	     *
	     * Returns:
	     * {String} 返回转换后的 JSON 字符串。
	     */
	    toJSON: function () {
	        return SuperMap.Util.toJSON(this.toServerJSONObject());
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = new Object();
	        obj.type = this.type;
	        if (this.graphText) {
	            obj.graphTextDisplayed = this.graphText.graphTextDisplayed;
	            obj.graphTextFormat = this.graphText.graphTextFormat;
	            obj.graphTextStyle = this.graphText.graphTextStyle;
	        }
	        if (this.flow) {
	            obj.flowEnabled = this.flow.flowEnabled;
	            obj.leaderLineDisplayed = this.flow.leaderLineDisplayed;
	            obj.leaderLineStyle = this.flow.leaderLineStyle;
	        }
	        if (this.graphAxes) {
	            obj.axesColor = this.graphAxes.axesColor;
	            obj.axesDisplayed = this.graphAxes.axesDisplayed;
	            obj.axesGridDisplayed = this.graphAxes.axesGridDisplayed;
	            obj.axesTextDisplayed = this.graphAxes.axesTextDisplayed;
	            obj.axesTextStyle = this.graphAxes.axesTextStyle;
	        }
	        if (this.graphSize) {
	            obj.maxGraphSize = this.graphSize.maxGraphSize;
	            obj.minGraphSize = this.graphSize.minGraphSize;
	        }
	        if (this.offset) {
	            obj.offsetFixed = this.offset.offsetFixed;
	            obj.offsetX = this.offset.offsetX;
	            obj.offsetY = this.offset.offsetY;
	        }
	        obj.barWidth = this.barWidth;
	        obj.graduatedMode = this.graduatedMode;
	        obj.graphSizeFixed = this.graphSizeFixed;
	        obj.graphType = this.graphType;
	        obj.graphAxesTextDisplayMode = this.graphAxesTextDisplayMode;
	        obj.items = this.items;
	        obj.memoryKeys = this.memoryKeys;
	        obj.negativeDisplayed = this.negativeDisplayed;
	        obj.overlapAvoided = this.overlapAvoided;
	        obj.roseAngle = this.roseAngle;
	        obj.startAngle = this.startAngle;
	        return obj;
	    },
	    CLASS_NAME: "ThemeGraph"
	});

	ThemeGraph.fromObj = function (obj) {
	    var res = new ThemeGraph();
	    var itemsG = obj.items;
	    var len = itemsG ? itemsG.length : 0;
	    SuperMap.Util.copy(res, obj);
	    res.items = [];
	    res.flow = ThemeFlow.fromObj(obj);
	    res.graphAxes = ThemeGraphAxes.fromObj(obj);
	    res.graphSize = ThemeGraphSize.fromObj(obj);
	    res.graphText = ThemeGraphText.fromObj(obj);
	    res.offset = ThemeOffset.fromObj(obj);
	    for (var i = 0; i < len; i++) {
	        res.items.push(ThemeGraphItem.fromObj(itemsG[i]));
	    }
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeGraph(options);
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGraphAxes
	 * 统计专题图坐标轴样式类。
	 * 该类用于设置统计图中坐标轴样式相关信息，如坐标轴颜色、是否显示、坐标文本样式等。
	 */
	__webpack_require__(4);
	__webpack_require__(78);
	__webpack_require__(87);
	ThemeGraphAxes = SuperMap.Class({

	    /**
	     * APIProperty: axesColor
	     * {<ServerColor>} 坐标轴颜色，默认为黑色。当 axesDisplayed = true 时有效。
	     */
	    axesColor: null,

	    /**
	     * APIProperty: axesDisplayed
	     * {Boolean} 是否显示坐标轴。默认为 false，即不显示。
	     * 由于饼状图和环状图无坐标轴，故该属性以及所有与坐标轴设置相关的属性都不适用于它们。并且只有当该值为 true 时，其它设置坐标轴的属性才起作用。
	     */
	    axesDisplayed: false,

	    /**
	     * APIProperty: axesGridDisplayed
	     * {Boolean} 是否在统计图坐标轴上显示网格。默认为 false，即不显示。
	     */
	    axesGridDisplayed: false,

	    /**
	     * APIProperty: axesTextDisplayed
	     * {Boolean} 是否显示坐标轴的文本标注。默认为 false，即不显示。
	     */
	    axesTextDisplayed: false,

	    /**
	     * APIProperty: axesTextStyle
	     * {<ServerTextStyle>} 坐标轴文本风格。当 axesTextDisplayed = true 时有效。
	     */
	    axesTextStyle: null,

	    /**
	     * Constructor: ThemeGraphAxes
	     * 统计专题图坐标轴样式类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * axesColor - {<ServerColor>} 坐标轴颜色。
	     * axesDisplayed - {Boolean} 是否显示坐标轴。
	     * axesGridDisplayed - {Boolean} 是否在统计图坐标轴上显示网格。
	     * axesTextDisplayed - {Boolean} 是否显示坐标轴的文本标注。
	     * axesTextStyle - {<ServerTextStyle>} 统计符号的最大最小尺寸。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.axesColor = new ServerColor(0, 0, 0);
	        me.axesTextStyle = new ServerTextStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.axesColor) {
	            me.axesColor.destroy();
	            me.axesColor = null;
	        }
	        me.axesDisplayed = null;
	        me.axesGridDisplayed = null;
	        me.axesTextDisplayed = null;
	        if (me.axesTextStyle) {
	            me.axesTextStyle.destroy();
	            me.axesTextStyle = null;
	        }
	    },

	    CLASS_NAME: "ThemeGraphAxes"
	});
	ThemeGraphAxes.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeGraphAxes();
	    SuperMap.Util.copy(res, obj);
	    res.axesColor = ServerColor.fromJson(obj.axesColor);
	    res.axesTextStyle = ServerTextStyle.fromObj(obj.axesTextStyle);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeGraphAxes(options);
	};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ServerTextStyle
	 * 服务端文本风格类
	 * 该类用于定义文本风格的相关属性。
	 */
	__webpack_require__(4);
	__webpack_require__(78);
	ServerTextStyle = SuperMap.Class({

	    /**
	     * APIProperty: align
	     * {<TextAlignment>} 文本的对齐方式。
	     * 默认为 SuperMap.Web.REST.TextAlignment.BASELINECENTER（基准线居中对齐）。
	     */
	    align: TextAlignment.BASELINECENTER,

	    /**
	     * APIProperty: backColor
	     * {<ServerColor>} 文本的背景色。
	     * 默认为白色。
	     */
	    backColor: null,

	    /**
	     * APIProperty: foreColor
	     * {<ServerColor>} 文本的前景色。
	     * 默认为黑色。
	     */
	    foreColor: null,

	    /**
	     * APIProperty: backOpaque
	     * {Boolean} 文本背景是否不透明。
	     * true 表示文本背景不透明。
	     */
	    backOpaque: false,

	    /**
	     * APIProperty: sizeFixed
	     * {Boolean} 文本大小是否固定。
	     * 默认为 true，表示图片为固定像素大小，具体大小请参考 fontHeight 。
	     * 当设为 false 时，图片会随着地图缩放而缩放。
	     */
	    sizeFixed: true,

	    /**
	     * APIProperty: fontHeight
	     * {Number} 文本字体的高度，默认为6，
	     * 单位与 sizeFixed 有关，当 sizeFixed 为 False 时，即非固定文本大小时使用地图坐标单位，
	     * 如地理坐标系下的地图中单位为度；当 sizeFixed 为 True 时，单位为毫米（mm）。
	     */
	    fontHeight: 6,

	    /**
	     * APIProperty: fontWidth
	     * {Number} 文本字体的宽度。
	     * 字体的宽度以英文字符为标准，由于一个中文字符相当于两个英文字符，默认为0地图坐标单位。
	     */
	    fontWidth: 0,

	    /**
	     * APIProperty: fontWeight
	     * {Integer} 文本字体的磅数。
	     * 表示粗体的具体数值。取值范围为从0－900之间的整百数，默认值为400。
	     */
	    fontWeight: 400,

	    /**
	     * APIProperty: fontName
	     * {String} 文本字体的名称。
	     * 默认值为 Times New Roman。
	     */
	    fontName: "Times New Roman",

	    /**
	     * APIProperty: bold
	     * {Boolean} 文本是否为粗体字。
	     * true 表示为粗体。默认值为 false，即文本不是粗体字。
	     */
	    bold: false,

	    /**
	     * APIProperty: italic
	     * {Boolean}文本是否采用斜体。
	     * true 表示采用斜体。默认为 false。
	     */
	    italic: false,

	    /**
	     * APIProperty: italicAngle
	     * {Number} 字体倾斜角度。
	     * 正负度之间，以度为单位，精确到0.1度，默认为0度。当倾斜角度为0度，为系统默认的字体倾斜样式。正负度是指以纵轴为起始零度线，其纵轴左侧为正，右侧为负。允许的最大角度为60，最小-60。大于60按照60处理，小于-60按照-60处理。目前只对标签专题图有效。
	     */
	    italicAngle: 0,

	    /**
	     * APIProperty: shadow
	     * {Boolean} 文本是否有阴影。
	     * true 表示给文本增加阴影。默认值为 false，即文本没有阴影。
	     */
	    shadow: false,

	    /**
	     * APIProperty: strikeout
	     * {Boolean} 文本字体是否加删除线。
	     * true 表示加删除线。默认值为 false，即文本字体不加删除线。
	     */
	    strikeout: false,

	    /**
	     * APIProperty: outline
	     * {Boolean} 是否以轮廓的方式来显示文本的背景。
	     * true 表示以轮廓的方式来显示文本的背景。默认值为 false，表示不以轮廓的方式来显示文本的背景。
	     */
	    outline: false,

	    /**
	     * APIProperty: opaqueRate
	     * {Number} 注记文字的不透明度。
	     * 不透明度的范围为0-100。默认为0，表示透明。
	     */
	    opaqueRate: 0,

	    /**
	     * APIProperty: underline
	     * {Boolean} 文本字体是否加下划线。
	     * true 表示加下划线。默认为 false。
	     */
	    underline: false,

	    /**
	     * APIProperty: rotation
	     * {Number} 文本旋转的角度。
	     * 逆时针方向为正方向，单位为度，精确到0.1度。默认值为0.0。
	     */
	    rotation: 0.0,

	    /**
	     * Constructor: ServerTextStyle
	     * 服务端文本风格类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * align - {<TextAlignment>} 文本的对齐方式。
	     * backColor - {<ServerColor>} 文本的背景色。
	     * foreColor - {<ServerColor>} 文本的前景色。
	     * backOpaque - {Boolean} 文本背景是否不透明。
	     * sizeFixed - {Boolean} 文本大小是否固定。
	     * fontHeight - {Number} 文本字体的高度。
	     * fontWidth - {Number} 文本字体的宽度。
	     * fontWeight - {Integer} 文本字体的磅数。
	     * fontName - {String} 文本字体的名称。
	     * bold - {Boolean} 文本是否为粗体字。
	     * italic - {Boolean}文本是否采用斜体。
	     * italicAngle - {Number} 字体倾斜角度。
	     * shadow - {Boolean} 文本是否有阴影。
	     * strikeout - {Boolean} 文本字体是否加删除线。
	     * outline - {Boolean} 是否以轮廓的方式来显示文本的背景。
	     * opaqueRate - {Number} 注记文字的不透明度。
	     * underline - {Boolean} 文本字体是否加下划线。
	     * rotation -  {Number} 文本旋转的角度。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.backColor = new ServerColor(255, 255, 255);
	        me.foreColor = new ServerColor(0, 0, 0);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.align = null;
	        if (me.backColor) {
	            me.backColor.destroy();
	            me.backColor = null;
	        }
	        if (me.foreColor) {
	            me.foreColor.destroy();
	            me.foreColor = null;
	        }
	        me.backOpaque = null;
	        me.sizeFixed = null;
	        me.fontHeight = null;
	        me.fontWidth = null;
	        me.fontWeight = null;
	        me.fontName = null;
	        me.bold = null;
	        me.italic = null;
	        me.italicAngle = null;
	        me.shadow = null;
	        me.strikeout = null;
	        me.outline = null;
	        me.opaqueRate = null;
	        me.underline = null;
	        me.rotation = null;
	    },

	    CLASS_NAME: "ServerTextStyle"
	});

	ServerTextStyle.fromObj = function (obj) {
	    var res = new ServerTextStyle(obj);
	    SuperMap.Util.copy(res, obj);
	    res.backColor = ServerColor.fromJson(obj.backColor);
	    res.foreColor = ServerColor.fromJson(obj.foreColor);
	    return res;
	};
	module.exports = function (options) {
	    return new ServerTextStyle(options);
	};



/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGraphSize
	 * 统计专题图符号尺寸类。
	 * 通过该类可以设置统计专题图符号最小和最大的基准尺寸。专题图表的尺寸大小与基准值、分级方式及专题字段值的大小都有着紧密联系。
	 * 它是利用指定的分级方式，最大基准值、最小基准值以及字段的最大值和最小值计算统计图中各个值对应的图表尺寸的大小。
	 */
	__webpack_require__(4);
	ThemeGraphSize = SuperMap.Class({

	    /**
	     * APIProperty: maxGraphSize
	     * {Number} 获取或设置统计图中显示的最大图表尺寸基准值，默认为0像素。
	     */
	    maxGraphSize: 0,

	    /**
	     * APIProperty: minGraphSize
	     * {Number} 获取或设置统计图中显示的最小图表尺寸基准值，默认为0像素。
	     */
	    minGraphSize: 0,

	    /**
	     * Constructor: ThemeGraphSize
	     * 统计专题图符号尺寸类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * maxGraphSize - {Number} 统计图中显示的最大图表尺寸基准值。
	     * minGraphSize - {Number} 统计图中显示的最小图表尺寸基准值。
	     */
	    initialize: function (options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.maxGraphSize = null;
	        me.minGraphSize = null;
	    },

	    CLASS_NAME: "ThemeGraphSize"
	});
	ThemeGraphSize.fromObj = function (obj) {
	    var res = new ThemeGraphSize();
	    SuperMap.Util.copy(res, obj);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeGraphSize(options);
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGraphText
	 * 统计图文字标注风格类。
	 * 通过该类可以设置统计图表中文字可见性以及标注风格。
	 */
	__webpack_require__(4);
	__webpack_require__(87);
	ThemeGraphText = SuperMap.Class({

	    /**
	     * APIProperty: graphTextDisplayed
	     * {Boolean} 是否显示统计图上的文字标注。默认为 false，即不显示。
	     */
	    graphTextDisplayed: false,

	    /**
	     * APIProperty: graphTextFormat
	     * {<ThemeGraphTextFormat>} 统计专题图文本显示格式。
	     * 文本显示格式包括百分数、真实数值、标题、标题+百分数、标题+真实数值。默认为 ThemeGraphTextFormat.CAPTION。
	     */
	    graphTextFormat: ThemeGraphTextFormat.CAPTION,

	    /**
	     * APIProperty: graphTextStyle
	     * {<ServerTextStyle>}统计图上的文字标注风格。
	     */
	    graphTextStyle: null,
	    /**
	     * Constructor: ThemeGraphText
	     * 统计图文字标注风格类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * graphTextDisplayed - {Boolean} 是否显示统计图上的文字标注。
	     * graphTextFormat - {<ThemeGraphTextFormat>} 统计专题图文本显示格式。
	     * graphTextStyle - {<ServerTextStyle>} 统计图上的文字标注风格。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.graphTextStyle = new ServerTextStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.graphTextDisplayed = null;
	        me.graphTextFormat = null;
	        if (me.graphTextStyle) {
	            me.graphTextStyle.destroy();
	            me.graphTextStyle = null;
	        }
	    },

	    CLASS_NAME: "ThemeGraphText"
	});
	ThemeGraphText.fromObj = function (obj) {
	    var res = new ThemeGraphText();
	    SuperMap.Util.copy(res, obj);
	    res.graphTextStyle = ServerTextStyle.fromObj(obj.graphTextStyle);
	    return res;

	};
	module.exports = function (options) {
	    return new ThemeGraphText(options);
	};


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGraphItem
	 * 统计专题图子项类。
	 * 统计专题图可以基于多个变量，反映多种属性，即可以将多个专题变量的值绘制在一个统计图上。每一个专题变量对应的统计图即为一个专题图子项。
	 * 该类用来设置每个统计专题图子项的名称，专题变量，显示风格，甚至可以将该子项再制作成范围分段专题图。
	 */
	__webpack_require__(4);
	__webpack_require__(77);
	ThemeGraphItem = SuperMap.Class({

	    /**
	     * APIProperty: caption
	     * {String} 专题图子项的名称。
	     */
	    caption: null,

	    /**
	     * APIProperty: graphExpression
	     * {String} 统计专题图的专题变量。专题变量可以是一个字段或字段表达式。字段必须为数值型；表达式只能为数值型的字段间的运算。必设字段。
	     */
	    graphExpression: null,

	    /**
	     * APIProperty: memoryDoubleValues
	     * {Array(Number)} 内存数组方式制作专题图时的值数组。
	     * 内存数组方式制作专题图时，只对 SmID 值在键数组（ThemeGraph.memoryKeys）中的记录制作专题图。
	     * 值数组的数值个数必须与键数组中数值的个数一致。 值数组中的值将代替原来的专题值来制作统计专题图。
	     * 比如：利用面积字段和周长字段（即有两个统计专题图子项 ）作为专题变量制作统计专题图。
	     */
	    memoryDoubleValues: null,

	    /**
	     * APIProperty: uniformStyle
	     * {<ServerStyle>} 统计专题图子项的显示风格。
	     * 每一个统计专题图子项都对应一种显示风格。
	     */
	    uniformStyle: null,

	    /**
	     * Constructor: ThemeGraphItem
	     * 统计专题图子项类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * caption - {String} 专题图子项的名称。
	     * graphExpression - {String} 统计专题图的专题变量。
	     * memoryDoubleValues - {Array(Number)} 内存数组方式制作专题图时的值数组。
	     * uniformStyle - {<ServerStyle>} 统计专题图子项的显示风格。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.uniformStyle = new ServerStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.caption = null;
	        me.graphExpression = null;
	        me.memoryDoubleValues = null;
	        me.uniformStyle = null;
	    },

	    CLASS_NAME: "ThemeGraphItem"
	});
	ThemeGraphItem.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeGraphItem();
	    SuperMap.Util.copy(res, obj);
	    res.uniformStyle = ServerStyle.fromJson(obj.uniformStyle);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeGraphItem(options);
	};


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeLabel
	 * 标签专题图。
	 * 标签专题图是用文本的形式在图层中显示点、线、面等对象的属性信息，一般将文本型或数值型字段标注于图层中，如地名、道路名称、河流等级、宽度等信息。
	 * 这里需要注意的是地图上一般还会出现图例说明，图名，比例尺等等，这些都是制图元素，不属于标签专题图标注的范畴。标签专题图有两种表现形式:
	 * 第一种 统一标签专题图，即将指定图层的表达式的所有值使用统一的风格输出，labelExpression 用于设定标签专题图所使用的字段。
	 * 第二种 为分段标签专题图。它仍然使用 labelExpression 设定标签专题图显示的字段值，通过 rangeExpression 指定数字型的字段作为分段数据，items 中的每
	 * 个子对象的 [start，end) 分段值必须来源于属性 rangeExpression 的字段值，并在 items 中为每个或部分分段子项自定义特殊的风格。
	 *
	 * Inherits from:
	 *  - <Theme>
	 */
	__webpack_require__(4);
	__webpack_require__(79);
	__webpack_require__(82);
	__webpack_require__(83);
	__webpack_require__(92);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(96);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);

	ThemeLabel = SuperMap.Class(Theme, {

	    /**
	     * APIProperty: alongLine
	     * {<ThemeLabelAlongLine>} 标签沿线标注方向样式类。
	     * 在该类中可以设置标签是否沿线标注以及沿线标注的多种方式。沿线标注属性只适用于线数据集专题图。
	     */
	    alongLine: null,

	    /**
	     * APIProperty: background
	     * {<ThemeLabelBackground>} 标签专题图中标签的背景风格类。通过该字段可以设置标签的背景形状和风格。
	     */
	    background: null,

	    /**
	     * APIProperty: flow
	     * {<ThemeFlow>} 标签专题图标签流动显示与牵引线设置类。通过该字段可以设置标签是否流动显示和牵引线风格。
	     */
	    flow: null,

	    /**
	     * APIProperty: items
	     * {Array(<ThemeLabelItem>)} 分段标签专题图的子项数组。分段标签专题图使用 rangeExpression
	     * 指定数字型的字段作为分段数据，items 中的每个子对象的 [start，end) 分段值必须来源于属性 rangeExpression 的字段值。每个子项拥有自己的风格。
	     */
	    items: null,

	    /**
	     * APIProperty: uniqueItems
	     * {Array(<ThemeLabelUniqueItem>)} 单值标签专题图子项数组。单值标签专题图使用 uniqueExpression
	     * 单值标签专题图子项集合
	     */
	    uniqueItems: null,

	    /**
	     * APIProperty: labelExpression
	     * {String} 标注字段表达式。系统将 labelExpression 对应的字段或字段表达式的值以标签的形式显示在图层中。必设字段。
	     */
	    labelExpression: null,

	    /**
	     * APIProperty: labelOverLengthMode
	     * {<LabelOverLengthMode>} 标签专题图中超长标签的处理模式枚举类。
	     * 对于标签的长度超过设置的标签最大长度 maxLabelLength 时称为超长标签。默认为 LabelOverLengthMode.NONE。
	     */
	    labelOverLengthMode: LabelOverLengthMode.NONE,

	    /**
	     * APIProperty: matrixCells
	     * {Array(<LabelMatrixCell>)} 矩阵标签元素数组，用于制作矩阵标签专题图。
	     * 数组中可以放置符号类型的矩阵标签元素和图片类型的矩阵标签元素。
	     */
	    matrixCells: null,

	    /**
	     * APIProperty: maxLabelLength
	     * {Number} 标签在每一行显示的最大长度，一个中文为两个字符。
	     * 如果超过最大长度，可以采用两种方式来处理，一种是换行的模式进行显示，另一种是以省略号方式显示。默认最大长度为256个字符。
	     */
	    maxLabelLength: 256,

	    /**
	     * APIProperty: numericPrecision
	     * {Number} 如果显示的标签内容为数字，通过该字段设置其显示的精度。例如标签对应的数字是8071.64529347，
	     * 如果该属性为0时，显示8071；为1时，显示8071.6；为3时，则是8071.645。
	     */
	    numericPrecision: 0,

	    /**
	     * APIProperty: offset
	     * {<ThemeOffset>} 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。
	     */
	    offset: null,

	    /**
	     * APIProperty: overlapAvoided
	     * {Boolean} 是否允许以文本避让方式显示文本。默认值为 true， 即自动避免文本叠盖。只针对该标签专题图层中的文本数据。
	     * 在标签重叠度很大的情况下，即使使用自动避让功能，可能也无法完全避免标签重叠现象。
	     */
	    overlapAvoided: true,

	    /**
	     * APIProperty: rangeExpression
	     * {String} 制作分段标签专题的分段字段或字段表达式。该表达式对应的字段（或者字段表达式）的值应该为数值型。
	     * 该字段与 items 分段子项联合使用，每个子项的起始值 [start，end)来源于 rangeExpression 字段值。
	     * 最后 labelExpression 指定的标签字段（标签专题图要显示的具体内容）会根据分段子项的风格进行分段显示。
	     */
	    rangeExpression: null,

	    /**
	     * APIProperty: uniqueExpression
	     * {String} 用于制作单值专题图的字段或字段表达式。
	     * 该字段值的数据类型可以为数值型或字符型。如果设置字段表达式，只能是相同数据类型字段间的运算。必设字段,必须与labelExpression一起使用
	     */
	    uniqueExpression: null,

	    /**
	     * APIProperty: smallGeometryLabeled
	     * {Boolean} 是否显示长度大于被标注对象本身长度的标签，默认为 false。在标签的长度大于线或者面对象本身的长度时，
	     * 如果该值为 true，则标签文字会叠加在一起显示，为了清楚完整的显示该标签，
	     * 可以采用换行模式来显示标签，但必须保证每行的长度小于对象本身的长度。
	     */
	    smallGeometryLabeled: false,

	    /**
	     * APIProperty: text
	     * {<ThemeLabelText>} 标签中文本风格。
	     */
	    text: null,

	    /**
	     * Constructor: ThemeLabel
	     * 标签专题图构造函数，用于创建 ThemeLabel 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * alongLine - {<ThemeLabelAlongLine>} 标签沿线标注方向样式类。
	     * background - {<ThemeLabelBackground>} 标签专题图中标签的背景风格类。
	     * flow - {<ThemeFlow>} 标签专题图标签流动显示与牵引线设置类。
	     * items - {Array(<ThemeLabelItem>)} 分段标签专题图的子项数组。
	     * labelExpression - {String} 标注字段表达式。
	     * labelOverLengthMode - {<LabelOverLengthMode>} 标签专题图中超长标签的处理模式枚举类。
	     * matrixCells - {Array(<LabelMatrixCell>)} 矩阵标签元素数组。
	     * maxLabelLength - {Number>} 标签在每一行显示的最大长度。
	     * numericPrecision - {Number} 通过该字段设置其显示的精度。
	     * offset - {<ThemeOffset>} 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。
	     * overlapAvoided - {Boolean} 是否允许以文本避让方式显示文本。
	     * rangeExpression - {String} 制作分段标签专题的分段字段或字段表达式。
	     * smallGeometryLabeled - {Boolean} 是否显示长度大于被标注对象本身长度的标签。
	     * text - {<ThemeLabelText>} 标签中文本风格。
	     * memoryData - {<ThemeMemoryData>} 专题图内存数据。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.alongLine = new ThemeLabelAlongLine();
	        me.background = new ThemeLabelBackground();
	        me.flow = new ThemeFlow();
	        me.offset = new ThemeOffset();
	        me.text = new ThemeLabelText();
	        Theme.prototype.initialize.apply(this, ["LABEL", options]);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        Theme.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.alongLine = null;
	        if (me.background) {
	            me.background.destroy();
	            me.background = null;
	        }
	        me.flow = null;
	        if (me.items) {
	            for (var i = 0, items = me.items, len = items.length; i < len; i++) {
	                items[i].destroy();
	            }
	            me.items = null;
	        }
	        if (me.uniqueItems) {
	            for (var j = 0, uniqueItems = me.uniqueItems, uniqueLen = uniqueItems.length; j < uniqueLen; j++) {
	                uniqueItems[j].destory();
	            }
	            me.uniqueItems = null;
	        }
	        me.labelExpression = null;
	        me.labelOverLengthMode = null;
	        me.matrixCells = null;
	        me.maxLabelLength = null;
	        me.numericPrecision = null;
	        me.overlapAvoided = null;
	        me.rangeExpression = null;
	        me.uniqueExpression = null;
	        if (me.offset) {
	            me.offset.destroy();
	            me.offset = null;
	        }
	        me.overlapAvoided = null;
	        me.smallGeometryLabeled = null;
	        if (me.text) {
	            me.text.destroy();
	            me.text = null;
	        }
	    },


	    /**
	     * Method: toJSON
	     * 将themeLabel对象转化为json字符串。
	     *
	     * Returns:
	     * {String} 返回转换后的 JSON 字符串。
	     */
	    toJSON: function () {
	        return SuperMap.Util.toJSON(this.toServerJSONObject());
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = new Object();
	        obj.type = this.type;
	        obj.memoryData = this.memoryData;
	        if (this.alongLine) {
	            obj.alongLine = this.alongLine.isAlongLine;
	            obj.alongLineDirection = this.alongLine.alongLineDirection;
	            obj.angleFixed = this.alongLine.angleFixed;
	            obj.isLabelRepeated = this.alongLine.isLabelRepeated;
	            obj.labelRepeatInterval = this.alongLine.labelRepeatInterval;
	            obj.repeatedLabelAvoided = this.alongLine.repeatedLabelAvoided;
	            obj.repeatIntervalFixed = this.alongLine.repeatIntervalFixed;
	        }
	        if (this.offset) {
	            obj.offsetFixed = this.offset.offsetFixed;
	            obj.offsetX = this.offset.offsetX;
	            obj.offsetY = this.offset.offsetY;
	        }

	        if (this.flow) {
	            obj.flowEnabled = this.flow.flowEnabled;
	            obj.leaderLineDisplayed = this.flow.leaderLineDisplayed;
	            obj.leaderLineStyle = this.flow.leaderLineStyle;
	        }
	        if (this.text) {
	            obj.maxTextHeight = this.text.maxTextHeight;
	            obj.maxTextWidth = this.text.maxTextWidth;
	            obj.minTextHeight = this.text.minTextHeight;
	            obj.minTextWidth = this.text.minTextWidth;
	            obj.uniformStyle = this.text.uniformStyle;
	            obj.uniformMixedStyle = this.text.uniformMixedStyle;
	        }
	        if (this.background) {
	            obj.labelBackShape = this.background.labelBackShape;
	            obj.backStyle = this.background.backStyle;
	        }
	        obj.labelOverLengthMode = this.labelOverLengthMode;
	        obj.maxLabelLength = this.maxLabelLength;
	        obj.smallGeometryLabeled = this.smallGeometryLabeled;
	        obj.rangeExpression = this.rangeExpression;
	        obj.uniqueExpression = this.uniqueExpression;
	        obj.numericPrecision = this.numericPrecision;
	        obj.items = this.items;
	        obj.uniqueItems = this.uniqueItems;
	        obj.labelExpression = this.labelExpression;
	        obj.overlapAvoided = this.overlapAvoided;
	        obj.matrixCells = this.matrixCells;
	        return obj;
	    },

	    CLASS_NAME: "ThemeLabel"
	});
	ThemeLabel.fromObj = function (obj) {
	    if (!obj) return;
	    var lab = new ThemeLabel();
	    var itemsL = obj.items, itemsU = obj.uniqueItems, cells = obj.matrixCells;
	    obj.matrixCells = null;
	    SuperMap.Util.copy(lab, obj);
	    lab.alongLine = ThemeLabelAlongLine.fromObj(obj);
	    lab.background = ThemeLabelBackground.fromObj(obj);
	    lab.flow = new ThemeFlow({flowEnabled: obj.flowEnabled, leaderLineDisplayed: obj.leaderLineDisplayed, leaderLineStyle: obj.leaderLineStyle});
	    if (itemsL) {
	        lab.items = [];
	        for (var i = 0, len = itemsL.length; i < len; i++) {
	            lab.items.push(ThemeLabelItem.fromObj(itemsL[i]));
	        }
	    }
	    if (itemsU) {
	        lab.uniqueItems = [];
	        for (var j = 0, uniqueLen = itemsU.length; j < uniqueLen; j++) {
	            lab.uniqueItems.push(ThemeUniqueItem.fromObj(itemsU[j]));
	        }
	    }
	    if (cells) {
	        lab.matrixCells = [];
	        for (var i = 0, len = cells.length; i < len; i++) {
	            //TODO
	            //lab.matrixCells.push(LabelMatrixCell.fromObj(cells[i])); 
	        }
	    }
	    lab.offset = ThemeOffset.fromObj(obj);
	    lab.text = ThemeLabelText.fromObj(obj);
	    return lab;
	};
	module.exports = function (options) {
	    return new ThemeLabel(options);
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeLabelItem
	 * 分段标签专题图的子项。
	 * 标签专题图用专题值对点、线、面等对象做标注，值得注意的是，分段标签专题图允许用户通过 rangeExpression
	 * 字段指定用于分段的数值型字段，同一范围段内的标签具有相同的显示风格，其中每一个范围段就是一个专题图子项，
	 * 每一个子项都具有其名称、风格、起始值和终止值。注意：每个分段所表示的范围为 [Start, End)。例如：标签专题图的分段点有两个子项，
	 * 他们所代表的分段区间分别为[0,5)，[5,10)。那么需要分别设置 ThemeLabelItem[0].start=0，
	 * ThemeLabelItem[0].end=5，ThemeLabelItem[1].start=5，ThemeLabelItem[1].end=10。
	 */
	__webpack_require__(4);
	__webpack_require__(87);
	ThemeLabelItem = SuperMap.Class({

	    /**
	     * APIProperty: caption
	     * {String} 标签专题子项的标题。
	     */
	    caption: null,

	    /**
	     * APIProperty: end
	     * {Number} 标签专题图子项的终止值。如果该子项是分段中最后一个子项，那么该终止值就是分段的最大值；
	     * 如果不是最后一项，该终止值必须与其下一子项的起始值相同，否则系统抛出异常。默认为0。
	     */
	    end: 0,

	    /**
	     * APIProperty: start
	     * {Number} 标签专题图子项的分段起始值。如果该子项是分段中第一项，那么该起始值就是分段的最小值；
	     * 如果该子项的序号大于等于 1 的时候，该起始值必须与前一子项的终止值相同，否则系统会抛出异常。默认为0。
	     */
	    start: 0,

	    /**
	     * APIProperty: visible
	     * {Boolean} 标签专题图子项是否可见。如果标签专题图子项可见，则为 true，否则为 false。默认值为 true。
	     */
	    visible: true,

	    /**
	     * APIProperty: style
	     * {<ServerTextStyle>} 标签专题图子项文本的显示风格。各种风格的优先级从高到低为：
	     * uniformMixedStyle（标签文本的复合风格），ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
	     */
	    style: null,

	    /**
	     * Constructor: ThemeLabelItem
	     * 分段标签专题图的子项类构造函数，用于创建 ThemeLabelItem 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * caption - {String} 专题图子项的名称。
	     * end - {Number} 标签专题图子项的终止值。
	     * start - {Number} 标签专题图子项的分段起始值。
	     * visible - {Boolean} 标签专题图子项是否可见。
	     * style - {<ServerTextStyle>} 标签专题图子项文本的显示风格。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.style = new ServerTextStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.caption = null;
	        me.end = null;
	        me.start = null;
	        if (me.style) {
	            me.style.destroy();
	            me.style = null;
	        }
	        me.visible = null;
	    },

	    CLASS_NAME: "ThemeLabelItem"
	});
	ThemeLabelItem.fromObj = function (obj) {
	    if (!obj) return;
	    var t = new ThemeLabelItem();
	    SuperMap.Util.copy(t, obj);
	    return t;
	};
	module.exports = function (options) {
	    return new ThemeLabelItem(options);
	};


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeLabelUniqueItem
	 * 单值标签专题图的子项。
	 * 标签专题图用专题值对点、线、面等对象做标注，值得注意的是，单值标签专题图允许用户通过 uniqueExpression
	 * 字段指定用于单值的字段，同一值的标签具有相同的显示风格，其中每一个值就是一个专题图子项，
	 * 每一个子项都具有其名称、风格、指定的单值、X方向偏移量和Y方向偏移量。
	 */
	__webpack_require__(4);
	__webpack_require__(87);
	ThemeLabelUniqueItem = SuperMap.Class({

	    /**
	     * APIProperty: caption
	     * {String} 标签专题子项的标题。
	     */
	    caption: null,
	    /**
	     * APIProperty: unique
	     * {String} 单值专题图子项的值，可以为数字、字符串等。
	     */
	    unique: null,
	    /**
	     * APIProperty: offsetX
	     * {Number} 标签在X方向偏移量。
	     */
	    offsetX: 0,

	    /**
	     * APIProperty: offsetY
	     * {Number} 标签在Y方向偏移量。
	     */
	    offsetY: 0,

	    /**
	     * APIProperty: visible
	     * {Boolean} 标签专题图子项是否可见。如果标签专题图子项可见，则为 true，否则为 false。默认值为 true。
	     */
	    visible: true,

	    /**
	     * APIProperty: style
	     * {<ServerTextStyle>} 标签专题图子项文本的显示风格。各种风格的优先级从高到低为：
	     * uniformMixedStyle（标签文本的复合风格），ThemeLabelUniqueItem.style（单值子项的文本风格），uniformStyle（统一文本风格）。
	     */
	    style: null,

	    /**
	     * Constructor: ThemeLabelUniqueItem
	     * 单值标签专题图的子项类构造函数，用于创建 ThemeLabelUniqueItem 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * caption - {String} 专题图子项的名称。
	     * unique - {String} 单值专题图子项的值，可以为数字、字符串等。
	     * offsetX - {Number} 标签在X方向偏移量。
	     * offsetY - {Number} 标签在Y方向偏移量。
	     * visible - {Boolean} 标签专题图子项是否可见。
	     * style - {<ServerTextStyle>} 标签专题图子项文本的显示风格。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.style = new ServerTextStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.unique = null;
	        me.caption = null;
	        me.offsetX = null;
	        me.offsetY = null;
	        if (me.style) {
	            me.style.destroy();
	            me.style = null;
	        }
	        me.visible = null;
	    },

	    CLASS_NAME: "ThemeLabelUniqueItem"
	});
	ThemeLabelUniqueItem.fromObj = function (obj) {
	    if (!obj) return;
	    var t = new ThemeLabelUniqueItem();
	    SuperMap.Util.copy(t, obj);
	    return t;
	};
	module.exports = function (options) {
	    return new ThemeLabelUniqueItem(options);
	};


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeLabelText
	 * 标签中文本风格类。
	 * 通过该类可以设置标签中的文本字体大小和显示风格。
	 */
	__webpack_require__(4);
	__webpack_require__(87);
	__webpack_require__(95);
	ThemeLabelText = SuperMap.Class({

	    /**
	     * APIProperty: maxTextHeight
	     * {Number} 标签中文本的最大高度。当标签文本不固定大小时，即 ServerTextStyle.sizeFixed = false 有效，
	     * 当放大后的文本高度超过最大高度之后就不再放大。高度单位为0.1毫米。高度单位为0.1毫米。默认为 0 毫米。
	     */
	    maxTextHeight: 0,

	    /**
	     * APIProperty: maxTextWidth
	     * {Number} 标签中文本的最大宽度。当标签文本不固定大小时，即 ServerTextStyle.sizeFixed = false 有效，
	     * 当放大后的文本宽度超过最大高度之后就不再放大。宽度单位为0.1毫米。默认为0毫米。
	     */
	    maxTextWidth: 0,

	    /**
	     * APIProperty: minTextHeight
	     * {Number} 标签中文本的最小高度。当标签文本不固定大小时，即 ServerTextStyle.sizeFixed = false 有效，
	     * 当缩小后的文本高度小于最小高度之后就不再缩小。宽度单位为0.1毫米。默认为0毫米。
	     */
	    minTextHeight: 0,

	    /**
	     * APIProperty: minTextWidth
	     * {Number} 标签中文本的最小宽度。当标签文本不固定大小时，即 ServerTextStyle.sizeFixed = false 有效，
	     * 当缩小后的文本宽度小于最小宽度之后就不再缩小。宽度单位为0.1毫米。默认为0毫米。
	     */
	    minTextWidth: 0,

	    /**
	     * APIProperty: uniformStyle
	     * {<ServerTextStyle>} 统一文本风格。当标签专题图子项的个数大于等于1时，
	     * uniformStyle 不起作用，各标签的风格使用子项中设置的风格。各种风格的优先级从高到低为：uniformMixedStyle（标签文本的复合风格），
	     * ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
	     */
	    uniformStyle: null,

	    /**
	     * APIProperty: uniformMixedStyle
	     * {<LabelMixedTextStyle>} 标签专题图统一的文本复合风格。通过该类可以使同一个标
	     * 签中的文字使用多种风格显示。各种风格的优先级从高到低为：uniformMixedStyle（标签文本的复合风格），
	     * ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
	     */
	    uniformMixedStyle: null,

	    /**
	     * Constructor: ThemeLabelText
	     * 标签中文本风格类构造函数，用于创建 ThemeLabelText 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * maxTextHeight - {Number} 标签中文本的最大高度。
	     * maxTextWidth - {Number} 标签中文本的最大宽度。
	     * minTextHeight - {Number} 标签中文本的最小高度。
	     * minTextWidth - {Number} 标签中文本的最小宽度。
	     * uniformStyle - {<ServerTextStyle>} 统一文本风格。
	     * uniformMixedStyle - {<LabelMixedTextStyle>} 标签专题图统一的文本复合风格。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.uniformStyle = new ServerTextStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.maxTextHeight = null;
	        me.maxTextWidth = null;
	        me.minTextHeight = null;
	        me.minTextWidth = null;
	        if (me.uniformStyle) {
	            me.uniformStyle.destroy();
	            me.uniformStyle = null;
	        }
	        if (me.uniformMixedStyle) {
	            me.uniformMixedStyle.destroy();
	            me.uniformMixedStyle = null;
	        }
	    },

	    CLASS_NAME: "ThemeLabelText"
	});
	ThemeLabelText.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeLabelText();
	    SuperMap.Util.copy(res, obj);
	    res.uniformStyle = ServerTextStyle.fromObj(obj.uniformStyle);
	    res.uniformMixedStyle = LabelMixedTextStyle.fromObj(obj.uniformMixedStyle);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeLabelText(options);
	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: LabelMixedTextStyle
	 * 标签文本复合风格类。
	 * 该类主要用于对标签专题图中标签的文本内容进行风格设置。通过该类用户可以使标签的文字显示不同的风格，
	 * 比如文本 “喜马拉雅山”，通过本类可以将前三个字用红色显示，后两个字用蓝色显示。
	 * 对同一文本设置不同的风格实质上是对文本的字符进行分段，同一分段内的字符具有相同的显示风格。
	 * 对字符分段有两种方式，一种是利用分隔符对文本进行分段；另一种是根据分段索引值进行分段。
	 * 1. 利用分隔符对文本进行分段: 比如文本 “5&109” 被分隔符 “&” 分为“5”和“109”两部分，
	 * 在显示时，“5” 和分隔符 “&” 使用同一个风格，字符串 “109” 使用相同的风格。
	 * 2. 利用分段索引值进行分段: 文本中字符的索引值是以0开始的整数，比如文本“珠穆朗玛峰”，
	 * 第一个字符（“珠”）的索引值为0，第二个字符（“穆”）的索引值为1，以此类推；当设置分段索引值为1，3，4，9时，
	 * 字符分段范围相应的就是(-∞，1)，[1，3)，[3，4)，[4，9)，[9，+∞)，可以看出索引号为0的字符（即“珠” ）在第一个分段内，
	 * 索引号为1，2的字符（即“穆”、“朗”）位于第二个分段内，索引号为3的字符（“玛”）在第三个分段内，索引号为4的字符（“峰”）在第四个分段内，其余分段中没有字符。
	 */
	__webpack_require__(4);
	__webpack_require__(87);
	LabelMixedTextStyle = SuperMap.Class({

	    /**
	     * APIProperty: defaultStyle
	     * {<ServerTextStyle>} 默认的文本复合风格，即 ServerTextStyle 各字段的默认值。
	     */
	    defaultStyle: null,

	    /**
	     * APIProperty: separator
	     * {String} 文本的分隔符，分隔符的风格与前一个字符的风格一样。文本的分隔符是一个将文本分割开的符号，
	     * 比如文本 “5_109” 被 “_” 隔符为 “5” 和 “109” 两部分，假设有风格数组：style1、style2。
	     * 在显示时，“5” 和分隔符 “_” 使用 Style1 风格渲染，字符串 “109” 使用 Style2 的风格。
	     */
	    separator: null,

	    /**
	     * APIProperty: separatorEnabled
	     * {Boolean} 文本的分隔符是否有效。分隔符有效时利用分隔符对文本进行分段；无效时根据文本中字符的位置进行分段。
	     * 分段后，同一分段内的字符具有相同的显示风格。默认为 false。
	     */
	    separatorEnabled: false,

	    /**
	     * APIProperty: splitIndexes
	     * {Array(Number)} 分段索引值，分段索引值用来对文本中的字符进行分段。
	     * 文本中字符的索引值是以0开始的整数，比如文本“珠穆朗玛峰”，第一个字符（“珠”）的索引值为0，第二个字符（“穆”）的索引值为1，
	     * 以此类推；当设置分段索引值数组为[1，3，4，9]时，字符分段范围相应的就是(-∞，1)，[1，3)，[3，4)，[4，9)，[9，+∞)，
	     * 可以看出索引号为0的字符（即“珠” ）在第一个分段内，索引号为1，2的字符（即“穆”、“朗”）位于第二个分段内，
	     * 索引号为3的字符（“玛”）在第三个分段内，索引号为4的字符（“峰”）在第四个分段内，其余分段中没有字符。
	     */
	    splitIndexes: null,

	    /**
	     * APIProperty: styles
	     * {Array(<ServerTextStyle>)} 文本样式集合。文本样式集合中的样式根据索引与不同分段一一对应，
	     * 如果有分段没有风格对应则使用 defaultStyle。
	     */
	    styles: null,
	    /**
	     * Constructor: LabelMixedTextStyle
	     * 标签文本复合风格类构造函数，用于创建 LabelMixedTextStyle 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * defaultStyle - {<ServerTextStyle>} 默认的文本复合风格。
	     * separator - {String} 文本的分隔符。
	     * separatorEnabled - Boolean} 文本的分隔符是否有效。
	     * splitIndexes - {Array(Number)} 分段索引值，分段索引值用来对文本中的字符进行分段。
	     * styles - {Array(<ServerTextStyle>)} 文本样式集合。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.defaultStyle = new ServerTextStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.defaultStyle) {
	            me.defaultStyle.destroy();
	            me.defaultStyle = null;
	        }
	        me.separator = null;
	        me.separatorEnabled = null;
	        if (me.splitIndexes) {
	            me.splitIndexes = null;
	        }
	        if (me.styles) {
	            for (var i = 0, styles = me.styles, len = styles.length; i < len; i++) {
	                styles[i].destroy();
	            }
	            me.styles = null;
	        }
	    },

	    CLASS_NAME: "LabelMixedTextStyle"
	});
	LabelMixedTextStyle.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new LabelMixedTextStyle();
	    var stys = obj.styles;
	    SuperMap.Util.copy(res, obj);
	    res.defaultStyle = new ServerTextStyle(obj.defaultStyle);
	    if (stys) {
	        res.styles = [];
	        for (var i = 0, len = stys.length; i < len; i++) {
	            res.styles.push(new ServerTextStyle(stys[i]));
	        }
	    }
	    return res;
	};
	module.exports = function (options) {
	    return new LabelMixedTextStyle(options);
	};



/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: LabelImageCell
	 * 图片类型的矩阵标签元素类。
	 * 该类继承自 LabelMatrixCell类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
	 * 矩阵标签专题图是标签专题图（ThemeLabel）的一种，其中矩阵标签中的填充元素又可分为图片类型（LabelImageCell）、
	 * 符号类型（LabelSymbolCell）、专题图类型（LabelThemeCell）三种，该类是这三种类型的矩阵标签元素其中的一种，
	 * 用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应） 、大小等。
	 * 用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 ThemeLabel.matrixCells 属性即可。matrixCells 属是一个二维数组，
	 * 每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
	 *
	 * Inherits from:
	 *  - <LabelMatrixCell>
	 */
	__webpack_require__(4);
	__webpack_require__(97);
	LabelImageCell = SuperMap.Class(LabelMatrixCell, {

	    /**
	     * APIProperty: height
	     * {Number} 设置图片的高度，单位为毫米。
	     */
	    height: 0,

	    /**
	     * APIProperty: pathField
	     * {String} 设置矩阵标签元素所使用的图片路径对应的字段名。
	     */
	    pathField: null,

	    /**
	     * APIProperty: rotation
	     * {Number} 图片的旋转角度。逆时针方向为正方向，单位为度，精确到0.1度。默认值为0.0。
	     */
	    rotation: 0.0,

	    /**
	     * APIProperty: width
	     * {Number} 设置图片的宽度，单位为毫米。
	     */
	    width: 0,

	    /**
	     * APIProperty: sizeFixed
	     * {Boolean} 是否固定图片的大小。默认值为 false，即图片将随地图缩放。
	     */
	    sizeFixed: false,

	    /**
	     * Property: type
	     * {Boolean} 制作矩阵专题图时是必须的。
	     */
	    type: "IMAGE",

	    /**
	     * Constructor: LabelImageCell
	     * 图片类型的矩阵标签元素类构造函数，用于创建 LabelImageCell 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * height - {Number} 设置图片的高度，单位为毫米。
	     * pathField - {String} 设置矩阵标签元素所使用图片的路径。
	     * rotation - {Number} 图片的旋转角度。逆时针方向为正方向，单位为度，精确到0.1度。默认值为0.0。
	     * width - {Number} 设置图片的宽度，单位为毫米。
	     * sizeFixed - {Boolean} 是否固定图片的大小。默认值为 false，即图片将随地图缩放。
	     */
	    initialize: function (options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.height = null;
	        me.pathField = null;
	        me.rotation = null;
	        me.width = null;
	        me.sizeFixed = null;
	    },

	    CLASS_NAME: "LabelImageCell"
	});
	module.exports = function (options) {
	    return new LabelImageCell(options);
	};

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: LabelMatrixCell
	 * 矩阵标签元素抽象类。
	 * 该类可以包含 n*n 个矩阵标签元素，矩阵标签元素的类型可以是图片，符号，标签专题图等。
	 * 符号类型的矩阵标签元素类、图片类型的矩阵标签元素类和专题图类型的矩阵标签元素类均继承自该类。
	 */
	__webpack_require__(4);
	LabelMatrixCell = SuperMap.Class({
	    CLASS_NAME: "LabelMatrixCell"
	});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: LabelSymbolCell
	 * 符号类型的矩阵标签元素类。
	 * 该类继承自 LabelMatrixCell类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
	 * 矩阵标签专题图是标签专题图（ThemeLabel）的一种，其中矩阵标签中的填充元素又可分为图片类型（LabelImageCell）、
	 * 符号类型（LabelSymbolCell）、专题图类型（LabelThemeCell）三种，该类是这三种类型的矩阵标签元素其中的一种，
	 * 用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应） 、大小等。
	 * 用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 ThemeLabel.matrixCells 属性即可。matrixCells 属是一个二维数组，
	 * 每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
	 *
	 * Inherits from:
	 *  - <LabelMatrixCell>
	 */
	__webpack_require__(4);
	__webpack_require__(77);
	__webpack_require__(97);
	LabelSymbolCell = SuperMap.Class(LabelMatrixCell, {

	    /**
	     * APIProperty: style
	     * {<ServerStyle>} 获取或设置符号样式—— ServerStyle 对象，包括符号大小（ServerStyle.markerSize）
	     * 和符号旋转（ServerStyle.markerAngle）角度，其中用于设置符号 ID 的属性（ServerStyle.markerSymbolID）在此处不起作用。
	     */
	    style: null,

	    /**
	     * APIProperty: symbolIDField
	     * {String} 获取或设置符号 ID 或符号 ID 所对应的字段名称，必设属性。
	     */
	    symbolIDField: null,

	    /**
	     * Property: type
	     * {String} 制作矩阵专题图时是必须的。
	     */
	    type: "SYMBOL",

	    /**
	     * Constructor: LabelSymbolCell
	     * 符号类型的矩阵标签元素类构造函数，用于创建 LabelSymbolCell 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * style - {<ServerStyle>} 获取或设置符号样式—— ServerStyle 对象。
	     * symbolIDField - {String} 符号 ID 或符号 ID 所对应的字段名称。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.style = new ServerStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.style) {
	            me.style.destroy();
	            me.style = null;
	        }
	        me.symbolIDField = null;
	    },

	    CLASS_NAME: "LabelSymbolCell"
	});
	module.exports = function (options) {
	    return new LabelSymbolCell(options);
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: LabelThemeCell
	 * 专题图类型的矩阵标签元素类。
	 * 该类继承自 LabelMatrixCell类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
	 * 矩阵标签专题图是标签专题图（ThemeLabel）的一种，其中矩阵标签中的填充元素又可分为图片类型（LabelImageCell）、
	 * 符号类型（LabelSymbolCell）、专题图类型（LabelThemeCell）三种，该类是这三种类型的矩阵标签元素其中的一种，
	 * 用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应） 、大小等。
	 * 用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 ThemeLabel.matrixCells 属性即可。matrixCells 属是一个二维数组，
	 * 每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
	 *
	 * Inherits from:
	 *  - <LabelMatrixCell>
	 */
	__webpack_require__(4);
	__webpack_require__(91);
	__webpack_require__(97);
	LabelThemeCell = SuperMap.Class(LabelMatrixCell, {

	    /**
	     * APIProperty: themeLabel
	     * {<ThemeLabel>} 使用专题图对象作为矩阵标签的一个元素。
	     */
	    themeLabel: null,

	    /**
	     * Property: type
	     * {String} 制作矩阵专题图时是必须的。
	     */
	    type: "THEME",

	    /**
	     * Constructor: LabelThemeCell
	     * 专题图类型的矩阵标签元素类构造函数，用于创建 LabelThemeCell 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * themeLabel - {<ThemeLabel>} 使用专题图对象作为矩阵标签的一个元素。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.themeLabel = new ThemeLabel();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.themeLabel) {
	            me.themeLabel.destroy();
	            me.themeLabel = null;
	        }
	    },

	    CLASS_NAME: "LabelThemeCell"
	});
	module.exports = function (options) {
	    return new LabelThemeCell(options);
	};

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeLabelAlongLine
	 * 标签沿线标注样式类。
	 * 通过该类可以设置是否标签沿线标注以及沿线标注的多种样式。沿线标注属性只适用于线数据集专题图。
	 */
	__webpack_require__(4);
	ThemeLabelAlongLine = SuperMap.Class({

	    /**
	     * APIProperty: isAlongLine
	     * {Boolean} 是否沿线显示文本。true 表示沿线显示文本，false 表示正常显示文本，默认为 true。
	     */
	    isAlongLine: true,

	    /**
	     * APIProperty: alongLineDirection
	     * {<AlongLineDirection>} 标签沿线标注方向。默认为 AlongLineDirection.LB_TO_RT（从上到下，从左到右放置）。
	     */
	    alongLineDirection: AlongLineDirection.LB_TO_RT,

	    /**
	     * APIProperty: angleFixed
	     * {Boonlean} 当沿线显示文本时，是否将文本角度固定。true 表示按固定文本角度显示文本，false 表示按照沿线角度显示文本。
	     * 默认值为 false。如果固定角度，则所有标签均按所设置的文本风格中字体的旋转角度来显示，不考虑沿线标注的方向；
	     * 如果不固定角度，在显示标签时会同时考虑字体的旋转角度和沿线标注的方向。
	     */
	    angleFixed: false,

	    /**
	     * APIProperty: repeatedLabelAvoided
	     * {Boonlean} 沿线循环标注时是否避免标签重复标注。
	     */
	    repeatedLabelAvoided: false,

	    /**
	     * APIProperty: repeatIntervalFixed
	     * {Boonlean} 循环标注间隔是否固定。true 表示使用固定循环标注间隔，即使用逻辑坐标来显示循环标注间隔；
	     * false 表示循环标注间隔随地图的缩放而变化，即使用地理坐标来显示循环标注间隔。默认值为 false。
	     */
	    repeatIntervalFixed: false,

	    /**
	     * APIProperty: labelRepeatInterval
	     * {Number} 沿线且循环标注时循环标注的间隔。长度的单位与地图的地理单位一致。只有设定 RepeatedLabelAvoided 为 true
	     * 的时候，labelRepeatInterval 属性才有效。默认为0地图单位。
	     */
	    labelRepeatInterval: 0,

	    /**
	     * Constructor: ThemeLabelAlongLine
	     * 标签沿线标注样式类构造函数，用于创建 ThemeLabelAlongLine 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * isAlongLine - {Boolean} 是否沿线显示文本。
	     * alongLineDirection - {<AlongLineDirection>} 标签沿线标注方向。
	     * angleFixed - {Boonlean} 当沿线显示文本时，是否将文本角度固定。
	     * repeatedLabelAvoided - {Boonlean} 沿线循环标注时是否避免标签重复标注。
	     * repeatIntervalFixed - {Boonlean} 循环标注间隔是否固定。
	     * labelRepeatInterval - {Number} 沿线且循环标注时循环标注的间隔。
	     */
	    initialize: function (options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.isAlongLine = null;
	        me.alongLineDirection = null;
	        me.angleFixed = null;
	        me.repeatedLabelAvoided = null;
	        me.repeatIntervalFixed = null;
	        me.labelRepeatInterval = null;
	    },

	    CLASS_NAME: "ThemeLabelAlongLine"
	});
	ThemeLabelAlongLine.fromObj = function (obj) {
	    if (!obj) return;
	    var t = new ThemeLabelAlongLine();
	    SuperMap.Util.copy(t, obj);
	    return t;
	};
	module.exports = function (options) {
	    return new ThemeLabelAlongLine(options);
	};


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeLabelBackground
	 * 标签背景风格类。
	 * 通过该类可以设置标签的背景形状和风格。
	 */
	__webpack_require__(4);
	__webpack_require__(77);
	ThemeLabelBackground = SuperMap.Class({

	    /**
	     * APIProperty: labelBackShape
	     * {<LabelBackShape>} 标签专题图中标签背景风格。当背景形状
	     * labelBackShape 属性设为 NONE（即无背景形状） 时，backStyle 属性无效。
	     */
	    labelBackShape: LabelBackShape.NONE,

	    /**
	     * APIProperty: backStyle
	     * {<ServerStyle>} 标签专题图中标签背景的形状枚举类。背景类型可
	     * 以是矩形、圆角矩形、菱形、椭圆形、三角形和符号等，默认为 LabelBackShape.NONE，
	     * 即不使用任何的形状作为标签的背景。
	     */
	    backStyle: null,

	    /**
	     * Constructor: ThemeLabelBackground
	     * 标签背景风格类构造函数，用于创建 ThemeLabelBackGround 类的新实例。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * labelBackShape - {<LabelBackShape>} 标签专题图中标签背景风格。
	     * backStyle - {<ServerStyle>} 标签专题图中标签背景的形状枚举类。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.backStyle = new ServerStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.labelBackShape = null;
	        if (me.backStyle) {
	            me.backStyle.destroy();
	            me.backStyle = null;
	        }
	    },

	    CLASS_NAME: "ThemeLabelBackground"
	});
	ThemeLabelBackground.fromObj = function (obj) {
	    if (!obj) return;
	    var t = new ThemeLabelBackground();
	    t.labelBackShape = obj.labelBackShape;
	    t.backStyle = ServerStyle.fromJson(obj.backStyle);

	    return t;
	};
	module.exports = function (options) {
	    return new ThemeLabelBackground(options);
	};


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeRange
	 * 范围分段专题图。
	 * 范围分段专题图是按照指定的分段方法（如：等距离分段法）对字段的属性值进行分段，使用不同的颜色或符号（线型、填充）表示不同范围段落的属性值在整体上的分布情况，体现区域的差异。
	 * 在分段专题图中，专题值按照某种分段方式被分成多个范围段，要素根据各自的专题值被分配到其中一个范围段中，在同一个范围段中的要素使用相同的颜色，填充，符号等风格进行显示。
	 * 分段专题图所基于的专题变量必须为数值型，分段专题图一般用来反映连续分布现象的数量或程度特征，如降水量的分布，土壤侵蚀强度的分布等。
	 *
	 * Inherits from:
	 *  - <Theme>
	 */
	__webpack_require__(4);
	__webpack_require__(79);
	__webpack_require__(103);
	ThemeRange = SuperMap.Class(Theme, {
	    /**
	     * Property: precision
	     * {String}
	     */
	    precision: '1.0E-12',
	    /**
	     * APIProperty: items
	     * {Array(<ThemeRangeItem>)} 分段专题图子项数组。
	     * 在分段专题图中，字段值按照某种分段模式被分成多个范围段，每个范围段即为一个子项，同一范围段的要素属于同一个分段专题图子项。
	     * 每个子项都有其分段起始值、终止值、名称和风格等。每个分段所表示的范围为[start, end)。
	     * 如果设置了范围分段模式和分段数，则会自动计算每段的范围[start, end)，故无需设置[start, end)；当然可以设置，那么结果就会按照您设置的值对分段结果进行调整。
	     */
	    items: null,

	    /**
	     * APIProperty: rangeExpression
	     * {String} 分段字段表达式。
	     * 由于范围分段专题图基于各种分段方法根据一定的距离进行分段，因而范围分段专题图所基于的字段值的数据类型必须为数值型。对于字段表达式，只能为数值型的字段间的运算。必设字段。
	     */
	    rangeExpression: null,

	    /**
	     * APIProperty: rangeMode
	     * {<RangeMode>} 分段专题图的分段模式。
	     * 默认值为 RangeMode.EQUALINTERVAL（等距离分段）。
	     * 在分段专题图中，作为专题变量的字段或表达式的值按照某种分段方式被分成多个范围段。
	     * 目前 SuperMap 提供的分段方式包括：等距离分段法、平方根分段法、标准差分段法、对数分段法、等计数分段法和自定义距离法，显然这些分段方法根据一定的距离进行分段，因而范围分段专题图所基于的专题变量必须为数值型。
	     */
	    rangeMode: RangeMode.EQUALINTERVAL,

	    /**
	     * APIProperty: rangeParameter
	     * {Number} 分段参数。
	     * 当分段模式为等距离分段法，平方根分段，对数分段法，计数分段法其中一种模式时，该参数用于设置分段个数，必设；当分段模式为标准差分段法时，该参数不起作用；当分段模式为自定义距离时，该参数用于设置自定义距离。默认值为 -1。
	     */
	    rangeParameter: 0,

	    /**
	     * APIProperty: colorGradientType
	     * {<ColorGradientType>} 渐变颜色枚举类
	     * 渐变色是由起始色根据一定算法逐渐过渡到终止色的一种混合型颜色。
	     * 该类作为单值专题图参数类、分段专题图参数类的属性，负责设置单值专题图、分段专题图的配色方案，在默认情况下专题图所有子项会根据这个配色
	     * 方案完成填*充。但如果为某几个子项的风格进行单独设置后（设置了 ThemeUniqueItem 或 ThemeRangeItem 类中Style属性），
	     * 该配色方案对于这几个子项将不起作用。
	     */
	    colorGradientType: ColorGradientType.YELLOW_RED,

	    /**
	     * Constructor: ThemeRange
	     * 范围分段专题图构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * items - {Array(<ThemeRangeItem>)} 分段专题图子项数组。
	     * rangeExpression - {String} 分段字段表达式。
	     * rangeMode - {<RangeMode>} 分段专题图的分段模式。
	     * rangeParameter - {Number} 分段参数。
	     * colorGradientType - {<ColorGradientType>} 渐变颜色枚举类。
	     * memoryData - {<ThemeMemoryData>} 专题图内存数据。
	     */
	    initialize: function (options) {
	        Theme.prototype.initialize.apply(this, ["RANGE", options]);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        Theme.prototype.destroy.apply(this, arguments);
	        var me = this;
	        if (me.items) {
	            if (me.items.length > 0) {
	                for (var item in me.items) {
	                    me.items[item].destroy();
	                    me.items[item] = null;
	                }
	            }
	            me.items = null;
	        }
	        me.rangeExpression = null;
	        me.rangeMode = null;
	        me.rangeParameter = null;
	        me.colorGradientType = null;
	    },

	    CLASS_NAME: "ThemeRange"
	});
	ThemeRange.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeRange();
	    SuperMap.Util.copy(res, obj);
	    var itemsR = obj.items;
	    var len = itemsR ? itemsR.length : 0;
	    res.items = [];
	    for (var i = 0; i < len; i++) {
	        res.items.push(ThemeRangeItem.fromObj(itemsR[i]));
	    }
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeRange(options);
	};


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeRangeItem
	 * 范围分段专题图子项类。
	 * 在分段专题图中，字段值按照某种分段模式被分成多个范围段，每个范围段即为一个子项，同一范围段的要素属于同一个分段专题图子项。
	 * 每个子项都有其分段起始值、终止值、名称和风格等。每个分段所表示的范围为[start, end)。
	 */
	__webpack_require__(4);
	__webpack_require__(77);
	ThemeRangeItem = SuperMap.Class({

	    /**
	     * APIProperty: caption
	     * {String} 分段专题图子项的标题。
	     */
	    caption: null,

	    /**
	     * APIProperty: end
	     * {Number} 分段专题图子项的终止值，即该段专题值范围的最大值，默认值为 0。
	     * 如果该子项是分段中最后一个子项，则该终止值应大于分段字段（ThemeRange 类的 rangeExpression 属性）的最大值，若该终止值小于分段字段最大值，则剩余部分由内部随机定义其颜色；如果不是最后一项，该终止值必须与其下一子项的起始值相同，否则系统抛出异常；
	     * 如果设置了范围分段模式和分段数，则会自动计算每段的范围[start, end)，故无需设置[start, end)；当然可以设置，那么结果就会按您设置的值对分段结果进行调整。
	     */
	    end: 0,

	    /**
	     * APIProperty: start
	     * {Number} 分段专题图子项的起始值，即该段专题值范围的最小值，默认值为 0。
	     * 如果该子项是分段中第一个子项，那么该起始值就是分段的最小值；如果子项的序号大于等于1的时候，该起始值必须与前一子项的终止值相同，否则系统会抛出异常。
	     * 如果设置了范围分段模式和分段数，则会自动计算每段的范围[start, end)，故无需设置[start, end)；当然可以设置，那么结果就会按您设置的值对分段结果进行调整。
	     */
	    start: 0,

	    /**
	     * APIProperty: style
	     * {<ServerStyle>} 分段专题图子项的风格。
	     * 每一个分段专题图子项都对应一种显示风格。
	     */
	    style: null,

	    /**
	     * APIProperty: visible
	     * {Boolean} 分段专题图子项是否可见。
	     * 默认为 true。
	     */
	    visible: true,

	    /**
	     * Constructor: ThemeRangeItem
	     * 范围分段专题图子项类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * caption - {String} 分段专题图子项的标题。
	     * end - {Number} 分段专题图子项的终止值。
	     * start - {Number} 分段专题图子项的起始值。
	     * style - {<ServerStyle>} 分段专题图子项的风格。
	     * visible - {Boolean} 分段专题图子项是否可见。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.style = new ServerStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.caption = null;
	        me.end = null;
	        me.start = null;

	        if (me.style) {
	            me.style.destroy();
	            me.style = null;
	        }
	        me.visible = null;
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = {};
	        obj = SuperMap.Util.copyAttributes(obj, this);
	        if (obj.style) {
	            if (obj.style.toServerJSONObject) {
	                obj.style = obj.style.toServerJSONObject();
	            }
	        }
	        return obj;
	    },

	    CLASS_NAME: "ThemeRangeItem"
	});
	ThemeRangeItem.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeRangeItem();
	    SuperMap.Util.copy(res, obj);
	    res.style = ServerStyle.fromJson(obj.style);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeRangeItem(options);
	};


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeUnique
	 * 单值专题图。
	 * 单值专题图是利用不同的颜色或符号（线型、填充）表示图层中某一属性信息的不同属性值，属性值相同的要素具有相同的渲染风格。单值专题图多用于具有分类属性的地图上，
	 * 比如土壤类型分布图、土地利用图、行政区划图等。单值专题图着重表示现象质的差别，一般不表示数量的特征。尤其是有交叉或重叠现象时，此类不推荐使用，例如：民族分布区等。
	 *
	 * Inherits from:
	 *  - <Theme>
	 */
	__webpack_require__(4);
	__webpack_require__(77);
	__webpack_require__(79);
	__webpack_require__(105);
	ThemeUnique = SuperMap.Class(Theme, {

	    /**
	     * APIProperty: defaultStyle
	     * {<ServerStyle>} 未参与单值专题图制作的对象的显示风格。
	     * 通过单值专题图子项数组 （items）可以指定某些要素参与单值专题图制作，对于那些没有被包含的要素，即不参加单值专题表达的要素，使用该风格显示。
	     */
	    defaultStyle: null,

	    /**
	     * APIProperty: items
	     * {Array(<ThemeUniqueItem>)} 单值专题图子项类数组。
	     * 单值专题图是将专题值相同的要素归为一类，为每一类设定一种渲染风格，其中每一类就是一个专题图子项。比如，利用单值专题图制作行政区划图，
	     * Name 字段代表省/直辖市名，该字段用来做专题变量，如果该字段的字段值总共有5种不同值，则该行政区划图有5个专题图子项。
	     */
	    items: null,

	    /**
	     * APIProperty: uniqueExpression
	     * {String} 用于制作单值专题图的字段或字段表达式。
	     * 该字段值的数据类型可以为数值型或字符型。如果设置字段表达式，只能是相同数据类型字段间的运算。必设字段。
	     */
	    uniqueExpression: null,

	    /**
	     * APIProperty: colorGradientType
	     * {<ColorGradientType>} 渐变颜色枚举类
	     * 渐变色是由起始色根据一定算法逐渐过渡到终止色的一种混合型颜色。
	     * 该类作为单值专题图参数类、分段专题图参数类的属性，负责设置单值专题图、分段专题图的配色方案，在默认情况下专题图所有子项会根据这个配色方案完成填充。但如果为某几个子项的风格进行单独设置后（设置了 ThemeUniqueItem 或 ThemeRangeItem 类中Style属性），
	     * 该配色方案对于这几个子项将不起作用。
	     */
	    colorGradientType: ColorGradientType.YELLOW_RED,

	    /**
	     * Constructor: ThemeUnique
	     * 单值专题图构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * items - {Array(<ThemeUniqueItem>)} 单值专题图子项类数组。
	     * uniqueExpression - {String} 用于制作单值专题图的字段或字段表达式。
	     * defaultStyle - {<ServerStyle>} 未参与单值专题图制作的对象的显示风格。
	     * colorGradientType - {<ColorGradientType>} 渐变颜色枚举类。
	     * memoryData - {<ThemeMemoryData>} 专题图内存数据。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.defaultStyle = new ServerStyle();
	        Theme.prototype.initialize.apply(this, ["UNIQUE", options]);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        Theme.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.uniqueExpression = null;
	        me.colorGradientType = null;
	        if (me.items) {
	            if (me.items.length > 0) {
	                for (var item in me.items) {
	                    me.items[item].destroy();
	                    me.items[item] = null;
	                }
	            }
	            me.items = null;
	        }

	        if (me.defaultStyle) {
	            me.defaultStyle.destroy();
	            me.defaultStyle = null;
	        }
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = {};
	        obj = SuperMap.Util.copyAttributes(obj, this);
	        if (obj.defaultStyle) {
	            if (obj.defaultStyle.toServerJSONObject) {
	                obj.defaultStyle = obj.defaultStyle.toServerJSONObject();
	            }
	        }
	        if (obj.items) {
	            var items = [],
	                len = obj.items.length;
	            for (var i = 0; i < len; i++) {
	                items.push(obj.items[i].toServerJSONObject());
	            }
	            obj.items = items;
	        }
	        return obj;
	    },

	    CLASS_NAME: "ThemeUnique"
	});
	ThemeUnique.fromObj = function (obj) {
	    var res = new ThemeUnique();
	    var uItems = obj.items;
	    var len = uItems ? uItems.length : 0;
	    SuperMap.Util.extend(res, obj);
	    res.items = [];
	    res.defaultStyle = new ServerStyle.fromJson(obj.defaultStyle);
	    for (var i = 0; i < len; i++) {
	        res.items.push(new ThemeUniqueItem.fromObj(uItems[i]));
	    }
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeUnique(options);
	};


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeUniqueItem
	 * 单值专题图子项类。
	 * 单值专题图是将专题值相同的要素归为一类，为每一类设定一种渲染风格，其中每一类就是一个专题图子项。比如，利用单值专题图制作行政区划图，Name 字段代表
	 * 省/直辖市名，该字段用来做专题变量，如果该字段的字段值总共有5种不同值，则该行政区划图有5个专题图子项。
	 */
	__webpack_require__(4);
	__webpack_require__(77);
	ThemeUniqueItem = SuperMap.Class({

	    /**
	     * APIProperty: caption
	     * {String} 单值专题图子项的标题。
	     */
	    caption: null,

	    /**
	     * APIProperty: style
	     * {<ServerStyle>} 单值专题图子项的显示风格。
	     */
	    style: null,

	    /**
	     * APIProperty: unique
	     * {String} 单值专题图子项的值，可以为数字、字符串等。
	     */
	    unique: null,

	    /**
	     * APIProperty: visible
	     * {Boolean} 单值专题图子项的可见性。默认为 true，表示可见。
	     */
	    visible: true,

	    /**
	     * Constructor: ThemeUniqueItem
	     * 单值专题图子项类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * caption - {String} 单值专题图子项的标题。
	     * style - {<ServerStyle>} 单值专题图子项的风格。
	     * unique - {String} 单值专题图子项的单值。
	     * visible - {Boolean} 单值专题图子项是否可见。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.style = new ServerStyle();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.caption = null;
	        me.unique = null;

	        if (me.style) {
	            me.style.destroy();
	            me.style = null;
	        }
	        me.visible = null;
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = {};
	        obj = SuperMap.Util.copyAttributes(obj, this);
	        if (obj.style) {
	            if (obj.style.toServerJSONObject) {
	                obj.style = obj.style.toServerJSONObject();
	            }
	        }
	        return obj;
	    },

	    CLASS_NAME: "ThemeUniqueItem"
	});
	ThemeUniqueItem.fromObj = function (obj) {
	    var res = new ThemeUniqueItem();
	    SuperMap.Util.copy(res, obj);
	    res.style = ServerStyle.fromJson(obj.style);
	    return res;

	};
	module.exports = function (options) {
	    return new ThemeUniqueItem(options);
	};



/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGridRange
	 * 栅格分段专题图。
	 * 栅格分段专题图，是将所有单元格的值按照某种分段方式分成多个范围段，值在同一个范围段中的单元格使用相同的颜色进行显示。
	 * 栅格分段专题图一般用来反映连续分布现象的数量或程度特征。比如某年的全国降水量分布图，将各气象站点的观测值经过内插之后生成的栅格数据进行分段显示。
	 * 该类类似于分段专题图类，不同点在于分段专题图的操作对象是矢量数据，而栅格分段专题图的操作对象是栅格数据。
	 * Inherits from:
	 *  - <Theme>
	 */
	__webpack_require__(4);
	__webpack_require__(79);
	__webpack_require__(107);
	ThemeGridRange = SuperMap.Class(Theme, {

	    /**
	     * APIProperty: items
	     * {Array(<ThemeGridRangeItem>)} 栅格分段专题图子项数组。
	     * 在栅格分段专题图中，将栅格值按照某种分段模式被分成多个范围段。
	     * 本类用来设置每个栅格范围段的分段起始值、终止值、名称和颜色等。每个分段所表示的范围为 [Start,End)。
	     */
	    items: null,


	    /**
	     * APIProperty: rangeMode
	     * {<RangeMode>} 分段专题图的分段模式。
	     * 默认值为 RangeMode.EQUALINTERVAL（等距离分段）。
	     * 在栅格分段专题图中，作为专题变量的字段或表达式的值按照某种分段方式被分成多个范围段。
	     * 目前 SuperMap 提供的分段方式包括：等距离分段法、平方根分段法、标准差分段法、对数分段法、等计数分段法和自定义距离法，显然这些分段方法根据一定的距离进行分段，因而范围分段专题图所基于的专题变量必须为数值型。
	     */
	    rangeMode: RangeMode.EQUALINTERVAL,

	    /**
	     * APIProperty: rangeParameter
	     * {Number} 分段参数。
	     * 当分段模式为等距离分段法，平方根分段，对数分段法，计数分段法其中一种模式时，该参数用于设置分段个数，必设；当分段模式为标准差分段法时，该参数不起作用；当分段模式为自定义距离时，该参数用于设置自定义距离。默认值为 -1。
	     */
	    rangeParameter: 0,

	    /**
	     * APIProperty: colorGradientType
	     * {<ColorGradientType>} 渐变颜色枚举类
	     *
	     */
	    colorGradientType: ColorGradientType.YELLOW_RED,
	    /**
	     * APIProperty: reverseColor
	     * {boolean}是否对栅格分段专题图中分段的颜色风格进行反序显示。
	     */
	    reverseColor: false,
	    /**
	     * Constructor: ThemeGridRange
	     * 栅格分段专题图构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * items - {Array(<ThemeGridRangeItem>)} 栅格分段专题图子项数组。
	     * reverseColor - {boolean} 是否对栅格分段专题图中分段的颜色风格进行反序显示。
	     * rangeMode - {<RangeMode>} 分段专题图的分段模式。
	     * rangeParameter - {Number} 分段参数。
	     * colorGradientType - {<ColorGradientType>} 渐变颜色枚举类。
	     */
	    initialize: function (options) {
	        Theme.prototype.initialize.apply(this, ["GRIDRANGE", options]);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        Theme.prototype.destroy.apply(this, arguments);
	        var me = this;
	        if (me.items) {
	            if (me.items.length > 0) {
	                for (var item in me.items) {
	                    me.items[item].destroy();
	                    me.items[item] = null;
	                }
	            }
	            me.items = null;
	        }
	        me.reverseColor = null;
	        me.rangeMode = null;
	        me.rangeParameter = null;
	        me.colorGradientType = null;
	    },

	    CLASS_NAME: "ThemeGridRange"
	});
	ThemeGridRange.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeGridRange();
	    SuperMap.Util.copy(res, obj);
	    var itemsR = obj.items;
	    var len = itemsR ? itemsR.length : 0;
	    res.items = [];
	    for (var i = 0; i < len; i++) {
	        res.items.push(ThemeGridRangeItem.fromObj(itemsR[i]));
	    }
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeGridRange(options);
	};



/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGridRangeItem
	 * 栅格分段专题图子项类。
	 * 在栅格分段专题图中，将栅格值按照某种分段模式被分成多个范围段。
	 * 本类用来设置每个范围段的分段起始值、终止值、名称和颜色等。每个分段所表示的范围为 [Start,End)。
	 */
	__webpack_require__(4);
	__webpack_require__(78);
	ThemeGridRangeItem = SuperMap.Class({

	    /**
	     * APIProperty: caption
	     * {String} 栅格分段专题图子项的标题。
	     */
	    caption: null,
	    /**
	     * APIProperty:color
	     * {ServerColor} 栅格分段专题图中每一个分段专题图子项的对应的颜色。
	     */
	    color: null,
	    /**
	     * APIProperty: end
	     * {Number} 栅格分段专题图子项的终止值，即该段专题值范围的最大值，默认值为 0。
	     */
	    end: 0,

	    /**
	     * APIProperty: start
	     * {Number} 栅格分段专题图子项的起始值，即该段专题值范围的最小值，默认值为 0。
	     */
	    start: 0,


	    /**
	     * APIProperty: visible
	     * {Boolean} 栅格分段专题图子项是否可见。
	     * 默认为 true。
	     */
	    visible: true,

	    /**
	     * Constructor: ThemeGridRangeItem
	     * 栅格分段专题图子项类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * caption - {String} 栅格分段专题图子项的标题。
	     * color - {ServerColor}栅格分段专题图中每一个分段专题图子项的对应的颜色。
	     * end - {Number} 栅格分段专题图子项的终止值。
	     * start - {Number} 栅格分段专题图子项的起始值。
	     * visible - {Boolean} 栅格分段专题图子项是否可见。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.color = new ServerColor();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.caption = null;
	        me.end = null;
	        me.start = null;
	        //需要验证是够存在destroy方法
	        if (me.color) {
	            me.color.destroy();
	            me.color = null;
	        }
	        me.visible = null;
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = {};
	        obj = SuperMap.Util.copyAttributes(obj, this);
	        if (obj.color) {
	            if (obj.color.toServerJSONObject) {
	                obj.color = obj.color.toServerJSONObject();
	            }
	        }
	        return obj;
	    },

	    CLASS_NAME: "ThemeGridRangeItem"
	});
	ThemeGridRangeItem.fromObj = function (obj) {
	    if (!obj) return;
	    var res = new ThemeGridRangeItem();
	    SuperMap.Util.copy(res, obj);
	    res.color = ServerColor.fromJson(obj.color);
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeGridRangeItem(options);
	};


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGridUnique
	 * 栅格单值专题图类。
	 * 栅格单值专题图，是将单元格值相同的归为一类，为每一类设定一种颜色，从而用来区分不同的类别。
	 * 栅格单值专题图适用于离散栅格数据和部分连续栅格数据，对于单元格值各不相同的那些连续栅格数据，使用栅格单值专题图不具有任何意义。
	 *
	 * Inherits from:
	 *  - <Theme>
	 */
	__webpack_require__(4);
	__webpack_require__(78);
	__webpack_require__(79);
	__webpack_require__(109);
	ThemeGridUnique = SuperMap.Class(Theme, {

	    /**
	     * APIProperty: defaultcolor
	     * {<ServerColor>} 栅格单值专题图的默认颜色。
	     * 对于那些未在格网单值专题图子项之列的要素使用该颜色显示。
	     */
	    defaultcolor: null,

	    /**
	     * APIProperty: items
	     * {Array(<ThemeGridUniqueItem>)} 栅格单值专题图子项数组。
	     * 栅格单值专题图将值相同的单元格归为一类，每一类是一个专题图子项。
	     */
	    items: null,

	    /**
	     * Constructor: ThemeGridUnique
	     * 栅格单值专题图类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * items - {Array(<ThemeGridUniqueItem>)} 栅格单值专题图子项数组。
	     * defaultcolor - {<ServerColor>} 栅格单值专题图的默认颜色。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.defaultcolor = new ServerColor();
	        Theme.prototype.initialize.apply(this, ["GRIDUNIQUE", options]);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        Theme.prototype.destroy.apply(this, arguments);
	        var me = this;
	        if (me.items) {
	            if (me.items.length > 0) {
	                for (var item in me.items) {
	                    me.items[item].destroy();
	                    me.items[item] = null;
	                }
	            }
	            me.items = null;
	        }

	        if (me.defaultcolor) {
	            me.defaultcolor.destroy();
	            me.defaultcolor = null;
	        }
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = {};
	        obj = SuperMap.Util.copyAttributes(obj, this);
	        if (obj.defaultcolor) {
	            if (obj.defaultcolor.toServerJSONObject) {
	                obj.defaultcolor = obj.defaultcolor.toServerJSONObject();
	            }
	        }
	        if (obj.items) {
	            var items = [],
	                len = obj.items.length;
	            for (var i = 0; i < len; i++) {
	                items.push(obj.items[i].toServerJSONObject());
	            }
	            obj.items = items;
	        }
	        return obj;
	    },

	    CLASS_NAME: "ThemeGridUnique"
	});
	ThemeGridUnique.fromObj = function (obj) {
	    var res = new ThemeGridUnique();
	    var uItems = obj.items;
	    var len = uItems ? uItems.length : 0;
	    SuperMap.Util.extend(res, obj);
	    res.items = [];
	    res.defaultcolor = new ServerColor.fromJson(obj.defaultcolor);
	    for (var i = 0; i < len; i++) {
	        res.items.push(new ThemeGridUniqueItem.fromObj(uItems[i]));
	    }
	    return res;
	};
	module.exports = function (options) {
	    return new ThemeGridUnique(options);
	};


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ThemeGridUniqueItem
	 * 栅格单值专题图子项类。
	 * 栅格单值专题图是将值相同的单元格归为一类，每一类是一个专题图子项。
	 */
	__webpack_require__(4);
	__webpack_require__(78);
	ThemeGridUniqueItem = SuperMap.Class({

	    /**
	     * APIProperty: caption
	     * {String} 栅格单值专题图子项的名称。
	     */
	    caption: null,

	    /**
	     * APIProperty: color
	     * {<ServerColor>} 栅格单值专题图子项的显示颜色。
	     */
	    color: null,

	    /**
	     * APIProperty: unique
	     * {Number} 栅格单值专题图子项的专题值，即单元格的值，值相同的单元格位于一个子项内。
	     */
	    unique: null,

	    /**
	     * APIProperty: visible
	     * {Boolean} 栅格单值专题图子项是否可见。默认为true。
	     */
	    visible: true,

	    /**
	     * Constructor: ThemeGridUniqueItem
	     * 栅格单值专题图子项类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * caption - {String} 栅格单值专题图子项的名称。
	     * color - {<ServerColor>} 栅格单值专题图子项的显示颜色。
	     * unique - {Number} 栅格单值专题图子项的专题值，即单元格的值，值相同的单元格位于一个子项内。
	     * visible - {Boolean} 栅格单值专题图子项是否可见。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.color = new ServerColor();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.caption = null;
	        me.unique = null;

	        if (me.color) {
	            me.color.destroy();
	            me.color = null;
	        }
	        me.visible = null;
	    },

	    /**
	     * Method: toServerJSONObject
	     * 转换成对应的 JSON 格式对象。
	     */
	    toServerJSONObject: function () {
	        var obj = {};
	        obj = SuperMap.Util.copyAttributes(obj, this);
	        if (obj.color) {
	            if (obj.color.toServerJSONObject) {
	                obj.color = obj.color.toServerJSONObject();
	            }
	        }
	        return obj;
	    },

	    CLASS_NAME: "ThemeGridUniqueItem"
	});
	ThemeGridUniqueItem.fromObj = function (obj) {
	    var res = new ThemeGridUniqueItem();
	    SuperMap.Util.copy(res, obj);
	    res.color = ServerColor.fromJson(obj.color);
	    return res;

	};
	module.exports = function (options) {
	    return new ThemeGridUniqueItem(options);
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: NetworkAnalystService
	 * 网络分析服务类
	 * 用法：
	 *      L.superMap.networkAnalystService(url).findPath({
	 *          nodes:[xxx,xxx],
	 *          parameter:{xxx:xxx}
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(4);
	__webpack_require__(111);
	__webpack_require__(114);
	__webpack_require__(118);
	__webpack_require__(120);
	__webpack_require__(122);
	__webpack_require__(125);
	__webpack_require__(127);
	__webpack_require__(129);
	__webpack_require__(131);
	__webpack_require__(133);
	__webpack_require__(135);
	__webpack_require__(11);

	NetworkAnalystService = ServiceBase.extend({

	    /**
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
	     * @param url
	     * @param options
	     */
	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    /**
	     * 爆管分析服务:即将给定弧段或节点作为爆管点来进行分析，返回关键结点 ID 数组，普通结点 ID 数组及其上下游弧段 ID 数组。
	     * @param params
	     *  <BurstPipelineAnalystParameters>
	     */
	    burstPipelineAnalyst: function (params) {
	        var me = this, param = me._processParams(params);
	        var burstPipelineAnalystService = new SuperMap.REST.BurstPipelineAnalystService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        burstPipelineAnalystService.processAsync(param);
	        return me;
	    },
	    /**
	     * 耗费矩阵分析服务:根据交通网络分析参数中的耗费字段返回一个耗费矩阵。该矩阵是一个二维数组，用来存储任意两点间的资源消耗。
	     * @param params
	     *      <ComputeWeightMatrixParameters>
	     */
	    computeWeightMatrix: function (params) {
	        var me = this, param = me._processParams(params);
	        var computeWeightMatrixService = new SuperMap.REST.ComputeWeightMatrixService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        computeWeightMatrixService.processAsync(param);
	        return me;
	    },

	    /**
	     * 最近设施分析服务:指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
	     * @param params
	     *      <FindClosestFacilitiesParameters>
	     * @param resultFormat
	     */
	    findClosestFacilities: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var findClosestFacilitiesService = new SuperMap.REST.FindClosestFacilitiesService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        findClosestFacilitiesService.processAsync(param);
	        return me;
	    },
	    /**
	     *上游/下游 关键设施查找资源服务:查找给定弧段或节点的上游/下游中的关键设施结点，返回关键结点 ID 数组及其下游弧段 ID 数组。
	     * @param params
	     *      <FacilityAnalystStreamParameters>
	     * @param resultFormat
	     */
	    streamFacilityAnalyst: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var facilityAnalystStreamService = new SuperMap.REST.FacilityAnalystStreamService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        facilityAnalystStreamService.processAsync(param);
	        return me;
	    },
	    /**
	     * 选址分区分析服务：确定一个或多个待建设施的最佳或最优位置
	     * @param params
	     *      <FindLocationParameters>
	     * @param resultFormat
	     */
	    findLocation: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var findLocationService = new SuperMap.REST.FindLocationService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        findLocationService.processAsync(param);
	        return me;
	    },
	    /**
	     * 最佳路径分析服务:在网络数据集中指定一些节点，按照节点的选择顺序，顺序访问这些节点从而求解起止点之间阻抗最小的路经。
	     * @param params
	     *      <FindPathParameters>
	     * @param resultFormat
	     */
	    findPath: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var findPathService = new SuperMap.REST.FindPathService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        findPathService.processAsync(param);
	        return me;
	    },
	    /**
	     * 旅行商分析服务:路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
	     * @param params
	     * <FindTSPPathsParameters>
	     * @param resultFormat
	     */
	    findTSPPaths: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var findTSPPathsService = new SuperMap.REST.FindTSPPathsService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        findTSPPathsService.processAsync(param);
	        return me;
	    },
	    /**
	     * 多旅行商分析服务:也称为物流配送，是指在网络数据集中，给定 M 个配送中心点和 N 个配送目的地（M，N 为大于零的整数）。查找经济有效的配送路径，并给出相应的行走路线。
	     * @param params
	     *      <FindMTSPPathsParameters>
	     * @param resultFormat
	     */
	    findMTSPPaths: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var findMTSPPathsService = new SuperMap.REST.FindMTSPPathsService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        findMTSPPathsService.processAsync(param);
	        return me;
	    },
	    /**
	     * 服务区分析服务：以指定服务站点为中心，在一定服务范围内查找网络上服务站点能够提供服务的区域范围。
	     * @param params
	     *      <FindServiceAreasParameters>
	     * @param resultFormat
	     */
	    findServiceAreas: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var findServiceAreasService = new SuperMap.REST.FindServiceAreasService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        findServiceAreasService.processAsync(param);
	        return me;
	    },
	    /**
	     * 更新边的耗费权重服务
	     * @param params
	     *      <UpdateEdgeWeightParameters>
	     */
	    updateEdgeWeight: function (params) {
	        var me = this;
	        var updateEdgeWeightService = new SuperMap.REST.UpdateEdgeWeightService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        updateEdgeWeightService.processAsync(params);
	        return me;
	    },
	    /**
	     * 转向耗费权重更新服务
	     * @param params
	     *      <UpdateTurnNodeWeightParameters>
	     */
	    updateTurnNodeWeight: function (params) {
	        var me = this;
	        var updateTurnNodeWeightService = new SuperMap.REST.UpdateTurnNodeWeightService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        updateTurnNodeWeightService.processAsync(params);
	        return me;
	    },

	    processCompleted: function (serverResult) {
	        this.fire('complete', {result: serverResult.result, originalResult: serverResult.originalResult});
	    },

	    _processParams: function (params) {
	        if (!params) {
	            return {};
	        }

	        if (params.centers && L.Util.isArray(params.centers)) {
	            params.centers.map(function (point, key) {
	                params.centers[key] = (point instanceof L.LatLng) ? {x: point.lng, y: point.lat} : point;
	            });
	        }

	        if (params.nodes && L.Util.isArray(params.nodes)) {
	            params.nodes.map(function (point, key) {
	                params.nodes[key] = (point instanceof L.LatLng) ? {x: point.lng, y: point.lat} : point;
	            });
	        }

	        if (params.event && params.event instanceof L.LatLng) {
	            params.event = {x: params.event.lng, y: params.event.lat};
	        }

	        if (params.facilities && L.Util.isArray(params.facilities)) {
	            params.facilities.map(function (point, key) {
	                params.facilities[key] = (point instanceof L.LatLng) ? {x: point.lng, y: point.lat} : point;
	            });
	        }

	        if (params.parameter && params.parameter.barrierPoints) {
	            var barrierPoints = params.parameter.barrierPoints;
	            if (L.Util.isArray(barrierPoints)) {
	                barrierPoints.map(function (point, key) {
	                    params.parameter.barrierPoints[key] = (point instanceof L.LatLng) ? {x: point.lng, y: point.lat} : point;
	                });
	            } else {
	                params.parameter.barrierPoints = [(barrierPoints instanceof L.LatLng) ? {x: barrierPoints.lng, y: barrierPoints.lat} : barrierPoints];
	            }
	        }
	        return params;
	    },
	    _processFormat: function (resultFormat) {
	        return (resultFormat) ? resultFormat : Format.GEOJSON;
	    }

	});

	L.supermap.networkAnalystService = function (url, options) {
	    return new NetworkAnalystService(url, options);
	};

	module.exports = L.supermap.networkAnalystService;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.BurstPipelineAnalystService
	 * 爆管分析服务类;即将给定弧段或节点作为爆管点来进行分析，返回关键结点 ID 数组，普通结点 ID 数组及其上下游弧段 ID 数组。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.NetworkAnalystServiceBase>
	 */
	__webpack_require__(112);
	__webpack_require__(113);
	SuperMap.REST.BurstPipelineAnalystService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.BurstPipelineAnalystService
	     * 爆管分析服务类构造函数。
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<BurstPipelineAnalystParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject;
	        var end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "burstAnalyse" : "/burstAnalyse") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");

	        jsonObject = {
	            sourceNodeIDs: params.sourceNodeIDs,
	            isUncertainDirectionValid: params.isUncertainDirectionValid
	        };

	        //必传参数不正确，就终止
	        if (params.edgeID !== null && params.nodeID !== null) return;
	        if (params.edgeID === null && params.nodeID === null) return;
	        if (params.edgeID !== null)
	            jsonObject.edgeID = params.edgeID;
	        else
	            jsonObject.nodeID = params.nodeID;

	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.BurstPipelineAnalystService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.BurstPipelineAnalystService(url, options);
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.NetworkAnalystServiceBase
	 * 网络分析服务基类。
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(3);
	__webpack_require__(13);
	SuperMap.REST.NetworkAnalystServiceBase = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     *  Property: format
	     *  {String} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
	     *  参数格式为"ISERVER","GEOJSON",GEOJSON
	     */
	    format: Format.GEOJSON,

	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options && options.format) {
	            this.format = options.format.toUpperCase();
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        this.format = null;
	    },

	    /**
	     * Method: getMapStatusCompleted
	     * 分析完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    serviceProcessCompleted: function (result) {
	        var me = this, analystResult;
	        result = SuperMap.Util.transformResult(result);
	        if (result && me.format === Format.GEOJSON && typeof me.toGeoJSONResult === 'function') {
	            analystResult = me.toGeoJSONResult(result);
	        }
	        if (!analystResult) {
	            analystResult = result;
	        }
	        me.events.triggerEvent("processCompleted", {result: analystResult, originalResult: result});
	    },

	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。只处理结果中的路由，由子类实现
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        return null;
	    },

	    CLASS_NAME: "SuperMap.REST.NetworkAnalystServiceBase"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.NetworkAnalystServiceBase(url, options);
	};


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: BurstPipelineAnalystParameters
	 * 爆管分析参数类。
	 */
	__webpack_require__(4);
	BurstPipelineAnalystParameters = SuperMap.Class({

	    /**
	     * APIProperty: sourceNodeIDs
	     * {Array(Number)} 指定的设施点ID数组,可以为空。
	     */
	    sourceNodeIDs: null,

	    /**
	     * APIProperty: edgeID
	     * {Number} 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。
	     */
	    edgeID: null,

	    /**
	     * APIProperty: nodeID
	     * {Number}: 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。
	     */
	    nodeID: null,

	    /**
	     * APIProperty: isUncertainDirectionValid
	     * {Boolean}: 指定不确定流向是否有效，默认为false。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
	     */
	    isUncertainDirectionValid: false,

	    /**
	     * Constructor: BurstPipelineAnalystParameters
	     * 爆管分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * sourceNodeIDs - {Array<Number>} 指定的设施点ID数组。
	     * edgeID - {Number} 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。
	     * nodeID - {Number} 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。
	     * isUncertainDirectionValid - {Boolean} 指定不确定流向是否有效；默认false，无效。
	     */
	    initialize: function (options) {
	        var me = this;
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.sourceNodeIDs = null;
	        me.edgeID = null;
	        me.nodeID = null;
	        me.isUncertainDirectionValid = null;
	    },

	    CLASS_NAME: "BurstPipelineAnalystParameters"
	});
	module.exports = function (options) {
	    return new BurstPipelineAnalystParameters(options);
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.ComputeWeightMatrixService
	 * 耗费矩阵分析服务类。
	 * 耗费矩阵是根据交通网络分析参数中的耗费字段来计算一个二维数组，
	 * 用来存储指定的任意两点间的资源消耗。
	 * 耗费矩阵分析结果通过该类支持的事件的监听函数参数获取
	 * Inherits from:
	 *  - <SuperMap.REST.NetworkAnalystServiceBase>
	 */
	__webpack_require__(112);
	__webpack_require__(115);
	SuperMap.REST.ComputeWeightMatrixService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.ComputeWeightMatrixService
	     * 耗费矩阵分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var mycomputeWeightMatrixService = new SuperMap.REST.ComputeWeightMatrixService(url,{
	     *     eventListeners: {
	     *	       "processCompleted": computeWeightMatrixCompleted, 
	     *		   "processFailed": computeWeightMatrixnError
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 耗费矩阵分析服务地址。请求服务的URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<ComputeWeightMatrixParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "weightmatrix" : "/weightmatrix") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            parameter: SuperMap.Util.toJSON(params.parameter),
	            nodes: me.getJson(params.isAnalyzeById, params.nodes)
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJson
	     * 将对象转化为JSON字符串。
	     *
	     * Parameters:
	     * isAnalyzeById - {Boolean}
	     * params - {Array}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJson: function (isAnalyzeById, params) {
	        var jsonString = "[",
	            len = params ? params.length : 0;

	        if (isAnalyzeById === false) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
	            }
	        } else if (isAnalyzeById == true) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += params[i];
	            }
	        }
	        jsonString += ']';
	        return jsonString;
	    },

	    CLASS_NAME: "SuperMap.REST.ComputeWeightMatrixService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.ComputeWeightMatrixService(url, options);
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: ComputeWeightMatrixParameters
	 * 耗费矩阵分析参数类。
	 * 根据交通网络分析参数中的耗费字段返回一个耗费矩阵。该矩阵是一个二维数组，用来存储任意两点间的资源消耗。
	 */
	__webpack_require__(4);
	__webpack_require__(116);
	ComputeWeightMatrixParameters = SuperMap.Class({

	    /**
	     * APIProperty: isAnalyzeById
	     * {Boolean} 是否通过节点 ID 指定路径分析的结点，默认为 false，即通过坐标点指定。
	     */
	    isAnalyzeById: false,

	    /**
	     * APIProperty: nodes
	     * {Array(<Point>/Number)} 要计算耗费矩阵的点数组，必设字段。
	     * 当 ComputeWeightMatrixParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；
	     * 当 ComputeWeightMatrixParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
	     */
	    nodes: null,

	    /**
	     * APIProperty: parameter
	     * {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    parameter: null,

	    /**
	     * Constructor: ComputeWeightMatrixParameters
	     * 耗费矩阵分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * isAnalyzeById - {Boolean} 是否通过节点 ID 指定路径分析的结点。
	     * nodes - {Array(<Point>/Number)} 要计算耗费矩阵的点数组，必设字段。
	     * parameter - {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.parameter = new TransportationAnalystParameter();
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.isAnalyzeById = null;
	        me.nodes = null;
	        if (me.parameter) {
	            me.parameter.destroy();
	            me.parameter = null;
	        }
	    },

	    CLASS_NAME: "ComputeWeightMatrixParameters"
	});
	module.exports = function (options) {
	    return new ComputeWeightMatrixParameters(options);
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP * 本程序只能在有效的授权许可下使用。 * 未经许可，不得以任何手段擅自使用或传播。*//** * Class: TransportationAnalystParameter * 交通网络分析通用参数类。 * 该类主要用来提供交通网络分析所需的通用参数。 * 通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息，还可以对分析结果包含的内容进行一些设置。 */__webpack_require__(4);__webpack_require__(117);TransportationAnalystParameter = SuperMap.Class({    /**     * APIProperty: barrierEdgeIDs     * {Array(<Number>)} 网络分析中障碍弧段的 ID 数组。弧段设置为障碍边之后，表示双向都不通。     */    barrierEdgeIDs: null,    /**     * APIProperty: barrierNodeIDs     * {Array(<Number>)} 网络分析中障碍点的 ID 数组。结点设置为障碍点之后，表示任何方向都不能通过此结点。     */    barrierNodeIDs: null,    /**     * APIProperty: barrierPoints     * {Array(<Point>)}网络分析中 Point2D 类型的障碍点数组。障碍点表示任何方向都不能通过此点。     * 当各网络分析参数类中的 isAnalyzeById 属性设置为 false 时，该属性才生效。     */    barrierPoints: null,    /**     * APIProperty: weightFieldName     * {String} 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，例如表示时间、长度等的字段都可以用作阻力字段。     * 该字段默值为服务器发布的所有耗费字段的第一个字段。     */    weightFieldName: null,    /**     * APIProperty: turnWeightField     * {String} 转向权重字段的名称。     */    turnWeightField: null,    /**     * APIProperty: resultSetting     * {<TransportationAnalystResultSetting>} 分析结果返回内容。     */    resultSetting: null,    /**     * Constructor: TransportationAnalystParameter     * 交通网络分析通用参数类构造函数。     *     * Parameters:     * options - {Object} 参数。     *     * Allowed options properties:     * barrierEdgeIDs - {Array(<Number>)} 网络分析中障碍弧段的 ID 数组。     * barrierNodeIDs - {Array(<Number>)} 网络分析中障碍点的 ID 数组。     * barrierPoints - {Array(<Point>)}     * weightFieldName - {String} 阻力字段的名称。     * turnWeightField - {String} 转向权重字段的名称。     * resultSetting - {<TransportationAnalystResultSetting>} 分析结果返回内容。     */    initialize: function (options) {        var me = this;        me.resultSetting = new TransportationAnalystResultSetting();        if (!options) {            return;        }        SuperMap.Util.extend(this, options);    },    /**     * APIMethod: destroy     * 释放资源，将引用资源的属性置空。     */    destroy: function () {        var me = this;        me.barrierEdgeIDs = null;        me.barrierNodeIDs = null;        me.weightFieldName = null;        me.turnWeightField = null;        if (me.resultSetting) {            me.resultSetting.destroy();            me.resultSetting = null;        }        if (me.barrierPoints && me.barrierPoints.length) {            for (var i in me.barrierPoints) {                me.barrierPoints.destroy();            }        }        me.barrierPoints = null;    },    CLASS_NAME: "TransportationAnalystParameter"});module.exports = function (options) {    return new TransportationAnalystParameter(options);};

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP * 本程序只能在有效的授权许可下使用。 * 未经许可，不得以任何手段擅自使用或传播。*//** * Class: TransportationAnalystResultSetting * 交通网络分析结果参数类。 * 通过该类设置交通网络分析返回的结果，包括是否返回图片、是否返回弧段空间信息、是否返回结点空间信息等。 */__webpack_require__(4);TransportationAnalystResultSetting = SuperMap.Class({    /**     * APIProperty: returnEdgeFeatures     * {Boolean} 是否在分析结果中包含弧段要素集合。弧段要素包括弧段的空间信息和属性信息。     */    returnEdgeFeatures: false,    /**     * APIProperty: returnEdgeGeometry     * {Boolean} 返回的弧段要素集合中是否包含几何对象信息。默认为 false。     */    returnEdgeGeometry: false,    /**     * APIProperty: returnEdgeIDs     * {Boolean} 返回结果中是否包含经过弧段 ID 集合。默认为 false。     */    returnEdgeIDs: false,    /**     * APIProperty: returnNodeFeatures     * {Boolean} 是否在分析结果中包含结点要素集合。     * 结点要素包括结点的空间信息和属性信息。其中返回的结点要素是否包含空间信息可通过 returnNodeGeometry 字段设置。默认为 false。     */    returnNodeFeatures: false,    /**     * APIProperty: returnNodeGeometry     * {Boolean} 返回的结点要素集合中是否包含几何对象信息。默认为 false。     */    returnNodeGeometry: false,    /**     * APIProperty: returnNodeIDs     * {Boolean} 返回结果中是否包含经过结点 ID 集合。默认为 false。     */    returnNodeIDs: false,    /**     * APIProperty: returnPathGuides     * {Boolean} 返回分析结果中是否包含行驶导引集合。     */    returnPathGuides: false,    /**     * APIProperty: returnRoutes     * {Boolean} 返回分析结果中是否包含路由对象的集合。     */    returnRoutes: false,    /**     * Constructor: TransportationAnalystResultSetting     * 交通网络分析结果参数类构造函数。     *     * Parameters:     * options - {Object} 参数。     *     * Allowed options properties:     * returnEdgeFeatures - {Boolean} 是否在分析结果中包含弧段要素集合。     * returnEdgeGeometry - {Boolean} 返回的弧段要素集合中是否包含几何对象信息。默认为 false。     * returnEdgeIDs - {Boolean} 返回结果中是否包含经过弧段 ID 集合。默认为 false。     * returnNodeFeatures - {Boolean} 是否在分析结果中包含结点要素集合。     * returnNodeGeometry - {Boolean} 返回的结点要素集合中是否包含几何对象信息。默认为 false。     * returnNodeIDs - {Boolean} 返回结果中是否包含经过结点 ID 集合。默认为 false。     * returnPathGuides - {Boolean} 返回分析结果中是否包含行驶导引集合。     * returnRoutes - {Boolean} 返回分析结果中是否包含路由对象的集合。     */    initialize: function (options) {        if (!options) {            return;        }        SuperMap.Util.extend(this, options);    },    /**     * APIMethod: destroy     * 释放资源，将引用资源的属性置空。     */    destroy: function () {        var me = this;        me.returnEdgeFeatures = null;        me.returnEdgeGeometry = null;        me.returnEdgeIDs = null;        me.returnNodeFeatures = null;        me.returnNodeGeometry = null;        me.returnNodeIDs = null;        me.returnPathGuides = null;        me.returnRoutes = null;    },    CLASS_NAME: "TransportationAnalystResultSetting"});module.exports = function (options) {    return new TransportationAnalystResultSetting(options);};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.FacilityAnalystStreamService
	 * 上游/下游 关键设施查找资源服务类;即查找给定弧段或节点的上游/下游中的关键设施结点，返回关键结点 ID 数组及其下游弧段 ID 数组。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.NetworkAnalystServiceBase>
	 */
	__webpack_require__(112);
	__webpack_require__(119);
	SuperMap.REST.FacilityAnalystStreamService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FacilityAnalystStreamService
	     * 上游/下游关键设施查找资源服务类构造函数。
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FacilityAnalystStreamParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject;
	        var end = me.url.substr(me.url.length - 1, 1);

	        //URL 通过参数类型来判断是 上游 还是下游 查询
	        if (params.queryType === 0) {
	            me.url = me.url + ((end === "/") ? "upstreamcirticalfaclilities" : "/upstreamcirticalfaclilities") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        }
	        else if (params.queryType === 1) {
	            me.url = me.url + ((end === "/") ? "downstreamcirticalfaclilities" : "/downstreamcirticalfaclilities") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        }
	        else return;

	        jsonObject = {
	            sourceNodeIDs: params.sourceNodeIDs,
	            isUncertainDirectionValid: params.isUncertainDirectionValid
	        };

	        if (params.edgeID !== null && params.nodeID !== null) return;
	        if (params.edgeID === null && params.nodeID === null) return;
	        if (params.edgeID !== null)
	            jsonObject.edgeID = params.edgeID;
	        else
	            jsonObject.nodeID = params.nodeID;

	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.FacilityAnalystStreamService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FacilityAnalystStreamService(url, options);
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: FacilityAnalystStreamParameters
	 * 上游/下游关键设施查找资源参数类。
	 */
	__webpack_require__(4);
	FacilityAnalystStreamParameters = SuperMap.Class({

	    /**
	     * APIProperty: sourceNodeIDs
	     * {Array<Number>} 指定的设施点ID数组,可以为空。
	     */
	    sourceNodeIDs: null,

	    /**
	     * APIProperty: edgeID
	     * {Number} 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。
	     */
	    edgeID: null,

	    /**
	     * APIProperty: nodeID
	     * {Number}: 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。
	     */
	    nodeID: null,

	    /**
	     * APIProperty: isUncertainDirectionValid
	     * {Boolean}: 指定不确定流向是否有效，默认为false。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
	     */
	    isUncertainDirectionValid: false,

	    /**
	     * APIProperty: type
	     * {Number}: 分析类型，只能是 0 (上游关键设施查询) 或者是 1（下游关键设施查询）。
	     */
	    queryType: null,

	    /**
	     * Constructor: FacilityAnalystStreamParameters
	     * 最近设施分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * sourceNodeIDs - {Array<Number>} 指定的设施点ID数组。
	     * edgeID - {Number} 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。
	     * nodeID - {Number} 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。
	     * isUncertainDirectionValid - {Boolean} 指定不确定流向是否有效；默认false，无效。
	     * type - {Number} 分析类型，只能是 0 (上游关键设施查询) 或者是 1（下游关键设施查询）
	     */
	    initialize: function (options) {
	        var me = this;
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.edgeID = null;
	        me.nodeID = null;
	        me.weightName = null;
	        me.isUncertainDirectionValid = null;
	        me.type = null;
	    },

	    CLASS_NAME: "FacilityAnalystStreamParameters"
	});
	module.exports = function (options) {
	    return new FacilityAnalystStreamParameters(options);
	};

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.FindClosestFacilitiesService
	 * 最近设施分析服务类。
	 * 最近设施分析是指在网络上给定一个事件点和一组设施点，
	 * 查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
	 * 该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
	 * 最近设施分析结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.NetworkAnalystServiceBase>
	 */
	__webpack_require__(112);
	__webpack_require__(121);
	SuperMap.REST.FindClosestFacilitiesService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FindClosestFacilitiesService
	     * 最近设施分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myfindClosestFacilitiesService = new SuperMap.REST.FindClosestFacilitiesService(url, {
	     *     eventListeners: {
	     *	       "processCompleted": findClosestFacilitiesCompleted, 
	     *		   "processFailed": findClosestFacilitiesError
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FindClosestFacilitiesParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "closestfacility" : "/closestfacility") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            expectFacilityCount: params.expectFacilityCount,
	            fromEvent: params.fromEvent,
	            maxWeight: params.maxWeight,
	            parameter: SuperMap.Util.toJSON(params.parameter),
	            event: SuperMap.Util.toJSON(params.event),
	            facilities: me.getJson(params.isAnalyzeById, params.facilities)
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJson
	     * 将对象转化为JSON字符串。
	     *
	     * Parameters:
	     * isAnalyzeById - {Boolean}
	     * params - {Array}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJson: function (isAnalyzeById, params) {
	        var jsonString = "[",
	            len = params ? params.length : 0;

	        if (isAnalyzeById === false) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
	            }
	        } else if (isAnalyzeById == true) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += params[i];
	            }
	        }
	        jsonString += ']';
	        return jsonString;
	    },
	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        if (!result || !result.facilityPathList) {
	            return result;
	        }
	        //只处理route ,pathGuide,edgeFeatures,nodeFeatures
	        var analystResults = [];
	        var geoJSONFormat = new SuperMap.Format.GeoJSON();
	        result.facilityPathList.forEach(function (path) {
	            var analystResult = {};
	            if (path.route) {
	                analystResult.route = JSON.parse(geoJSONFormat.write(path.route));
	            }
	            if (path.pathGuideItems) {
	                analystResult.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));

	            }
	            if (path.edgeFeatures) {
	                analystResult.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
	            }
	            if (path.nodeFeatures) {
	                analystResult.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
	            }
	            analystResults.push(analystResult);
	        });
	        return analystResults;
	    },

	    CLASS_NAME: "SuperMap.REST.FindClosestFacilitiesService"
	});
	module.exports = function (url, options) {
	    return new SuperMap.REST.FindClosestFacilitiesService(url, options);
	};

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: FindClosestFacilitiesParameters
	 * 最近设施分析参数类。
	 * 最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
	 * 设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。
	 * 例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。
	 * 最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
	 */
	__webpack_require__(4);
	__webpack_require__(116);
	FindClosestFacilitiesParameters = SuperMap.Class({

	    /**
	     * APIProperty: event
	     * {<Point>/Integer} 事件点，一般为需要获得服务设施服务的事件位置，必设字段。
	     * 可以通过两种方式赋予事件点：当该类中字段 isAnalyzeById = true 时，应输入事件点 ID 号；当 isAnalyzeById = false 时，应输入事件点坐标。
	     */
	    event: null,

	    /**
	     * APIProperty: expectFacilityCount
	     * {Number} 要查找的设施点数量。默认值为1。
	     */
	    expectFacilityCount: 1,

	    /**
	     * APIProperty: facilities
	     * {Array(<Point>/Number)} 设施点集合，一般为提供服务的服务设施位置，必设字段。
	     * 可以通过两种方式赋予设施点：当该类中字段 isAnalyzeById = true 时，应输入设施点 ID 号；当 isAnalyzeById = false 时，应输入设施点坐标。
	     */
	    facilities: null,

	    /**
	     * APIProperty: fromEvent
	     * {Boolean} 是否从事件点到设施点进行查找。
	     * 最近设施分析主要是通过设施点和事件点之间最优的路线来分析在一定范围内哪个或哪些设施与事件点有最优路线的关系。
	     * 这个行走线路是通过网络图层进行网络分析算法计算出来的两点间的最优路线。
	     * 由于存在从 A 点到 B 点与从 B 点到 A 点的耗费不一样的情况，因此起止点不同可能会得到不同的最优路线。
	     * 因此在进行最近设施分析之前，需要设置获取的最优路线的方向，即是以事件点作为起点到最近设施点的方向分析，还是以最近设施点为起点到事件点的方向分析。
	     * 如果需要以事件点作为起点到设施点方向进行查找，设置该字段值为 true；默认为 false，表示从设施点到事件点进行查找。
	     */
	    fromEvent: false,

	    /**
	     * APIProperty: isAnalyzeById
	     * {Boolean} 事件点和设施点是否通过节点 ID 号来指定，默认为 false，即通过坐标点指定事件点和设施点。
	     */
	    isAnalyzeById: false,

	    /**
	     * APIProperty: maxWeight
	     * {Number} 查找半径。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。默认值为0，表示查找全网络。
	     * 例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。那么需要将网络分析参数中 parameter.weightFieldName 设置为表示时间的字段，然后设置查找范围的半径值为10。
	     */
	    maxWeight: 0,

	    /**
	     * APIProperty: parameter
	     * {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     * 通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。
	     * 它为 TransportationAnalystParameter 类型，虽然为可选参数，但是如果不设置其中的 resultSetting 字段，则返回结果空间信息等都为空。
	     */
	    parameter: null,

	    /**
	     * Constructor: FindClosestFacilitiesParameters
	     * 最近设施分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * event - {<Point>/Integer} 事件点，一般为需要获得服务设施服务的事件位置，必设字段。
	     * expectFacilityCount - {Integer} 要查找的设施点数量。默认值为1。
	     * facilities - {Array(<Point>/Number)} 设施点集合，一般为提供服务的服务设施位置，必设字段。
	     * fromEvent - {Boolean} 是否从事件点到设施点进行查找。
	     * isAnalyzeById - {Boolean} 事件点和设施点是否通过节点 ID 号来指定，默认为 false，即通过坐标点指定事件点和设施点。
	     * maxWeight - {Number} 查找半径。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。默认值为0，表示查找全网络。
	     * parameter - {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.parameter = new TransportationAnalystParameter();
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.event = null;
	        me.expectFacilityCount = null;
	        me.facilities = null;
	        me.fromEvent = null;
	        me.isAnalyzeById = null;
	        me.maxWeight = null;
	        if (me.parameter) {
	            me.parameter.destroy();
	            me.parameter = null;
	        }
	    },

	    CLASS_NAME: "FindClosestFacilitiesParameters"
	});
	module.exports = function (options) {
	    return new FindClosestFacilitiesParameters(options);
	};

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.FindLocationService
	 * 选址分区分析服务类。
	 * 选址分区分析是为了确定一个或多个待建设施的最佳或最优位置，使得设施可以用一种最经济有效的方式为需求方提供服务或者商品。
	 * 选址分区不仅仅是一个选址过程，还要将需求点的需求分配到相应的新建设施的服务区中，因此称之为选址与分区。
	 * 选址分区分析结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.NetworkAnalystServiceBase>
	 */
	__webpack_require__(112);
	__webpack_require__(123);
	SuperMap.REST.FindLocationService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FindLocationService
	     * 选址分区分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var findLocationService = new SuperMap.REST.FindLocationService(url, {
	     *     eventListeners: {
	     *         "processCompleted": findLocationCompleted, 
	     *		   "processFailed": findLocationError
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FindLocationParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "location" : "/location") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            isFromCenter: params.isFromCenter,
	            expectedSupplyCenterCount: params.expectedSupplyCenterCount,
	            weightName: params.weightName,
	            turnWeightField: params.turnWeightField,
	            returnEdgeFeature: true,
	            returnEdgeGeometry: true,
	            returnNodeFeature: true,
	            mapParameter: SuperMap.Util.toJSON(params.mapParameter),
	            supplyCenters: me.getCentersJson(params.supplyCenters)
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getCentersJson
	     * 将数组对象转化为JSON字符串。
	     *
	     * Parameters:
	     * params - {Array}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getCentersJson: function (params) {
	        var json = "[",
	            len = params ? params.length : 0;
	        for (var i = 0; i < len; i++) {
	            if (i > 0) json += ",";
	            json += SuperMap.Util.toJSON(params[i]);
	        }
	        json += "]";
	        return json;
	    },
	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        if (!result) {
	            return null;
	        }
	        var analystResult = {};
	        var geoJSONFormat = new SuperMap.Format.GeoJSON();
	        if (result.demandResults) {
	            analystResult.demandResults = JSON.parse(geoJSONFormat.write(result.demandResults));
	        }
	        if (result.supplyResults) {
	            analystResult.supplyResults = JSON.parse(geoJSONFormat.write(result.supplyResults)); }

	        return analystResult;
	    },

	    CLASS_NAME: "SuperMap.REST.FindLocationService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FindLocationService(url, options);
	};

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: FindLocationParameters
	 * 选址分区分析参数类。
	 * 选址分区分析是为了确定一个或多个待建设施的最佳或最优位置，使得设施可以用一种最经济有效的方式为需求方提供服务或者商品。
	 * 选址分区不仅仅是一个选址过程，还要将需求点的需求分配到相应的新建设施的服务区中，因此称之为选址与分区。
	 *  分析过程中使用的需求点都为网络结点，即除了各种类型的中心点所对应的网络结点以外，
	 * 所有网络结点都作为资源需求点参与选址分区分析，如果要排除某部分结点不分析，可以将其设置为障碍点。
	 */
	__webpack_require__(4);
	__webpack_require__(124);
	FindLocationParameters = SuperMap.Class({

	    /**
	     * APIProperty: expectedSupplyCenterCount
	     * {Number} 期望用于最终设施选址的资源供给中心数量，必设字段。
	     * 当输入值为0时，最终设施选址的资源供给中心数量默认为覆盖分析区域内的所需最少的供给中心数。
	     */
	    expectedSupplyCenterCount: null,

	    /**
	     * APIProperty: isFromCenter
	     * {Boolean} 是否从中心点开始分配资源。默认为 false。
	     * 由于网路数据中的弧段具有正反阻力，即弧段的正向阻力值与其反向阻力值可能不同，
	     * 因此，在进行分析时，从资源供给中心开始分配资源到需求点与从需求点向资源供给中心分配这两种分配形式下，所得的分析结果会不同。
	     */
	    isFromCenter: false,


	    /**
	     * APIProperty: supplyCenters
	     * {Array(<SupplyCenter>)} 资源供给中心集合，必设字段。
	     * 资源供给中心是提供资源和服务的设施，对应于网络结点，
	     * 资源供给中心的相关信息包括资源量、最大阻力值、资源供给中心类型，资源供给中心在网络中所处结点的 ID 等，以便在进行选址分区分析时使用。
	     */
	    supplyCenters: null,

	    /**
	     * APIProperty: turnWeightField
	     * {String} 转向权值字段的名称。
	     */
	    turnWeightField: null,

	    /**
	     * APIProperty: weightName
	     * {String} 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，必设字段。
	     */
	    weightName: null,

	    /**
	     * Constructor: FindLocationParameters
	     * 服务区分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * expectedSupplyCenterCount - {Integer} 期望用于最终设施选址的资源供给中心数量，必设字段。
	     * isFromCenter - {Boolean} 是否从中心点开始分配资源。默认为 false。
	     * supplyCenters - {Array(<SupplyCenter>)} 资源供给中心集合，必设字段。
	     * turnWeightField - {String} 转向权值字段的名称。
	     * weightName - {String} 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，必设字段。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.expectedSupplyCenterCount = null;
	        me.isFromCenter = null;
	        me.turnWeightField = null;
	        me.weightName = null;
	        if (me.supplyCenters) {
	            for (var i = 0, supplyCenters = me.supplyCenters, len = supplyCenters.length; i < len; i++) {
	                supplyCenters[i].destroy();
	            }
	            me.supplyCenters = null;
	        }
	    },

	    CLASS_NAME: "FindLocationParameters"
	});
	module.exports = function (options) {
	    return new FindLocationParameters(options);
	};

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SupplyCenter
	 * 资源供给中心类
	 * 资源供给中心类，在资源分配和选址分区分析两个功能中使用。
	 */
	__webpack_require__(4);
	SupplyCenter = SuperMap.Class({
	    /**
	     * APIProperty: maxWeight
	     * {Number} 资源供给中心的最大耗费值，必设参数。中心点最大阻值设置越小，表示中心点所提供的资源可影响范围越大。
	     * 最大阻力值是用来限制需求点到中心点的花费。
	     * 如果需求点（弧段或结点）到此中心的花费大于最大阻力值，则该需求点不属于该资源供给中心提供资源的范围。
	     */
	    maxWeight: null,

	    /**
	     * APIProperty: nodeID
	     * {Integer} 资源供给中心点的结点 ID 号，必设参数。资源供给中心必须是结点。
	     */
	    nodeID: null,

	    /**
	     * APIProperty: resourceValue
	     * {Number} 资源供给中心能提供的最大服务量或商品数量，必设参数。例如资源中心为学校，资源中心资源量表示
	     * 该学校能够接纳多少学生。
	     */
	    resourceValue: null,

	    /**
	     * APIProperty: type
	     * {<SupplyCenterType>} 资源供给中心点的类型常量。资源供给中心点的类型包括非中心，固定中心和可选中心。
	     * 固定中心用于资源分配分析；固定中心和可选中心用于选址分析；非中心在两种网络分析时都不予考虑。
	     */
	    type: null,

	    /**
	     * Constructor: SupplyCenter
	     * 资源供给中心类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * maxWeight - {Number} 资源供给中心的最大耗费值，必设参数。
	     * nodeID - {Integer} 资源供给中心点的结点 ID 号，必设参数。资源供给中心必须是结点。
	     * resourceValue - {Number} 资源供给中心能提供的最大服务量或商品数量，必设参数。
	     * type - {SupplyCenterType} 资源供给中心点的类型常量。
	     */
	    initialize: function (options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.maxWeight = null;
	        me.nodeID = null;
	        me.resourceValue = null;
	        me.type = null;
	    },

	    CLASS_NAME: "SupplyCenter"
	});

	SupplyCenter.fromJson = function (jsonObject) {
	    if (!jsonObject) {
	        return;
	    }
	    var result = new SupplyCenter({
	        maxWeight: jsonObject.maxWeight,
	        nodeID: jsonObject.nodeID,
	        resourceValue: jsonObject.resourceValue,
	        type: jsonObject.type
	    });
	    return result;
	};
	module.exports = function (options) {
	    return new SupplyCenter(options);
	};



/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.FindMTSPPathsService
	 * 多旅行商分析服务类
	 * 多旅行商分析也称为物流配送，是指在网络数据集中，给定 M 个配送中心点和 N 个配送目的地（M，N 为大于零的整数）。
	 * 查找经济有效的配送路径，并给出相应的行走路线。
	 * 物流配送功能就是解决如何合理分配配送次序和送货路线，使配送总花费达到最小或每个配送中心的花费达到最小。
	 * 该类负责将客户端指定的多旅行商分析参数传递给服务端，并接收服务端返回的结果数据。
	 * 多旅行商分析结果通过该类支持的事件的监听函数参数获取
	 * Inherits from:
	 *  - <SuperMap.REST.NetworkAnalystServiceBase>
	 */
	__webpack_require__(112);
	__webpack_require__(126);
	SuperMap.REST.FindMTSPPathsService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FindMTSPPathsService
	     * 最佳路径分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myFindMTSPPathsService = new SuperMap.REST.FindMTSPPathsService(url, {
	     *     eventListeners: {
	     *         "processCompleted": findMTSPPathsCompleted, 
	     *		   "processFailed": findMTSPPathsError
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FindMTSPPathsParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1),
	            centers = me.getJson(params.isAnalyzeById, params.centers),
	            nodes = me.getJson(params.isAnalyzeById, params.nodes);
	        me.url = me.url + "/mtsppath" + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            centers: centers,
	            nodes: nodes,
	            parameter: SuperMap.Util.toJSON(params.parameter),
	            hasLeastTotalCost: params.hasLeastTotalCost
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJson
	     * 将对象转化为JSON字符串。
	     *
	     * Parameters:
	     * isAnalyzeById - {Boolean}
	     * params - {Array}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJson: function (isAnalyzeById, params) {
	        var jsonString = "[",
	            len = params ? params.length : 0;

	        if (isAnalyzeById === false) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
	            }
	        } else if (isAnalyzeById == true) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += params[i];
	            }
	        }
	        jsonString += ']';
	        return jsonString;
	    },
	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        if (!result || !result.pathList) {
	            return null;
	        }
	        //只处理route ,pathGuide,edgeFeatures,nodeFeatures
	        var analystResults = [];
	        var geoJSONFormat = new SuperMap.Format.GeoJSON();
	        result.pathList.forEach(function (path) {
	            var analystResult = {};
	            if (path.route) {
	                analystResult.route = JSON.parse(geoJSONFormat.write(path.route));
	            }
	            if (path.pathGuideItems) {
	                analystResult.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));

	            }
	            if (path.edgeFeatures) {
	                analystResult.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
	            }
	            if (path.nodeFeatures) {
	                analystResult.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
	            }
	            analystResults.push(analystResult);
	        });
	        return analystResults;
	    },

	    CLASS_NAME: "SuperMap.REST.FindMTSPPathsService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FindMTSPPathsService(url, options);
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: FindMTSPPathsParameters
	 * 多旅行商分析参数类。
	 * 多旅行商分析也称为物流配送，是指在网络数据集中，给定 M 个配送中心点和 N 个配送目的地（M，N 为大于零的整数），查找经济有效的配送路径，并给出相应的行走路线。
	 * 物流配送功能就是解决如何合理分配配送次序和送货路线，使配送总花费达到最小或每个配送中心的花费达到最小。
	 * 例如：现在有50个报刊零售地（配送目的地），和4个报刊供应地（配送中心），现寻求这4个供应地向报刊零售地发送报纸的最优路线，属物流配送问题。
	 */
	__webpack_require__(4);
	__webpack_require__(116);
	FindMTSPPathsParameters = SuperMap.Class({

	    /**
	     * APIProperty: centers
	     * {<Point>/Integer} 配送中心集合，必设字段。
	     * 当 FindMTSPPathsParameters.isAnalyzeById = false 时，centers 应为点的坐标数组；当 FindMTSPPathsParameters.isAnalyzeById = true 时，centers 应为点的 ID 数组。
	     */
	    centers: null,

	    /**
	     * APIProperty: hasLeastTotalCost
	     * {Boolean} 配送模式是否为总花费最小方案。默认为 false。
	     * 若为 true，则按照总花费最小的模式进行配送，此时可能会出现某几个配送中心点配送的花费较多而其他配送中心点的花费很少的情况。
	     * 若为 false，则为局部最优，此方案会控制每个配送中心点的花费，使各个中心点花费相对平均，此时总花费不一定最小。
	     */
	    hasLeastTotalCost: false,

	    /**
	     * APIProperty: isAnalyzeById
	     * {Boolean} 是否通过节点 ID 号来指定配送中心点和配送目的点，默认为 false，即通过坐标点指定。
	     */
	    isAnalyzeById: false,

	    /**
	     * APIProperty: nodes
	     * {Array(<Point>/Number)} 配送目标集合，必设字段。
	     * 当 FindMTSPPathsParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；当 FindMTSPPathsParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
	     */
	    nodes: null,

	    /**
	     * APIProperty: parameter
	     * {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     * 通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。
	     * TransportationAnalystParameter 类型，它虽然为可选参数，但是如果不设置其中的 resultSetting 字段，则返回结果空间信息等都为空。
	     */
	    parameter: null,

	    /**
	     * Constructor: FindMTSPPathsParameters
	     * 多旅行商分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * centers - {<Point>/Integer} 配送中心集合，必设字段。
	     * hasLeastTotalCost - {Boolean} 配送模式是否为总花费最小方案。默认为 false。
	     * isAnalyzeById - {Boolean} 是否通过节点 ID 号来指定配送中心点和配送目的点，默认为 false，即通过坐标点指定。
	     * nodes - {Array(<Point>/Number)} 配送目标集合，必设字段。
	     * parameter - {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.parameter = new TransportationAnalystParameter();
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.centers = null;
	        me.hasLeastTotalCost = null;
	        me.isAnalyzeById = null;
	        me.nodes = null;
	        me.maxWeight = null;
	        if (me.parameter) {
	            me.parameter.destroy();
	            me.parameter = null;
	        }
	    },

	    CLASS_NAME: "FindMTSPPathsParameters"
	});
	module.exports = function (options) {
	    return new FindMTSPPathsParameters(options);
	};

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.FindPathService
	 * 最佳路径分析服务类。
	 * 最佳路径是在网络数据集中指定一些节点，按照节点的选择顺序，
	 * 顺序访问这些节点从而求解起止点之间阻抗最小的路经。
	 * 该类负责将客户端指定的最佳路径分析参数传递给服务端，并接收服务端返回的结果数据。
	 * 最佳路径分析结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.NetworkAnalystServiceBase>
	 */
	__webpack_require__(112);
	__webpack_require__(128);
	SuperMap.REST.FindPathService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FindPathService
	     * 最佳路径分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myFindPathService = new SuperMap.REST.FindPathService(url, {
	     *     eventListeners: {
	     *	       "processCompleted": findPathCompleted, 
	     *		   "processFailed": findPathError
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FindPathParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "path" : "/path") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            hasLeastEdgeCount: params.hasLeastEdgeCount,
	            parameter: SuperMap.Util.toJSON(params.parameter),
	            nodes: me.getJson(params.isAnalyzeById, params.nodes)
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJson
	     * 将对象转化为JSON字符串。
	     *
	     * Parameters:
	     * isAnalyzeById - {Boolean}
	     * params - {Array}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJson: function (isAnalyzeById, params) {
	        var jsonString = "[",
	            len = params ? params.length : 0;

	        if (isAnalyzeById === false) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
	            }
	        } else if (isAnalyzeById == true) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += params[i];
	            }
	        }
	        jsonString += ']';
	        return jsonString;
	    },

	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        if (!result || !result.pathList || result.pathList.length < 1) {
	            return null;
	        }
	        //只处理route ,pathGuide,edgeFeatures,nodeFeatures
	        var analystResults = [];
	        var geoJSONFormat = new SuperMap.Format.GeoJSON();
	        result.pathList.forEach(function (path) {
	            var analystResult = {};
	            if (path.route) {
	                analystResult.route = JSON.parse(geoJSONFormat.write(path.route));
	            }
	            if (path.pathGuideItems) {
	                analystResult.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));

	            }
	            if (path.edgeFeatures) {
	                analystResult.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
	            }
	            if (path.nodeFeatures) {
	                analystResult.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
	            }
	            analystResults.push(analystResult);
	        });
	        return analystResults;
	    },

	    CLASS_NAME: "SuperMap.REST.FindPathService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FindPathService(url, options);
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: FindPathParameters
	 * 最佳路径分析参数类。
	 * 最佳路径是在网络数据集中指定一些结点，按照顺序访问结点从而求解起止点之间阻抗最小的路径。
	 * 例如如果要顺序访问1、2、3、4四个结点，则需要分别找到1、2结点间的最佳路径 R1—2，2、3间的最佳路径 R2—3和3、4结点间的最佳路径 R3—4，顺序访问1、2、3、4四个结点的最佳路径就是 R= R1—2 + R2—3 + R3—4。
	 * 阻抗就是指从一点到另一点的耗费，在实际应用中我们可以将距离、时间、花费等作为阻抗条件。
	 * 阻抗最小也就可以理解为从一点到另一点距离最短、时间最少、花费最低等。当两点间距离最短时为最短路径，它是最佳路径问题的一个特例。
	 * 阻抗值通过 TransportationAnalystParameter.weightFieldName 设置。
	 * 计算最佳路径除了受阻抗影响外，还受转向字段的影响。转向值通过 TransportationAnalystParameter.turnWeightField 设置。
	 */
	__webpack_require__(4);
	__webpack_require__(116);
	FindPathParameters = SuperMap.Class({

	    /**
	     * APIProperty: isAnalyzeById
	     * {Boolean} 是否通过节点 ID 指定路径分析的结点，默认为 false。
	     * 指定路径分析经过的结点或设施点有两种方式：输入结点 ID 号或直接输入点坐标。
	     * 当该字段为 true 时，表示通过结点 ID 指定途经点，即 FindPathParameters.nodes = [ID1,ID2,...]；
	     * 反之表示通过结点坐标指定途经点，即 FindPathParameters.nodes = [{x1,y1},{x2,y2},...] 。
	     */
	    isAnalyzeById: false,

	    /**
	     * APIProperty: hasLeastEdgeCount
	     * {Boolean} 是否按照弧段数最少的进行最佳路径分析。
	     * true 表示按照弧段数最少进行分析，返回弧段数最少的路径中一个阻抗最小的最佳路径；
	     * false表示直接返回阻抗最小的路径，而不考虑弧段的多少。
	     */
	    hasLeastEdgeCount: null,

	    /**
	     * APIProperty: nodes
	     * {Array(<Point>/Number)} 最佳路径分析经过的结点或设施点数组，必设字段。该字段至少包含两个点。
	     * 当 FindPathParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；
	     * 当 FindPathParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
	     */
	    nodes: null,

	    /**
	     * APIProperty: parameter
	     * {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    parameter: null,

	    /**
	     * Constructor: FindPathParameters
	     * 最佳路径分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * isAnalyzeById - {Boolean} 是否通过节点 ID 指定路径分析的结点。
	     * hasLeastEdgeCount - {Boolean} 是否按照弧段数最少的进行最佳路径分析。
	     * nodes - {Array()} 最佳路径分析经过的结点或设施点数组，必设字段。该字段至少包含两个点。
	     * parameter - {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.parameter = new TransportationAnalystParameter();
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.isAnalyzeById = null;
	        me.hasLeastEdgeCount = null;
	        me.nodes = null;
	        if (me.parameter) {
	            me.parameter.destroy();
	            me.parameter = null;
	        }
	    },

	    CLASS_NAME: "FindPathParameters"
	});
	module.exports = function (options) {
	    return new FindPathParameters(options);
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.FindServiceAreasService
	 * 服务区分析服务类。
	 * 服务区分析是以指定服务站点为中心，
	 * 在一定服务范围内查找网络上服务站点能够提供服务的区域范围。
	 * 该类负责将客户端指定的服务区分析参数传递给服务端，并接收服务端返回的结果数据。
	 * 服务区分析结果通过该类支持的事件的监听函数参数获取
	 * Inherits from:
	 *  - <SuperMap.REST.NetworkAnalystServiceBase>
	 */
	__webpack_require__(112);
	__webpack_require__(130);
	SuperMap.REST.FindServiceAreasService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FindServiceAreasService
	     * 服务区分析服务类构造函数。
	     *
	     * 例如:
	     * (start code)
	     * var myFindServiceAreasService = new SuperMap.REST.FindServiceAreasService(url, {eventListeners: {"processCompleted": findServiceAreasCompleted, "processFailed": findServiceAreasError}});
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FindServiceAreasParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "servicearea" : "/servicearea") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            isFromCenter: params.isFromCenter,
	            isCenterMutuallyExclusive: params.isCenterMutuallyExclusive,
	            parameter: SuperMap.Util.toJSON(params.parameter),
	            centers: me.getJson(params.isAnalyzeById, params.centers),
	            weights: me.getJson(true, params.weights)
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJson
	     * 将对象转化为JSON字符串。
	     *
	     * Parameters:
	     * isAnalyzeById - {Boolean}
	     * params - {Array}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJson: function (isAnalyzeById, params) {
	        var jsonString = "[",
	            len = params ? params.length : 0;

	        if (isAnalyzeById === false) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
	            }
	        } else if (isAnalyzeById == true) {
	            for (var i = 0; i < len; i++) {
	                if (i > 0) jsonString += ",";
	                jsonString += params[i];
	            }
	        }
	        jsonString += ']';
	        return jsonString;
	    },

	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        if (!result || !result.serviceAreaList) {
	            return result;
	        }
	        var analystResult = [];
	        var geoJSONFormat = new SuperMap.Format.GeoJSON();
	        result.serviceAreaList.map(function (serviceArea) {
	            if (serviceArea.serviceRegion) {
	                analystResult.push(JSON.parse(geoJSONFormat.write(serviceArea.serviceRegion)));
	            }
	        });

	        return analystResult;
	    },

	    CLASS_NAME: "SuperMap.REST.FindServiceAreasService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FindServiceAreasService(url, options);
	};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: FindServiceAreasParameters
	 * 服务区分析参数类。
	 * 服务区分析是以指定服务站点为中心，在一定服务范围内查找网络上服务站点能够提供服务的区域范围。
	 * 例如：计算某快餐店能够在30分钟内送达快餐的区域。
	 */
	__webpack_require__(4);
	__webpack_require__(116);
	FindServiceAreasParameters = SuperMap.Class({

	    /**
	     * APIProperty: isAnalyzeById
	     * {Boolean} 是否通过节点 ID 指定路径分析的结点，默认为 false。
	     * 指定路径分析经过的结点或设施点有两种方式：输入结点 ID 号或直接输入点坐标。
	     * 当该字段为 true 时，表示通过结点 ID 指定途经点，即 FindServiceAreasParameters.centers = [ID1,ID2,...]；
	     * 反之表示通过结点坐标指定途经点，即 FindServiceAreasParameters.centers = [{x1,y1},{x2,y2},...]。
	     */
	    isAnalyzeById: false,

	    /**
	     * APIProperty: isCenterMutuallyExclusive
	     * {Boolean} 是否中心点互斥，即按照中心点的距离进行判断是否要进行互斥处理，默认为 false。
	     * 若分析出的服务区有重叠的部分，则通过设置该参数进行互斥处理。
	     */
	    isCenterMutuallyExclusive: false,

	    /**
	     * APIProperty: centers
	     * {Array(<Point>/Number)} 服务站点数组，必设字段。
	     * 当该类的 iSAnalyzeById = true 时，通过结点 ID 号指定服务站点；
	     * 当 iSAnalyzeById = false 时，通过点坐标指定服务站点。
	     */
	    centers: null,

	    /**
	     * APIProperty: isFromCenter
	     * {Boolean} 是否从中心点开始分析。默认为 false。
	     * 从中心点开始分析和不从中心点开始分析，体现了服务中心和需要该服务的需求地的关系模式。
	     * 从中心点开始分析，是一个服务中心向服务需求地提供服务；
	     * 而不从中心点开始分析，是一个服务需求地主动到服务中心获得服务。
	     */
	    isFromCenter: false,

	    /**
	     * APIProperty: weights
	     * {Array(Number)} 每个服务站点提供服务的阻力半径，即超过这个阻力半径的区域不予考虑，其单位与阻力字段一致，必设字段。
	     * 该字段为一个数组，数组长度跟服务中心个数一致，按照索引顺序与站点一一对应，每个元素表示了在对每个服务中心进行服务区分析时，所用的服务半径。
	     */
	    weights: null,

	    /**
	     * APIProperty: parameter
	     * {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    parameter: null,

	    /**
	     * Constructor: FindServiceAreasParameters
	     * 服务区分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * isAnalyzeById - {Boolean} 是否通过节点 ID 指定路径分析的结点。
	     * isCenterMutuallyExclusive - {Boolean} 是否中心点互斥。
	     * centers - {Array()} 服务站点数组，必设字段。
	     * isFromCenter - {Boolean} 是否从中心点开始分析。
	     * weights - {Array()} 每个服务站点提供服务的阻力半径，即超过这个阻力半径的区域不予考虑，其单位与阻力字段一致，必设字段。
	     * parameter - {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.parameter = new TransportationAnalystParameter();
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.isAnalyzeById = null;
	        me.isCenterMutuallyExclusive = null;
	        me.centers = null;
	        me.isFromCenter = null;
	        me.weights = null;
	        if (me.parameter) {
	            me.parameter.destroy();
	            me.parameter = null;
	        }
	    },

	    CLASS_NAME: "FindServiceAreasParameters"
	});
	module.exports = function (options) {
	    return new FindServiceAreasParameters(options);
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.FindTSPPathsService
	 * 旅行商分析服务类
	 * 旅行商分析是路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
	 * 旅行商分析也可以指定到达的终点，这时查找从起点能够遍历所有途经点最后到达终点，且花费最小的路径。
	 * 该类负责将客户端指定的旅行商分析参数传递给服务端，并接收服务端返回的结果数据。
	 * 旅行商分析结果通过该类支持的事件的监听函数参数获取
	 * Inherits from:
	 *  - <SuperMap.REST.NetworkAnalystServiceBase>
	 */
	__webpack_require__(112);
	__webpack_require__(132);
	SuperMap.REST.FindTSPPathsService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FindTSPPathsService
	     * 最佳路径分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myFindTSPPathsService = new SuperMap.REST.FindTSPPathsService(url, {
	     *     eventListeners: {
	     *	      "processCompleted": findTSPPathsCompleted, 
	     *		  "processFailed": findTSPPathsError
	     *		  }
	     *  });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FindTSPPathsParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "tsppath" : "/tsppath") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            parameter: SuperMap.Util.toJSON(params.parameter),
	            endNodeAssigned: params.endNodeAssigned,
	            nodes: me.getNodesJson(params)
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getNodesJson
	     * 将节点对象转化为JSON字符串。
	     *
	     * Parameters:
	     * params - {<FindTSPPathsParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getNodesJson: function (params) {
	        var jsonParameters = "", nodesString, i, len, nodes;
	        if (params.isAnalyzeById === false) {
	            for (nodesString = "[", i = 0, nodes = params.nodes, len = nodes.length; i < len; i++) {
	                if (i > 0) nodesString += ",";
	                nodesString += '{"x":' + nodes[i].x + ',"y":' + nodes[i].y + '}';
	            }
	            nodesString += ']';
	            jsonParameters += nodesString;
	        } else if (params.isAnalyzeById == true) {
	            for (var nodeIDsString = "[", i = 0, nodes = params.nodes, len = nodes.length; i < len; i++) {
	                if (i > 0) nodeIDsString += ",";
	                nodeIDsString += nodes[i];
	            }
	            nodeIDsString += ']';
	            jsonParameters += nodeIDsString;
	        }
	        return jsonParameters;
	    },
	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        if (!result || !result.tspPathList) {
	            return null;
	        }
	        //只处理route ,pathGuide,edgeFeatures,nodeFeatures
	        var analystResults = [];
	        var geoJSONFormat = new SuperMap.Format.GeoJSON();
	        result.tspPathList.forEach(function (path) {
	            var analystResult = {};
	            if (path.route) {
	                analystResult.route = JSON.parse(geoJSONFormat.write(path.route));
	            }
	            if (path.pathGuideItems) {
	                analystResult.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));

	            }
	            if (path.edgeFeatures) {
	                analystResult.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
	            }
	            if (path.nodeFeatures) {
	                analystResult.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
	            }
	            analystResults.push(analystResult);
	        });
	        return analystResults;
	    },
	    CLASS_NAME: "SuperMap.REST.FindTSPPathsService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FindTSPPathsService(url, options);
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: FindTSPPathsParameters
	 * 旅行商分析参数类
	 * 旅行商分析是路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。旅行商分析也
	 * 可以指定到达的终点，这时查找从起点能够遍历所有途经点最后到达终点，且花费最小的路径。
	 * 旅行商分析和最佳路径分析都是在网络中寻找遍历所有站点的最经济的路径，区别是在遍历网络所有站点的过程中对结点访问顺序不同
	 * 最佳路径分析必须按照指定顺序对站点进行访问，而旅行商分析是无序的路径分析。
	 */
	__webpack_require__(4);
	__webpack_require__(116);
	FindTSPPathsParameters = SuperMap.Class({
	    /**
	     * APIProperty: endNodeAssigned
	     * {Boolean} 是否指定终止点，将指定的途经点的最后一个点作为终止点。
	     * true 表示指定终止点，则旅行商必须最后一个访问终止点。
	     * 默认为 false。
	     */
	    endNodeAssigned: false,

	    /**
	     * APIProperty: isAnalyzeById
	     * {Boolean} 是否通过节点 ID 号来指定途经点，默认为 false，即通过坐标点指定。
	     */
	    isAnalyzeById: false,

	    /**
	     * APIProperty: nodes
	     * {Array(<Point>/Number)} 旅行商分析途经点数组，必设字段。
	     * 当 FindTSPPathsParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；
	     * 当 FindTSPPathsParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
	     */
	    nodes: null,

	    /**
	     * APIProperty: parameter
	     * {<TransportationAnalystParameter>} 交通网络分析通用参数。通过本类可以设置障碍边、障碍点、
	     * 权值字段信息的名称标识、转向权值字段等信息。
	     * TransportationAnalystParameter 类型，它虽然为可选参数，但是如果不设置其中的 resultSetting
	     * 字段，则返回结果空间信息等都为空。
	     */
	    parameter: null,

	    /**
	     * Constructor: FindTSPPathsParameters
	     * 旅行商分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * endNodeAssigned - {Boolean} 是否指定终止点，将指定的途经点的最后一个点作为终止点。
	     * true 表示指定终止点，则旅行商必须最后一个访问终止点。默认为 false
	     * isAnalyzeById - {Boolean} 是否通过节点 ID 号来指定配送中心点和配送目的点，默认为 false，即通过坐标点指定。
	     * nodes - {Array(<Point>/Number)} 配送目标集合，必设字段。
	     * parameter - {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */

	    initialize: function (options) {
	        var me = this;
	        me.parameter = new TransportationAnalystParameter();
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.endNodeAssigned = null;
	        me.isAnalyzeById = null;
	        me.nodes = null;
	        if (me.parameter) {
	            me.parameter.destroy();
	            me.parameter = null;
	        }
	    },

	    CLASS_NAME: "FindTSPPathsParameters"
	});
	module.exports = function (options) {
	    return new FindTSPPathsParameters(options);
	};

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	__webpack_require__(112);
	__webpack_require__(134);
	 SuperMap.REST.UpdateEdgeWeightService=SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase,{

	    /**
	     * Constructor: SuperMap.REST.UpdateEdgeWeightService
	     * 更新边的边的耗费权重服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var updateEdgeWeightService = new SuperMap.REST.UpdateEdgeWeightService(url, {
	     *     eventListeners: {
	     *         "processCompleted": UpdateEdgeWeightCompleted,      //参数为SuperMap.REST.UpdateEdgeWeightEventArgs
	     *		   "processFailed": UpdateEdgeWeightError             //参数为SuperMap.ServiceFailedEventArgs
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function(url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function() {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },


	     /**
	      * APIMethod: processAsync
	      * 开始异步执行边的边的耗费权重的更新
	      * Parameters:
	      * params - {UpdateEdgeWeightParameters} 更新服务参数
	      *
	      * 例如:
	      * (code)
	      *  var updateEdgeWeightParam=new UpdateEdgeWeightParameters({
	      *          edgeId:"20",
	      *          fromNodeId:"26",
	      *          toNodeId:"109",
	      *          weightField:"time",
	      *          edgeWeight:"25"
	      *      });
	      *  updateEdgeWeightService.processAsync(updateEdgeWeightParam);
	      * (end)
	      *
	      **/
	    processAsync: function(params) {
	        if(!params){
	            return;
	        }

	        var me = this, end = me.url.substr(me.url.length - 1, 1);
	        var paramStr=me.parse(params);
	        if(end === "/"){
	            me.url.splice(me.url.length-1,1);
	        }
	        me.url = me.url +paramStr+ (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        var data=params.edgeWeight?params.edgeWeight:null;
	        me.request({
	            method: "PUT",
	            scope: me,
	            data:data,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: parse
	     * 将更新服务参数解析为用‘/’做分隔的字符串
	     * */
	    parse:function(params){
	        if(!params){
	            return;
	        }
	        var paramStr="";
	        for(var attr in params){
	            if(params[attr]===""||params[attr]==="edgeWeight")continue;
	            switch(attr){
	                case "edgeId":
	                    paramStr+="/edgeweight/"+params[attr];
	                    break;
	                case "fromNodeId":
	                    paramStr+="/fromnode/"+params[attr];
	                    break;
	                case "toNodeId":
	                    paramStr+="/tonode/"+params[attr];
	                    break;
	                case "weightField":
	                    paramStr+="/weightfield/"+params[attr];
	                    break;
	                default :break;
	            }
	        }
	        return paramStr;
	    },

	    CLASS_NAME:"SuperMap.REST.UpdateEdgeWeightService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.UpdateEdgeWeightService(url, options);
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class:UpdateEdgeWeightParameters
	 * 边的耗费权重更新服务参数类
	 * */
	__webpack_require__(4);
	UpdateEdgeWeightParameters = SuperMap.Class({
	    /**
	     * APIProperty: edgeId
	     * {String} 所在边的id
	     */
	    edgeId: "",

	    /**
	     * APIProperty: fromNodeId
	     * {String} 起始转向点的id
	     */
	    fromNodeId: "",

	    /**
	     * APIProperty: toNodeId
	     * {String} 终止转向点的id
	     */
	    toNodeId: "",

	    /**
	     * APIProperty: weightField
	     * {String} 边的耗费字段
	     */
	    weightField: "",

	    /**
	     * APIProperty: edgeWeight
	     * {String} 耗费权重
	     */
	    edgeWeight: "",

	    /**
	     * Constructor: UpdateEdgeWeightParameters
	     * 边的耗费权重更新服务参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * edgeId - {String} 所在边的id
	     * fromNodeId - {String} 起始转向点的id
	     * toNodeId - {String}  终止转向点的id
	     * weightField - {String}  边的耗费字段
	     * edgeWeight - {String}   耗费权重
	     */
	    initialize: function (option) {
	        if (!option)return;

	        option.edgeId && (this.edgeId = option.edgeId);
	        option.fromNodeId && (this.fromNodeId = option.fromNodeId);
	        option.toNodeId && (this.toNodeId = option.toNodeId);
	        option.weightField && (this.weightField = option.weightField);
	        option.edgeWeight && (this.edgeWeight = option.edgeWeight);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        this.edgeId = null;
	        this.fromNodeId = null;
	        this.toNodeId = null;
	        this.weightField = null;
	        this.edgeWeight = null;
	    },

	    CLASS_NAME: "UpdateEdgeWeightParameters"
	});
	module.exports = function (options) {
	    return new UpdateEdgeWeightParameters(options);
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	__webpack_require__(112);
	__webpack_require__(136);
	SuperMap.REST.UpdateTurnNodeWeightService = SuperMap.Class(SuperMap.REST.NetworkAnalystServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.UpdateTurnNodeWeightService
	     * 转向耗费权重更新服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var UpdateTurnNodeWeightService = new SuperMap.REST.UpdateTurnNodeWeightService(url, {
	     *     eventListeners: {
	     *         "processCompleted": UpdateTurnNodeWeightCompleted,    //参数为SuperMap.REST.UpdateTurnNodeWeightEventArgs
	     *		   "processFailed": UpdateTurnNodeWeightError          //参数为SuperMap.ServiceFailedEventArgs
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.NetworkAnalystServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 开始异步执行转向耗费权重的更新
	     * Parameters:
	     * params - {UpdateTurnNodeWeightParameters} 更新服务参数
	     *
	     * 例如:
	     * (code)
	     *  var updateTurnNodeWeightParam=new UpdateTurnNodeWeightParameters({
	     *           nodeId:"106",
	     *           fromEdgeId:"6508",
	     *           toEdgeId:"6504",
	     *           weightField:"TurnCost",
	     *           turnNodeWeight:"50"
	     *       });
	     *  updateTurnNodeWeightService.processAsync(updateTurnNodeWeightParam);
	     * (end)
	     *
	     **/
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }

	        var me = this, end = me.url.substr(me.url.length - 1, 1);
	        var paramStr = me.parse(params);
	        if (end === "/") {
	            me.url.splice(me.url.length - 1, 1);
	        }
	        me.url = me.url + paramStr + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        var data = params.turnNodeWeight ? params.turnNodeWeight : null;
	        me.request({
	            method: "PUT",
	            scope: me,
	            data: data,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: parse
	     * 将更新服务参数解析为用‘/’做分隔的字符串
	     * */
	    parse: function (params) {
	        if (!params) {
	            return;
	        }
	        var paramStr = "";
	        for (var attr in params) {
	            if (params[attr] === "" || params[attr] === "turnNodeWeight")continue;
	            switch (attr) {
	                case "nodeId":
	                    paramStr += "/turnnodeweight/" + params[attr];
	                    break;
	                case "fromEdgeId":
	                    paramStr += "/fromedge/" + params[attr];
	                    break;
	                case "toEdgeId":
	                    paramStr += "/toedge/" + params[attr];
	                    break;
	                case "weightField":
	                    paramStr += "/weightfield/" + params[attr];
	                    break;
	                default :
	                    break;
	            }
	        }
	        return paramStr;
	    },

	    CLASS_NAME: "SuperMap.REST.UpdateTurnNodeWeightService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.UpdateTurnNodeWeightService(url, options);
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class:UpdateTurnNodeWeightParameters
	 * 转向耗费权重更新服务参数类
	 * */
	__webpack_require__(4);
	UpdateTurnNodeWeightParameters = SuperMap.Class({
	    /**
	     * APIProperty:  nodeId
	     * {String} 转向结点的id
	     */
	    nodeId: "",

	    /**
	     * APIProperty: fromEdgeId
	     * {String} 起始边的id
	     */
	    fromEdgeId: "",

	    /**
	     * APIProperty: toEdgeId
	     * {String} 终止边的id
	     */
	    toEdgeId: "",

	    /**
	     * APIProperty: weightField
	     * {String} 转向结点的耗费字段
	     */
	    weightField: "",

	    /**
	     * APIProperty: turnNodeWeight
	     * {String} 耗费权重
	     */
	    turnNodeWeight: "",


	    /**
	     * Constructor: SuperMap.REST.UpdateEdgeWeightParameters
	     * 转向耗费权重更新服务参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * nodeId - {String} 转向结点的id
	     * fromEdgeId - {String} 起始边的id
	     * toEdgeId - {String}  终止边的id
	     * weightField - {String}  转向结点的耗费字段
	     * turnNodeWeight - {String}   耗费权重
	     */
	    initialize: function (option) {
	        if (!option)return;

	        option.nodeId && (this.nodeId = option.nodeId);
	        option.fromEdgeId && (this.fromEdgeId = option.fromEdgeId);
	        option.toEdgeId && (this.toEdgeId = option.toEdgeId);
	        option.weightField && (this.weightField = option.weightField);
	        option.turnNodeWeight && (this.turnNodeWeight = option.turnNodeWeight);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        this.nodeId = null;
	        this.fromEdgeId = null;
	        this.toEdgeId = null;
	        this.weightField = null;
	        this.turnNodeWeight = null;
	    },

	    CLASS_NAME: "UpdateTurnNodeWeightParameters"
	});
	module.exports = function (options) {
	    return new UpdateTurnNodeWeightParameters(options);
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: NetworkAnalyst3DService
	 * 3D网络分析服务类
	 * 用法：
	 *      L.superMap.networkAnalyst3DService(url).sinksFacilityAnalyst({
	 *          nodeID:xxx,
	 *          weightName:xxx
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(4);
	__webpack_require__(138);
	__webpack_require__(141);
	__webpack_require__(143);
	__webpack_require__(145);
	__webpack_require__(147);
	__webpack_require__(11);

	NetworkAnalyst3DService = ServiceBase.extend({

	    /**
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * @param url
	     * @param options
	     */
	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    /**
	     * 汇查找服务
	     * @param params
	     *      <FacilityAnalystSinks3DParameters>
	     */
	    sinksFacilityAnalyst: function (params) {
	        var me = this;
	        var facilityAnalystSinks3DService = new SuperMap.REST.FacilityAnalystSinks3DService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        facilityAnalystSinks3DService.processAsync(params);
	        return me;
	    },
	    /**
	     * 源查找服务
	     * @param params
	     *      <FacilityAnalystSources3DParameters>
	     */
	    sourcesFacilityAnalyst: function (params) {
	        var me = this;
	        var facilityAnalystSources3DService = new SuperMap.REST.FacilityAnalystSources3DService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        facilityAnalystSources3DService.processAsync(params);
	        return me;
	    },
	    /**
	     * 上游追踪资源服务
	     * @param params
	     *      <FacilityAnalystTraceup3DParameters>
	     */
	    traceUpFacilityAnalyst: function (params) {
	        var me = this;
	        var facilityAnalystTraceup3DService = new SuperMap.REST.FacilityAnalystTraceup3DService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        facilityAnalystTraceup3DService.processAsync(params);
	        return me;
	    },
	    /**
	     * 下游追踪资源服务
	     * @param params
	     *      <FacilityAnalystTracedown3DParameters>
	     */
	    traceDownFacilityAnalyst: function (params) {
	        var me = this;
	        var facilityAnalystTracedown3DService = new SuperMap.REST.FacilityAnalystTracedown3DService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        facilityAnalystTracedown3DService.processAsync(params);
	        return me;
	    },

	    /**
	     * 上游关键设施查找服务
	     * @param params
	     *      <FacilityAnalystUpstream3DParameters>
	     */
	    upstreamFacilityAnalyst: function (params) {
	        var me = this;
	        var facilityAnalystUpstream3DService = new SuperMap.REST.FacilityAnalystUpstream3DService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        facilityAnalystUpstream3DService.processAsync(params);
	        return me;
	    }
	});

	L.supermap.networkAnalyst3DService = function (url, options) {
	    return new NetworkAnalyst3DService(url, options);
	};

	module.exports = L.supermap.networkAnalyst3DService;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.FacilityAnalystSinks3DService
	 * 最近设施分析服务类(汇查找资源)
	 * 最近设施分析是指在网络上给定一个事件点和一组设施点，
	 * 查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
	 * 该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
	 * 最近设施分析结果通过该类支持的事件的监听函数参数获取
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(139);
	SuperMap.REST.FacilityAnalystSinks3DService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FacilityAnalystSinks3DService
	     * 最近设施分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myFacilityAnalystSinks3DService = new SuperMap.REST.FacilityAnalystSinks3DService(url, {
	     *     eventListeners: {
	     *	       "processCompleted": facilityAnalystSinks3DCompleted,
	     *		   "processFailed": facilityAnalystSinks3DError
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FacilityAnalystSinks3DParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "sinks" : "/sinks") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            edgeID: params.edgeID,
	            nodeID: params.nodeID,
	            weightName: params.weightName,
	            isUncertainDirectionValid: params.isUncertainDirectionValid
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.FacilityAnalystSinks3DService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FacilityAnalystSinks3DService(url, options);
	};

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(140);

	/**
	 * Class: FacilityAnalystSinks3DParameters
	 * 最近设施分析参数类(汇查找资源)
	 * 最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
	 * 设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。
	 * 例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。
	 * 最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
	 */
	FacilityAnalystSinks3DParameters = SuperMap.Class(FacilityAnalyst3DParameters, {

	    /**
	     * Constructor: FacilityAnalystSinks3DParameters
	     * 最近设施分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * event - {<SuperMap.Geometry.Point>/Integer} 事件点，一般为需要获得服务设施服务的事件位置，必设字段。
	     * expectFacilityCount - {Integer} 要查找的设施点数量。默认值为1。
	     * facilities - {Array(<SuperMap.Geometry.Point>/Number)} 设施点集合，一般为提供服务的服务设施位置，必设字段。
	     * fromEvent - {Boolean} 是否从事件点到设施点进行查找。
	     * isAnalyzeById - {Boolean} 事件点和设施点是否通过节点 ID 号来指定，默认为 false，即通过坐标点指定事件点和设施点。
	     * maxWeight - {Number} 查找半径。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。默认值为0，表示查找全网络。
	     * parameter - {<SuperMap.REST.TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.edgeID = null;
	        me.nodeID = null;
	        me.weightName = null;
	        me.isUncertainDirectionValid = null;
	    },

	    CLASS_NAME: "FacilityAnalystSinks3DParameters"
	});

	module.exports = function (options) {
	    return new FacilityAnalystSinks3DParameters(options);
	};

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: FacilityAnalyst3DParameters
	 * 最近设施分析参数基类。
	 * 最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
	 * 设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。
	 * 例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。
	 * 最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
	 */
	FacilityAnalyst3DParameters = SuperMap.Class({

	    /**
	     * APIProperty: event
	     * {Number} 指定的弧段ID
	     */
	    edgeID: null,

	    /**
	     * APIProperty: nodeID
	     * {Number}: 指定的结点ID
	     */
	    nodeID: null,

	    /**
	     * APIProperty: weightName
	     * {String}: 指定的权值字段信息对象的名称
	     */
	    weightName: null,

	    /**
	     * APIProperty: isUncertainDirectionValid
	     * {Boolean}: 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找
	     */
	    isUncertainDirectionValid: false,

	    /**
	     * Constructor: FacilityAnalyst3DParameters
	     * 最近设施分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * event - {<SuperMap.Geometry.Point>/Integer} 事件点，一般为需要获得服务设施服务的事件位置，必设字段。
	     * expectFacilityCount - {Integer} 要查找的设施点数量。默认值为1。
	     * facilities - {Array(<SuperMap.Geometry.Point>/Number)} 设施点集合，一般为提供服务的服务设施位置，必设字段。
	     * fromEvent - {Boolean} 是否从事件点到设施点进行查找。
	     * isAnalyzeById - {Boolean} 事件点和设施点是否通过节点 ID 号来指定，默认为 false，即通过坐标点指定事件点和设施点。
	     * maxWeight - {Number} 查找半径。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。默认值为0，表示查找全网络。
	     * parameter - {<TransportationAnalystParameter>} 交通网络分析通用参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.edgeID = null;
	        me.nodeID = null;
	        me.weightName = null;
	        me.isUncertainDirectionValid = null;
	    },

	    CLASS_NAME: "FacilityAnalyst3DParameters"
	});

	module.exports = function (options) {
	    return new FacilityAnalyst3DParameters(options);
	};

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.FacilityAnalystSources3DService
	 * 最近设施分析服务类(源查找资源)
	 * 最近设施分析是指在网络上给定一个事件点和一组设施点，
	 * 查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
	 * 该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
	 * 最近设施分析结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(142);
	SuperMap.REST.FacilityAnalystSources3DService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FacilityAnalystSources3DService
	     * 最近设施分析服务类构造函数。
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FacilityAnalystSources3DParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "sources" : "/sources") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            edgeID: params.edgeID,
	            nodeID: params.nodeID,
	            weightName: params.weightName,
	            isUncertainDirectionValid: params.isUncertainDirectionValid
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.FacilityAnalystSources3DService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FacilityAnalystSources3DService(url, options);
	};

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(140);

	/**
	 * Class: FacilityAnalystSources3DParameters
	 * 最近设施分析参数类(源查找资源)
	 * 最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
	 * 设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。
	 * 例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。
	 * 最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
	 */
	FacilityAnalystSources3DParameters = SuperMap.Class(FacilityAnalyst3DParameters, {

	    /**
	     * Constructor: FacilityAnalystSources3DParameters
	     * 最近设施分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     */
	    initialize: function (options) {
	        var me = this;
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.edgeID = null;
	        me.nodeID = null;
	        me.weightName = null;
	        me.isUncertainDirectionValid = null;
	    },

	    CLASS_NAME: "FacilityAnalystSources3DParameters"
	});

	module.exports = function (options) {
	    return new FacilityAnalystSources3DParameters(options);
	};

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.FacilityAnalystTraceup3DService
	 * 上游追踪资源服务类
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(144);
	SuperMap.REST.FacilityAnalystTraceup3DService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FacilityAnalystTraceup3DService
	     * 上游追踪资源服务类构造函数。
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FacilityAnalystTraceup3DParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "traceupresult" : "/traceupresult") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            edgeID: params.edgeID,
	            nodeID: params.nodeID,
	            weightName: params.weightName,
	            isUncertainDirectionValid: params.isUncertainDirectionValid
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.FacilityAnalystTraceup3DService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FacilityAnalystTraceup3DService(url, options);
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(140);

	/**
	 * Class: FacilityAnalystTraceup3DParameters
	 * 上游追踪资源参数类
	 */
	FacilityAnalystTraceup3DParameters = SuperMap.Class(FacilityAnalyst3DParameters, {

	    /**
	     * Constructor: FacilityAnalystTraceup3DParameters
	     * 上游追踪资源参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.edgeID = null;
	        me.nodeID = null;
	        me.weightName = null;
	        me.isUncertainDirectionValid = null;
	    },

	    CLASS_NAME: "FacilityAnalystTraceup3DParameters"
	});

	module.exports = function (options) {
	    return new FacilityAnalystTraceup3DParameters(options);
	};

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.FacilityAnalystTracedown3DService
	 * 下游追踪资源服务类
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(146);
	SuperMap.REST.FacilityAnalystTracedown3DService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FacilityAnalystTracedown3DService
	     * 下游追踪资源服务类构造函数
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FacilityAnalystTracedown3DParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "tracedownresult" : "/tracedownresult") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            edgeID: params.edgeID,
	            nodeID: params.nodeID,
	            weightName: params.weightName,
	            isUncertainDirectionValid: params.isUncertainDirectionValid
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.FacilityAnalystTracedown3DService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FacilityAnalystTracedown3DService(url, options);
	};

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(140);

	/**
	 * Class: FacilityAnalystTracedown3DParameters
	 * 下游追踪资源参数类
	 */
	FacilityAnalystTracedown3DParameters = SuperMap.Class(FacilityAnalyst3DParameters, {

	    /**
	     * Constructor: FacilityAnalystTracedown3DParameters
	     * 下游追踪资源参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     */
	    initialize: function (options) {
	        var me = this;
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.edgeID = null;
	        me.nodeID = null;
	        me.weightName = null;
	        me.isUncertainDirectionValid = null;
	    },

	    CLASS_NAME: "FacilityAnalystTracedown3DParameters"
	});

	module.exports = function (options) {
	    return new FacilityAnalystTracedown3DParameters(options);
	};

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.FacilityAnalystUpstream3DService
	 * 上游关键设施查找资源服务类
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(148);
	SuperMap.REST.FacilityAnalystUpstream3DService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.FacilityAnalystUpstream3DService
	     * 上游关键设施查找资源服务类构造函数。
	     *
	     * Parameters:
	     * url - {String} 网络分析服务地址。请求网络分析服务，URL应为：
	     * http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
	     * 例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */

	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<FacilityAnalystUpstream3DParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonObject,
	            end = me.url.substr(me.url.length - 1, 1);
	        me.url = me.url + ((end === "/") ? "upstreamcirticalfaclilities" : "/upstreamcirticalfaclilities") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
	        jsonObject = {
	            sourceNodeIDs: params.sourceNodeIDs,
	            edgeID: params.edgeID,
	            nodeID: params.nodeID,
	            isUncertainDirectionValid: params.isUncertainDirectionValid
	        };
	        me.request({
	            method: "GET",
	            params: jsonObject,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.FacilityAnalystUpstream3DService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.FacilityAnalystUpstream3DService(url, options);
	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(140);

	/**
	 * Class: FacilityAnalystUpstream3DParameters
	 * 上游关键设施查找资源参数类
	 */
	FacilityAnalystUpstream3DParameters = SuperMap.Class(FacilityAnalyst3DParameters, {

	    /**
	     * APIProperty: sourceNodeIDs
	     * {Array<Number>} 指定的设施点ID数组
	     */
	    sourceNodeIDs: null,

	    /**
	     * Constructor: FacilityAnalystUpstream3DParameters
	     * 上游关键设施查找资源参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.sourceNodeIDs = null;
	        me.edgeID = null;
	        me.nodeID = null;
	        me.isUncertainDirectionValid = null;
	    },

	    CLASS_NAME: "FacilityAnalystUpstream3DParameters"
	});

	module.exports = function (options) {
	    return new FacilityAnalystTraceup3DParameters(options);
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class:SpatialAnalystService
	 * 空间分析服务类。
	 * 提供：地区太阳辐射、缓冲区分析、点密度分析、动态分段分析、空间关系分析、插值分析、栅格代数运算、叠加分析、路由定位、路由测量计算、表面分析、地形曲率计算、泰森多边形分析。
	 * 用法：
	 *      L.superMap.spatialAnalystService(url).bufferAnalysis({
	 *
	 *      }).on("complete",function(result){
	 *          //doSomething 
	 *      }).on("failed",function(result){
	 *          //doSomething
	 *      });
	 */

	__webpack_require__(4);
	__webpack_require__(150);
	__webpack_require__(153);
	__webpack_require__(160);
	__webpack_require__(162);
	__webpack_require__(164);
	__webpack_require__(166);
	__webpack_require__(173);
	__webpack_require__(175);
	__webpack_require__(179);
	__webpack_require__(181);
	__webpack_require__(183);
	__webpack_require__(188);
	__webpack_require__(190);
	__webpack_require__(11);

	SpatialAnalystService = ServiceBase.extend({

	    /**
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-sample/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     * @param url
	     * @param options
	     */
	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },
	    /**
	     * 地区太阳辐射
	     * @param params
	     * {AreaSolarRadiationParameters}
	     * @param resultFormat
	     */
	    getAreaSolarRadiationResult: function (params, resultFormat) {
	        var me = this, format = me._processFormat(resultFormat);
	        var areaSolarRadiationService = new SuperMap.REST.AreaSolarRadiationService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        areaSolarRadiationService.processAsync(params);
	        return me;
	    },

	    /**
	     * 缓冲区分析
	     * @param params
	     * {DatasetBufferAnalystParameters}
	     * @param resultFormat
	     */
	    bufferAnalysis: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var bufferAnalystService = new SuperMap.REST.BufferAnalystService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        bufferAnalystService.processAsync(param);
	        return me;
	    },

	    /**
	     * 点密度分析
	     * @param params
	     * {DensityKernelAnalystParameters}
	     * @param resultFormat
	     */
	    densityAnalysis: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var densityAnalystService = new SuperMap.REST.DensityAnalystService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        densityAnalystService.processAsync(param);
	        return me;
	    },

	    /**
	     * 动态分段分析
	     * @param params
	     * {GenerateSpatialDataParameters}
	     * @param resultFormat
	     */
	    generateSpatialData: function (params, resultFormat) {
	        var me = this, format = me._processFormat(resultFormat);
	        var generateSpatialDataService = new SuperMap.REST.GenerateSpatialDataService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        generateSpatialDataService.processAsync(params);
	        return me;
	    },

	    /**
	     * 空间关系分析
	     * @param params
	     * {GeoRelationAnalystParameters}
	     * @param resultFormat
	     */
	    geoRelationAnalysis: function (params, resultFormat) {
	        var me = this, format = me._processFormat(resultFormat);
	        var geoRelationAnalystService = new SuperMap.REST.GeoRelationAnalystService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        geoRelationAnalystService.processAsync(params);
	        return me;
	    },

	    /**
	     * 插值分析
	     * @param params
	     * {InterpolationRBFAnalystParameters}
	     * @param resultFormat
	     */
	    interpolationAnalysis: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var interpolationAnalystService = new SuperMap.REST.InterpolationAnalystService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        interpolationAnalystService.processAsync(param);
	        return me;
	    },

	    /**
	     * 栅格代数运算
	     * @param params
	     * {MathExpressionAnalysisParameters}
	     * @param resultFormat
	     */
	    mathExpressionAnalysis: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var mathExpressionAnalysisService = new SuperMap.REST.MathExpressionAnalysisService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        mathExpressionAnalysisService.processAsync(param);
	        return me;
	    },

	    /**
	     * 叠加分析
	     * @param params
	     * {DatasetOverlayAnalystParameters}
	     * @param resultFormat
	     */
	    overlayAnalysis: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var overlayAnalystService = new SuperMap.REST.OverlayAnalystService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        overlayAnalystService.processAsync(param);
	        return me;
	    },

	    /**
	     * 路由测量计算
	     * @param params
	     * {RouteCalculateMeasureParameters}
	     * @param resultFormat
	     */
	    routeCalculateMeasure: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var routeCalculateMeasureService = new SuperMap.REST.RouteCalculateMeasureService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        routeCalculateMeasureService.processAsync(param);
	        return me;
	    },

	    /**
	     * 路由定位
	     * @param params
	     * {RouteLocatorParameters}
	     * @param resultFormat
	     */
	    routeLocate: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var routeLocatorService = new SuperMap.REST.RouteLocatorService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        routeLocatorService.processAsync(param);
	        return me;
	    },

	    /**
	     * 表面分析
	     * @param params
	     * {DatasetSurfaceAnalystParameters}
	     * @param resultFormat
	     */
	    surfaceAnalysis: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var surfaceAnalystService = new SuperMap.REST.SurfaceAnalystService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        surfaceAnalystService.processAsync(param);
	        return me;
	    },

	    /**
	     * 地形曲率计算
	     * @param params
	     * {TerrainCurvatureCalculationParameters}
	     * @param resultFormat
	     */
	    terrainCurvatureCalculate: function (params, resultFormat) {
	        var me = this, format = me._processFormat(resultFormat);
	        var terrainCurvatureCalculationService = new SuperMap.REST.TerrainCurvatureCalculationService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        terrainCurvatureCalculationService.processAsync(params);
	        return me;
	    },

	    /**
	     * 泰森多边形分析
	     * @param params
	     * {DatasetThiessenAnalystParameters}
	     * @param resultFormat
	     */
	    thiessenAnalysis: function (params, resultFormat) {
	        var me = this, param = me._processParams(params), format = me._processFormat(resultFormat);
	        var thiessenAnalystService = new SuperMap.REST.ThiessenAnalystService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            },
	            format: format
	        });
	        thiessenAnalystService.processAsync(param);
	        return me;
	    },

	    processCompleted: function (serverResult) {
	        this.fire('complete', {result: serverResult.result, originalResult: serverResult.originalResult});
	    },

	    _processParams: function (params) {
	        if (!params) {
	            return {};
	        }
	        if (params.bounds && params.bounds instanceof L.LatLngBounds) {
	            params.bounds = new SuperMap.Bounds(
	                params.bounds.getSouthWest().lng,
	                params.bounds.getSouthWest().lat,
	                params.bounds.getNorthEast().lng,
	                params.bounds.getNorthEast().lat
	            );
	        }
	        if (params.inputPoints) {
	            for (var i = 0; i < params.inputPoints.length; i++) {
	                var inputPoint = params.inputPoints[i];
	                if (L.Util.isArray(inputPoint)) {
	                    params.inputPoints[i] = {x: inputPoint[0], y: inputPoint[1]};
	                }
	            }
	        }

	        if (params.points) {
	            for (var i = 0; i < params.points.length; i++) {
	                var point = params.points[i];
	                if (L.Util.isArray(point)) {
	                    params.points[i] = {x: point[0], y: point[1]};
	                }
	            }
	        }

	        if (params.extractRegion) {
	            params.extractRegion = L.Util.toSuperMapGeometry(params.extractRegion);
	        }
	        if (params.clipRegion) {
	            params.clipRegion = L.Util.toSuperMapGeometry(params.clipRegion);
	        }
	        if (params.sourceGeometry) {
	            params.sourceGeometry = L.Util.toSuperMapGeometry(params.sourceGeometry);
	        }
	        if (params.sourceRoute && params.sourceRoute.points) {
	            params.sourceRoute.points = L.Util.toSuperMapGeometry(params.sourceRoute.points);
	        }
	        if (params.operateRegions && L.Util.isArray(params.operateRegions)) {
	            params.operateRegions.map(function (geometry, key) {
	                params.operateRegions[key] = L.Util.toSuperMapGeometry(geometry);
	            });
	        }
	        if (params.sourceRoute && params.sourceRoute.components && L.Util.isArray(params.sourceRoute.components)) {
	            params.sourceRoute.components.map(function (geometry, key) {
	                params.sourceRoute.components[key] = L.Util.toSuperMapGeometry(geometry);
	            });
	        }

	        return params;
	    },
	    _processFormat: function (resultFormat) {
	        return (resultFormat) ? resultFormat : Format.GEOJSON;
	    }
	});
	L.supermap.spatialAnalystService = function (url, options) {
	    return new SpatialAnalystService(url, options);
	};
	module.exports = L.supermap.spatialAnalystService;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.AreaSolarRadiationService
	 *  地区太阳辐射服务类。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(152);
	SuperMap.REST.AreaSolarRadiationService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Constructor: SuperMap.REST.AreaSolarRadiationService
	     * 地区太阳辐射服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myAreaSolarRadiationService = new SuperMap.REST.AreaSolarRadiationService(url);
	     * myAreaSolarRadiationService.on({
	     *     "processCompleted": processCompleted,
	     *     "processFailed": processFailed
	     *     }
	     * );
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-sample/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<AreaSolarRadiationService>}
	     */
	    processAsync: function (parameter) {
	        var me = this;

	        var end = me.url.substr(me.url.length - 1, 1);
	        if (end === '/') {

	        } else {
	            me.url += "/";
	        }

	        var parameterObject = new Object();

	        if (parameter instanceof AreaSolarRadiationService) {
	            me.url += 'datasets/' + parameter.dataset + '/solarradiation';
	        }

	        AreaSolarRadiationService.toObject(parameter, parameterObject);
	        var jsonParameters = SuperMap.Util.toJSON(parameterObject);

	        if (me.isInTheSameDomain) {
	            me.url += '.json?returnContent=true';
	        } else {
	            me.url += '.jsonp?returnContent=true';
	        }

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.AreaSolarRadiationService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.AreaSolarRadiationService(url, options);
	};

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.SpatialAnalystBase
	 * 空间分析服务基类。
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(3);
	__webpack_require__(13);
	SuperMap.REST.SpatialAnalystBase = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     *  Property: format
	     *  {String} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
	     *  参数格式为"ISERVER","GEOJSON",GEOJSON
	     */
	    format: Format.GEOJSON,

	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        if (options && options.format) {
	            this.format = options.format.toUpperCase();
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        this.format = null;
	    },

	    /**
	     * Method: getMapStatusCompleted
	     * 分析完成，执行此方法。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    serviceProcessCompleted: function (result) {
	        var me = this, analystResult;
	        result = SuperMap.Util.transformResult(result);
	        if (result && me.format === Format.GEOJSON && typeof me.toGeoJSONResult === 'function') {
	            analystResult = me.toGeoJSONResult(result);
	        }
	        if (!analystResult) {
	            analystResult = result;
	        }
	        me.events.triggerEvent("processCompleted", {result: analystResult, originalResult: result});
	    },
	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        if (!result) {
	            return null;
	        }
	        var geoJSONResult;
	        var geoJSONFormat = new SuperMap.Format.GeoJSON();
	        if (result.recordsets) {
	            geoJSONResult = [];
	            for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
	                if (recordsets[i].features) {
	                    var feature = JSON.parse(geoJSONFormat.write(recordsets[i].features));
	                    geoJSONResult.push(feature);
	                }
	            }
	        } else if (result.recordset && result.recordset.features) {
	            geoJSONResult = JSON.parse(geoJSONFormat.write(result.recordset.features));
	        }
	        
	        return geoJSONResult;
	    },
	    CLASS_NAME: "SuperMap.REST.SpatialAnalystBase"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.SpatialAnalystBase(url, options);
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: AreaSolarRadiationParameters
	 * 地区太阳辐射参数类。
	 *
	 */
	AreaSolarRadiationParameters = SuperMap.Class({

	    /**
	     * APIProperty: dataset
	     * {String} 要用来做地区太阳辐射数据源中数据集的名称。
	     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin （必设参数）。
	     *
	     * 注：地区太阳辐射数据必须为栅格数据集。
	     */
	    dataset: null,

	    /**
	     * APIProperty: targetDatasourceName
	     * {String}  指定的存储结果数据集的数据源名称（必设参数）； 例如："Jingjin"。
	     */
	    targetDatasourceName: null,

	    /**
	     * APIProperty: totalGridName
	     * {String} 指定地区太阳辐射总辐射量数据集的名称（必设参数）。
	     */
	    totalGridName: null,

	    /**
	     * APIProperty: diffuseDatasetGridName
	     * {String} 指定地区太阳辐射散射辐射量数据集的名称。
	     */
	    diffuseDatasetGridName: null,

	    /**
	     * APIProperty: durationDatasetGridName
	     * {String} 指定地区太阳辐射太阳直射持续时间数据集的名称。
	     */
	    durationDatasetGridName: null,

	    /**
	     * APIProperty: directDatasetGridName
	     * {String} 指定地区太阳辐射直射辐射量数据集的名称。
	     */
	    directDatasetGridName: null,

	    /**
	     * APIProperty: latitude
	     * {Number} 待计算区域的纬度值。
	     */
	    latitude: null,

	    /**
	     * APIProperty: timeMode
	     * {String} 时间模式。可设置有“WITHINDAY”（单日）和“MULTIDAYS”（多日）；默认值为"MULTIDAYS";
	     */
	    timeMode: "MULTIDAYS",

	    /**
	     * APIProperty: dayStart
	     * {Number} 起始日期（年内的第几天）。（必设参数）
	     */
	    dayStart: null,

	    /**
	     * APIProperty: dayEnd
	     * {Number} 结束日期（年内的第几天）。（必设参数）
	     */
	    dayEnd: null,

	    /**
	     * APIProperty: hourStart
	     * {Number} 起始时间（一天中的第几个小时）。
	     */
	    hourStart: null,

	    /**
	     * APIProperty: hourEnd
	     * {Number} 结束时间（一天中的第几个小时）。
	     */
	    hourEnd: null,

	    /**
	     * APIProperty: transmittance
	     * {Number} 太阳辐射穿过大气的透射率。
	     */
	    transmittance: null,

	    /**
	     * APIProperty: hourInterval
	     * {Number} 计算时的小时间隔（设置的越小计算量越大并且计算结果更精确, 默认为0.5小时，如果修改此参数，必须使用整数）
	     */
	    hourInterval: null,

	    /**
	     * APIProperty: dayInterval
	     * {Number} 计算时的天数间隔（设置的越小计算量越大并且计算结果更精确, 默认为5天，必须使用整数）
	     */
	    dayInterval: null,

	    /**
	     * APIProperty: deleteExistResultDataset
	     * {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
	     */
	    deleteExistResultDataset: false,

	    /**
	     * Constructor: AreaSolarRadiationParameters
	     * 地区太阳辐射参数构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * dataset - {String} 要用来做地区太阳辐射数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。（必设参数）。
	     * targetDatasourceName - {String}  指定的存储结果数据集的数据源名称（必设参数）, 例如："Jingjin"。
	     * totalGridName - {String} 指定地区太阳辐射总辐射量数据集的名称（必设参数）。
	     * diffuseDatasetGridName - {String} 指定地区太阳辐射散射辐射量数据集的名称。
	     * durationDatasetGridName - {String} 指定地区太阳辐射太阳直射持续时间数据集的名称。
	     * directDatasetGridName - {String} 指定地区太阳辐射直射辐射量数据集的名称。
	     * latitude - {Number} 待计算区域的纬度值。
	     * timeMode - {String} 时间模式。可设置有“WITHINDAY”（单日）和“MULTIDAYS”（多日）；默认值为"MULTIDAYS";
	     * dayStart - {Number} 起始日期（年内的第几天）。（必设参数）
	     * dayEnd - {Number} 结束日期（年内的第几天）。（必设参数）
	     * hourStart - {Number} 起始时间（一天中的第几个小时）。
	     * hourEnd - {Number} 结束时间（一天中的第几个小时）。
	     * transmittance - {Number} 太阳辐射穿过大气的透射率。
	     * hourInterval - {Number} 计算时的小时间隔（设置的越小计算量越大并且计算结果更精确, 默认为0.5小时，如果修改此参数，必须使用整数）
	     * dayInterval - {Number} 计算时的天数间隔（设置的越小计算量越大并且计算结果更精确, 默认为5天，必须使用整数）
	     * deleteExistResultDataset - {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.dataset = null;
	        me.zFactor = 1.0;
	        me.averageCurvatureName = null;
	        me.profileCurvatureName = null;
	        me.planCurvatureName = null;
	        me.deleteExistResultDataset = true;
	    },

	    CLASS_NAME: "AreaSolarRadiationParameters"
	});

	AreaSolarRadiationParameters.toObject = function (derrainCurvatureCalculationParameters, tempObj) {
	    var parameter = new Object();
	    for (var name in derrainCurvatureCalculationParameters) {
	        if (name !== "dataset") {
	            if (name === "latitude" || name === "timeMode" || name === "dayStart" || name === "dayEnd" || name === "hourStart" || name === "hourEnd" || name === "transmittance" || name === "hourInterval" || name === "dayInterval") {
	                parameter[name] = derrainCurvatureCalculationParameters[name];
	            }
	            else {
	                tempObj[name] = derrainCurvatureCalculationParameters[name];
	            }
	        }
	    }
	    tempObj["parameter"] = parameter;
	};

	module.exports = function (options) {
	    return new AreaSolarRadiationParameters(options);
	};

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.BufferAnalystService
	 * 缓冲区分析服务类
	 * 该类负责将客户设置的缓冲区分析参数传递给服务端，并接收服务端返回的缓冲区分析结果数据。
	 * 缓冲区分析结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(154);
	__webpack_require__(159);
	SuperMap.REST.BufferAnalystService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Property: mode
	     * {<String>} 缓冲区分析类型
	     */
	    mode: null,

	    /**
	     * Constructor: SuperMap.REST.BufferAnalystService
	     * 缓冲区分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myBufferAnalystService = new SuperMap.REST.BufferAnalystService(url, {
	     *     eventListeners: {
	     *           "processCompleted": bufferCompleted,
	     *           "processFailed": bufferFailed
	     *           }
	     *    });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	        var me = this;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	        this.mode = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<BufferAnalystParameters>}
	     */
	    processAsync: function (parameter) {
	        var parameterObject = new Object();
	        var me = this;

	        var end = me.url.substr(me.url.length - 1, 1);
	        if (end === '/') {

	        } else {
	            me.url += "/";
	        }

	        if (parameter instanceof DatasetBufferAnalystParameters) {
	            me.mode = "datasets";
	            me.url += 'datasets/' + parameter.dataset + '/buffer';
	            DatasetBufferAnalystParameters.toObject(parameter, parameterObject);
	        }
	        else if (parameter instanceof GeometryBufferAnalystParameters) {
	            me.mode = "geometry";
	            me.url += 'geometry/buffer';
	            GeometryBufferAnalystParameters.toObject(parameter, parameterObject);
	        }

	        var jsonParameters = SuperMap.Util.toJSON(parameterObject);


	        if (me.isInTheSameDomain) {
	            me.url += '.json?returnContent=true';
	        } else {
	            me.url += '.jsonp?returnContent=true';
	        }

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        if (!result) {
	            return result;
	        }

	        var analystResult = SuperMap.REST.SpatialAnalystBase.prototype.toGeoJSONResult.apply(this, arguments);
	        if (!analystResult && result.resultGeometry) {
	            var geoJSONFormat = new SuperMap.Format.GeoJSON();
	            analystResult = JSON.parse(geoJSONFormat.write(result.resultGeometry));
	        }
	        return analystResult;
	    },
	    CLASS_NAME: "SuperMap.REST.BufferAnalystService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.BufferAnalystService(url, options);
	};

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(155);
	__webpack_require__(156);
	/**
	 * Class: DatasetBufferAnalystParameters
	 * 数据集缓冲区分析参数类
	 *
	 * Inherits from:
	 *  - <BufferAnalystParameters>
	 */
	DatasetBufferAnalystParameters = SuperMap.Class(BufferAnalystParameters, {

	    /**
	     * APIProperty: dataset
	     * {String} 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
	     */
	    dataset: null,

	    /**
	     * APIProperty: filterQueryParameter
	     * {<SuperMap.REST.FilterParameter>} 设置数据集中几何对象的过滤条件。只有满足此条件的几何对象才参与缓冲区分析。
	     */
	    filterQueryParameter: null,

	    /**
	     * APIProperty: resultSetting
	     * {<DataReturnOption>} 结果返回设置类。
	     */
	    resultSetting: null,

	    /**
	     * APIProperty: isAttributeRetained
	     * {Boolean} 是否保留进行缓冲区分析的对象的字段属性，默认为 true。当 isUnion 字段为 false 时该字段有效。
	     */
	    isAttributeRetained: true,

	    /**
	     * APIProperty: isUnion
	     * {Boolean} 是否将缓冲区与源记录集中的对象合并后返回。对于面对象而言，要求源数据集中的面对象不相交。默认为 false。
	     */
	    isUnion: false,

	    /**
	     * Constructor: DatasetBufferAnalystParameters
	     * 数据集缓冲区分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * dataset - {String} 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
	     * filterQueryParameter - {<SuperMap.REST.FilterParameter>} 设置数据集中几何对象的过滤条件。只有满足此条件的几何对象才参与缓冲区分析。
	     * resultSetting - {<DataReturnOption>} 结果返回设置类。
	     * isAttributeRetained - {Boolean} 是否保留进行缓冲区分析的对象的字段属性，默认为 true。当 isUnion 字段为 false 时该字段有效。
	     * isUnion - {Boolean} 是否将缓冲区与源记录集中的对象合并后返回。对于面对象而言，要求源数据集中的面对象不相交。默认为 false。
	     * bufferSetting - {<BufferSetting>} 设置缓冲区通用参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.filterQueryParameter = new SuperMap.REST.FilterParameter();
	        me.resultSetting = new DataReturnOption();
	        BufferAnalystParameters.prototype.initialize.apply(this, arguments);
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        BufferAnalystParameters.prototype.destroy.apply(this, arguments);

	        var me = this;
	        me.dataset = null;
	        if (me.filterQueryParameter) {
	            me.filterQueryParameter.destroy();
	            me.filterQueryParameter = null;
	        }
	        if (me.resultSetting) {
	            me.resultSetting.destroy();
	            me.resultSetting = null;
	        }
	        me.isAttributeRetained = null;
	        me.isUnion = null;
	    },

	    CLASS_NAME: "DatasetBufferAnalystParameters"
	});

	DatasetBufferAnalystParameters.toObject = function (datasetBufferAnalystParameters, tempObj) {
	    for (var name in datasetBufferAnalystParameters) {
	        if (name === "bufferSetting") {
	            datasetBufferAnalystParameters.bufferSetting.radiusUnit = datasetBufferAnalystParameters.bufferSetting.radiusUnit.toUpperCase();
	            tempObj.bufferAnalystParameter = datasetBufferAnalystParameters.bufferSetting;
	        }
	        else if (name === "resultSetting") {
	            tempObj.dataReturnOption = datasetBufferAnalystParameters.resultSetting;
	        }
	        else if (name === "dataset") {
	        }
	        else {
	            tempObj[name] = datasetBufferAnalystParameters[name];
	        }
	    }
	};

	module.exports = function (options) {
	    return new DatasetBufferAnalystParameters(options);
	};

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: DataReturnOption
	 * 数据返回设置类
	 */
	DataReturnOption = SuperMap.Class({

	    /**
	     * APIProperty: expectCount
	     * {Number}  设置返回的最大记录数，小于或者等于0时表示返回所有记录数。
	     */
	    expectCount: 1000,

	    /**
	     * APIProperty: dataset
	     * {String} 设置结果数据集标识，当dataReturnMode为 SuperMap.REST.DataReturnMode.DATASET_ONLY
	     * 或SuperMap.REST.DataReturnMode.DATASET_AND_RECORDSET时有效，
	     * 作为返回数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
	     */
	    dataset: null,

	    /**
	     * APIProperty: dataReturnMode
	     * {<SuperMap.REST.DataReturnMode>} 数据返回模式，默认为SuperMap.REST.DataReturnMode.RECORDSET_ONLY。
	     */
	    dataReturnMode: SuperMap.REST.DataReturnMode.RECORDSET_ONLY,

	    /**
	     * APIProperty: deleteExistResultDataset
	     * {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
	     */
	    deleteExistResultDataset: true,

	    /**
	     * Constructor: DataReturnOption
	     * 数据返回设置类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * expectCount - {Number} 返回的最大记录数。
	     * dataset - {String} 设置结果数据集标识，当dataReturnMode为 SuperMap.REST.DataReturnMode.DATASET_ONLY
	     或SuperMap.REST.DataReturnMode.DATASET_AND_RECORDSET时有效，作为返回数据集的名称。
	     * dataReturnMode - {<SuperMap.REST.DataReturnMode>} 数据返回模式，默认为DataReturnMode.DATASET_ONLY。
	     * deleteExistResultDataset - {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
	     */
	    initialize: function (options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.expectCount = null;
	        me.dataset = null;
	        me.dataReturnMode = null;
	        me.deleteExistResultDataset = null;
	    },

	    CLASS_NAME: "DataReturnOption"
	});

	module.exports = function (options) {
	    return new DataReturnOption(options);
	};

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(157);

	/**
	 * Class: BufferAnalystParameters
	 * 缓冲区分析参数基类。
	 */
	BufferAnalystParameters = SuperMap.Class({

	    /**
	     * APIProperty: bufferSetting
	     * {<BufferSetting>} 设置缓冲区通用参数。
	     * 为缓冲区分析提供必要的参数信息，包括左缓冲距离、右缓冲距离、端点类型、圆头缓冲圆弧处线段的个数信息。
	     */
	    bufferSetting: null,

	    /**
	     * Constructor: BufferAnalystParameters
	     * 缓冲区分析参数基类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * bufferSetting - {<BufferSetting>} 设置缓冲区通用参数。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.bufferSetting = new BufferSetting();
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.bufferSetting) {
	            me.bufferSetting.destroy();
	            me.bufferSetting = null;
	        }
	    },

	    CLASS_NAME: "BufferAnalystParameters"
	});

	module.exports = function (options) {
	    return new BufferAnalystParameters(options);
	};

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(158);

	/**
	 * Class: BufferSetting
	 * 缓冲区分析通用设置类
	 */
	BufferSetting = SuperMap.Class({

	    /**
	     * APIProperty: endType
	     * {<SuperMap.REST.BufferEndType>} 缓冲区端点枚举值。
	     * 分为平头和圆头两种，默认为平头，即 SuperMap.REST.BufferEndType.FLAT 。
	     */
	    endType: SuperMap.REST.BufferEndType.FLAT,

	    /**
	     * APIProperty: leftDistance
	     * {<BufferDistance>} 左侧缓冲距离。
	     * 默认为100。当为GeometryBufferAnalyst时，单位为默认地图的投影系的单位（如3857为米，4326为度），当为DatasetBufferAnalyst时，单位通过BufferSetting.radiusUnit设置（默认全部为米）。
	     */
	    leftDistance: null,

	    /**
	     * APIProperty: rightDistance
	     * {<BufferDistance>} 右侧缓冲距离。
	     * 默认为100。当为GeometryBufferAnalyst时，单位为默认地图的投影系的单位（如3857为米，4326为度），当为DatasetBufferAnalyst时，单位通过BufferSetting.radiusUnit设置（默认全部为米）。
	     */
	    rightDistance: null,

	    /**
	     * APIProperty: semicircleLineSegment
	     * {Number} 圆头缓冲圆弧处线段的个数。
	     * 即用多少个线段来模拟一个半圆，默认值为4。
	     */
	    semicircleLineSegment: 4,

	    /**
	     * APIProperty: radiusUnit
	     * [Enum] 缓冲半径单位，默认值为SuperMap.REST.Unit.METER，还可以是SuperMap.REST.Unit.MILIMETER、SuperMap.REST.Unit.CENTIMETER、
	     * SuperMap.REST.Unit.DECIMETER、SuperMap.REST.Unit.KILOMETER、SuperMap.REST.Unit.FOOT、SuperMap.REST.Unit.INCH、SuperMap.REST.Unit.MILE、
	     * SuperMap.REST.Unit.YARD。仅对DatasetBufferAnalyst有效
	     */
	    radiusUnit: SuperMap.REST.Unit.METER,

	    /**
	     * Constructor: BufferSetting
	     * 缓冲区分析通用设置类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * endType - {<SuperMap.REST.BufferEndType>} 缓冲区端点枚举值。
	     * leftDistance - {<BufferDistance>} 左侧缓冲距离。
	     * rightDistance - {<BufferDistance>} 右侧缓冲距离。
	     * semicircleLineSegment - {Number} 圆头缓冲圆弧处线段的个数。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.leftDistance = new BufferDistance();
	        me.rightDistance = new BufferDistance();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.endType = null;
	        if (me.leftDistance) {
	            me.leftDistance.destroy();
	            me.leftDistance = null;
	        }
	        if (me.rightDistance) {
	            me.rightDistance.destroy();
	            me.rightDistance = null;
	        }
	        me.semicircleLineSegment = null;
	        me.radiusUnit = null;
	    },

	    CLASS_NAME: "BufferSetting"
	});

	module.exports = function (options) {
	    return new BufferSetting(options);
	};

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: BufferDistance
	 * 缓冲区分析的缓冲距离类
	 * 通过该类可以设置缓冲区分析的缓冲距离，距离可以是数值也可以是数值型的字段表达式。
	 */
	BufferDistance = SuperMap.Class({

	    /**
	     * APIProperty: exp
	     * {String} 以数值型的字段表达式作为缓冲区分析的距离值。
	     */
	    exp: null,

	    /**
	     * APIProperty: value
	     * {Number} 以数值作为缓冲区分析的距离值。默认为100，单位：米。
	     */
	    value: 100,

	    /**
	     * Constructor: BufferDistance
	     * 缓冲区分析的缓冲距离类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * exp - {String} 以数值型的字段表达式作为缓冲区分析的距离值。
	     * value - {Number} 以数值作为缓冲区分析的距离值。默认为100，单位：米。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.exp = null;
	        me.value = null;
	    },

	    CLASS_NAME: "BufferDistance"
	});

	module.exports = function (options) {
	    return new BufferDistance(options);
	};

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(156);

	/**
	 * Class: GeometryBufferAnalystParameters
	 * 几何对象缓冲区分析参数类
	 * 对指定的某个几何对象做缓冲区分析。通过该类可以指定要做缓冲区分析的几何对象、缓冲区参数等。
	 *
	 * Inherits from:
	 *  - <BufferAnalystParameters>
	 */
	GeometryBufferAnalystParameters = SuperMap.Class(BufferAnalystParameters, {

	    /**
	     * Property: sourceGeometry
	     * {<Object>} 要做缓冲区分析的几何对象(支持Point、LineString、LinearRing、Polygon)。必设字段。
	     */
	    sourceGeometry: null,

	    /**
	     * Constructor: GeometryBufferAnalystParameters
	     * 几何对象缓冲区分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * sourceGeometry - {<Object>} 要做缓冲区分析的几何对象。必设字段。
	     * bufferSetting - {<BufferSetting>} 设置缓冲区通用参数。
	     */
	    initialize: function (options) {
	        BufferAnalystParameters.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        BufferAnalystParameters.prototype.destroy.apply(this, arguments);
	        var me = this;
	        if (me.sourceGeometry) {
	            me.sourceGeometry.destroy();
	            me.sourceGeometry = null;
	        }
	    },

	    CLASS_NAME: "GeometryBufferAnalystParameters"
	});

	GeometryBufferAnalystParameters.toObject = function (geometryBufferAnalystParameters, tempObj) {
	    for (var name in geometryBufferAnalystParameters) {
	        if (name === "bufferSetting") {
	            var tempBufferSetting = {};
	            for (var key in geometryBufferAnalystParameters.bufferSetting) {
	                tempBufferSetting[key] = geometryBufferAnalystParameters.bufferSetting[key];
	            }
	            delete tempBufferSetting.radiusUnit;
	            tempObj.analystParameter = tempBufferSetting;
	        }
	        else if (name === "sourceGeometry") {
	            tempObj.sourceGeometry = SuperMap.REST.ServerGeometry.fromGeometry(geometryBufferAnalystParameters.sourceGeometry);
	        }
	        else {
	            tempObj[name] = geometryBufferAnalystParameters[name];
	        }
	    }
	};

	module.exports = function (options) {
	    return new GeometryBufferAnalystParameters(options);
	};

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.DensityAnalystService
	 *  密度分析服务类，密度分析可计算每个输出栅格像元周围圆形邻域内输入的点或线对象的密度。
	 *  密度分析，在某种意义上来说，相当于在表面上将输入的点线对象的测量值散开来，
	 *  将每个点或线对象的测量量分布在整个研究区域，并计算输出栅格中每个像元的密度值。
	 *
	 *  目前提供1种密度分析：核密度分析（Kernel）。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(161);
	SuperMap.REST.DensityAnalystService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Property: mode
	     * {String} 密度分析类型。
	     */
	    mode: null,

	    /**
	     * Constructor: SuperMap.REST.DensityAnalystService
	     * 密度分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myDensityAnalystService = new SuperMap.REST.DensityAnalystService(url);
	     * myDensityAnalystService.on({
	     *     "processCompleted": processCompleted,
	     *     "processFailed": processFailed
	     *     }
	     * );
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	        var me = this;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	        this.mode = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<DensityKernelAnalystParameters>}
	     */
	    processAsync: function (parameter) {
	        var me = this;

	        var end = me.url.substr(me.url.length - 1, 1);
	        if (end === '/') {

	        } else {
	            me.url += "/";
	        }

	        var parameterObject = new Object();

	        if (parameter instanceof DensityKernelAnalystParameters) {
	            me.url += 'datasets/' + parameter.dataset + '/densityanalyst/kernel';
	            me.mode = "kernel";
	        }

	        DensityKernelAnalystParameters.toObject(parameter, parameterObject);
	        var jsonParameters = SuperMap.Util.toJSON(parameterObject);

	        if (me.isInTheSameDomain) {
	            me.url += '.json?returnContent=true';
	        } else {
	            me.url += '.jsonp?returnContent=true';
	        }

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.DensityAnalystService"
	});
	module.exports = function (url, options) {
	    return new SuperMap.REST.DensityAnalystService(url, options);
	};

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: DensityKernelAnalystParameters
	 * 核密度分析参数类
	 *
	 */
	DensityKernelAnalystParameters = SuperMap.Class({

	    /**
	     * APIProperty: dataset
	     * {String} 要用来做核密度分析数据源中数据集的名称。
	     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：Railway@Changchun。必设字段。
	     *
	     * 注：核密度分析支持点数据集和线数据集。
	     */
	    dataset: null,

	    /**
	     * APIProperty: bounds
	     * {<SuperMap.Bounds>} 核密度分析的范围，用于确定结果栅格数据集的范围。
	     * 如果缺省，则默认为原数据集的范围。
	     */
	    bounds: null,

	    /**
	     * APIProperty: fieldName
	     * {String} 用于进行核密度分析的测量值的字段名称，核密度分析不支持文本类型的字段，必设字段。
	     */
	    fieldName: null,

	    /**
	     * APIProperty: resultGridDatasetResolution
	     * {Number} 密度分析结果栅格数据的分辨率，单位与当前数据集相同。默认值为当前数据集的长宽中的最小值除500。
	     */
	    resultGridDatasetResolution: null,

	    /**
	     * APIProperty: searchRadius
	     * {Number} 栅格邻域内用于计算密度的查找半径，单位与当前数据集相同。默认值为当前数据集的长宽中的最大值除30。
	     */
	    searchRadius: null,

	    /**
	     * APIProperty: targetDatasource
	     * {String}  指定的存储结果数据集的数据源，默认为当前分析的数据集所在的数据源。
	     */
	    targetDatasource: null,

	    /**
	     * APIProperty: resultGridName
	     * {String} 指定结果数据集名称，必设字段。
	     */
	    resultGridName: null,

	    /**
	     * APIProperty: deleteExistResultDataset
	     * {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
	     */
	    deleteExistResultDataset: false,

	    /**
	     * Constructor: DensityKernelAnalystParameters
	     * 核密度分析参数构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * dataset - {String} 要用来做核密度分析数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：BaseMap_P@Jingjin。必设字段。
	     * bounds - {<SuperMap.Bounds>} 核密度分析的范围，用于确定结果栅格数据集的范围。 如果缺省，则默认为原数据集的范围。
	     * searchRadius - {Number} 栅格邻域内用于计算密度的查找半径，单位与当前数据集相同。默认值为当前数据集的长宽中的最大值除30。
	     * fieldName - {String} 用于进行核密度分析的测量值的字段名称，核密度分析不支持文本类型的字段，必设字段。
	     * resultGridDatasetResolution - {Number} 密度分析结果栅格数据的分辨率，单位与当前数据集相同。默认值为当前数据集的长宽中的最小值除500。
	     * targetDatasource - {String} 指定的存储结果数据集的数据源，默认为当前分析的数据集所在的数据源。
	     * resultGridName - {Number} 指定结果数据集名称，必设字段。
	     * deleteExistResultDataset - {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.dataset = null;
	        me.bounds = null;
	        me.fieldName = null;
	        me.resultGridDatasetResolution = null;
	        me.searchRadius = null;

	        me.targetDatasource = null;
	        me.resultGridName = null;
	        me.deleteExistResultDataset = null;
	    },

	    CLASS_NAME: "DensityKernelAnalystParameters"
	});

	DensityKernelAnalystParameters.toObject = function (densityKernelAnalystParameters, tempObj) {
	    for (var name in densityKernelAnalystParameters) {
	        if (name !== "dataset") {
	            tempObj[name] = densityKernelAnalystParameters[name];
	        }
	        /*
	         if(name == "bounds"){
	         var icbounds = densityKernelAnalystParameters[name];
	         //var boundsJson = "{\"leftBottom\":{\"x\":" + bounds.left + ",\"y\":" + bounds.bottom
	         //   + ",\"rightTop\":{\"x\":" + bounds.right + ",\"y\":" + bounds.top + "}}";;

	         var leftBottom = {},  rightTop = {}, bounds = {};
	         leftBottom["x"] = icbounds.left;
	         leftBottom["y"] = icbounds.bottom;

	         rightTop["x"] = icbounds.right;
	         rightTop["y"] = icbounds.top;

	         bounds["leftBottom"] = leftBottom;
	         bounds["rightTop"] = rightTop;

	         tempObj[name] = bounds;
	         }
	         */
	    }
	};

	module.exports = function (options) {
	    return new DensityKernelAnalystParameters(options);
	};

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.GenerateSpatialDataService
	 * 动态分段分析服务类。
	 * 该类负责将客户设置的动态分段分析服务参数传递给服务端，并接收服务端返回的动态分段分析结果数据。
	 * 动态分段分析结果通过该类支持的事件的监听函数参数获取，参数类型为 {<SuperMap.REST.GenerateSpatialDataEventArgs>};
	 * 获取的结果数据包括 originResult 、result 两种，
	 * 其中，originResult 为服务端返回的用 JSON 对象表示的动态分段分析结果数据，
	 * result 为服务端返回的动态分段分析结果数据，
	 * 保存在 {<SuperMap.REST.GenerateSpatialDataResult>} 对象中。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(163);
	SuperMap.REST.GenerateSpatialDataService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Constructor: SuperMap.REST.GenerateSpatialDataService
	     * 动态分段服务类构造函数。
	     *
	     * 实例化该类如下例所示：
	     * (start code)
	     *  function GenerateSpatialData(){
	     *   
	     *  //配置数据返回选项(option)
	     *  var option = new SuperMap.REST.DataReturnOption({
	     *      expectCount: 1000,
	     *      dataset: "generateSpatialData",
	     *      deleteExistResultDataset: true,
	     *      dataReturnMode: SuperMap.REST.DataReturnMode.DATASET_ONLY
	     *  }),
	     *  //配置动态分段参数(Parameters)
	     *  parameters = new GenerateSpatialDataParameters({
	     *      routeTable: "RouteDT_road@Changchun",
	     *      routeIDField: "RouteID",
	     *      eventTable: "LinearEventTabDT@Changchun",
	     *      eventRouteIDField: "RouteID",
	     *      measureField: "",
	     *      measureStartField: "LineMeasureFrom",
	     *      measureEndField: "LineMeasureTo",
	     *      measureOffsetField: "",
	     *      errorInfoField: "",
	     *      retainedFields:[],
	     *      dataReturnOption: option
	     *  }),
	     *  //配置动态分段iService
	     *  iService = new SuperMap.REST.GenerateSpatialDataService(Changchun_spatialanalyst, {
	     *      eventListeners: {
	     *          processCompleted: generateCompleted,
	     *          processFailed: generateFailded 
	     *      }
	     *  });
	     *  //执行
	     *  iService.processAsync(parameters);
	     *  function Completed(generateSpatialDataEventArgs){//todo};
	     *  function Error(generateSpatialDataEventArgs){//todo};
	     * (end)   
	     *          
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的动态分段服务参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<GenerateSpatialDataParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this,
	            jsonParameters;

	        jsonParameters = me.getJsonParameters(params);

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJsonParameters
	     * 将参数转化为 JSON 字符串。
	     *
	     * Parameters:
	     * params - {<GenerateSpatialDataParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJsonParameters: function (params) {
	        var jsonParameters = "",
	            jsonStr = "datasets/" + params.routeTable + "/linearreferencing/generatespatialdata",
	            me = this,
	            end;

	        end = me.url.substr(me.url.length - 1, 1);
	        if (me.isInTheSameDomain) {
	            me.url += (end === "/") ? jsonStr + ".json" : "/" + jsonStr + ".json";
	        } else {
	            me.url += (end === "/") ? jsonStr + ".jsonp" : "/" + jsonStr + ".jsonp";
	        }

	        me.url += "?returnContent=true";
	        jsonParameters = SuperMap.Util.toJSON(params);
	        return jsonParameters;
	    },

	    CLASS_NAME: "SuperMap.REST.GenerateSpatialDataService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GenerateSpatialDataService(url, options);
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(155);

	/**
	 * Class: GenerateSpatialDataParameters
	 * 动态分段操作参数类。
	 * 通过该类可以为动态分段提供参数信息。
	 */
	GenerateSpatialDataParameters = SuperMap.Class({

	    /**
	     * APIProperty: routeTable
	     * {Sting} 路由数据集。
	     */
	    routeTable: null,

	    /**
	     * APIProperty: routeIDField
	     * {Sting} 路由数据集的标识字段。
	     */
	    routeIDField: null,

	    /**
	     * APIProperty: eventTable
	     * {Sting} 用于生成空间数据的事件表名。
	     */
	    eventTable: null,

	    /**
	     * APIProperty: eventRouteIDField
	     * {Sting} 用于生成空间数据的事件表的路由标识字段。
	     */
	    eventRouteIDField: null,

	    /**
	     * APIProperty: measureField
	     * {Sting} 用于生成空间数据的事件表的刻度字段，只有当事件为点事件的时候该属性才有意义
	     */
	    measureField: null,

	    /**
	     * APIProperty: measureStartField
	     * {Sting} 用于生成空间数据的事件表的起始刻度字段，只有当事件为线事件的时候该属性才有意义。
	     */
	    measureStartField: null,

	    /**
	     * APIProperty: measureEndField
	     * {Sting} 用于生成空间数据的事件表的终止刻度字段，只有当事件为线事件的时候该属性才有意义。
	     */
	    measureEndField: null,

	    /**
	     * APIProperty: measureOffsetField
	     * {Sting} 刻度偏移量字段。
	     */
	    measureOffsetField: null,

	    /**
	     * APIProperty: errorInfoField
	     * {Sting} 错误信息字段，直接写入原事件表，用于描述事件未能生成对应的点或线时的错误信息。
	     */
	    errorInfoField: null,

	    /**
	     * APIProperty: retainedFields
	     * {Array(String)} 欲保留到结果空间数据中的字段集合（系统字段除外）。
	     *  生成空间数据时，无论是否指定保留字段，路由 ID 字段、刻度偏移量字段、刻度值字段（点事件为刻度字段，线事件是起始和终止刻度字段）都会保留到结果空间数据中；
	     *  如果没有指定 retainedFields 参数或者retainedFields 参数数组长度为0，则返回所有用户字段。
	     */
	    retainedFields: null,

	    /**
	     * APIProperty: dataReturnOption
	     * {<DataReturnOption>} 设置数据返回的选项。
	     */
	    dataReturnOption: null,

	    /**
	     * Constructor: SuperMap.REST.SurfaceAnalystParameters
	     * 表面分析提取操作参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * routeTable - {Sting} 路由数据集。
	     * routeIDField - {Sting} 路由数据集的标识字段。
	     * eventTable - {Sting} 用于生成空间数据的事件表名。
	     * eventRouteIDField - {Sting} 用于生成空间数据的事件表的路由标识字段。
	     * measureField - {Sting} 用于生成空间数据的事件表的刻度字段，只有当事件为点事件的时候该属性才有意义
	     * measureStartField - {Sting} 用于生成空间数据的事件表的起始刻度字段，只有当事件为线事件的时候该属性才有意义。
	     * measureEndField - {Sting} 用于生成空间数据的事件表的终止刻度字段，只有当事件为线事件的时候该属性才有意义。
	     * measureOffsetField - {Sting} 刻度偏移量字段。
	     * errorInfoField - {Sting} 错误信息字段，直接写入原事件表，用于描述事件未能生成对应的点或线时的错误信息。
	     * retainedFields - {Array(String)} 欲保留到结果空间数据中的字段集合（系统字段除外）。
	     * dataReturnOption - {<DataReturnOption>} 设置数据返回的最大记录。
	     */
	    initialize: function (options) {
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.routeTable) {
	            me.routeTable = null;
	        }
	        me.routeIDField = null;
	        me.eventTable = null;
	        me.eventRouteIDField = null;
	        me.measureField = null;
	        me.measureStartField = null;
	        me.measureEndField = null;
	        me.measureOffsetField = null;
	        me.errorInfoField = null;
	        if (me.dataReturnOption) {
	            me.dataReturnOption.destroy();
	            me.dataReturnOption = null;
	        }
	    },

	    CLASS_NAME: "GenerateSpatialDataParameters"
	});

	module.exports = function (options) {
	    return new GenerateSpatialDataParameters(options);
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.GeoRelationAnalystService
	 * 空间关系分析服务类。
	 * 该类负责将客户设置的空间关系分析服务参数传递给服务端，并接收服务端返回的空间关系分析结果数据。
	 */
	__webpack_require__(151);
	__webpack_require__(165);
	SuperMap.REST.GeoRelationAnalystService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Constructor: SuperMap.REST.GenerateSpatialDataService
	     * 空间关系分析服务类构造函数。
	     *
	     * 实例化该类如下例所示：
	     * (start code)
	     *  function datasetGeoRelationAnalystProcess() {
	     *      var referenceFilter = new SuperMap.REST.FilterParameter({
	     *                              name:"Frame_R@Changchun",
	     *                              attributeFilter:"SmID>0"});
	     *      var sourceFilter = new SuperMap.REST.FilterParameter({
	     *                          attributeFilter:"SmID>0"});
	     *      //初始化服务类
	     *      var datasetGeoRelationService = new SuperMap.REST.GeoRelationAnalystService(
	     *          "http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst/"),
	     *      //构建参数类
	     *      datasetGeoRelationParameters = new GeoRelationAnalystParameters({
	     *          dataset: "Park@Changchun",
	     *          startRecord: 0,
	     *          expectCount: 20,
	     *          sourceFilter: sourceFilter,
	     *          referenceFilter: referenceFilter,
	     *          spatialRelationType: SuperMap.REST.SpatialRelationType.INTERSECT,
	     *          isBorderInside: true,
	     *          returnFeature: true,
	     *          returnGeoRelatedOnly: true
	     *      });
	     *      datasetGeoRelationService.events.on({
	     *          "processCompleted": datasetGeoRelationAnalystCompleted, 
	     *          "processFailed": datasetGeoRelationAnalystFailed});
	     *      //执行
	     *      datasetGeoRelationService.processAsync(datasetGeoRelationParameters);
	     *  }
	     *  function Completed(datasetGeoRelationAnalystCompleted){//todo};
	     *  function Error(datasetGeoRelationAnalystFailed){//todo};
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的空间关系分析参数传递到服务端
	     *
	     * Parameters:
	     * params - {<GeoRelationAnalystParameters>} 空间关系分析所需的参数信息。
	     */
	    processAsync: function (parameter) {
	        var me = this;
	        var end = me.url.substr(me.url.length - 1, 1);
	        if (end === '/') {
	            me.url += 'datasets/' + parameter.dataset + '/georelation';
	        } else {
	            me.url += '/datasets/' + parameter.dataset + '/georelation';
	        }

	        var jsonParameters = SuperMap.Util.toJSON(parameter);

	        if (me.isInTheSameDomain) {
	            me.url += '.json?returnContent=true';
	        } else {
	            me.url += '.jsonp?returnContent=true';
	        }

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.GeoRelationAnalystService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.GeoRelationAnalystService(url, options);
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: GeoRelationAnalystParameters
	 * 空间关系分析服务参数类。
	 * 使用该类可以为空间关系分析服务提供所需的参数信息。
	 */
	GeoRelationAnalystParameters = SuperMap.Class({

	    /**
	     * APIProperty: dataset
	     * {<String>} 源数据集名称。
	     */
	    dataset: null,

	    /**
	     * APIProperty: sourceFilter
	     * {<SuperMap.REST.FilterParameter>} 空间关系分析中的源数据集查询参数。仅 ids、attributeFilter 和 fields 字段有效。
	     */
	    sourceFilter: null,

	    /**
	     * APIProperty: referenceFilter
	     * {<SuperMap.REST.FilterParameter>} 空间关系分析中的参考数据集查询参数。仅 name, ids, attributeFilter
	     * 和 fields 字段有效。
	     */
	    referenceFilter: null,

	    /**
	     * APIProperty: spatialRelationType
	     * {<SuperMap.REST.SpatialRelationType>} 指定的空间关系类型。
	     */
	    spatialRelationType: null,

	    /**
	     * APIProperty: isBorderInside
	     * {Boolean} 边界处理方式，即位于面边线上的点是否被面包含。此参数仅用于空间关系为包含或被包含的情况。
	     */
	    isBorderInside: null,

	    /**
	     * APIProperty: returnFeature
	     * {Boolean} 是否返回Feature信息。
	     */
	    returnFeature: null,

	    /**
	     * APIProperty: returnGeoRelatedOnly
	     * {Boolean} 是否仅返回满足指定空间关系的空间对象，默认为 True。
	     */
	    returnGeoRelatedOnly: null,

	    /**
	     * APIProperty: startRecord
	     * {Integer} 分析结果起始记录位置，默认为0。
	     */
	    startRecord: 0,

	    /**
	     * Property: expectCount
	     * {Integer} 空间关系分析期望返回结果记录数，默认为500条，如果实际不足500条结果则返回所有分析结果。
	     */
	    expectCount: 500,

	    /**
	     * Constructor: GeoRelationAnalystParameters
	     * 叠加分析参数基类构造函数构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * sourceFilter - {<SuperMap.REST.FilterParameter>} 空间关系分析中的参考数据集查询参数。仅 name, ids,
	     *      attributeFilter 和 fields 字段有效。
	     * referenceFilter - {<SuperMap.REST.FilterParameter>} 空间关系分析中的参考数据集查询参数。仅 name, ids,
	     *      attributeFilter 和 fields 字段有效。
	     * isBorderInside - {Boolean} 边界处理方式，即位于面边线上的点是否被面包含。此参数仅用于空间关系为包含或被包含的情况。
	     * returnFeature - {Boolean} 是否返回Feature信息。
	     * returnGeoRelatedOnly - {Boolean} 仅返回满足指定空间关系的空间对象，默认为 True。
	     * startRecord - {Integer} 分析结果起始记录位置，默认为0。
	     * expectCount - {Integer} 空间关系分析期望返回结果记录数，默认为500条，如果实际不足500条结果则返回所有分析结果。
	     */
	    initialize: function (options) {
	        var me = this;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.sourceFilter) {
	            me.sourceFilter.destroy();
	        }
	        me.sourceFilter = null;

	        if (me.referenceFilter) {
	            me.referenceFilter.destroy();
	        }
	        me.referenceFilter = null;

	        me.dataset = null;
	        me.spatialRelationType = null;
	        me.isBorderInside = null;
	        me.returnFeature = null;
	        me.returnGeoRelatedOnly = null;
	        me.startRecord = null;
	        me.expectCount = null;
	    },

	    CLASS_NAME: "GeoRelationAnalystParameters"
	});

	module.exports = function (options) {
	    return new GeoRelationAnalystParameters(options);
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.InterpolationAnalystService
	 * 插值分析服务类
	 * 插值分析可以将有限的采样点数据， 通过插值算法对采样点周围的数值情况进行预测，
	 * 可以掌握研究区域内数据的总体分布状况，从而使采样的离散点不仅仅反映其所在位置的数值情况，
	 * 还可以反映区域的数值分布。目前SuperMap iServer的插值功能提供从点数据集插值得到栅格数据集的功能，
	 * 支持以下常用的内插方法，
	 * 包括：反距离加权插值、克吕金（Kriging）插值法、样条（径向基函数，Radial Basis Function）插值、点密度插值。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(167);
	__webpack_require__(169);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(168);
	SuperMap.REST.InterpolationAnalystService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Property: mode
	     * {String} 插值分析类型。
	     */
	    mode: null,

	    /**
	     * Constructor: SuperMap.REST.InterpolationAnalystService
	     * 插值分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myTInterpolationAnalystService = new SuperMap.REST.InterpolationAnalystService(url);
	     * myTInterpolationAnalystService.events.on({
	     *     "processCompleted": processCompleted,
	     *     "processFailed": processFailed
	     *     }
	     * );
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	        var me = this;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	        this.mode = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<InterpolationAnalystParameters>}/
	     * {<InterpolationAnalystParameters>}
	     */
	    processAsync: function (parameter) {
	        var parameterObject = new Object();
	        var me = this;

	        var end = me.url.substr(me.url.length - 1, 1);
	        if (end === '/') {

	        } else {
	            me.url += "/";
	        }

	        if (parameter instanceof InterpolationDensityAnalystParameters) {
	            me.mode = "Density";
	            if (parameter.InterpolationAnalystType === "geometry") {
	                me.url += 'geometry/interpolation/density';
	            } else {
	                me.url += 'datasets/' + parameter.dataset + '/interpolation/density';
	            }
	        }
	        else if (parameter instanceof InterpolationIDWAnalystParameters) {
	            me.mode = "IDW";
	            if (parameter.InterpolationAnalystType === "geometry") {
	                me.url += 'geometry/interpolation/idw';
	            } else {
	                me.url += 'datasets/' + parameter.dataset + '/interpolation/idw';
	            }
	        }
	        else if (parameter instanceof InterpolationRBFAnalystParameters) {
	            me.mode = "RBF";
	            if (parameter.InterpolationAnalystType === "geometry") {
	                me.url += 'geometry/interpolation/rbf';
	            } else {
	                me.url += 'datasets/' + parameter.dataset + '/interpolation/rbf';
	            }
	        }
	        else if (parameter instanceof InterpolationKrigingAnalystParameters) {
	            me.mode = "Kriging";
	            if (parameter.InterpolationAnalystType === "geometry") {
	                me.url += 'geometry/interpolation/kriging';
	            } else {
	                me.url += 'datasets/' + parameter.dataset + '/interpolation/kriging';
	            }
	        }
	        InterpolationAnalystParameters.toObject(parameter, parameterObject);
	        var jsonParameters = SuperMap.Util.toJSON(parameterObject);


	        if (me.isInTheSameDomain) {
	            me.url += '.json?returnContent=true';
	        } else {
	            me.url += '.jsonp?returnContent=true';
	        }

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.InterpolationAnalystService"

	});
	module.exports = function (url, options) {
	    return new SuperMap.REST.InterpolationAnalystService(url, options);
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(168);

	/**
	 * Class: SuperMap.REST.InterpolationRBFAnalystParameter
	 * 样条插值（径向基函数插值法）分析参数类
	 *
	 * Inherits from:
	 *  - <InterpolationAnalystParameters>
	 */

	InterpolationRBFAnalystParameters = SuperMap.Class(InterpolationAnalystParameters, {
	    /**
	     * APIProperty: smooth
	     * {Number} 光滑系数，值域为 0到1，默认值为0.1，常用取值如0、0.001、0.01、0.1、和0.5。
	     * 该值表示插值函数曲线与点的逼近程度，此数值越大，函数曲线与点的偏差越大，反之越小。
	     */
	    smooth: 0.1,

	    /**
	     * APIProperty: tension
	     * {Number} 张力系数，默认为40，常用取值如0、1、5和10。
	     * 用于调整结果栅格数据表面的特性，张力越大，插值时每个点对计算结果影响越小，反之越大。
	     */
	    tension: 40,

	    /**
	     * APIProperty: searchMode
	     * {<SuperMap.REST.SearchMode>} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数
	     * 具体如下：
	     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
	     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
	     * {QUADTREE} 使用 QUADTREE 方式查找参与内插分析的点（块查找）。
	     */
	    searchMode: null,

	    /**
	     * APIProperty: expectedCount
	     * {Number} 【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数。默认值为12。
	     */
	    expectedCount: 12,

	    /**
	     * APIProperty: maxPointCountForInterpolation
	     * {Number} 【块查找】方式下，最多参与插值的点数。默认值为200。
	     */
	    maxPointCountForInterpolation: 200,

	    /**
	     * APIProperty: maxPointCountInNode
	     * {Number} 【块查找】方式下，单个块内最多参与运算点数。默认值为50。
	     */
	    maxPointCountInNode: 50,

	    /**
	     * Constructor: InterpolationRBFAnalystParameters
	     * 样条插值分析参数类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myInterpolationRBFAnalystParameters = new InterpolationRBFAnalystParameters({
	     *     dataset:"SamplesP@Interpolation",
	     *     smooth: 0.1,
	     *     tension: 40,
	     *     searchMode: "QUADTREE",
	     *     maxPointCountForInterpolation: 20,
	     *     maxPointCountInNode: 5,
	     *     pixelFormat: "BIT16",
	     *     zValueFieldName: "AVG_TMP",
	     *     resolution: 3000,
	     *     filterQueryParameter: {
	     *         attributeFilter: ""
	     *     },
	     *     outputDatasetName: "myRBF"
	     * });
	     * (end)
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * smooth - {Number} 光滑系数，该值表示插值函数曲线与点的逼近程度，值域为 0到1，默认值为0.1。
	     * tension - {Number} 张力系数，用于调整结果栅格数据表面的特性，默认为40。
	     * bounds - {<SuperMap.Bounds>} 插值分析的范围，用于确定结果栅格数据集的范围。
	     * searchMode - {String} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数
	     * expectedCount - {Number} 【固定点数查找】方式下，设置参与差值运算的点数，默认值为12。
	     * searchRadius - {Number} 【定长查找】方式下，设置参与运算点的查找范围，默认值为0。
	     * maxPointCountForInterpolation - {Number} 【块查找】方式下，设置最多参与插值的点数。默认为200。
	     * maxPointCountInNode - {Number} 【块查找】方式下，设置单个块内最多参与运算点数。默认为50。
	     * zValueFieldName - {String} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     * zValueScale - {Number} 用于进行插值分析值的缩放比率，默认值为1。
	     * resolution - {Number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
	     * filterQueryParameter - {<SuperMap.REST.FilterParameter>} 属性过滤条件。
	     * outputDatasetName - {String} 插值分析结果数据集的名称。必设参数
	     * outputDatasourceName - {String} 插值分析结果数据源的名称。必设参数
	     * pixelFormat - {String} 指定结果栅格数据集存储的像素格式。
	     * dataset - {String} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     * inputPoints - {Array <SuperMap.Geometry.Point>} 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时，必设参数。
	     */
	    initialize: function (options) {
	        InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
	        var me = this;
	        me.smooth = 0.1;
	        me.tension = 40;
	        me.searchMode = null;
	        me.expectedCount = 12;
	        me.maxPointCountForInterpolation = 200;
	        me.maxPointCountInNode = 50;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.smooth = null;
	        me.tension = null;
	        me.searchMode = null;
	        me.expectedCount = null;
	        me.maxPointCountForInterpolation = null;
	        me.maxPointCountInNode = null;
	    },

	    CLASS_NAME: "InterpolationRBFAnalystParameters"
	});

	InterpolationRBFAnalystParameters.toObject = function (datasetInterpolationRBFAnalystParameters, tempObj) {
	    for (var name in datasetInterpolationRBFAnalystParameters) {
	        tempObj[name] = datasetInterpolationRBFAnalystParameters[name];

	    }
	};

	/**
	 * Class: SuperMap.REST.InterpolationRBFAnalystParameter
	 * 样条插值（径向基函数插值法）分析参数类
	 *
	 * Inherits from:
	 *  - <InterpolationAnalystParameters>
	 */

	InterpolationRBFAnalystParameters = SuperMap.Class(InterpolationAnalystParameters, {
	    /**
	     * APIProperty: smooth
	     * {Number} 光滑系数，值域为 0到1，默认值为0.1，常用取值如0、0.001、0.01、0.1、和0.5。
	     * 该值表示插值函数曲线与点的逼近程度，此数值越大，函数曲线与点的偏差越大，反之越小。
	     */
	    smooth: 0.1,

	    /**
	     * APIProperty: tension
	     * {Number} 张力系数，默认为40，常用取值如0、1、5和10。
	     * 用于调整结果栅格数据表面的特性，张力越大，插值时每个点对计算结果影响越小，反之越大。
	     */
	    tension: 40,

	    /**
	     * APIProperty: searchMode
	     * {String} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必输参数。
	     * 具体如下：
	     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
	     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
	     * {QUADTREE} 使用 QUADTREE 方式查找参与内插分析的点（块查找）。
	     */
	    searchMode: null,

	    /**
	     * APIProperty: expectedCount
	     * {Number} 【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数。默认为12。
	     */
	    expectedCount: 12,

	    /**
	     * APIProperty: maxPointCountForInterpolation
	     * {Number} 【块查找】方式下，最多参与插值的点数。默认为200。
	     */
	    maxPointCountForInterpolation: 200,

	    /**
	     * APIProperty: maxPointCountInNode
	     * {Number} 【块查找】方式下，单个块内最多参与运算点数。默认为50。
	     */
	    maxPointCountInNode: 50,

	    /**
	     * Constructor: InterpolationRBFAnalystParameters
	     * 样条插值分析参数类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myInterpolationRBFAnalystParameters = new InterpolationRBFAnalystParameters({
	     *     dataset:"SamplesP@Interpolation",
	     *     smooth: 0.1,
	     *     tension: 40,
	     *     searchMode: "QUADTREE",
	     *     maxPointCountForInterpolation: 20,
	     *     maxPointCountInNode: 5,
	     *     pixelFormat: "BIT16",
	     *     zValueFieldName: "AVG_TMP",
	     *     resolution: 3000,
	     *     filterQueryParameter: {
	     *         attributeFilter: ""
	     *     },
	     *     outputDatasetName: "myRBF"
	     * });
	     * (end)
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * smooth - {Number} 光滑系数，该值表示插值函数曲线与点的逼近程度，值域为 0到1，默认值约为0.1。
	     * tension - {Number} 张力系数，用于调整结果栅格数据表面的特性，默认为40。
	     * bounds - {<SuperMap.Bounds>} 插值分析的范围，用于确定结果栅格数据集的范围。
	     * searchMode - {String} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数
	     * expectedCount - {Number} 【固定点数查找】方式下，设置参与差值运算的点数。
	     * searchRadius - {Number} 【定长查找】方式下，设置参与运算点的查找范围。
	     * maxPointCountForInterpolation - {Number} 【块查找】方式下，设置最多参与插值的点数。默认为200。
	     * maxPointCountInNode - {Number} 【块查找】方式下，设置单个块内最多参与运算点数。默认为50。
	     * zValueFieldName - {String} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。必设参数
	     * zValueScale - {Number} 用于进行插值分析值的缩放比率，默认为1。
	     * resolution - {Number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
	     * filterQueryParameter - {<SuperMap.REST.FilterParameter>} 属性过滤条件。必设参数
	     * outputDatasetName - {String} 插值分析结果数据集的名称。必设参数
	     * pixelFormat - {String} 指定结果栅格数据集存储的像素格式。必设参数
	     * dataset - {String} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。必设参数
	     */
	    initialize: function (options) {
	        InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
	        var me = this;
	        me.smooth = 0.1;
	        me.tension = 40;
	        me.searchMode = null;
	        me.expectedCount = 12;
	        me.maxPointCountForInterpolation = 200;
	        me.maxPointCountInNode = 50;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.smooth = null;
	        me.tension = null;
	        me.searchMode = null;
	        me.expectedCount = null;
	        me.maxPointCountForInterpolation = null;
	        me.maxPointCountInNode = null;
	    },

	    CLASS_NAME: "InterpolationRBFAnalystParameters"
	});

	module.exports = function (options) {
	    return new InterpolationRBFAnalystParameters(options);
	};

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: InterpolationAnalystParameters
	 * 插值分析参数类
	 *
	 */
	InterpolationAnalystParameters = SuperMap.Class({

	    /**
	     * APIProperty: bounds
	     * {<SuperMap.Bounds>} 插值分析的范围，用于确定结果栅格数据集的范围。
	     * 如果缺省，则默认为原数据集的范围。鉴于此插值方法为内插方法，原数据集的范围内的插值结果才相对有参考价值，
	     * 因此建议此参数不大于原数据集范围。
	     */
	    bounds: null,

	    /**
	     * APIProperty: searchRadius
	     * {Number} 查找半径，即参与运算点的查找范围，与点数据集单位相同，默认值为0。
	     * 计算某个位置的Z 值时，会以该位置为圆心，以查找范围的值为半径，落在这个范围内的采样点都将参与运算。
	     * 该值需要根据待插值点数据的分布状况和点数据集范围进行设置。
	     */
	    searchRadius: 0,

	    /**
	     * APIProperty: zValueFieldName
	     * {String} 数据集插值分析中，用于指定进行插值分析的目标字段名，插值分析不支持文本类型的字段。
	     * 含义为每个插值点在插值过程中的权重，可以将所有点此字段值设置为1，即所有点在整体插值中权重相同。
	     * 当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     */
	    zValueFieldName: null,

	    /**
	     * APIProperty: zValueScale
	     * {Number} 用于进行插值分析值的缩放比率，默认值为1。
	     * 参加插值分析的值将乘以该参数值后再进行插值，也就是对进行插值分析的值进行统一的扩大或缩小。
	     */
	    zValueScale: 1,

	    /**
	     * APIProperty: resolution
	     * {Number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
	     * 该值不能超过待分析数据集的范围边长。
	     * 且该值设置时，应该考虑点数据集范围大小来取值，一般为结果栅格行列值（即结果栅格数据集范围除以分辨率），在500以内可以较好地体现密度走势。
	     */
	    resolution: null,

	    /**
	     * APIProperty: filterQueryParameter
	     * {<SuperMap.REST.FilterParameter>} 过滤条件，
	     *对分析数据集中的点进行过滤，不设置时默认为null，即对数据集中的所有点进行分析。
	     */
	    filterQueryParameter: null,

	    /**
	     * APIProperty: outputDatasetName
	     * {String} 插值分析结果数据集的名称。必设参数
	     */
	    outputDatasetName: null,

	    /**
	     * APIProperty: outputDatasourceName
	     * {String} 插值分析结果数据源的名称。必设参数
	     */
	    outputDatasourceName: null,

	    /**
	     * APIProperty: pixelFormat
	     * {<SuperMap.REST.PixelFormat>} 指定结果栅格数据集存储的像素格式。
	     * 默认值为 SuperMap.REST.PixelFormat.BIT16。
	     * 支持存储的像素格式有 BIT16、BIT32、DOUBLE、SINGLE、UBIT1、UBIT4、UBIT8、UBIT24、UBIT32。
	     */
	    pixelFormat: SuperMap.REST.PixelFormat.BIT16,

	    /**
	     * APIProperty: dataset
	     * {String}用来做插值分析的数据源中数据集的名称，该名称用形如"数据集名称@数据源别名"形式来表示。
	     * 当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     */
	    dataset: null,

	    /**
	     * APIProperty: inputPoints
	     * {Array <Point||Array>} 用于做插值分析的离散点（离散点包括Z值）集合。
	     * 当插值分析类型（InterpolationAnalystType）为 geometry 时，此参数为必设参数。
	     * 通过离散点直接进行插值分析不需要指定输入数据集inputDatasourceName，inputDatasetName以及zValueFieldName。
	     */
	    inputPoints: null,

	    /**
	     * APIProperty: InterpolationAnalystType
	     * {String} 插值分析类型。差值分析包括数据集插值分析和几何插值分析两类，
	     * “dataset”表示对数据集进行插值分析，“geometry”表示对离散点数组进行插值分析，默认值为“dataset”。
	     */
	    InterpolationAnalystType: "dataset",

	    /**
	     * APIProperty: clipParam
	     * {<SuperMap.REST.ClipParameter>}  对插值分析结果进行裁剪的参数。
	     */
	    clipParam: null,

	    /**
	     * Constructor: InterpolationAnalystParameters
	     * 插值分析参数基类构造函数。不能用于实例化插值分析参数。
	     * 使用其具体子类（如点密度差值分析参数类）实例化对应的插值分析参数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * bounds - {<SuperMap.Bounds>} 插值分析的范围，用于确定结果栅格数据集的范围。
	     * searchRadius - {Number} 查找半径，即参与运算点的查找范围，与点数据集单位相同。
	     * zValueFieldName - {String} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。
	     * zValueScale - {Number} 用于进行插值分析值的缩放比率，默认为1。
	     * resolution - {Number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
	     * filterQueryParameter - {<SuperMap.REST.FilterParameter>} 属性过滤条件。
	     * outputDatasetName - {String} 插值分析结果数据集的名称。
	     * outputDatasourceName - {String} 插值分析结果数据源的名称。
	     * pixelFormat - {<SuperMap.REST.PixelFormat>} 指定结果栅格数据集存储的像素格式。
	     * dataset - {String} 用于做插值分析的数据源中数据集的名称。
	     * inputPoints - {Array <Point||Array>} 用于做插值分析的离散点集合。
	     * InterpolationAnalystType - {String} 插值分析类型（dataset或geometry），默认为dataset 。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.bounds = null;
	        me.searchRadius = null;
	        me.zValueFieldName = null;
	        me.zValueScale = null;

	        me.resolution = null;
	        me.filterQueryParameter = null;
	        me.outputDatasetName = null;
	        me.pixelFormat = null;
	    },

	    CLASS_NAME: "InterpolationAnalystParameters"
	});

	InterpolationAnalystParameters.toObject = function (interpolationAnalystParameters, tempObj) {
	    for (var name in interpolationAnalystParameters) {
	        if (name === "inputPoints" && interpolationAnalystParameters.InterpolationAnalystType === "geometry") {
	            var objs = [];
	            for (var i = 0; i < interpolationAnalystParameters.inputPoints.length; i++) {
	                var item = interpolationAnalystParameters.inputPoints[i];
	                var obj = {
	                    x: item.x,
	                    y: item.y,
	                    z: item.tag
	                };
	                objs.push(obj);
	            }
	            tempObj[name] = objs;
	        } else {
	            tempObj[name] = interpolationAnalystParameters[name];
	        }
	    }
	};

	module.exports = function (options) {
	    return new InterpolationAnalystParameters(options);
	};

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(168);
	__webpack_require__(170);
	/**
	 * Class: InterpolationDensityAnalystParameters
	 * 点密度差值分析参数类
	 *
	 * Inherits from:
	 *  - <InterpolationAnalystParameters>
	 */
	InterpolationDensityAnalystParameters = SuperMap.Class(InterpolationAnalystParameters, {

	    /**
	     * Constructor: InterpolationDensityAnalystParameters
	     * 点密度插值分析参数构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myInterpolationDensityAnalystParameters = new InterpolationDensityAnalystParameters({
	     *      dataset: "SamplesP@Interpolation",
	     *      searchRadius: "100000",
	     *      pixelFormat: "BIT16",
	     *      zValueFieldName: "AVG_TMP",
	     *      resolution: 3000,
	     *      filterQueryParameter: {
	     *          attributeFilter: ""
	     *      },
	     *      outputDatasetName: "myDensity"
	     * });
	     * (end)
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * bounds - {<SuperMap.Bounds>} 插值分析的范围，用于确定结果栅格数据集的范围。
	     * searchRadius - {Number} 查找半径，即参与运算点的查找范围，与点数据集单位相同，默认值为0。
	     * zValueFieldName - {String} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     * zValueScale - {Number} 用于进行插值分析值的缩放比率，默认值为1。
	     * resolution - {Number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
	     * filterQueryParameter - {<SuperMap.REST.FilterParameter>} 属性过滤条件。
	     * outputDatasetName - {String} 插值分析结果数据集的名称。必设参数
	     * outputDatasourceName - {String} 插值分析结果数据源的名称。必设参数
	     * pixelFormat - {String} 指定结果栅格数据集存储的像素格式。
	     * dataset - {String} 用来做插值分析的数据源中数据集的名称，该名称用形如"数据集名称@数据源别名"形式来表示。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     * inputPoints - {Array <SuperMap.Geometry.Point>} 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时，必设参数。
	     */
	    initialize: function (options) {
	        InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
	    },

	    CLASS_NAME: "InterpolationDensityAnalystParameters"
	});

	module.exports = function (options) {
	    return new InterpolationDensityAnalystParameters(options);
	};

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: ThiessenAnalystParameters
	 * 泰森多边形分析参数基类。
	 */
	ThiessenAnalystParameters = SuperMap.Class({

	    /**
	     * APIProperty: clipRegion
	     * {<SuperMap.Geometry>} 结果数据裁剪区域，可以为null，表示不对结果进行裁剪。
	     */
	    clipRegion: null,

	    /**
	     * APIProperty: createResultDataset
	     * {Boolean} 是否返回结果数据集，默认值 false。如果为true，则必须设置属性resultDatasetName和resultDatasourceName。
	     */
	    createResultDataset: false,

	    /**
	     * APIProperty: resultDatasetName
	     * {String} 指定结果数据集名称。
	     */
	    resultDatasetName: null,

	    /**
	     * APIProperty: resultDatasourceName
	     * {String} 指定结果数据集所在数据源。
	     */
	    resultDatasourceName: null,

	    /**
	     * APIProperty: returnResultRegion
	     * {Boolean} 是否返回分析得到的多边形面数组，默认 true，返回。
	     */
	    returnResultRegion: true,


	    /**
	     * Constructor: ThiessenAnalystParameters
	     * 泰森多边形分析参数基类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * clipRegion - {<SuperMap.Geometry>} 结果数据裁剪区域，可以为null，表示不对结果进行裁剪。
	     * createResultDataset - {Boolean} 是否返回结果数据集，默认不返回。
	     * resultDatasetName - {Boolean} 指定结果数据集名称。
	     * resultDatasourceName - {Boolean} 指定结果数据集所在数据源，默认为当前数据源。
	     * returnResultRegion - {Boolean} 是否返回分析得到的多边形面数组，默认返回。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.clipRegion) {
	            me.clipRegion.destroy();
	            me.clipRegion = null;
	        }
	        me.createResultDataset = null;
	        me.resultDatasetName = null;
	        me.resultDatasourceName = null;
	        me.returnResultRegion = null;
	    },

	    CLASS_NAME: "ThiessenAnalystParameters"
	});

	module.exports = function (options) {
	    return new ThiessenAnalystParameters(options);
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(168);
	__webpack_require__(170);
	/**
	 * Class: SuperMap.REST.InterpolationIDWAnalystParameter
	 * 反距离加权插值（IDW）分析参数类
	 *
	 * Inherits from:
	 *  - <InterpolationAnalystParameters>
	 */

	InterpolationIDWAnalystParameters = SuperMap.Class(InterpolationAnalystParameters, {
	    /**
	     * APIProperty: power
	     * {Number} 距离权重计算的幂次，默认值为2。
	     * 该值决定了权值下降的速度，幂次越大，随距离的增大权值下降越快，距离预测点越远的点的权值也越小。
	     * 理论上，参数值必须大于0，但是0.5到3之间时运算结果更合理，因此推荐值为0.5~3。
	     */
	    power: 2,

	    /**
	     * APIProperty: searchMode
	     * {<SuperMap.REST.SearchMode>} 插值运算时，查找参与运算点的方式，支持固定点数查找、定长查找。必设参数
	     * 具体如下：
	     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
	     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
	     */
	    searchMode: null,

	    /**
	     * APIProperty: expectedCount
	     * {Number} 【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数，默认值为12。
	     */
	    expectedCount: 12,

	    /**
	     * Constructor: InterpolationIDWAnalystParameters
	     * IDW分析参数类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myInterpolationIDWAnalystParameters = new InterpolationIDWAnalystParameters({
	     *      dataset:"SamplesP@Interpolation",
	     *      power: 2,
	     *      searchMode: "KDTREE_FIXED_COUNT",
	     *      expectedCount: 12,
	     *      pixelFormat: "BIT16",
	     *      zValueFieldName: "AVG_TMP",
	     *      resolution: 3000,
	     *      filterQueryParameter: {
	     *          attributeFilter: ""
	     *      },
	     *      outputDatasetName: "myIDW"
	     * });
	     * (end)
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * power - {Number} 距离权重计算的幂次。
	     * bounds - {<SuperMap.Bounds>} 插值分析的范围，用于确定结果栅格数据集的范围。
	     * searchMode - {String} 插值运算时，查找参与运算点的方式，支持固定点数查找、定长查找。必设参数
	     * expectedCount - {Number} 【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数，默认值为12。
	     * searchRadius - {Number} 【定长查找】方式下，设置查找半径，即参与运算点的查找范围，与点数据集单位相同，默认值为0。
	     * zValueFieldName - {String} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     * zValueScale - {Number} 用于进行插值分析值的缩放比率，默认为1。
	     * resolution - {Number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
	     * filterQueryParameter - {<SuperMap.REST.FilterParameter>} 属性过滤条件。
	     * outputDatasetName - {String} 插值分析结果数据集的名称。必设参数
	     * outputDatasourceName - {String} 插值分析结果数据源的名称。必设参数
	     * pixelFormat - {String} 指定结果栅格数据集存储的像素格式。
	     * dataset - {String} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     * inputPoints - {Array <SuperMap.Geometry.Point>} 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时，必设参数。
	     */
	    initialize: function (options) {
	        InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
	        var me = this;
	        me.power = 2;
	        me.searchMode = null;
	        me.expectedCount = 12;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.power = null;
	        me.searchMode = null;
	        me.expectedCount = null;
	    },

	    CLASS_NAME: "InterpolationIDWAnalystParameters"
	});

	module.exports = function (options) {
	    return new InterpolationIDWAnalystParameters(options);
	};


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: SuperMap.REST.InterpolationKrigingAnalystParameter
	 * 克吕金插值分析参数类。 通过该类可以设置克吕金插值分析所需的参数。
	 *
	 * 克吕金（Kriging）法为地统计学上一种空间数据内插处理方法，主要的目的是利用各数据点间变异数（variance）的大小来推求某一未知点与各已知点的权重关系，再由各数据点的值和其与未知点的权重关系推求未知点的值。Kriging 法最大的特色不仅是提供一个最小估计误差的预测值，并且可明确的指出误差值的大小。一般而言，许多地质参数，如地形面，本身即具有连续性，故在一段距离内的任两点必有空间上的关系。反之，在一不规则面上的两点若相距甚远，则在统计意义上可视为互为独立 (stastically indepedent)。这种随距离而改变的空间上连续性，可用半变异图 (semivariogram) 来表现。
	 *
	 * 因此，若想由已知的散乱点来推求某一未知点的值，则可利用半变异图推求各已知点与未知点的空间关系，即以下四个参数。然后，由此空间参数推求半变异数，由各数据点间的半变异数可推求未知点与已知点间的权重关系，进而推求出未知点的值。
	 *
	 * · 块金值（nugget）：当采样点间距为0时，理论上半变异函数值为0，但时间上两采样点非常接近时半变异函数值并不为0，即产生了上图所示的块金效应，对应的半变异函数值为块金值。块金值可能由于测量误差或者空间变异产生。
	 *
	 * · 基台值（sill）：随着采样点间距的不断增大，半变异函数的值趋向一个稳定的常数，该常数成为基台值。到达基台值后，半变异函数的值不再随采样点间距而改变，即大于此间距的采样点不再具有空间相关性。
	 *
	 * · 偏基台值：基台值与块金值的差值。
	 *
	 * · 自相关阈值（range）：也称变程，是半变异函数值达到基台值时，采样点的间距。超过自相关阈值的采样点不再具有空间相关性，将不对预测结果产生影响。
	 *
	 * 由上述可知，半变异函数是克吕金插值的关键，因此选择合适的半变异函数模型非常重要，SuperMap提供了以下三种半变异函数模型：
	 *
	 * · 指数型（EXPONENTIAL）：适用于空间相关关系随样本间距的增加成指数递减的情况，其空间自相关关系在样本间距的无穷远处完全消失。
	 *
	 * · 球型（SPHERICAL）：适用于空间自相关关系随样本间距的增加而逐渐减少，直到超出一定的距离时空间自相关关系消失的情况。
	 *
	 * · 高斯型（GAUSSIAN）：适用于半变异函数值渐进地逼近基台值的情况。
	 *
	 * 半变异函数中，有一个关键参数即插值的字段值的期望（平均值），由于对于此参数的不同处理方法而衍生出了不同的Kriging方法。SuperMap的差值功能基于以下三种常用Kriging算法：
	 *
	 * １.　简单克吕金（Simple Kriging）：该方法假定用于插值的字段值的期望（平均值）已知的某一常数。
	 *
	 * ２.　普通克吕金（Kriging）：该方法假定用于插值的字段值的期望（平均值）未知且恒定。它利用一定的数学函数，通过对给定的空间点进行拟合来估算单元格的值，生成格网数据集。它不仅可以生成一个表面，还可以给出预测结果的精度或者确定性的度量。因此，此方法计算精度较高，常用于地学领域。
	 *
	 * ３.　泛克吕金（Universal Kriging）：该方法假定用于插值的字段值的期望（平均值）是未知的变量。在样点数据中存在某种主导趋势且该趋势可以通过某一个确定的函数或者多项式进行拟合的情况下，适用泛克吕金插值法。
	 *
	 * 克吕金法的优点是以空间统计学作为其坚实的理论基础，物理含义明确；不但能估计测定参数的空间变异分布，而且还可以估算参数的方差分布。克吕金法的缺点是计算步骤较烦琐，计算量大，且变异函数有时需要根据经验人为选定。
	 *
	 *
	 * Inherits from:
	 *  - <InterpolationAnalystParameters>
	 */
	__webpack_require__(4);
	__webpack_require__(168);
	__webpack_require__(170);

	InterpolationKrigingAnalystParameters = SuperMap.Class(InterpolationAnalystParameters, {
	    /**
	     * APIProperty: type
	     * {<SuperMap.REST.InterpolationAlgorithmType>} 克吕金插值的类型。必设参数
	     * 具体如下：
	     * {KRIGING} 普通克吕金插值法
	     * {SimpleKriging} 简单克吕金插值法
	     * {UniversalKriging} 泛克吕金插值法
	     */
	    type: null,

	    /**
	     * APIProperty: mean
	     * {Number} 【简单克吕金】方式下，插值字段的平均值。
	     * 即采样点插值字段值总和除以采样点数目。
	     */
	    mean: null,

	    /**
	     * APIProperty: angle
	     * {Number} 克吕金算法中旋转角度值。默认值为0。
	     * 此角度值指示了每个查找邻域相对于水平方向逆时针旋转的角度。
	     */
	    angle: 0,

	    /**
	     * APIProperty: nugget
	     * {Number} 克吕金算法中块金效应值。默认值为0。
	     */
	    nugget: 0,

	    /**
	     * APIProperty: range
	     * {Number} 克吕金算法中自相关阈值，单位与原数据集单位相同。默认值为0。
	     */
	    range: 0,

	    /**
	     * APIProperty: sill
	     * {Number} 克吕金算法中基台值。默认值为0。
	     */
	    sill: 0,

	    /**
	     * APIProperty: variogramMode
	     * {<SuperMap.REST.VariogramMode>} 克吕金插值时的半变函数类型.
	     * 默认值为 SuperMap.REST.VariogramMode.SPHERICAL。
	     * 用户所选择的半变函数类型会影响未知点的预测，特别是曲线在原点处的不同形状有重要意义。
	     * 曲线在原点处越陡，则较近领域对该预测值的影响就越大，因此输出表面就会越不光滑。
	     */
	    variogramMode: SuperMap.REST.VariogramMode.SPHERICAL,

	    /**
	     * APIProperty: exponent
	     * {<SuperMap.REST.Exponent>} 【泛克吕金】类型下，用于插值的样点数据中趋势面方程的阶数。
	     * 默认值为 SuperMap.REST.Exponent.EXP1。
	     */
	    exponent: SuperMap.REST.Exponent.EXP1,

	    /**
	     * APIProperty: searchMode
	     * {<SuperMap.REST.SearchMode>} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数
	     * 简单克吕金和泛克吕金不支持块查找。
	     * 具体如下：
	     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
	     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
	     * {QUADTREE} 使用 QUADTREE 方式查找参与内插分析的点（块查找）。
	     */
	    searchMode: null,

	    /**
	     * APIProperty: expectedCount
	     * {Number}
	     * 【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数，默认值为12。
	     * 【定长查找】方式下，设置查找的最小点数，默认值为12
	     */
	    expectedCount: 12,

	    /**
	     * APIProperty: maxPointCountForInterpolation
	     * {Number} 【块查找】方式下，最多参与插值的点数。默认值为200。
	     * 仅用于普通克吕金插值，简单克吕金和泛克吕金不支持块查找。
	     */
	    maxPointCountForInterpolation: 200,

	    /**
	     * APIProperty: maxPointCountInNode
	     * {Number} 【块查找】方式下，设置单个块内最多参与运算点数。默认值为50。
	     * 仅用于普通克吕金插值，简单克吕金和泛克吕金不支持块查找。
	     */
	    maxPointCountInNode: 50,

	    /**
	     * Constructor: InterpolationKrigingAnalystParameters
	     * 克吕金插值分析参数类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myInterpolationKrigingAnalystParameters = new InterpolationKrigingAnalystParameters({
	     *     dataset:"SamplesP@Interpolation",
	     *     type: "KRIGING",
	     *     angle: 0,
	     *     mean: 5,
	     *     nugget: 30,
	     *     range: 50,
	     *     sill: 300,
	     *     variogramMode: "EXPONENTIAL",
	     *     searchMode: "QUADTREE",
	     *     maxPointCountForInterpolation: 20,
	     *     maxPointCountInNode: 5,
	     *     pixelFormat: "BIT16",
	     *     zValueFieldName: "AVG_TMP",
	     *     resolution: 30000,
	     *     filterQueryParameter: {
	     *         attributeFilter: ""
	     *     },
	     *     outputDatasetName: "myKriging"
	     * });
	     * (end)
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * type - {String} 克吕金插值的类型。必设参数。
	     * mean - {Number} 【简单克吕金】类型下,插值字段的平均值。
	     * angle - {Number} 克吕金算法中旋转角度值，默认值为0。
	     * nugget - {Number} 克吕金算法中块金效应值，默认值为0。
	     * range - {Number} 克吕金算法中自相关阈值，单位与原数据集单位相同，默认值为0。
	     * sill - {Number} 克吕金算法中基台值，默认值为0。
	     * variogramMode - {String} 克吕金插值时的半变函数类型，默认为球型（SPHERICAL）。
	     * exponent - {String} 【泛克吕金】类型下，用于插值的样点数据中趋势面方程的阶数，可选值为exp1、exp2，默认值为exp1。
	     * bounds - {<SuperMap.Bounds>} 插值分析的范围，用于确定结果栅格数据集的范围。
	     * searchMode - {String} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找，必设参数。
	     * expectedCount - {Number} 【固定点数查找】方式下，设置待查找的点数，默认值为12；【定长查找】方式下，设置查找的最小点数，默认值为12。
	     * searchRadius - {Number} 【定长查找】方式下，设置参与运算点的查找范围，默认值为0。
	     * maxPointCountForInterpolation - {Number} 【块查找】方式下，设置最多参与插值的点数，默认值为200。
	     * maxPointCountInNode - {Number} 【块查找】方式下，设置单个块内最多参与运算点数，默认值为50。
	     * zValueFieldName - {String} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     * zValueScale - {Number} 用于进行插值分析值的缩放比率，默认值为1。
	     * resolution - {Number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
	     * filterQueryParameter - {<SuperMap.REST.FilterParameter>} 属性过滤条件。
	     * outputDatasetName - {String} 插值分析结果数据集的名称，必设参数。
	     * outputDatasourceName - {String} 插值分析结果数据源的名称。必设参数
	     * pixelFormat - {String} 指定结果栅格数据集存储的像素格式。
	     * dataset - {String} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
	     * inputPoints - {Array <SuperMap.Geometry.Point>} 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时，必设参数。
	     */
	    initialize: function (options) {
	        InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
	        var me = this;
	        me.type = null;
	        me.mean = null;
	        me.angle = 0;
	        me.nugget = 0;
	        me.range = 0;
	        me.sill = 0;
	        me.variogramMode = "SPHERICAL";
	        me.exponent = "EXP1";
	        me.searchMode = null;
	        me.expectedCount = 12;
	        me.maxPointCountForInterpolation = 200;
	        me.maxPointCountInNode = 50;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.type = null;
	        me.mean = null;
	        me.angle = null;
	        me.nugget = null;
	        me.range = null;
	        me.sill = null;
	        me.variogramMode = null;
	        me.exponent = null;
	        me.searchMode = null;
	        me.expectedCount = null;
	        me.maxPointCountForInterpolation = null;
	        me.maxPointCountInNode = null;
	    },

	    CLASS_NAME: "InterpolationKrigingAnalystParameters"
	});

	module.exports = function (options) {
	    return new InterpolationKrigingAnalystParameters(options);
	};

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.MathExpressionAnalysisService
	 *  栅格代数运算服务类。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(174);
	SuperMap.REST.MathExpressionAnalysisService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Constructor: SuperMap.REST.MathExpressionAnalysisService
	     * 核栅格代数运算服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myMathExpressionAnalysisService = new SuperMap.REST.MathExpressionAnalysisService(url);
	     * myMathExpressionAnalysisService.on({
	     *     "processCompleted": processCompleted,
	     *     "processFailed": processFailed
	     *     }
	     * );
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<MathExpressionAnalysisParameters>}
	     */
	    processAsync: function (parameter) {
	        var me = this;

	        var end = me.url.substr(me.url.length - 1, 1);
	        if (end === '/') {

	        } else {
	            me.url += "/";
	        }

	        var parameterObject = new Object();

	        if (parameter instanceof MathExpressionAnalysisParameters) {
	            me.url += 'datasets/' + parameter.dataset + '/mathanalyst';
	        }

	        MathExpressionAnalysisParameters.toObject(parameter, parameterObject);
	        var jsonParameters = SuperMap.Util.toJSON(parameterObject);

	        if (me.isInTheSameDomain) {
	            me.url += '.json?returnContent=true';
	        } else {
	            me.url += '.jsonp?returnContent=true';
	        }

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.MathExpressionAnalysisService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.MathExpressionAnalysisService(url, options);
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: MathExpressionAnalysisParameters
	 * 栅格代数运算参数类
	 *
	 */
	MathExpressionAnalysisParameters = SuperMap.Class({

	    /**
	     * APIProperty: dataset
	     * {String} 要用来做栅格代数运算数据源中数据集的名称。
	     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。必设字段。
	     *
	     */
	    dataset: null,

	    /**
	     * APIProperty: extractRegion
	     * {<SuperMap.Geometry.Ploygon>} 栅格代数运算的范围，指定数据集中参与栅格代数运算的区域。
	     * 如果缺省，则计算全部区域，如果参与运算的数据集范围不一致，将使用所有数据集的范围的交集作为计算区域 。
	     */
	    extractRegion: null,

	    /**
	     * APIProperty: expression
	     * {String} 指定的栅格运算表达式。如："[DatasourceAlias1.Raster1]*2-10"；必设字段。
	     */
	    expression: null,

	    /**
	     * APIProperty: isZip
	     * {Boolean} 是否对结果数据集进行压缩处理。默认为False，表示不压缩。
	     */
	    isZip: false,

	    /**
	     * APIProperty: ignoreNoValue
	     * {Boolean} 是否忽略无值栅格数据，默认为true。
	     */
	    ignoreNoValue: false,

	    /**
	     * APIProperty: targetDatasource
	     * {String}  指定存储结果数据集的数据源，必设字段。
	     */
	    targetDatasource: null,

	    /**
	     * APIProperty: resultGridName
	     * {String} 指定结果数据集名称，必设字段。
	     */
	    resultGridName: null,

	    /**
	     * APIProperty: deleteExistResultDataset
	     * {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
	     */
	    deleteExistResultDataset: false,

	    /**
	     * Constructor: MathExpressionAnalysisParameters
	     * 栅格代数运算参数构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * dataset - {String} 要用来做栅格代数运算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：BaseMap_P@Jingjin。必设字段。
	     * extractRegion - {<SuperMap.Geometry.Ploygon>} 栅格代数运算的范围，指定数据集中参与栅格代数运算的区域。 如果缺省，则计算全部区域，如果参与运算的数据集范围不一致，将使用所有数据集的范围的交集作为计算区域 。
	     * expression - {String} 指定的栅格运算表达式。如：[DatasourceAlias1.Raster1]*2-10；必设字段。
	     * isZip - {Boolean} 是否对结果数据集进行压缩处理。默认为 false，表示不压缩。
	     * ignoreNoValue - {Boolean} 是否忽略无值栅格数据。true 表示忽略无值数据，即无值栅格不参与运算。默认为 false。
	     * targetDatasource - {String} 指定存储结果数据集的数据源，必设字段。
	     * resultGridName - {Number} 指定结果数据集名称，必设字段。
	     * deleteExistResultDataset - {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.dataset = null;
	        me.bounds = null;
	        me.expression = null;
	        me.isZip = true;
	        me.ignoreNoValue = true;
	        me.targetDatasource = null;
	        me.resultGridName = null;
	        me.deleteExistResultDataset = null;
	    },

	    CLASS_NAME: "MathExpressionAnalysisParameters"
	});

	MathExpressionAnalysisParameters.toObject = function (mathExpressionAnalysisParameters, tempObj) {
	    for (var name in mathExpressionAnalysisParameters) {
	        if (name !== "dataset") {
	            tempObj[name] = mathExpressionAnalysisParameters[name];
	        }

	        if (name === "extractRegion") {
	            if (mathExpressionAnalysisParameters[name]) {
	                var bs = mathExpressionAnalysisParameters[name].components[0].components;
	                var region = {},
	                    points = [],
	                    type = "REGION";

	                var len = bs.length;
	                for (var i = 0; i < len - 1; i++) {
	                    var poi = {};
	                    poi["x"] = bs[i].x;
	                    poi["y"] = bs[i].y;
	                    points.push(poi);
	                }
	                ;

	                region["points"] = points;
	                region["type"] = type;

	                tempObj[name] = region;
	            }
	        }
	    }
	};

	module.exports = function (options) {
	    return new MathExpressionAnalysisParameters(options);
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.OverlayAnalystService
	 * 叠加分析服务类
	 * 该类负责将客户设置的叠加分析参数传递给服务端，并接收服务端返回的叠加分析结果数据。
	 * 叠加分析结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(176);
	__webpack_require__(178);
	SuperMap.REST.OverlayAnalystService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Property: mode
	     * {<String>} 叠加分析类型
	     */
	    mode: null,

	    /**
	     * Constructor: SuperMap.REST.OverlayAnalystService
	     * 查询叠加分析服务基类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myOverlayAnalystService = new SuperMap.REST.OverlayAnalystService(url, {
	     *     eventListeners: {
	     *	       "processCompleted": OverlayCompleted, 
	     *		   "processFailed": OverlayFailed
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	        var me = this;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	        this.mode = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<SuperMap.REST.OverlayAnalystParameters>}
	     */
	    processAsync: function (parameter) {
	        var parameterObject = new Object();
	        var me = this;

	        var end = me.url.substr(me.url.length - 1, 1);
	        if (end === '/') {

	        } else {
	            me.url += "/";
	        }

	        if (parameter instanceof DatasetOverlayAnalystParameters) {
	            me.mode = "datasets";
	            me.url += 'datasets/' + parameter.sourceDataset + '/overlay';
	            DatasetOverlayAnalystParameters.toObject(parameter, parameterObject);
	        }
	        else if (parameter instanceof GeometryOverlayAnalystParameters) {
	            me.mode = "geometry";
	            me.url += 'geometry/overlay';
	            GeometryOverlayAnalystParameters.toObject(parameter, parameterObject);
	        }

	        var jsonParameters = SuperMap.Util.toJSON(parameterObject);

	        if (me.isInTheSameDomain) {
	            me.url += '.json?returnContent=true';
	        } else {
	            me.url += '.jsonp?returnContent=true';
	        }

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.OverlayAnalystService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.OverlayAnalystService(url, options);
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(155);
	__webpack_require__(177);

	/**
	 * Class: DatasetOverlayAnalystParameters
	 * 数据集叠加分析参数类
	 *
	 * Inherits from:
	 *  - <OverlayAnalystParameters>
	 */
	DatasetOverlayAnalystParameters = SuperMap.Class(OverlayAnalystParameters, {

	    /**
	     * APIProperty: operateDataset
	     * {String} 叠加分析中操作数据集的名称。
	     */
	    operateDataset: null,

	    /**
	     * APIProperty: operateDatasetFields
	     * {Array(String} 叠加分析中操作数据集保留在结果数据集中的字段名列表。
	     */
	    operateDatasetFields: null,

	    /**
	     * APIProperty: operateDatasetFilter
	     * {<SuperMap.REST.FilterParameter>} 设置操作数据集中空间对象过滤条件。
	     */
	    operateDatasetFilter: null,

	    /**
	     * APIProperty: operateRegions
	     * {Array(<SuperMap.Geometry>)}操作面对象集合，表示与这些面对象进行叠加分析。
	     * 与 operateDataset 参数互斥，冲突时以operateDataset 为准。
	     */
	    operateRegions: null,


	    /**
	     * APIProperty: sourceDataset
	     * {String} 叠加分析中源数据集的名称。必设字段。
	     */
	    sourceDataset: null,


	    /**
	     * APIProperty: sourceDatasetFields
	     * {Array(String} 叠加分析中源数据集保留在结果数据集中的字段名列表。
	     */
	    sourceDatasetFields: null,


	    /**
	     * APIProperty: filterQueryParameter
	     * {<SuperMap.REST.FilterParameter>} 设置源数据集中空间对象过滤条件。
	     */
	    sourceDatasetFilter: null,


	    /**
	     * APIProperty: tolerance
	     * {Integer} 容限。
	     */
	    tolerance: 0,

	    /**
	     * APIProperty: resultSetting
	     * {<DataReturnOption>} 结果返回设置类。
	     */
	    resultSetting: null,

	    /**
	     * Constructor: DatasetOverlayAnalystParameters
	     * 数据集叠加分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * operateDataset - {String} 叠加分析中操作数据集的名称。必设字段。
	     * operateDatasetFields - {Array(String} 叠加分析中操作数据集保留在结果数据集中的字段名列表。
	     * operateDatasetFilter - {<SuperMap.REST.FilterParameter>} 设置操作数据集中空间对象过滤条件。
	     * operateRegions - {Array(<SuperMap.Geometry>)} 操作区域。设置了操作区域后，仅对该区域内的对象进行分析。
	     * sourceDataset - {String} 叠加分析中源数据集的名称。必设字段。
	     * sourceDatasetFields - {Array(String} 叠加分析中源数据集保留在结果数据集中的字段名列表。
	     * sourceDatasetFilter - {<SuperMap.REST.FilterParameter>} 设置源数据集中空间对象过滤条件。
	     * tolerance - {Integer} 容限。
	     * operation - {<SuperMap.REST.OverlayOperationType>} 叠加操作枚举值。
	     * resultSetting - {<DataReturnOption>} 结果返回设置类。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.operateDatasetFields = new Array();
	        me.operateDatasetFilter = new SuperMap.REST.FilterParameter();
	        me.operateRegions = new Array();
	        me.sourceDatasetFields = new Array();
	        me.sourceDatasetFilter = new SuperMap.REST.FilterParameter();
	        me.resultSetting = new DataReturnOption();

	        OverlayAnalystParameters.prototype.initialize.apply(this, arguments);
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        OverlayAnalystParameters.prototype.destroy.apply(this, arguments);

	        var me = this;
	        me.operateDataset = null;
	        me.operateDatasetFields = null;
	        if (me.operateDatasetFilter) {
	            me.operateDatasetFilter.destroy();
	            me.operateDatasetFilter = null;
	        }
	        if (me.operateRegions) {
	            for (var i = 0, opRegions = me.operateRegions, len = opRegions.length; i < len; i++) {
	                opRegions[i].destroy();
	            }
	            me.operateRegions = null;
	        }
	        me.sourceDataset = null;
	        me.sourceDatasetFields = null;
	        if (me.sourceDatasetFilter) {
	            me.sourceDatasetFilter.destroy();
	            me.sourceDatasetFilter = null;
	        }
	        me.tolerance = null;
	        if (me.resultSetting) {
	            me.resultSetting.destroy();
	            me.resultSetting = null;
	        }
	    },

	    CLASS_NAME: "DatasetOverlayAnalystParameters"
	});

	DatasetOverlayAnalystParameters.toObject = function (datasetOverlayAnalystParameters, tempObj) {
	    for (var name in datasetOverlayAnalystParameters) {
	        if (name === "sourceDataset") {
	        }
	        else if (name === "operateRegions") {
	            tempObj.operateRegions = new Array();
	            var ors = datasetOverlayAnalystParameters.operateRegions;
	            for (var index in ors) {
	                if (ors.hasOwnProperty(index)) {    //icl542
	                    tempObj.operateRegions[index] = SuperMap.REST.ServerGeometry.fromGeometry(ors[index]);
	                }
	            }
	        }
	        else if (name === "resultSetting") {
	            tempObj.dataReturnOption = datasetOverlayAnalystParameters.resultSetting;
	        }
	        else {
	            tempObj[name] = datasetOverlayAnalystParameters[name];
	        }
	    }
	};

	module.exports = function (options) {
	    return new DatasetOverlayAnalystParameters(options);
	};

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: OverlayAnalystParameters
	 * 叠加分析参数基类，数据集叠加分析参数和几何对象叠加分析参数均继承此基类
	 */
	OverlayAnalystParameters = SuperMap.Class({

	    /**
	     * Property: operation
	     * {<SuperMap.REST.OverlayOperationType>}
	     */
	    operation: SuperMap.REST.OverlayOperationType.UNION,

	    /**
	     * Constructor: OverlayAnalystParameters
	     * 叠加分析参数基类构造函数构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * operation - {<SuperMap.REST.OverlayOperationType>} 指定叠加分析操作类型。
	     */
	    initialize: function (options) {
	        var me = this;
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.operation = null;
	    },

	    CLASS_NAME: "OverlayAnalystParameters"
	});

	module.exports = function (options) {
	    return new OverlayAnalystParameters(options);
	};

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(177);
	/**
	 * Class: GeometryOverlayAnalystParameters
	 * 几何对象叠加分析参数类
	 * 对指定的某两个几何对象做叠加分析。通过该类可以指定要做叠加分析的几何对象、叠加操作类型。
	 *
	 * Inherits from:
	 *  - <OverlayAnalystParameters>
	 */
	GeometryOverlayAnalystParameters = SuperMap.Class(OverlayAnalystParameters, {

	    /**
	     * Property: operateGeometry
	     * {SuperMap.Geometry} 叠加分析的操作几何对象。必设字段。
	     */
	    operateGeometry: null,

	    /**
	     * Property: sourceGeometry
	     * {SuperMap.Geometry} 叠加分析的源几何对象。必设字段。
	     */
	    sourceGeometry: null,

	    /**
	     * Constructor: GeometryOverlayAnalystParameters
	     * 几何对象叠加分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * operateGeometry - {SuperMap.Geometry} 叠加分析的操作几何对象。必设字段。
	     * sourceGeometry - {SuperMap.Geometry} 叠加分析的源几何对象。必设字段。
	     * operation - {<SuperMap.REST.OverlayOperationType>} 叠加操作枚举值。
	     */
	    initialize: function (options) {
	        OverlayAnalystParameters.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        OverlayAnalystParameters.prototype.destroy.apply(this, arguments);

	        var me = this;
	        if (me.sourceGeometry) {
	            me.sourceGeometry.destroy();
	            me.sourceGeometry = null;
	        }

	        if (me.operateGeometry) {
	            me.operateGeometry.destroy();
	            me.operateGeometry = null;
	        }
	    },

	    CLASS_NAME: "GeometryOverlayAnalystParameters"
	});

	GeometryOverlayAnalystParameters.toObject = function (geometryOverlayAnalystParameters, tempObj) {
	    for (var name in geometryOverlayAnalystParameters) {
	        if (name === "sourceGeometry") {
	            tempObj.sourceGeometry = SuperMap.REST.ServerGeometry.fromGeometry(geometryOverlayAnalystParameters.sourceGeometry);
	        }
	        else if (name === "operateGeometry") {
	            tempObj.operateGeometry = SuperMap.REST.ServerGeometry.fromGeometry(geometryOverlayAnalystParameters.operateGeometry);
	        }
	        else {
	            tempObj[name] = geometryOverlayAnalystParameters[name];
	        }
	    }
	};

	module.exports = function (options) {
	    return new GeometryOverlayAnalystParameters(options);
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.RouteCalculateMeasureService
	 * 该类负责将客户设置的计算指定点的M值参数传递给服务端，并接收服务端返回的
	 *      指定点的M值。通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(180);
	SuperMap.REST.RouteCalculateMeasureService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Constructor: SuperMap.REST.RouteCalculateMeasureService
	     * 计算指定点的M值服务类构造函数。
	     *
	     * 实例化该类如下例所示：
	     * (start code)
	     * var parameters = new RouteCalculateMeasureParameters({
	     *     "sourceRoute":{
	     *         "type":"LINEM",
	     *        "parts":[4],
	     *         "points":[
	     *             {
	     *                 "measure":0,
	     *                 "y":-6674.466867067764,
	     *                 "x":3817.3527876130133
	     *             },
	     *             {
	     *                 "measure":199.57954019411724,
	     *                 "y":-6670.830929417594,
	     *                 "x":3617.806369901496
	     *             },
	     *             {
	     *                 "measure":609.3656478634477,
	     *                "y":-6877.837541432356,
	     *                 "x":3264.1498746678444
	     *             },
	     *             {
	     *                 "measure":936.0174126282958,
	     *                 "y":-7038.687780615184,
	     *                 "x":2979.846206068903
	     *             }
	     *         ]
	     *     },
	     *     "tolerance":1,
	     *     "point":{
	     *         "x":3330.7754269417,
	     *         "y":-6838.8394457216
	     *     },
	     *     "isIgnoreGap":false
	     * });
	     *
	     * var routeCalculateMeasureService = new SuperMap.REST.RouteCalculateMeasureService(spatialAnalystURL, {
	     *     eventListeners:{
	     *         processCompleted:calculateCompleted,
	     *         processFailed:calculateFailded
	     *     }
	     * );
	     * routeCalculateMeasureService.processAsync(parameters);
	     *
	     *  //执行
	     * function calculateCompleted(){todo}
	     * function calculateFailded(){todo}
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的基于路由对象计算指定点M值操作的参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<RouteCalculateMeasureParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonParameters;

	        jsonParameters = me.getJsonParameters(params);

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJsonParameters
	     * 将参数转化为 JSON 字符串。
	     *
	     * Parameters:
	     * params - {<RouteCalculateMeasureParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJsonParameters: function (params) {
	        var jsonParameters, jsonStr = "geometry/calculatemeasure", me = this, end;
	        end = me.url.substr(me.url.length - 1, 1);
	        if (me.isInTheSameDomain) {
	            me.url += (end === "/") ? jsonStr + ".json" : "/" + jsonStr + ".json";
	        } else {
	            me.url += (end === "/") ? jsonStr + ".jsonp" : "/" + jsonStr + ".jsonp";
	        }

	        me.url += "?returnContent=true";
	        jsonParameters = SuperMap.Util.toJSON(params);
	        return jsonParameters;
	    },

	    CLASS_NAME: "SuperMap.REST.RouteCalculateMeasureService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.RouteCalculateMeasureService(url, options);
	};

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: RouteCalculateMeasureParameters
	 * 基于路由对象计算指定点M值操作的参数类。通过该类提供参数信息。
	 */
	RouteCalculateMeasureParameters = SuperMap.Class({

	    /**
	     * APIProperty: sourceRoute
	     * {<SuperMap.REST.Route>} 【必选参数】路由对象。该对象可以是用户自己生
	     *      成或在数据源中查询得到的符合标准的路由对象；
	     */
	    sourceRoute: null,

	    /**
	     * APIProperty: point
	     * {Object} 【必选参数】二维地理坐标点对象，包含x,y坐标值属性的对象。
	     */
	    point: null,

	    /**
	     * APIProperty: tolerance
	     * {Double} 【可选参数】容限值。
	     */
	    tolerance: null,

	    /**
	     * APIProperty: isIgnoreGap
	     * {Boolean} 【可选参数】是否忽略子对象之间的距离。默认为false，即不忽略子
	     *      对象之间的距离。
	     */
	    isIgnoreGap: false,

	    /**
	     * Constructor: RouteCalculateMeasureParameters
	     * 基于路由对象计算指定点M值操作的参数类的构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * sourceRoute - {Object} 【必选参数】路由对象。该对象可以是用户自己生成或在
	     *      数据源中查询得到的符合标准的路由对象。
	     * point - {Object} 【必选参数】二维地理坐标点对象，包含x,y坐标值属性的对象。
	     * tolerance - {Double} 【可选参数】容限值。
	     * isIgnoreGap - {Double}  【可选参数】是否忽略子对象之间的距离。默认
	     *      为false，即不忽略子对象之间的距离。
	     *
	     */
	    initialize: function (options) {
	        if (options) {
	            var routeFromClient = options.sourceRoute;
	            var routeHandle = {};
	            if (routeFromClient) {
	                if (routeFromClient instanceof SuperMap.Geometry && routeFromClient.components) {
	                    routeHandle.type = routeFromClient.type;
	                    routeHandle.parts = routeFromClient.parts;
	                    var parts = [];
	                    for (var i = 0, len = routeFromClient.components.length; i < len; i++) {
	                        parts = parts.concat(routeFromClient.components[i].components);
	                    }
	                    routeHandle.points = parts;
	                    options.sourceRoute = routeHandle;
	                }
	            }
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.sourceRoute = null;
	        me.point = null;
	        if (me.tolerance) {
	            me.tolerance = null;
	        }
	        if (me.isIgnoreGap) {
	            me.isIgnoreGap = false;
	        }
	    },

	    CLASS_NAME: "RouteCalculateMeasureParameters"
	});

	module.exports = function (options) {
	    return new RouteCalculateMeasureParameters(options);
	};

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.RouteLocatorService
	 * 路由对象定位空间对象的服务类。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(182);
	SuperMap.REST.RouteLocatorService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Constructor: SuperMap.REST.RouteLocatorService
	     * 路由对象定位空间对象的服务类构造函数。
	     *
	     * 实例化该类如下例所示：
	     * (start code)
	     * var routeLocatorParameters_point = new RouteLocatorParameters({
	     *   "sourceRoute":{
	     *       "type":"LINEM",
	     *       "parts":[4],
	     *       "points":[
	     *           {
	     *               "measure":0,
	     *               "y":-6674.466867067764,
	     *               "x":3817.3527876130133
	     *           },
	     *           {
	     *               "measure":199.57954019411724,
	     *               "y":-6670.830929417594,
	     *               "x":3617.806369901496
	     *          },
	     *           {
	     *               "measure":609.3656478634477,
	     *               "y":-6877.837541432356,
	     *               "x":3264.1498746678444
	     *           },
	     *           {
	     *               "measure":936.0174126282958,
	     *               "y":-7038.687780615184,
	     *               "x":2979.846206068903
	     *           }
	     *       ]
	     *   },
	     *   "type":"POINT",
	     *   "measure":10,
	     *   "offset":3,
	     *   "isIgnoreGap":true
	     * });
	     * var routeLocatorService = new SuperMap.REST.RouteLocatorService(spatialAnalystURL, {
	     *     eventListeners:{
	     *         processCompleted:routeLocatorCompleted,
	     *         processFailed:routeLocatorFailded
	     *     }
	     * );
	     * routeLocatorService.processAsync(routeLocatorParameters_point);
	     *
	     *  //执行
	     * function routeLocatorCompleted(){todo}
	     * function routeLocatorFailded(){todo}
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     *
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的基于路由对象计算指定点M值操作的参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<RouteLocatorParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonParameters;

	        jsonParameters = me.getJsonParameters(params);

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJsonParameters
	     * 将参数转化为 JSON 字符串。
	     *
	     * Parameters:
	     * params - {<RouteLocatorParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJsonParameters: function (params) {
	        var jsonParameters, jsonStr = "geometry/routelocator", me = this, end;
	        end = me.url.substr(me.url.length - 1, 1);

	        if (params.dataset) {
	            jsonStr = "datasets/" + params.dataset + "/linearreferencing/routelocator";
	            params.sourceRoute = null;
	        }
	        if (me.isInTheSameDomain) {
	            me.url += (end === "/") ? jsonStr + ".json" : "/" + jsonStr + ".json";
	        } else {
	            me.url += (end === "/") ? jsonStr + ".jsonp" : "/" + jsonStr + ".jsonp";
	        }

	        me.url += "?returnContent=true";
	        jsonParameters = SuperMap.Util.toJSON(params);
	        return jsonParameters;
	    },

	    CLASS_NAME: "SuperMap.REST.RouteLocatorService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.RouteLocatorService(url, options);
	};

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: RouteLocatorParameters
	 * 路由对象定位空间对象的参数类。
	 * 参数有两种方式，分别为Geometry和Dataset两种，前者需要指定sourceRoute对象作为参数，后者需要dataset，routeIDField，routeID三个参数
	 * 如果用户两种参数均设置，优先选择Dataset方式
	 */
	RouteLocatorParameters = SuperMap.Class({

	    /**
	     * APIProperty:sourceRoute
	     * {<SuperMap.REST.Route>} 路由对象。
	     */
	    sourceRoute: null,

	    /**
	     * APIProperty: dataset
	     * {String} 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
	     */
	    dataset: null,

	    /**
	     * APIProperty：routeIDField
	     * {String}  路由对象所在的字段名称。
	     *
	     */
	    routeIDField: null,

	    /**
	     * APIProperty:routeID
	     * {Interger}  路由对象标识 。
	     *
	     */
	    routeID: null,

	    /**
	     * APIProperty:type
	     * {String} 【必选参数】类型：点 or 线。
	     *
	     * 可选值为:
	     * LINE :根据起始 M 值及终止 M 值定位线对象。
	     *POINT : 根据 M 值定位点对象。
	     */
	    type: null,

	    /**
	     * APIProperty:measure
	     * {Double} 【必选参数】定位点的M值。只当路由对象定位点时有意义。
	     */
	    measure: null,

	    /**
	     * APIProperty：offset
	     * {Double} 定位点偏移量。只当路由对象定位点时有意义，默认为0。
	     */
	    offset: 0,

	    /**
	     * APIProperty:isIgnoreGap
	     * {Boolean} 是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。
	     */
	    isIgnoreGap: false,

	    /**
	     * APIProperty:startMeasure
	     * {Double} 定位线的起始M值。只当路由对象定位线时有意义。
	     */
	    startMeasure: null,

	    /**
	     * APIProperty:endMeasure
	     * {Double} 定位线的终止M值。只当路由对象定位线时有意义。
	     */
	    endMeasure: null,


	    /**
	     * Constructor: RouteLocatorParameters
	     * 路由对象定位空间对象的参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * sourceRoute -  {<SuperMap.REST.Route>} 【必选参数】路由对象。
	     * type -  {String} 【必选参数】类型：点 or 线。
	     * measure - {Double} 【必选参数】定位点的M值。只当路由对象定位点时有意义。
	     * offset - {Double} 定位点偏移量。只当路由对象定位点时有意义，默认为0。
	     * isIgnoreGap - {Boolean} 是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。
	     * startMeasure - {Double} 定位线的起始M值。只当路由对象定位线时有意义。
	     * endMeasure -  {Double} 定位线的终止M值。只当路由对象定位线时有意义。
	     */
	    initialize: function (options) {
	        if (options) {
	            var routeFromClient = options.sourceRoute;
	            var routeHandle = {};
	            if (routeFromClient) {
	                if (routeFromClient instanceof SuperMap.Geometry && routeFromClient.components) {
	                    routeHandle.type = routeFromClient.type;
	                    routeHandle.parts = routeFromClient.parts;
	                    var parts = [];
	                    for (var i = 0, len = routeFromClient.components.length; i < len; i++) {
	                        parts = parts.concat(routeFromClient.components[i].components);
	                    }
	                    routeHandle.points = parts;
	                    options.sourceRoute = routeHandle;
	                }
	            }
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.sourceRoute = null;
	        me.type = null;
	        me.measure = null;
	        me.offset = 0;
	        me.isIgnoreGap = false;
	        me.startMeasure = null;
	        me.endMeasure = null;
	        me.dataset = null;
	        me.routeID = null;
	        me.routeIDField = null;
	    },

	    CLASS_NAME: "RouteLocatorParameters"
	});

	module.exports = function (options) {
	    return new RouteLocatorParameters(options);
	};

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.SurfaceAnalystService
	 * 表面分析服务类。
	 * 该类负责将客户设置的表面分析服务参数传递给服务端，并接收服务端返回的表面分析服务分析结果数据。
	 * 表面分析结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(184);
	__webpack_require__(187);
	SuperMap.REST.SurfaceAnalystService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Constructor: SuperMap.REST.SurfaceAnalystService
	     * 表面分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var mySurfaceAnalystService = new SuperMap.REST.SurfaceAnalystService(url, {
	     *      eventListeners: {
	     *	       "processCompleted": surfaceAnalysCompleted, 
	     *		   "processFailed": surfaceAnalysFailed
	     *		   }
	     * });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用的资源属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的表面分析服务参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<SuperMap.REST.SurfaceAnalystParameters>}
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, jsonParameters;
	        jsonParameters = me.getJsonParameters(params);
	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    /**
	     * Method: getJsonParameters
	     * 将参数转化为 JSON 字符串。
	     *
	     * Parameters:
	     * params - {<SuperMap.REST.SurfaceAnalystParameters>}
	     *
	     * Returns:
	     * {Object} 转化后的JSON字符串。
	     */
	    getJsonParameters: function (params) {
	        var jsonParameters = "";
	        var me = this, end;
	        if (params instanceof DatasetSurfaceAnalystParameters) {
	            var end = me.url.substr(me.url.length - 1, 1);

	            if (me.isInTheSameDomain) {
	                me.url += (end === "/") ? "datasets/" + params.dataset + "/" + params.surfaceAnalystMethod.toLowerCase() +
	                ".json?returnContent=true" : "/datasets/" + params.dataset + "/" +
	                params.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true";
	            } else {
	                me.url += (end === "/") ? "datasets/" + params.dataset + "/" + params.surfaceAnalystMethod.toLowerCase() +
	                ".jsonp?returnContent=true" : "/datasets/" + params.dataset + "/" +
	                params.surfaceAnalystMethod.toLowerCase() + ".jsonp?returnContent=true";
	            }
	        } else if (params instanceof GeometrySurfaceAnalystParameters) {
	            end = me.url.substr(me.url.length - 1, 1);
	            if (me.isInTheSameDomain) {
	                me.url += (end === "/") ? "geometry/" + params.surfaceAnalystMethod.toLowerCase() +
	                ".json?returnContent=true" : "/geometry/" + params.surfaceAnalystMethod.toLowerCase() +
	                ".json?returnContent=true";
	            } else {
	                me.url += (end === "/") ? "geometry/" + params.surfaceAnalystMethod.toLowerCase() +
	                ".jsonp?returnContent=true" : "/geometry/" + params.surfaceAnalystMethod.toLowerCase() +
	                ".jsonp?returnContent=true";
	            }
	        } else {
	            return;
	        }
	        jsonParameters = SuperMap.Util.toJSON(params);
	        return jsonParameters;
	    },

	    CLASS_NAME: "SuperMap.REST.SurfaceAnalystService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.SurfaceAnalystService(url, options);
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(155);
	__webpack_require__(185);

	/**
	 * Class: DatasetSurfaceAnalystParameters
	 * 数据集表面分析参数类。
	 * 该类对数据集表面分析所用到的参数进行设置。
	 *
	 * Inherits from:
	 *  - <SurfaceAnalystParameters>
	 */
	DatasetSurfaceAnalystParameters = SuperMap.Class(SurfaceAnalystParameters, {

	    /**
	     * APIProperty: dataset
	     * {String} 要用来做数据集表面分析的数据源中数据集的名称。
	     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：Country@World。必设字段。
	     */
	    dataset: null,

	    /**
	     * APIProperty: filterQueryParameter
	     * {<SuperMap.REST.FilterParameter>} 获取或设置查询过滤条件参数。
	     */
	    filterQueryParameter: null,

	    /**
	     * APIProperty: zValueFieldName
	     * {String} 获取或设置用于提取操作的字段名称。
	     * 提取等值线时，将使用该字段中的值，对点记录集中的点数据进行插值分析，得到栅格数据集（中间结果），接着从栅格数据集提取等值线。
	     */
	    zValueFieldName: null,

	    /**
	     * Constructor: DatasetSurfaceAnalystParameters
	     * 数据集表面分析参数类构造函数.
	     *
	     * Parameters:
	     * options - {Object} 可选参数。
	     *
	     * Allowed options properties:
	     * dataset - {String} 要用来做数据集表面分析的数据源中数据集的名称。
	     * filterQueryParameter - {<SuperMap.REST.FilterParameter>} 获取或设置查询过滤条件参数。
	     * zValueFieldName - {String} 获取或设置用于提取操作的字段名称。
	     * extractParameter - {<SurfaceAnalystParametersSetting>} 表面分析参数设置类。获取或设置表面分析参数。
	     * resolution - {Integer} 获取或设置指定中间结果（栅格数据集）的分辨率。
	     * resultSetting - {<DataReturnOption>} 结果返回设置类。
	     * surfaceAnalystMethod - {<SuperMap.REST.SurfaceAnalystMethod>} 获取或设置表面分析的提取方法，提取等值线和提取等值面。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.filterQueryParameter = new SuperMap.REST.FilterParameter();
	        SurfaceAnalystParameters.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SurfaceAnalystParameters.prototype.destroy.apply(this, arguments);
	        var me = this;
	        me.dataset = null;
	        if (me.filterQueryParameter) {
	            me.filterQueryParameter.destroy();
	            me.filterQueryParameter = null;
	        }
	        me.zValueFieldName = null;
	    },

	    CLASS_NAME: "DatasetSurfaceAnalystParameters"
	});

	DatasetSurfaceAnalystParameters.toObject = function (datasetSurfaceAnalystParameters, tempObj) {
	    for (var name in datasetSurfaceAnalystParameters) {
	        if (name === "filterQueryParameter") {
	            tempObj.filterQueryParameter = datasetSurfaceAnalystParameters.filterQueryParameter;
	        }
	        if (name === "extractParameter") {
	            tempObj.extractParameter = datasetSurfaceAnalystParameters.extractParameter;
	        }
	        else if (name === "dataset") {
	        }
	        else if (name === "surfaceAnalystMethod") {
	        }
	        else {
	            tempObj[name] = datasetSurfaceAnalystParameters[name];
	        }
	    }
	};

	module.exports = function (options) {
	    return new DatasetSurfaceAnalystParameters(options);
	};

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(186);
	__webpack_require__(155);

	/**
	 * Class: SurfaceAnalystParameters
	 * 表面分析提取操作参数类。
	 * 通过该类可以为进行表面分析提供参数信息，包括表面分析的方法提取等值线、提取等值面和中间结果的分辨率，
	 * {<SuperMap.REST.DatasetSurfaceAnalystParameters>} 和 {<SuperMap.REST.GeometrySurfaceAnalystParameters>} 继承自该类。
	 */
	SurfaceAnalystParameters = SuperMap.Class({

	    /**
	     * APIProperty: resolution
	     * {Number} 获取或设置指定中间结果（栅格数据集）的分辨率。
	     */
	    resolution: 0,

	    /**
	     * APIProperty: extractParameter
	     * {<SurfaceAnalystParametersSetting>} 获取或设置表面分析参数。
	     * 在进行点数据集进行提取等值面分析时，暂时不支持 SurfaceAnalystParametersSetting 类中的 expectedZValues 字段。
	     */
	    extractParameter: null,

	    /**
	     * APIProperty: resultSetting
	     * {<DataReturnOption>} 结果返回设置类。
	     */
	    resultSetting: null,

	    /**
	     * APIProperty: surfaceAnalystMethod
	     * {<SuperMap.REST.SurfaceAnalystMethod>} 获取或设置表面分析的提取方法，提取等值线和提取等值面，默认为等值线分析。
	     */
	    surfaceAnalystMethod: SuperMap.REST.SurfaceAnalystMethod.ISOLINE,

	    /**
	     * Constructor: SurfaceAnalystParameters
	     * 表面分析提取操作参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * extractParameter - {<SurfaceAnalystParametersSetting>} 获取或设置表面分析参数。
	     * resolution - {Number} 指定中间结果（栅格数据集）的分辨率。
	     * resultSetting - {<DataReturnOption>} 结果返回设置类。
	     * surfaceAnalystMethod - {<SuperMap.REST.SurfaceAnalystMethod>} 获取或设置表面分析的提取方法，提取等值线和提取等值面。
	     */
	    initialize: function (options) {
	        var me = this;
	        me.extractParameter = new SurfaceAnalystParametersSetting();
	        me.resultSetting = new DataReturnOption();
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.resolution = null;
	        if (me.extractParameter) {
	            me.extractParameter.destroy();
	            me.extractParameter = null;
	        }
	        if (me.resultSetting) {
	            me.resultSetting.destroy();
	            me.resultSetting = null;
	        }
	        me.surfaceAnalystMethod = null;
	    },

	    CLASS_NAME: "SurfaceAnalystParameters"
	});

	module.exports = function (options) {
	    return new SurfaceAnalystParameters(options);
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: SurfaceAnalystParametersSetting
	 * 表面分析参数设置类。
	 * 通过该类可以设置表面分析提取等值线、提取等值面的一些参数，包括基准值、等值距、光滑度、光滑方法等。
	 */
	SurfaceAnalystParametersSetting = SuperMap.Class({

	    /**
	     * APIProperty: clipRegion
	     * {<SuperMap.Geometry>} 获取或设置裁剪面对象，如果不需要对操作结果进行裁剪，可以使用null值取代该参数。
	     */
	    clipRegion: null,

	    /**
	     * APIProperty: datumValue
	     * {Number} 获取或设置表面分析中提取等值线、提取等值面的基准值。
	     * 基准值是作为一个生成等值线的初始起算值，并不一定是最小等值线的值。 例如，高程范围为 220 -1550 的 DEM 栅格数据，
	     * 如果设基准值为0， 等值距为50，则提取等值线时，以基准值0为起点，等值距50为间隔提取等值线，
	     * 因为给定高程的最小值是220，所以，在给定范围内提取等值线的最小高程是250。
	     * 提取等值线的结果是：最小等值线值为250，最大等值线值为1550。
	     */
	    datumValue: 0,

	    /**
	     * APIProperty: expectedZValues
	     * {Array(Number)} 获取或设置期望分析结果的 Z 值集合。
	     * Z 值集合存储一系列数值，该数值为待提取等值线的值。即仅高程值在Z值集合中的等值线会被提取。
	     */
	    expectedZValues: null,

	    /**
	     * APIProperty: interval
	     * {Number} 获取或设置等值距。等值距是两条等值线之间的间隔值。
	     */
	    interval: 0,

	    /**
	     * APIProperty: resampleTolerance
	     * {Number} 获取或设置重采样容限。
	     * 容限值越大，采样结果数据越简化。当分析结果出现交叉时，可通过调整重采样容限为较小的值来处理。
	     */
	    resampleTolerance: 0,

	    /**
	     * APIProperty: smoothMethod
	     * {<SuperMap.REST.SmoothMethod>} 获取或设置光滑处理所使用的方法。
	     */
	    smoothMethod: SuperMap.REST.SmoothMethod.BSPLINE,

	    /**
	     * APIProperty: smoothness
	     * {Number} 获取或设置表面分析中等值线或等值面的边界线的光滑度。
	     * 以为0-5为例，光滑度为0表示不进行光滑操作，值越大表示光滑度越高。
	     * 随着光滑度的增加，提取的等值线越光滑.当然光滑度越大，
	     * 计算所需的时间和占用的内存也就越大。而且，当等值距较小时，
	     * 光滑度太高会出现等值线相交的问题。
	     */
	    smoothness: 0,

	    /**
	     * Constructor: SurfaceAnalystParametersSetting
	     * 表面分析参数设置类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * clipRegion - {<SuperMap.Geometry>} 获取或设置裁剪面对象，如果不需要对操作结果进行裁剪，可以使用null值取代该参数。
	     * datumValue - {Number} 获取或设置表面分析中提取等值线、提取等值面的基准值。
	     * expectedZValues - {Array(Number)} 获取或设置期望分析结果的 Z 值集合。
	     * interval - {Number} 获取或设置等值距。等值距是两条等值线之间的间隔值。
	     * resampleTolerance - {Number} 获取或设置重采样容限。
	     * smoothMethod - {<SuperMap.REST.SmoothMethod>} 获取或设置光滑处理所使用的方法。
	     * smoothness - {Number} 获取或设置表面分析中等值线或等值面的边界线的光滑度。
	     */
	    initialize: function (options) {
	        if (options) {
	            var clipRg = options.clipRegion;
	            if (clipRg) {
	                if (clipRg instanceof SuperMap.Geometry && clipRg.components) {
	                    options.clipRegion = SuperMap.REST.ServerGeometry.fromGeometry(clipRg);
	                } else {
	                    delete options.clipRegion;
	                }
	            }
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        if (me.clipRegion) {
	            me.clipRegion.destroy();
	            me.clipRegion = null;
	        }

	        me.datumValue = null;
	        me.expectedZValues = null;
	        me.interval = null;
	        me.resampleTolerance = null;
	        me.smoothMethod = null;
	        me.smoothness = null;
	    },

	    CLASS_NAME: "SurfaceAnalystParametersSetting"
	});

	module.exports = function (options) {
	    return new SurfaceAnalystParametersSetting(options);
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(185);
	/**
	 * Class: GeometrySurfaceAnalystParameters
	 * 几何对象表面分析参数类。
	 * 该类对几何对象表面分析所用到的参数进行设置。
	 *
	 * Inherits from:
	 *  - <SurfaceAnalystParameters>
	 */
	GeometrySurfaceAnalystParameters = SuperMap.Class(SurfaceAnalystParameters, {

	    /**
	     * APIProperty: points
	     * {Array(<SuperMap.Geometry.Point>)} 获取或设置用于表面分析的坐标点数组。
	     */
	    points: null,

	    /**
	     * APIProperty: zValues
	     * {Array(Number)} 获取或设置用于提取操作的值。提取等值线时，将使用该数组中的值，
	     * 对几何对象中的坐标点数组进行插值分析，得到栅格数据集（中间结果），接着从栅格数据集提取等值线。
	     */
	    zValues: null,

	    /**
	     * Constructor: GeometrySurfaceAnalystParameters
	     * 几何对象表面分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * points - {Array(<SuperMap.Geometry.Point>)} 表面分析的坐标点数组。
	     * zValues - {Array(Number)} 表面分析的坐标点的 Z 值数组。
	     * resolution - {Number} 获取或设置指定中间结果（栅格数据集）的分辨率。
	     * resultSetting - {<SuperMap.REST.DataReturnOption>} 结果返回设置类。
	     * extractParameter - {<SurfaceAnalystParametersSetting>} 获取或设置表面分析参数。
	     * surfaceAnalystMethod - {<SuperMap.REST.SurfaceAnalystMethod>} 获取或设置表面分析的提取方法，提取等值线和提取等值面。
	     */
	    initialize: function (options) {
	        SurfaceAnalystParameters.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SurfaceAnalystParameters.prototype.destroy.apply(this, arguments);
	        var me = this;
	        if (me.points) {
	            for (var i = 0, points = me.points, len = points.length; i < len; i++) {
	                points[i].destroy();
	            }
	            me.points = null;
	        }
	        me.zValues = null;
	    },

	    CLASS_NAME: "GeometrySurfaceAnalystParameters"
	});

	module.exports = function (options) {
	    return new GeometrySurfaceAnalystParameters(options);
	};

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.TerrainCurvatureCalculationService
	 *  地形曲率计算服务类。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(189);
	SuperMap.REST.TerrainCurvatureCalculationService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Constructor: SuperMap.REST.TerrainCurvatureCalculationService
	     * 地形曲率计算服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myTerrainCurvatureCalculationService = new SuperMap.REST.TerrainCurvatureCalculationService(url);
	     * myTerrainCurvatureCalculationService.on({
	     *     "processCompleted": processCompleted,
	     *     "processFailed": processFailed
	     *     }
	     * );
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<TerrainCurvatureCalculationParameters>}
	     */
	    processAsync: function (parameter) {
	        var me = this;

	        var end = me.url.substr(me.url.length - 1, 1);
	        if (end === '/') {

	        } else {
	            me.url += "/";
	        }

	        var parameterObject = new Object();

	        if (parameter instanceof TerrainCurvatureCalculationParameters) {
	            me.url += 'datasets/' + parameter.dataset + '/terraincalculation/curvature';
	        }

	        TerrainCurvatureCalculationParameters.toObject(parameter, parameterObject);
	        var jsonParameters = SuperMap.Util.toJSON(parameterObject);

	        if (me.isInTheSameDomain) {
	            me.url += '.json?returnContent=true';
	        } else {
	            me.url += '.jsonp?returnContent=true';
	        }

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.TerrainCurvatureCalculationService"
	});
	module.exports = function (url, options) {
	    return new SuperMap.REST.TerrainCurvatureCalculationService(url, options);
	};


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: TerrainCurvatureCalculationParameters
	 * 地形曲率计算参数类。
	 *
	 */
	TerrainCurvatureCalculationParameters = SuperMap.Class({

	    /**
	     * APIProperty: dataset
	     * {String} 要用来做地形曲率计算数据源中数据集的名称。
	     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。必设字段。
	     *
	     * 注：地形曲率计算必须为栅格数据集。
	     */
	    dataset: null,

	    /**
	     * APIProperty: zFactor
	     * {Number} 指定的高程缩放系数。默认值为 1.0，表示不缩放。
	     * 该值是指在 DEM 栅格数据中，栅格值（Z 坐标，即高程值）相对于 X 和 Y 坐标的单位变换系数。
	     * 通常有 X，Y，Z 都参加的计算中，需要将高程值乘以一个高程缩放系数，使得三者单位一致。
	     * 例如，X、Y 方向上的单位是米，而 Z 方向的单位是英尺，由于 1 英尺等于 0.3048 米，则需要指定缩放系数为 0.3048。
	     */
	    zFactor: 1.0,

	    /**
	     * APIProperty: averageCurvatureName
	     * {String} 结果数据集：平均曲率数据集的名称，必设字段。
	     */
	    averageCurvatureName: null,

	    /**
	     * APIProperty: profileCurvatureName
	     * {String} 结果数据集：剖面曲率数据集的名称。
	     */
	    profileCurvatureName: "",

	    /**
	     * APIProperty: planCurvatureName
	     * {String} 结果数据集：平面曲率数据集的名称。
	     */
	    planCurvatureName: "",

	    /**
	     * Property: deleteExistResultDataset
	     * {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
	     */
	    deleteExistResultDataset: false,

	    /**
	     * Constructor: TerrainCurvatureCalculationParameters
	     * 地形曲率计算参数构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * dataset - {String} 要用来做地形曲率计算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。必设字段。
	     * zFactor - {Number} 指定的高程缩放系数。默认值为 1.0，表示不缩放。
	     * averageCurvatureName - {String} 结果数据集：平均曲率数据集的名称，必设字段。
	     * profileCurvatureName - {String} 结果数据集：剖面曲率数据集的名称。
	     * planCurvatureName - {String} 结果数据集：平面曲率数据集的名称。
	     * deleteExistResultDataset - {Boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
	     */
	    initialize: function (options) {
	        if (!options) {
	            return;
	        }
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        var me = this;
	        me.dataset = null;
	        me.zFactor = 1.0;
	        me.averageCurvatureName = null;
	        me.profileCurvatureName = null;
	        me.planCurvatureName = null;
	        me.deleteExistResultDataset = true;
	    },

	    CLASS_NAME: "TerrainCurvatureCalculationParameters"
	});

	TerrainCurvatureCalculationParameters.toObject = function (derrainCurvatureCalculationParameters, tempObj) {
	    for (var name in derrainCurvatureCalculationParameters) {
	        if (name !== "dataset") {
	            tempObj[name] = derrainCurvatureCalculationParameters[name];
	        }
	    }
	};

	module.exports = function (options) {
	    return new TerrainCurvatureCalculationParameters(options);
	};

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.ThiessenAnalystService
	 * 泰森多边形分析服务类
	 * 该类负责将客户设置的泰森多边形分析参数传递给服务端，并接收服务端返回的分析结果数据。
	 * 泰森多边形分析结果通过该类支持的事件的监听函数参数获取
	 * 泰森多边形分析的参数支持两种，当参数为 {<DatasetThiessenAnalystParameters>} 类型
	 * 时，执行数据集泰森多边形分析，
	 * 当参数为 {<GeometryThiessenAnalystParameters>} 类型时，执行几何对象泰森多边形分析。
	 *
	 * Inherits from:
	 *  - <SuperMap.REST.SpatialAnalystBase>
	 */
	__webpack_require__(151);
	__webpack_require__(191);
	__webpack_require__(192);
	SuperMap.REST.ThiessenAnalystService = SuperMap.Class(SuperMap.REST.SpatialAnalystBase, {

	    /**
	     * Property: mode
	     * {<String>} 缓冲区分析类型
	     */
	    mode: null,

	    /**
	     * Constructor: SuperMap.REST.ThiessenAnalystService
	     * 泰森多边形分析服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myThiessenAnalystService = new SuperMap.REST.ThiessenAnalystService(url, {
	     *     eventListeners: {
	     *           "processCompleted": bufferCompleted, 
	     *           "processFailed": bufferFailed
	     *           }
	     *    });
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.REST.SpatialAnalystBase.prototype.initialize.apply(this, arguments);
	        var me = this;
	        if (options) {
	            SuperMap.Util.extend(me, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.REST.SpatialAnalystBase.prototype.destroy.apply(this, arguments);
	        this.mode = null;
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的查询参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<DatasetThiessenAnalystParameters>}/
	     * {<GeometryThiessenAnalystParameters>}
	     */
	    processAsync: function (parameter) {
	        var parameterObject = new Object();
	        var me = this;

	        var end = me.url.substr(me.url.length - 1, 1);
	        if (end === '/') {

	        } else {
	            me.url += "/";
	        }

	        if (parameter instanceof DatasetThiessenAnalystParameters) {
	            me.mode = "datasets";
	            me.url += 'datasets/' + parameter.dataset + '/thiessenpolygon';
	            DatasetThiessenAnalystParameters.toObject(parameter, parameterObject);
	        }
	        else if (parameter instanceof GeometryThiessenAnalystParameters) {
	            me.mode = "geometry";
	            me.url += 'geometry/thiessenpolygon';
	            GeometryThiessenAnalystParameters.toObject(parameter, parameterObject);
	        }

	        var jsonParameters = SuperMap.Util.toJSON(parameterObject);


	        if (me.isInTheSameDomain) {
	            me.url += '.json?returnContent=true';
	        } else {
	            me.url += '.jsonp?returnContent=true';
	        }

	        me.request({
	            method: "POST",
	            data: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },
	    /**
	     * Method: toGeoJSONResult
	     * 将含有geometry的数据转换为geojson格式。
	     *
	     * Parameters:
	     * result - {Object} 服务器返回的结果对象。
	     */
	    toGeoJSONResult: function (result) {
	        if (!result) {
	            return result;
	        }

	        var analystResult = SuperMap.REST.SpatialAnalystBase.prototype.toGeoJSONResult.apply(this, arguments);
	        if (!analystResult && result.regions) {
	            var geoJSONFormat = new SuperMap.Format.GeoJSON();
	            analystResult = JSON.parse(geoJSONFormat.write(result.regions));
	        }
	        return analystResult;
	    },

	    CLASS_NAME: "SuperMap.REST.ThiessenAnalystService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.ThiessenAnalystService(url, options);
	};

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(170);

	/**
	 * Class: DatasetThiessenAnalystParameters
	 * 数据集泰森多边形分析参数类
	 *
	 * Inherits from:
	 *  - <ThiessenAnalystParameters>
	 */
	DatasetThiessenAnalystParameters = SuperMap.Class(ThiessenAnalystParameters, {

	    /**
	     * APIProperty: filterQueryParameter
	     * {<SuperMap.REST.FilterParameter>} 过滤条件，
	     * 对待分析数据集中的点进行过滤，不设置时默认为null，即对数据集中的所有点进行分析。
	     * (start code)
	     * filterQueryParameter的使用方法如：
	     *  filterQueryParameter = new SuperMap.REST.FilterParameter({
	     *   name: "Countries@World",
	     *   attributeFilter: "SmID>100"
	     *  });
	     * (end)
	     */
	    filterQueryParameter: null,

	    /**
	     * APIProperty: dataset
	     * {String} 数据集名称
	     * 待分析的数据集名称，请使用‘datasetName@datasourceName’格式来表示。
	     */
	    dataset: null,

	    /**
	     * Constructor: DatasetThiessenAnalystParameters
	     * 数据集泰森多边形分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * filterQueryParameter - {<SuperMap.REST.FilterParameter>} 对待分析数据集中的点进行过滤，不设置时默认为null，即对数据集中的所有点进行分析。
	     */
	    initialize: function (options) {
	        ThiessenAnalystParameters.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);

	        var me = this;
	        if (me.filterQueryParameter) {
	            me.filterQueryParameter.destroy();
	            me.filterQueryParameter = null;
	        }
	    },

	    CLASS_NAME: "DatasetThiessenAnalystParameters"
	});

	DatasetThiessenAnalystParameters.toObject = function (datasetThiessenAnalystParameters, tempObj) {
	    for (var name in datasetThiessenAnalystParameters) {
	        if (name === "clipRegion") {
	            tempObj.clipRegion = SuperMap.REST.ServerGeometry.fromGeometry(datasetThiessenAnalystParameters.clipRegion);
	        } else {
	            tempObj[name] = datasetThiessenAnalystParameters[name];
	        }
	    }
	};

	module.exports = function (options) {
	    return new DatasetThiessenAnalystParameters(options);
	};

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(170);
	/**
	 * Class: GeometryThiessenAnalystParameters
	 * 几何对象泰森多边形分析参数类
	 * 对指定的某个几何对象做泰森多边形分析。通过该类可以指定要做泰森多边形分析的几何对象、返回数据集名称等。
	 *
	 * Inherits from:
	 *  - <ThiessenAnalystParameters>
	 */
	GeometryThiessenAnalystParameters = SuperMap.Class(ThiessenAnalystParameters, {

	    /**
	     * Property: points
	     * {Array(<Point||Array>)}
	     * 使用点数组进行分析时使用的几何对象。
	     */
	    points: null,

	    /**
	     * Constructor: GeometryThiessenAnalystParameters
	     * 几何对象泰森多边形分析参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * points - {Array(<Point||Array>)} 使用点数组进行分析时使用的几何对象。
	     */
	    initialize: function (options) {
	        ThiessenAnalystParameters.prototype.initialize.apply(this, arguments);
	        if (options) {
	            SuperMap.Util.extend(this, options);
	        }
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);

	        var me = this;
	        if (me.points) {
	            for (var i = me.points.length - 1; i >= 0; i--) {
	                me.points[i].destroy();
	            }
	            me.points = null;
	        }
	    },

	    CLASS_NAME: "GeometryThiessenAnalystParameters"
	});

	GeometryThiessenAnalystParameters.toObject = function (geometryThiessenAnalystParameters, tempObj) {
	    for (var name in geometryThiessenAnalystParameters) {
	        if (name === "clipRegion") {
	            tempObj.clipRegion = SuperMap.REST.ServerGeometry.fromGeometry(geometryThiessenAnalystParameters.clipRegion);
	        } else {
	            tempObj[name] = geometryThiessenAnalystParameters[name];
	        }
	    }
	};

	module.exports = function (options) {
	    return new GeometryThiessenAnalystParameters(options);
	};

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Class: TrafficTransferAnalystService
	 * 交通换乘分析服务类
	 * 用法：
	 *      L.superMap.trafficTransferAnalystService(url).queryStop({
	 *           keyWord:xxx
	 *      }).on("complete",function(result){
	 *           //doSomething
	 *      }).on("failed",function(result){
	 *           //doSomething
	 *      });
	 */
	__webpack_require__(4);
	__webpack_require__(194);
	__webpack_require__(196);
	__webpack_require__(199);
	__webpack_require__(11);

	TrafficTransferAnalystService = ServiceBase.extend({

	    initialize: function (url, options) {
	        ServiceBase.prototype.initialize.call(this, url, options);
	    },

	    /**
	     * 站点查询服务
	     * @param params
	     * {StopQueryParameters}
	     */
	    queryStop: function (params) {
	        var me = this;
	        var stopQueryService = new SuperMap.REST.StopQueryService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        stopQueryService.processAsync(params);
	        return me;
	    },
	    /**
	     * 交通换乘线路查询服务
	     * @param params
	     *    {TransferPathParameters}
	     */
	    analysisTransferPath: function (params) {
	        var me = this, param = me._processParams(params);
	        var transferPathService = new SuperMap.REST.TransferPathService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        transferPathService.processAsync(param);
	        return me;
	    },
	    /**
	     * 交通换乘方案查询服务
	     * @param params
	     *    {TransferSolutionParameters}
	     */
	    analysisTransferSolution: function (params) {
	        var me = this, param = me._processParams(params);
	        var transferSolutionService = new SuperMap.REST.TransferSolutionService(me.options.url, {
	            eventListeners: {
	                scope: me,
	                processCompleted: me.processCompleted,
	                processFailed: me.processFailed
	            }
	        });
	        transferSolutionService.processAsync(param);
	        return me;
	    },

	    _processParams: function (params) {
	        if (!params) {
	            return {};
	        }

	        if (params.points && L.Util.isArray(params.points)) {
	            params.points.map(function (point, key) {
	                params.points[key] = (point instanceof L.LatLng) ? {x: point.lng, y: point.lat} : point;
	            });
	        }
	        return params;
	    }
	});

	L.supermap.trafficTransferAnalystService = function (url, options) {
	    return new TrafficTransferAnalystService(url, options);
	};

	module.exports = L.supermap.trafficTransferAnalystService;

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/


	/**
	 * Class: SuperMap.REST.StopQueryService
	 * 站点查询服务类。
	 * 返回结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(195);
	SuperMap.REST.StopQueryService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.StopQueryService
	     * 站点查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.StopQueryService(url, {eventListeners: {
	     *     "processCompleted": StopQueryCompleted, 
	     *     "processFailed": StopQueryError
	     *     }
	     * };
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 与客户端交互的站点查询服务地址。
	     * 例如:"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	        options = options || {};
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	        SuperMap.Util.reset(this);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的更新参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<StopQueryParameters>} 交通换乘参数。
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this, end;

	        end = me.url.substr(me.url.length - 1, 1);
	        me.url += (end === "/") ? '' : '/';
	        me.url += "stops/keyword/" + params.keyWord;
	        me.url += me.isInTheSameDomain ? ".json?" : ".jsonp";

	        me.request({
	            method: "GET",
	            params: {returnPosition: params.returnPosition},
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.StopQueryService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.StopQueryService(url, options);
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: StopQueryParameters
	 * 站点查询参数类。
	 */
	StopQueryParameters = SuperMap.Class({
	    /**
	     * APIProperty: keyWord
	     * {String} 站点名称关键字。
	     */
	    keyWord: null,

	    /**
	     * APIProperty: returnPosition
	     * {Boolean} 是否返回站点坐标信息。
	     */
	    returnPosition: false,

	    /**
	     * Constructor: StopQueryParameters
	     * 站点查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * keyWord - {String} 站点名称关键字。
	     * returnPosition - {Boolean} 是否返回站点坐标信息。
	     */
	    initialize: function (options) {
	        options = options || {};
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.Util.reset(this);
	    },

	    CLASS_NAME: "StopQueryParameters"
	});

	module.exports = function (options) {
	    return new StopQueryParameters(options);
	};

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.TransferPathService
	 * 交通换乘线路查询服务类，根据交通换乘分析结果(TransferSolutionResult)，获取某一条乘车路线的详细信息。
	 * 返回结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(197);
	SuperMap.REST.TransferPathService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.TransferPathService
	     * 交通换乘线路服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.TransferPathService(url, {eventListeners: {
	     *     "processCompleted": TrafficTransferCompleted, 
	     *     "processFailed": TrafficTransferError
	     *     }
	     * };
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 与客户端交互的交通换乘线路查询服务地址。
	     * 例如:"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的更新参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<TransferPathParameters>} 交通换乘参数。
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this,
	            method = "GET",
	            jsonParameters,
	            end;

	        end = me.url.substr(me.url.length - 1, 1);
	        me.url += (end === "/") ? '' : '/';
	        me.url += me.isInTheSameDomain ? "path.json?" : "path.jsonp";

	        jsonParameters = {
	            points: SuperMap.Util.toJSON(params.points),
	            transferLines: params['transferLines']
	        };

	        me.request({
	            method: method,
	            params: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },

	    CLASS_NAME: "SuperMap.REST.TransferPathService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.TransferPathService(url, options);
	};


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(198);

	/**
	 * Class: TransferPathParameters
	 * 交通换乘线路查询参数类。
	 */
	TransferPathParameters = SuperMap.Class({
	    /**
	     * APIProperty: transferLines
	     * {Array(<TransferLine>)} 本换乘分段内可乘车的路线集合，通过交通换乘方案查询得到，存放在 <SuperMap.REST.TransferSolutionResult> 中。
	     */
	    transferLines: null,

	    /**
	     * APIProperty: points
	     * {Array(String) or Array(Object)} 两种查询方式：
	     *           1. 按照公交站点的起止ID进行查询，则points参数的类型为int[]，形如：[起点ID、终点ID]，
	     * 公交站点的ID对应服务提供者配置中的站点ID字段；
	     *           2. 按照起止点的坐标进行查询，则points参数的类型为Point2D[]，形如：[{"x":44,"y":39},{"x":45,"y":40}]。
	     */
	    points: false,

	    /**
	     * Constructor: TransferPathParameters
	     * 交通换乘线路查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * transferLines - {Array(<TransferLine>)} 本换乘分段内可乘车的路线集合。
	     * points - {Array(Integer)} 两种查询方式：按照公交站点的起止ID进行查询和按照起止点的坐标进行查询。
	     */
	    initialize: function (options) {
	        options = options || {};
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.Util.reset(this);
	    },

	    CLASS_NAME: "TransferPathParameters"
	});
	/**
	 * Function: TransferPathParameters.toJson
	 * 将 <TransferPathParameters> 对象参数转换为 json 字符串。
	 *
	 * Parameters:
	 * params - {<TransferPathParameters>} 交通换乘参数。
	 *
	 * Returns:
	 * {String} 转化后的 json字符串。
	 */
	TransferPathParameters.toJson = function (params) {
	    if (params) {
	        return SuperMap.Util.toJSON(params);
	    }
	};

	module.exports = function (options) {
	    return new TransferPathParameters(options);
	};

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: TransferLine
	 * 换乘路线信息类。
	 */
	TransferLine = SuperMap.Class({
	    /**
	     * APIProperty: lineID
	     * {Number} 乘车路线名称。
	     */
	    lineID: null,

	    /**
	     * APIProperty: lineName
	     * {String} 乘车路线名称。
	     */
	    lineName: null,

	    /**
	     * APIProperty: lineAliasName
	     * {String} 乘车路线别名。
	     */
	    lineAliasName: null,

	    /**
	     * APIProperty: startStopIndex
	     * {Number} 上车站点在本公交路线中的索引。
	     */
	    startStopIndex: null,

	    /**
	     * APIProperty: startStopName
	     * {String} 上车站点名称。
	     */
	    startStopName: null,

	    /**
	     * APIProperty: startStopAliasName
	     * {String} 上车站点别名。
	     */
	    startStopAliasName: null,

	    /**
	     * APIProperty: endStopIndex
	     * {Number} 下车站点在本公交路线中的索引。
	     */
	    endStopIndex: null,

	    /**
	     * APIProperty: endStopName
	     * {String} 下车站点名称。
	     */
	    endStopName: null,

	    /**
	     * APIProperty: endStopAliasName
	     * {String} 下车站点别名。
	     */
	    endStopAliasName: null,

	    /**
	     * Constructor: TransferLine
	     * 换乘路线信息类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * lineID - {String} 乘车路线名称。
	     * lineName - {String} 乘车路线名称。
	     * lineAliasName - {String} 乘车路线别名。
	     * startStopIndex - {Number} 上车站点在本公交路线中的索引。
	     * startStopName - {String} 上车站点名称。
	     * startStopAliasName - {String} 上车站点别名。
	     * endStopIndex - {Number} 下车站点在本公交路线中的索引。
	     * endStopName - {String} 下车站点名称。
	     * endStopAliasName - {String} 下车站点别名。
	     */
	    initialize: function (options) {
	        options = options || {};
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.Util.reset(this);
	    },

	    CLASS_NAME: "TransferLine"
	});

	/**
	 * Function: TransferLine.fromJson
	 * 将返回结果转化为 TransferLine 对象。
	 *
	 * Parameters:
	 * jsonObject - {Object} 新的返回结果。
	 *
	 * Returns:
	 * {<TransferLine>} 转化后的 TransferLine 对象。
	 */
	TransferLine.fromJson = function (jsonObject) {
	    if (!jsonObject) {
	        return;
	    }
	    return new TransferLine({
	        lineID: jsonObject['lineID'],
	        lineName: jsonObject['lineName'],
	        lineAliasName: jsonObject['lineAliasName'],
	        startStopIndex: jsonObject['startStopIndex'],
	        startStopName: jsonObject['startStopName'],
	        startStopAliasName: jsonObject['startStopAliasName'],
	        endStopIndex: jsonObject['endStopIndex'],
	        endStopName: jsonObject['endStopName'],
	        endStopAliasName: jsonObject['endStopAliasName']
	    });
	};

	module.exports = function (options) {
	    return new TransferLine(options);
	};

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/* COPYRIGHT 2017 SUPERMAP
	 * 本程序只能在有效的授权许可下使用。
	 * 未经许可，不得以任何手段擅自使用或传播。*/

	/**
	 * Class: SuperMap.REST.TransferSolutionService
	 * 交通换乘方案查询服务类。
	 * 返回结果通过该类支持的事件的监听函数参数获取
	 *
	 * Inherits from:
	 *  - <SuperMap.ServiceBase>
	 */
	__webpack_require__(13);
	__webpack_require__(200);
	SuperMap.REST.TransferSolutionService = SuperMap.Class(SuperMap.ServiceBase, {

	    /**
	     * Constructor: SuperMap.REST.TransferSolutionService
	     * 交通换乘方案查询服务类构造函数。
	     *
	     * 例如：
	     * (start code)
	     * var myService = new SuperMap.REST.TransferSolutionService(url, {eventListeners: {
	     *     "processCompleted": trafficTransferCompleted,
	     *     "processFailed": trafficTransferError
	     *     }
	     * };
	     * (end)
	     *
	     * Parameters:
	     * url - {String} 与客户端交互的交通换乘方案查询服务地址。
	     * 例如:"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * eventListeners - {Object} 需要被注册的监听器对象。
	     */
	    initialize: function (url, options) {
	        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源,将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
	    },

	    /**
	     * APIMethod: processAsync
	     * 负责将客户端的更新参数传递到服务端。
	     *
	     * Parameters:
	     * params - {<TransferSolutionParameters>} 交通换乘参数。
	     */
	    processAsync: function (params) {
	        if (!params) {
	            return;
	        }
	        var me = this,
	            method = "GET",
	            jsonParameters,
	            end;

	        end = me.url.substr(me.url.length - 1, 1);
	        me.url += (end === "/") ? '' : '/';
	        me.url += me.isInTheSameDomain ? "solutions.json?" : "solutions.jsonp";

	        jsonParameters = {
	            points: SuperMap.Util.toJSON(params.points),
	            walkingRatio: params['walkingRatio'],
	            transferTactic: params['transferTactic'],
	            solutionCount: params['solutionCount'],
	            transferPreference: params["transferPreference"]
	        };
	        if (params.evadeLines) jsonParameters["evadeLines"] = SuperMap.Util.toJSON(params.evadeLines);
	        if (params.evadeStops) jsonParameters["evadeStops"] = SuperMap.Util.toJSON(params.evadeStops);
	        if (params.priorLines) jsonParameters["priorLines"] = SuperMap.Util.toJSON(params.priorLines);
	        if (params.priorStops) jsonParameters["priorStops"] = SuperMap.Util.toJSON(params.priorStops);
	        if (params.travelTime) jsonParameters["travelTime"] = params.travelTime;

	        me.request({
	            method: method,
	            params: jsonParameters,
	            scope: me,
	            success: me.serviceProcessCompleted,
	            failure: me.serviceProcessFailed
	        });
	    },
	    CLASS_NAME: "SuperMap.REST.TransferSolutionService"
	});

	module.exports = function (url, options) {
	    return new SuperMap.REST.TransferSolutionService(url, options);
	};


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);

	/**
	 * Class: TransferSolutionParameters
	 * 交通换乘方案查询参数类。
	 */
	TransferSolutionParameters = SuperMap.Class({
	    /**
	     * APIProperty: solutionCount
	     * {Number} 乘车方案的数量。默认为6。
	     */
	    solutionCount: 6,

	    /**
	     * APIProperty: transferPreference
	     * {<TransferPreference>} 乘车偏好枚举。默认为SuperMap.REST.TransferPreference.NONE
	     */
	    transferPreference: TransferPreference.NONE,

	    /**
	     * APIProperty: transferTactic
	     * {<TransferTactic>} 交通换乘策略类型，包括时间最短、距离最短、最少换乘、
	     * 最少步行四种选择。默认为SuperMap.REST.TransferTactic.LESS_TIME
	     */
	    transferTactic: TransferTactic.LESS_TIME,

	    /**
	     * APIProperty: walkingRatio
	     * {Number} 步行与公交的消耗权重比，默认值为 10。此值越大，则步行因素对于方案选择的影响越大。例如：
	     * 例如现在有两种换乘方案（在仅考虑消耗因素的情况下）：
	     * 方案1：坐车10公里，走路1公里；
	     * 方案2：坐车15公里，走路0.5公里；
	     * 1. 假设权重比为15：
	     * •方案1的总消耗为：10 + 1*15 = 25
	     * •方案2的总消耗为：15 + 0.5*15 = 22.5
	     * 此时方案2消耗更低。
	     * 2. 假设权重比为2：
	     * •方案1的总消耗为：10+1*2 = 12
	     * •方案2的总消耗为：15+0.5*2 = 17
	     * 此时方案1消耗更低。
	     */
	    walkingRatio: null,

	    /**
	     * APIProperty: points
	     * {Array(String) or Array(Object)} 两种查询方式：
	     *           1. 按照公交站点的起止ID进行查询，则points参数的类型为int[]，形如：[起点ID、终点ID]，
	     * 公交站点的ID对应服务提供者配置中的站点ID字段；
	     *           2. 按照起止点的坐标进行查询，则points参数的类型为Point2D[]，形如：[{"x":44,"y":39},{"x":45,"y":40}]。
	     */
	    points: false,

	    /**
	     * APIProperty: evadeLines
	     * {Array(Number)} 避让路线ID。
	     * */
	    evadeLines: null,

	    /**
	     * APIProperty: evadeStops
	     * {Array(Number)} 避让站点ID。
	     * */
	    evadeStops: null,

	    /**
	     * APIProperty: priorLines
	     * {Array(Number)} 优先路线ID。
	     * */
	    priorLines: null,

	    /**
	     * APIProperty: priorStops
	     * {Array(Number)} 优先站点ID。
	     * */
	    priorStops: null,

	    /**
	     * APIProperty: travelTime
	     * {String} 出行的时间； 格式是："小时:分钟"，如："08:30"。如果设置了该参数，在分析时，则会考虑线路的首末班车时间的限制，即在返回的结果中会提示公交的首末班发车时间。
	     */
	    travelTime: null,

	    /**
	     * Constructor: TransferSolutionParameters
	     * 交通换乘方案查询参数类构造函数。
	     *
	     * Parameters:
	     * options - {Object} 参数。
	     *
	     * Allowed options properties:
	     * solutionCount - {Boolean} 乘车方案的数量。默认为6。
	     * transferTactic - {<TransferTactic>} 交通换乘策略类型，
	     * 包括时间最短、距离最短、最少换乘、最少步行四种选择。
	     * transferPreference - {<TransferPreference>} 乘车偏好枚举。
	     * walkingRatio - {Array(Number)} 步行与公交的消耗权重比，默认值为 10。
	     * points - {Array(Number)} 两种查询方式：按照公交站点的起止ID进行查询和按照起止点的坐标进行查询。
	     * evadeLines - {Array(Number)} 避让路线的ID，默认为null。
	     * evadeStops - {Array(Number)} 避让站点的ID，默认为null。
	     * priorLines - {Array(Number)} 优先路线的ID，默认为null。
	     * priorStops - {Array(Number)} 优先站点的ID，默认为null。
	     * travelTime - {String} 出行的时间。
	     */
	    initialize: function (options) {
	        options = options || {};
	        SuperMap.Util.extend(this, options);
	    },

	    /**
	     * APIMethod: destroy
	     * 释放资源，将引用资源的属性置空。
	     */
	    destroy: function () {
	        SuperMap.Util.reset(this);
	    },

	    CLASS_NAME: "TransferSolutionParameters"
	});
	/**
	 * Function: TransferSolutionParameters.toJsonParameters
	 * 将 <TransferSolutionParameters> 对象参数转换为 json 字符串。
	 *
	 * Parameters:
	 * params - {<TransferSolutionParameters>} 交通换乘参数。
	 *
	 * Returns:
	 * {String} 转化后的 json字符串。
	 */
	TransferSolutionParameters.toJson = function (params) {
	    if (params) {
	        return SuperMap.Util.toJSON(params);
	    }
	};

	module.exports = function (options) {
	    return new TransferSolutionParameters(options);
	};


/***/ },
/* 201 */
/***/ function(module, exports) {

	EchartsMapLayer = L.Layer.extend({
	    includes: [],
	    _echartsContainer: null,
	    _map: null,
	    _ec: null,
	    _option: null,

	    initialize: function (option) {
	        this._option = option;
	    },

	    onAdd: function (map) {
	        this._map = map;
	        this._initEchartsContainer();
	        map.on("moveend", this._redraw, this);
	        var me = this;
	        map.on("movestart", function (e) {
	            me._disableEchartsContainer();
	        })
	        this._redraw();
	    },

	    onRemove: function (map) {
	        if (this._echartsContainer) {
	            map.getPanes().overlayPane.removeChild(this._echartsContainer);
	        }
	        map.off("moveend", this._redraw, this);
	        var me = this;
	        map.off("movestart", function () {
	            me._disableEchartsContainer();
	        })
	    },
	    addTo: function (map) {
	        map.addLayer(this);
	        return this;
	    },
	    _initEchartsContainer: function () {
	        var size = this._map.getSize();
	        var _div = document.createElement('div');
	        _div.style.position = 'absolute';
	        _div.style.height = size.y + 'px';
	        _div.style.width = size.x + 'px';
	        _div.style.zIndex = 10;
	        this._echartsContainer = _div;
	        this._map.getPanes().overlayPane.appendChild(this._echartsContainer);
	    },

	    _resetCanvasPosition: function () {
	        var bounds = this._map.getBounds();
	        var topLeft = this._map.latLngToLayerPoint(bounds.getNorthWest());
	        L.DomUtil.setPosition(this._echartsContainer, topLeft);
	        this._enableEchartsContainer();
	    },
	    _disableEchartsContainer: function () {
	        this._echartsContainer.style.visibility = "hidden";
	    },
	    _enableEchartsContainer: function () {
	        this._echartsContainer.style.visibility = "visible";
	    },
	    _redraw: function () {
	        var lastOption = this._ec && this._ec.getOption() ? this._ec.getOption() : this._option;
	        this._resetCanvasPosition();
	        this._echartsContainer.innerHTML = '';
	        this.initECharts();
	        this._ec.setOption(lastOption);
	        return this;
	    },

	    clear: function () {
	        this._echartsContainer.innerHTML = '';
	    },

	    redraw: function () {
	        this._redraw();
	    },

	    /**
	     * 初始化echarts实例
	     *
	     */
	    initECharts: function () {
	        this._ec = echarts.init(this._echartsContainer);
	        var me = this;
	        echarts.registerCoordinateSystem("leaflet",
	            {
	                create: function (ecModel, api) {
	                    ecModel.eachSeries(function (seriesModel, index) {
	                        var coordSysType = seriesModel.get('coordinateSystem');
	                        if (!coordSysType || coordSysType === 'leaflet') {
	                            seriesModel.coordinateSystem = new Geo(me._map);
	                        }
	                    });
	                    for (var i = 0; i < me._ec._componentsViews.length; i++) {
	                        var view = me._ec._componentsViews[i];
	                        if (view.__model && view.__model.mainType === 'visualMap') {
	                            view.__model.eachTargetSeries(function (targetSeries) {
	                                var viewRect=view.group.getBoundingRect();
	                                viewRect.width=parseInt(me._echartsContainer.style.width);
	                                viewRect.height=parseInt(me._echartsContainer.style.height);
	                                targetSeries.coordinateSystem.setViewRect(viewRect);
	                            });
	                        }
	                        if (view.__model && view.__model.mainType === 'visualMap'&& view._shapes&& view._shapes.barGroup) {
	                            view._shapes.barGroup.on('mouseover', function () {
	                                me._map.dragging.disable();
	                                me._map.scrollWheelZoom.disable();
	                                me._map.doubleClickZoom.disable();
	                            })
	                            view._shapes.barGroup.on('mouseout', function () {
	                                me._map.dragging.enable();
	                                me._map.scrollWheelZoom.enable();
	                                me._map.doubleClickZoom.enable();
	                            })
	                        }
	                    }

	                },
	                dimensions: ['lng', 'lat']
	            }
	        );
	    }
	});

	function Geo(map) {
	    this._map = map;
	    this.viewRect = null;
	}
	Geo.prototype = {
	    constructor: Geo,
	    type: 'geo',
	    dimensions: ['lng', 'lat'],
	    dataToPoints: function (data) {
	        var item = [];
	        return data.mapArray(['lng', 'lat'], function (lon, lat) {
	            item[0] = lon;
	            item[1] = lat;
	            return this.dataToPoint(item);
	        }, this);
	    },
	    setViewRect: function (viewRect) {
	        this.viewRect = viewRect;
	    },
	    getViewRect: function () {
	        return this.viewRect;
	    },
	    getRoamTransform:function(){
	        var roamTransform={};
	        roamTransform.transform;
	        return roamTransform;
	    },

	    // Overwrite
	    dataToPoint: function (data) {
	        var point = new L.latLng(data[1], data[0]);
	        if (point && point.lng && point.lat) {
	            var pos = this._map.latLngToContainerPoint(point);
	            return [pos.x, pos.y];
	        }
	        return data;

	    }


	}


	L.echartsMapLayer = function (options, echartsOptions) {
	    return new EchartsMapLayer(options, echartsOptions);
	};
	module.exports = L.echartsMapLayer;



/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2);

	L.supermap.Graphic = L.Class.extend({

	    initialize: function (options) {
	        options = options || {};
	        this._latlng = L.latLng(options._latlng.lat, options._latlng.lng);
	        this._canvas = options._canvas;
	    },

	    setLatlng: function (latlng) {
	        this._latlng = latlng;
	    },

	    setCanvas: function (canvas) {
	        this._canvas = canvas;
	    },

	    getLatLng: function () {
	        return this._latlng;
	    },

	    getCanvas: function () {
	        return this._canvas;
	    }

	});

	L.supermap.graphic = function (options) {
	    return new L.supermap.Graphic(options);
	};


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2);

	L.supermap.GraphicGroup = L.Path.extend({

	        initialize: function (graphics, options) {
	            options = options || {};
	            L.setOptions(this, options);
	            this.graphics = graphics;
	        },

	        getEvents: function () {
	            var events = {
	                click: this._handleClick
	            }
	            return events;
	        },

	        onAdd: function () {
	            this._canvas = document.createElement('canvas');
	            var width = this._map.getPixelBounds().getSize().x;
	            var height = this._map.getPixelBounds().getSize().y;
	            this._canvas.width = width;
	            this._canvas.height = height;
	            this._ctx = this._canvas.getContext('2d');
	            L.Path.prototype.onAdd.call(this);
	        },

	        _update: function () {
	            if (this._map) {
	                this._updatePath();
	            }
	        },

	        _updatePath: function () {
	            this._renderer._drawGraphics(this._getGraphicsInBounds());
	        },

	        _project: function () {
	            var me = this;
	            me._getGraphicsInBounds().map(function (graphic) {
	                var point = me._map.latLngToLayerPoint(graphic.getLatLng());
	                var w = me._clickTolerance();
	                var p = [graphic._anchor + w, graphic._anchor + w];
	                graphic._pxBounds = new L.Bounds(point.subtract(p), point.add(p));
	            })
	            me._pxBounds = L.bounds(L.point(0, 0), L.point(this._canvas.width, this._canvas.height));
	        },

	        _getGraphicsInBounds: function () {
	            var me = this;
	            var graphicsInBounds = [];
	            var viewBounds = me._map.getBounds();
	            this.graphics.map(function (graphic) {
	                if (viewBounds.contains(graphic.getLatLng())) {
	                    graphicsInBounds.push(graphic);
	                }
	            });
	            return graphicsInBounds;
	        },

	        _containsPoint: function (p) {
	            return false;
	        },

	        _handleClick: function (evt) {
	            var me = this;
	            var graphics = me._getGraphicsInBounds();
	            for (var i = 0; i < graphics.length; i++) {
	                var center = me._map.latLngToLayerPoint(graphics[i].getLatLng());
	                var canvas = graphics[i].getCanvas();
	                var p1 = L.point(center.x - canvas.width / 2, center.y - canvas.height / 2),
	                    p2 = L.point(center.x + canvas.width / 2, center.y + canvas.height / 2),
	                    bounds = L.bounds(p1, p2);
	                if (bounds.contains(me._map.latLngToLayerPoint(evt.latlng))) {
	                    return me.options.handleClick.call(me, graphics[i]);
	                }
	            }
	        }
	    }
	);

	L.Canvas.include({
	    _drawGraphics: function (graphics) {
	        var me = this;
	        me._ctx.clearRect(0, 0, me._ctx.canvas.width, me._ctx.canvas.height);
	        graphics.map(function (graphic) {
	            var canvas = graphic.getCanvas();
	            var pt = me._map.latLngToLayerPoint(graphic.getLatLng());
	            var p0 = pt.x - canvas.width / 2;
	            var p1 = pt.y - canvas.height / 2;
	            me._ctx.drawImage(canvas, p0, p1);
	        })
	    }
	});

	L.supermap.graphicGroup = function (graphics, options) {
	    return new L.supermap.GraphicGroup(graphics, options);
	};


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2);

	L.supermap.CircleStyle = L.Class.extend({

	    options: {
	        stroke: true,
	        color: '#3388ff',
	        weight: 1,
	        opacity: 1,
	        lineCap: 'round',
	        lineJoin: 'round',
	        fill: false,
	        fillColor: null,
	        fillOpacity: 0.2,
	        fillRule: 'evenodd',
	        radius: 3
	    },

	    initialize: function (options) {
	        options = options || {};
	        L.Util.setOptions(this, options);
	        this._canvas = document.createElement('canvas');
	        this._canvas.width = 2 * (this.options.radius + this.options.weight);
	        this._canvas.height = 2 * (this.options.radius + this.options.weight);
	        this._ctx = this._canvas.getContext('2d');
	        this._initStyle();
	    },

	    getCanvas: function () {
	        return this._canvas;
	    },

	    _initStyle: function () {
	        this._ctx.beginPath();
	        this._ctx.arc(this._canvas.width / 2, this._canvas.height / 2, this.options.radius, 0, Math.PI * 2);
	        this._fillStroke();
	    },

	    _fillStroke: function () {
	        var options = this.options;
	        if (options.fill) {
	            this._ctx.globalAlpha = options.fillOpacity;
	            this._ctx.fillStyle = options.fillColor || options.color;
	            this._ctx.fill(options.fillRule || 'evenodd');
	        }
	        if (options.stroke && options.weight !== 0) {
	            this._ctx.globalAlpha = options.opacity;
	            this._ctx.lineWidth = options.weight;
	            this._ctx.strokeStyle = options.color;
	            this._ctx.lineCap = options.lineCap;
	            this._ctx.lineJoin = options.lineJoin;
	            this._ctx.stroke();
	        }
	    }

	});

	L.supermap.circleStyle = function (options) {
	    return new L.supermap.CircleStyle(options);
	};


/***/ }
/******/ ]);