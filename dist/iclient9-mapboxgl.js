/*!
 * 
 *     iclient9-mapboxgl.(http://iclient.supermapol.com)
 *     Copyright© 2000-2017 SuperMap Software Co. Ltd
 *     license: Apache-2.0
 *     version: v9.0.0
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 321);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SuperMap = window.SuperMap = window.SuperMap || {};
module.exports = SuperMap;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SummaryType = exports.StatisticAnalystMode = exports.AnalystSizeUnit = exports.AnalystAreaUnit = exports.ClipAnalystMode = exports.ChartType = exports.ClientType = exports.ServerType = exports.Exponent = exports.VariogramMode = exports.InterpolationAlgorithmType = exports.SearchMode = exports.PixelFormat = exports.StatisticMode = exports.LayerType = exports.ColorSpaceType = exports.GridType = exports.TransferPreference = exports.TransferTactic = exports.EditType = exports.DataReturnMode = exports.SurfaceAnalystMethod = exports.SmoothMethod = exports.OverlayOperationType = exports.BufferEndType = exports.TurnType = exports.SupplyCenterType = exports.SideType = exports.DirectionType = exports.LabelOverLengthMode = exports.LabelBackShape = exports.AlongLineDirection = exports.FillGradientMode = exports.TextAlignment = exports.ColorGradientType = exports.ThemeType = exports.RangeMode = exports.GraduatedMode = exports.GraphAxesTextDisplayMode = exports.ThemeGraphType = exports.ThemeGraphTextFormat = exports.EngineType = exports.Unit = exports.MeasureMode = exports.SpatialRelationType = exports.SpatialQueryMode = exports.JoinType = exports.QueryOption = exports.GeometryType = exports.DataFormat = undefined;

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *服务请求返回结果数据类型
 *  GEOJSON: "GEOJSON",
 *  ISERVER: "ISERVER"
 */
var DataFormat = exports.DataFormat = _SuperMap2.default.DataFormat = {
    GEOJSON: "GEOJSON",
    ISERVER: "ISERVER"
};

/**
 * Constant: GeometryType
 * {Object} 几何对象枚举类。
 * 该类定义了一系列几何对象类型。
 *
 * LINE: "LINE",
 *
 * LINEM: "LINEM",
 *
 * POINT: "POINT",
 *
 * REGION: "REGION",
 *
 * ELLIPSE: "ELLIPSE",
 *
 * CIRCLE: "CIRCLE",
 *
 * TEXT: "TEXT",
 *
 * UNKNOWN: "UNKNOWN".
 */
var GeometryType = exports.GeometryType = _SuperMap2.default.GeometryType = {
    LINE: "LINE",
    LINEM: "LINEM",
    POINT: "POINT",
    REGION: "REGION",
    ELLIPSE: "ELLIPSE",
    CIRCLE: "CIRCLE",
    TEXT: "TEXT",
    UNKNOWN: "UNKNOWN"
};

/**
 * Constant: QueryOption
 * {Object} 查询结果类型枚举类。
 * 该类描述查询结果返回类型，包括只返回属性、只返回几何实体以及返回属性和几何实体。
 *
 * ATTRIBUTE: "ATTRIBUTE",
 *
 * ATTRIBUTEANDGEOMETRY: "ATTRIBUTEANDGEOMETRY",
 *
 * GEOMETRY: "GEOMETRY".
 */
var QueryOption = exports.QueryOption = _SuperMap2.default.QueryOption = {
    ATTRIBUTE: "ATTRIBUTE",
    ATTRIBUTEANDGEOMETRY: "ATTRIBUTEANDGEOMETRY",
    GEOMETRY: "GEOMETRY"
};

/**
 * Constant: JoinType
 * {Object} 关联查询时的关联类型常量。
 * 该类定义了两个表之间的连接类型常量，决定了对两个表之间进行连接查询时，查询结果中得到的记录的情况。
 *
 * INNERJOIN: "INNERJOIN",
 *
 * LEFTJOIN: "LEFTJOIN".
 */
var JoinType = exports.JoinType = _SuperMap2.default.JoinType = {
    INNERJOIN: "INNERJOIN",
    LEFTJOIN: "LEFTJOIN"
};

/**
 * Constant: SpatialQueryMode
 * {Object} 空间查询模式枚举类。
 * 该类定义了空间查询操作模式常量。
 *
 * CONTAIN: "CONTAIN",
 *
 * CROSS: "CROSS",
 *
 * DISJOINT: "DISJOINT",
 *
 * IDENTITY: "IDENTITY",
 *
 * INTERSECT: "INTERSECT",
 *
 * NONE: "NONE",
 *
 * OVERLAP: "OVERLAP",
 *
 * TOUCH: "TOUCH",
 *
 * WITHIN: "WITHIN".
 */
var SpatialQueryMode = exports.SpatialQueryMode = _SuperMap2.default.SpatialQueryMode = {
    CONTAIN: "CONTAIN",
    CROSS: "CROSS",
    DISJOINT: "DISJOINT",
    IDENTITY: "IDENTITY",
    INTERSECT: "INTERSECT",
    NONE: "NONE",
    OVERLAP: "OVERLAP",
    TOUCH: "TOUCH",
    WITHIN: "WITHIN"
};

/**
 * Constant: SpatialRelationType
 * {Object} 数据集对象间的空间关系枚举类。
 * 该类定义了数据集对象间的空间关系类型常量。
 *
 * 包含关系
 * CONTAIN: "CONTAIN",
 *
 * 相交关系
 * INTERSECT: "INTERSECT",
 *
 * 被包含关系
 * WITHIN: "WITHIN"。
 */
var SpatialRelationType = exports.SpatialRelationType = _SuperMap2.default.SpatialRelationType = {
    CONTAIN: "CONTAIN",
    INTERSECT: "INTERSECT",
    WITHIN: "WITHIN"
};

/**
 * Constant: MeasureMode
 * {Object} 量算模式枚举类。
 * 该类定义了两种测量模式：距离测量和面积测量。
 *
 * DISTANCE: "DISTANCE",
 *
 * AREA: "AREA".
 */
var MeasureMode = exports.MeasureMode = _SuperMap2.default.MeasureMode = {
    DISTANCE: "DISTANCE",
    AREA: "AREA"
};

/**
 * Constant: Unit
 * {Object} 距离单位枚举类。
 * 该类定义了一系列距离单位类型。
 *
 * METER: "METER",
 *
 * KILOMETER: "KILOMETER",
 *
 * MILE: "MILE",
 *
 * YARD: "YARD",
 *
 * DEGREE: "DEGREE",
 *
 * MILLIMETER: "MILLIMETER",
 *
 * CENTIMETER: "CENTIMETER",
 *
 * INCH: "INCH",
 *
 * DECIMETER: "DECIMETER",
 *
 * FOOT: "FOOT",
 *
 * SECOND: "SECOND",
 *
 * MINUTE: "MINUTE",
 *
 * RADIAN: "RADIAN".
 */
var Unit = exports.Unit = _SuperMap2.default.Unit = {
    METER: "METER",
    KILOMETER: "KILOMETER",
    MILE: "MILE",
    YARD: "YARD",
    DEGREE: "DEGREE",
    MILLIMETER: "MILLIMETER",
    CENTIMETER: "CENTIMETER",
    INCH: "INCH",
    DECIMETER: "DECIMETER",
    FOOT: "FOOT",
    SECOND: "SECOND",
    MINUTE: "MINUTE",
    RADIAN: "RADIAN"
};

/**
 * Constant: EngineType
 * {Object} 数据源引擎类型枚举类。
 *
 * IMAGEPLUGINS: "IMAGEPLUGINS",
 *
 * OGC: "OGC",
 *
 * ORACLEPLUS: "ORACLEPLUS",
 *
 * SDBPLUS: "SDBPLUS",
 *
 * SQLPLUS: "SQLPLUS",
 *
 * UDB: "UDB"。
 */
var EngineType = exports.EngineType = _SuperMap2.default.EngineType = {
    IMAGEPLUGINS: "IMAGEPLUGINS",
    OGC: "OGC",
    ORACLEPLUS: "ORACLEPLUS",
    SDBPLUS: "SDBPLUS",
    SQLPLUS: "SQLPLUS",
    UDB: "UDB"
};

/**
 * Constant: ThemeGraphTextFormat
 * {Object } 统计专题图文本显示格式枚举类。
 *
 * CAPTION: "CAPTION",
 *
 * CAPTION_PERCENT: "CAPTION_PERCENT",
 *
 * CAPTION_VALUE: "CAPTION_VALUE",
 *
 * PERCENT: "PERCENT",
 *
 * VALUE: "VALUE".
 */
var ThemeGraphTextFormat = exports.ThemeGraphTextFormat = _SuperMap2.default.ThemeGraphTextFormat = {
    CAPTION: "CAPTION",
    CAPTION_PERCENT: "CAPTION_PERCENT",
    CAPTION_VALUE: "CAPTION_VALUE",
    PERCENT: "PERCENT",
    VALUE: "VALUE"
};

/**
 * Constant: ThemeGraphType
 * {Object} 统计专题图类型枚举类。
 *
 * AREA: "AREA",
 *
 * BAR: "BAR",
 *
 * BAR3D: "BAR3D",
 *
 * LINE: "LINE",
 *
 * PIE: "PIE",
 *
 * PIE3D: "PIE3D",
 *
 * POINT: "POINT",
 *
 * RING: "RING",
 *
 * ROSE: "ROSE",
 *
 * ROSE3D: "ROSE3D",
 *
 * STACK_BAR: "STACK_BAR",
 *
 * STACK_BAR3D: "STACK_BAR3D",
 *
 * STEP: "STEP".
 */
var ThemeGraphType = exports.ThemeGraphType = _SuperMap2.default.ThemeGraphType = {
    AREA: "AREA",
    BAR: "BAR",
    BAR3D: "BAR3D",
    LINE: "LINE",
    PIE: "PIE",
    PIE3D: "PIE3D",
    POINT: "POINT",
    RING: "RING",
    ROSE: "ROSE",
    ROSE3D: "ROSE3D",
    STACK_BAR: "STACK_BAR",
    STACK_BAR3D: "STACK_BAR3D",
    STEP: "STEP"
};

/**
 * Constant: GraphAxesTextDisplayMode
 * {Object} 统计专题图坐标轴文本显示模式。
 * ALL: "ALL", 显示全部文本
 *
 * NONE: "NONE", 没有显示
 *
 * YAXES: "YAXES". 显示Y轴的文本
 */
var GraphAxesTextDisplayMode = exports.GraphAxesTextDisplayMode = _SuperMap2.default.GraphAxesTextDisplayMode = {
    ALL: "ALL",
    NONE: "NONE",
    YAXES: "YAXES"
};

/**
 * Constant: GraduatedMode
 * {Object} 专题图分级模式枚举类。 CONSTANT: "CONSTANT",
 *
 * LOGARITHM: "LOGARITHM",
 *
 * SQUAREROOT: "SQUAREROOT".
 */
var GraduatedMode = exports.GraduatedMode = _SuperMap2.default.GraduatedMode = {
    CONSTANT: "CONSTANT",
    LOGARITHM: "LOGARITHM",
    SQUAREROOT: "SQUAREROOT"
};

/**
 * Constant: RangeMode
 * {Object} 范围分段专题图分段方式枚举类。
 *
 * CUSTOMINTERVAL: "CUSTOMINTERVAL",
 *
 * EQUALINTERVAL: "EQUALINTERVAL",
 *
 * LOGARITHM: "LOGARITHM",
 *
 * QUANTILE: "QUANTILE",
 *
 * SQUAREROOT: "SQUAREROOT",
 *
 * STDDEVIATION: "STDDEVIATION".
 */
var RangeMode = exports.RangeMode = _SuperMap2.default.RangeMode = {
    CUSTOMINTERVAL: "CUSTOMINTERVAL",
    EQUALINTERVAL: "EQUALINTERVAL",
    LOGARITHM: "LOGARITHM",
    QUANTILE: "QUANTILE",
    SQUAREROOT: "SQUAREROOT",
    STDDEVIATION: "STDDEVIATION"
};

/**
 * Constant: ThemeType
 * {Object} 专题图类型枚举类。
 *
 * DOTDENSITY: "DOTDENSITY",
 *
 * GRADUATEDSYMBOL: "GRADUATEDSYMBOL",
 *
 * GRAPH: "GRAPH",
 *
 * LABEL: "LABEL",
 *
 * RANGE: "RANGE",
 *
 * UNIQUE: "UNIQUE".
 */
var ThemeType = exports.ThemeType = _SuperMap2.default.ThemeType = {
    DOTDENSITY: "DOTDENSITY",
    GRADUATEDSYMBOL: "GRADUATEDSYMBOL",
    GRAPH: "GRAPH",
    LABEL: "LABEL",
    RANGE: "RANGE",
    UNIQUE: "UNIQUE"
};

/**
 * Constant: ColorGradientType
 * {Object} 渐变颜色枚举类。
 *
 * BLACK_WHITE: "BLACKWHITE",
 *
 * BLUE_BLACK: "BLUEBLACK",
 *
 * BLUE_RED : "BLUERED",
 *
 * BLUE_WHITE: "BLUEWHITE",
 *
 * CYAN_BLACK: "CYANBLACK",
 *
 * CYAN_BLUE: "CYANBLUE",
 *
 * CYAN_GREEN: "CYANGREEN",
 *
 * CYAN_WHITE: "CYANWHITE",
 *
 * GREEN_BLACK: "GREENBLACK",
 *
 * GREEN_BLUE: "GREENBLUE",
 *
 * GREEN_ORANGE_VIOLET: "GREENORANGEVIOLET",
 *
 * GREEN_RED: "GREENRED",
 *
 * GREEN_WHITE: "GREENWHITE",
 *
 * PINK_BLACK: "PINKBLACK",
 *
 * PINK_BLUE: "PINKBLUE",
 *
 * PINK_RED: "PINKRED",
 *
 * PINK_WHITE: "PINKWHITE",
 *
 * RAIN_BOW: "RAINBOW",
 *
 * RED_BLACK: "REDBLACK",
 *
 * RED_WHITE: "REDWHITE",
 *
 * SPECTRUM: "SPECTRUM",
 *
 * TERRAIN: "TERRAIN",
 *
 * YELLOW_BLACK: "YELLOWBLACK",
 *
 * YELLOW_BLUE: "YELLOWBLUE",
 *
 * YELLOW_GREEN: "YELLOWGREEN",
 *
 * YELLOW_RED: "YELLOWRED",
 *
 * YELLOW_WHITE: "YELLOWWHITE".
 */
var ColorGradientType = exports.ColorGradientType = _SuperMap2.default.ColorGradientType = {
    BLACK_WHITE: "BLACKWHITE",
    BLUE_BLACK: "BLUEBLACK",
    BLUE_RED: "BLUERED",
    BLUE_WHITE: "BLUEWHITE",
    CYAN_BLACK: "CYANBLACK",
    CYAN_BLUE: "CYANBLUE",
    CYAN_GREEN: "CYANGREEN",
    CYAN_WHITE: "CYANWHITE",
    GREEN_BLACK: "GREENBLACK",
    GREEN_BLUE: "GREENBLUE",
    GREEN_ORANGE_VIOLET: "GREENORANGEVIOLET",
    GREEN_RED: "GREENRED",
    GREEN_WHITE: "GREENWHITE",
    PINK_BLACK: "PINKBLACK",
    PINK_BLUE: "PINKBLUE",
    PINK_RED: "PINKRED",
    PINK_WHITE: "PINKWHITE",
    RAIN_BOW: "RAINBOW",
    RED_BLACK: "REDBLACK",
    RED_WHITE: "REDWHITE",
    SPECTRUM: "SPECTRUM",
    TERRAIN: "TERRAIN",
    YELLOW_BLACK: "YELLOWBLACK",
    YELLOW_BLUE: "YELLOWBLUE",
    YELLOW_GREEN: "YELLOWGREEN",
    YELLOW_RED: "YELLOWRED",
    YELLOW_WHITE: "YELLOWWHITE"
};

/**
 * Constant: TextAlignment
 * {Object} 文本对齐枚举类。
 *
 * TOPLEFT: "TOPLEFT",
 *
 * TOPCENTER: "TOPCENTER",
 *
 * TOPRIGHT: "TOPRIGHT",
 *
 * BASELINELEFT: "BASELINELEFT",
 *
 * BASELINECENTER: "BASELINECENTER",
 *
 * BASELINERIGHT: "BASELINERIGHT",
 *
 * BOTTOMLEFT: "BOTTOMLEFT",
 *
 * BOTTOMCENTER: "BOTTOMCENTER",
 *
 * BOTTOMRIGHT: "BOTTOMRIGHT",
 *
 * MIDDLELEFT: "MIDDLELEFT",
 *
 * MIDDLECENTER: "MIDDLECENTER",
 *
 * MIDDLERIGHT: "MIDDLERIGHT".
 */
var TextAlignment = exports.TextAlignment = _SuperMap2.default.TextAlignment = {
    TOPLEFT: "TOPLEFT",
    TOPCENTER: "TOPCENTER",
    TOPRIGHT: "TOPRIGHT",
    BASELINELEFT: "BASELINELEFT",
    BASELINECENTER: "BASELINECENTER",
    BASELINERIGHT: "BASELINERIGHT",
    BOTTOMLEFT: "BOTTOMLEFT",
    BOTTOMCENTER: "BOTTOMCENTER",
    BOTTOMRIGHT: "BOTTOMRIGHT",
    MIDDLELEFT: "MIDDLELEFT",
    MIDDLECENTER: "MIDDLECENTER",
    MIDDLERIGHT: "MIDDLERIGHT"
};

/**
 * Constant: FillGradientMode
 * {Object} 渐变填充风格的渐变类型枚举类。
 *
 * NONE: "NONE",
 *
 * LINEAR: "LINEAR",
 *
 * RADIAL: "RADIAL",
 *
 * CONICAL: "CONICAL",
 *
 * SQUARE: "SQUARE".
 */
var FillGradientMode = exports.FillGradientMode = _SuperMap2.default.FillGradientMode = {
    NONE: "NONE",
    LINEAR: "LINEAR",
    RADIAL: "RADIAL",
    CONICAL: "CONICAL",
    SQUARE: "SQUARE"
};

/**
 * Constant: AlongLineDirection
 * {Object} 标签沿线标注方向枚举类。
 *
 * NORMAL: "ALONG_LINE_NORMAL",
 *
 * LB_TO_RT: "LEFT_BOTTOM_TO_RIGHT_TOP",
 *
 * LT_TO_RB: "LEFT_TOP_TO_RIGHT_BOTTOM",
 *
 * RB_TO_LT: "RIGHT_BOTTOM_TO_LEFT_TOP",
 *
 * RT_TO_LB: "RIGHT_TOP_TO_LEFT_BOTTOM".
 */
var AlongLineDirection = exports.AlongLineDirection = _SuperMap2.default.AlongLineDirection = {
    NORMAL: "ALONG_LINE_NORMAL",
    LB_TO_RT: "LEFT_BOTTOM_TO_RIGHT_TOP",
    LT_TO_RB: "LEFT_TOP_TO_RIGHT_BOTTOM",
    RB_TO_LT: "RIGHT_BOTTOM_TO_LEFT_TOP",
    RT_TO_LB: "RIGHT_TOP_TO_LEFT_BOTTOM"
};

/**
 * Constant: LabelBackShape
 * {Object} 标签专题图中标签背景的形状枚举类。
 *
 * DIAMOND: "DIAMOND",
 *
 * ELLIPSE: "ELLIPSE",
 *
 * MARKER: "MARKER",
 *
 * NONE: "NONE",
 *
 * RECT: "RECT",
 *
 * ROUNDRECT: "ROUNDRECT",
 *
 * TRIANGLE: "TRIANGLE".
 */
var LabelBackShape = exports.LabelBackShape = _SuperMap2.default.LabelBackShape = {
    DIAMOND: "DIAMOND",
    ELLIPSE: "ELLIPSE",
    MARKER: "MARKER",
    NONE: "NONE",
    RECT: "RECT",
    ROUNDRECT: "ROUNDRECT",
    TRIANGLE: "TRIANGLE"
};

/**
 * Constant: LabelOverLengthMode
 * {Object} 标签专题图中超长标签的处理模式枚举类。
 *
 * NEWLINE: "NEWLINE",
 *
 * NONE: "NONE",
 *
 * OMIT: "OMIT".
 */
var LabelOverLengthMode = exports.LabelOverLengthMode = _SuperMap2.default.LabelOverLengthMode = {
    NEWLINE: "NEWLINE",
    NONE: "NONE",
    OMIT: "OMIT"
};

/**
 * Constant: DirectionType
 * {Object} 网络分析中方向枚举类。
 * 在行驶引导子项中使用。
 *
 * EAST: "EAST",
 *
 * NONE: "NONE",
 *
 * NORTH: "NORTH",
 *
 * SOURTH: "SOURTH",
 *
 * WEST: "WEST".
 */
var DirectionType = exports.DirectionType = _SuperMap2.default.DirectionType = {
    EAST: "EAST",
    NONE: "NONE",
    NORTH: "NORTH",
    SOURTH: "SOURTH",
    WEST: "WEST"
};

/**
 * Constant: SideType
 * {Object} 行驶位置枚举类。
 * 表示在行驶在路的左边、右边或者路上的枚举,该类用在行驶导引子项类中。
 *
 * LEFT: "LEFT",
 *
 * MIDDLE: "MIDDLE",
 *
 * NONE: "NONE",
 *
 * RIGHT: "RIGHT".
 */
var SideType = exports.SideType = _SuperMap2.default.SideType = {
    LEFT: "LEFT",
    MIDDLE: "MIDDLE",
    NONE: "NONE",
    RIGHT: "RIGHT"
};

/**
 * Constant: SupplyCenterType
 * {Object} 资源供给中心类型枚举类。
 * 该枚举类定义了网络分析中资源中心点的类型，主要用于资源分配和选址分区。
 * 资源供给中心点的类型包括非中心，固定中心和可选中心。固定中心用于资源分配分析； 固定中心和可选中心用于选址分析；非中心在两种网络分析时都不予考虑。
 *
 * FIXEDCENTER: "FIXEDCENTER",
 *
 * NULL: "NULL",
 *
 * OPTIONALCENTER: "OPTIONALCENTER".
 */
var SupplyCenterType = exports.SupplyCenterType = _SuperMap2.default.SupplyCenterType = {
    FIXEDCENTER: "FIXEDCENTER",
    NULL: "NULL",
    OPTIONALCENTER: "OPTIONALCENTER"
};

/**
 * Constant: TurnType
 * {Object} 转弯方向枚举类。
 * 用在行驶引导子项类中，表示转弯的方向。
 *
 * AHEAD: "AHEAD",
 *
 * BACK: "BACK",
 *
 * END: "END",
 *
 * LEFT: "LEFT",
 *
 * NONE: "NONE",
 *
 * RIGHT: "RIGHT".
 */
var TurnType = exports.TurnType = _SuperMap2.default.TurnType = {
    AHEAD: "AHEAD",
    BACK: "BACK",
    END: "END",
    LEFT: "LEFT",
    NONE: "NONE",
    RIGHT: "RIGHT"
};

/**
 * Constant: BufferEndType
 * {Object} 缓冲区分析BufferEnd类型。
 *
 * FLAT: "FLAT",
 *
 * ROUND: "ROUND".
 */
var BufferEndType = exports.BufferEndType = _SuperMap2.default.BufferEndType = {
    FLAT: "FLAT",
    ROUND: "ROUND"
};

/**
 * Constant: OverlayOperationType
 * {Object} 叠加分析类型枚举。
 *
 * CLIP: "CLIP",
 *
 * ERASE: "ERASE",
 *
 * IDENTITY: "IDENTITY",
 *
 * INTERSECT: "INTERSECT",
 *
 * UNION: "UNION",
 *
 * UPDATE: "UPDATE",
 *
 * XOR: "XOR".
 */
var OverlayOperationType = exports.OverlayOperationType = _SuperMap2.default.OverlayOperationType = {
    CLIP: "CLIP",
    ERASE: "ERASE",
    IDENTITY: "IDENTITY",
    INTERSECT: "INTERSECT",
    UNION: "UNION",
    UPDATE: "UPDATE",
    XOR: "XOR"
};

/**
 * Constant: SmoothMethod
 * {Object} 光滑方法枚举类。
 * 用于从Grid 或DEM数据生成等值线或等值面时对等值线或者等值面的边界线进行平滑处理的方法。
 *
 * BSPLINE: "BSPLINE",
 *
 * POLISH: "POLISH".
 */
var SmoothMethod = exports.SmoothMethod = _SuperMap2.default.SmoothMethod = {
    BSPLINE: "BSPLINE",
    POLISH: "POLISH"
};

/**
 * Constant: SurfaceAnalystMethod
 * {Object} 表面分析方法枚举类。
 * 通过对数据进行表面分析，能够挖掘原始数据所包含的信息，使某些细节明显化，易于分析。
 *
 * ISOLINE: "ISOLINE",
 *
 * ISOREGION: "ISOREGION".
 */
var SurfaceAnalystMethod = exports.SurfaceAnalystMethod = _SuperMap2.default.SurfaceAnalystMethod = {
    ISOLINE: "ISOLINE",
    ISOREGION: "ISOREGION"
};
/**
 * Constant: DataReturnMode
 * {Object} 数据返回模式枚举类。
 * 该枚举类用于指定空间分析返回结果模式,包含返回数据集标识和记录集、只返回数据集标识(数据集名称@数据源名称)及只返回记录集三种模式。
 *
 * DATASET_AND_RECORDSET: "DATASET_AND_RECORDSET",
 *
 * DATASET_ONLY: "DATASET_ONLY",
 *
 * RECORDSET_ONLY: "RECORDSET_ONLY".
 */
var DataReturnMode = exports.DataReturnMode = _SuperMap2.default.DataReturnMode = {
    DATASET_AND_RECORDSET: "DATASET_AND_RECORDSET",
    DATASET_ONLY: "DATASET_ONLY",
    RECORDSET_ONLY: "RECORDSET_ONLY"
};

/**
 * Constant: EditType
 * {Object} 要素集更新模式枚举类。
 * 该枚举类用于指定数据服务中要素集更新模式,包含添加要素集、更新要素集和删除要素集。
 *
 * ADD: "add",
 *
 * UPDATE: "update",
 *
 * DELETE: "delete".
 */
var EditType = exports.EditType = _SuperMap2.default.EditType = {
    ADD: "add",
    UPDATE: "update",
    DELETE: "delete"
};

/**
 * Constant: TransferTactic
 * {Object} 公交换乘策略枚举类。
 * 该枚举类用于指定公交服务中要素集更新模式,包含添加要素集、更新要素集和删除要素集。
 *
 * LESS_TIME: "LESS_TIME",
 *
 * LESS_TRANSFER: "LESS_TRANSFER",
 *
 * LESS_WALK: "LESS_WALK",
 *
 * MIN_DISTANCE: "MIN_DISTANCE"
 */
var TransferTactic = exports.TransferTactic = _SuperMap2.default.TransferTactic = {
    LESS_TIME: "LESS_TIME",
    LESS_TRANSFER: "LESS_TRANSFER",
    LESS_WALK: "LESS_WALK",
    MIN_DISTANCE: "MIN_DISTANCE"
};

/**
 * Constant: TransferPreference
 * {Object} 公交换乘策略枚举类。
 * 该枚举类用于指定交通换乘服务中设置地铁优先、公交优先、不乘地铁、无偏好等偏好设置。
 *
 * BUS: "BUS",
 *
 * SUBWAY: "SUBWAY",
 *
 * NO_SUBWAY: "NO_SUBWAY",
 *
 * NONE: "NONE"
 */
var TransferPreference = exports.TransferPreference = _SuperMap2.default.TransferPreference = {
    BUS: "BUS",
    SUBWAY: "SUBWAY",
    NO_SUBWAY: "NO_SUBWAY",
    NONE: "NONE"
};

/**
 * Constant: GridType
 * {Object} 地图背景格网类型枚举类。
 *
 * CROSS: "CROSS",
 *
 * GRID: "GRID",
 *
 * POINT: "POINT"
 */
var GridType = exports.GridType = _SuperMap2.default.GridType = {
    CROSS: "CROSS",
    GRID: "GRID",
    POINT: "POINT"
};

/**
 * Constant: ColorSpaceType
 * {Object} 色彩空间枚举。
 * 由于成色原理的不同，决定了显示器、投影仪这类靠色光直接合成颜色的颜色设备和打印机、
 * 印刷机这类靠使用颜料的印刷设备在生成颜色方式上的区别。
 * 针对上述不同成色方式，SuperMap 提供两种色彩空间，
 * 分别为 RGB 和 CMYK。RGB 主要用于显示系统中，CMYK 主要用于印刷系统中。
 *
 * CMYK: "CMYK",
 *
 * RGB: "RGB"
 */
var ColorSpaceType = exports.ColorSpaceType = _SuperMap2.default.ColorSpaceType = {
    CMYK: "CMYK",
    RGB: "RGB"
};

/**
 * Constant: LayerType
 * {Object} 图层类型。
 *
 * UGC: "UGC",
 *
 * WMS: "WMS"
 *
 * WFS: "WFS",
 *
 * CUSTOM: "CUSTOM"
 */
var LayerType = exports.LayerType = _SuperMap2.default.LayerType = {
    UGC: "UGC",
    WMS: "WMS",
    WFS: "WFS",
    CUSTOM: "CUSTOM"

};

/**
 * Constant: StatisticMode
 * {Object} 字段统计方法类型。
 *
 * AVERAGE: "AVERAGE", 统计所选字段的平均值
 *
 * MAX: "MAX", 统计所选字段的最大值
 *
 * MIN: "MIN", 统计所选字段的最小值
 *
 * STDDEVIATION: "STDDEVIATION", 统计所选字段的标准差
 *
 * SUM: "SUM", 统计所选字段的总和
 *
 * VARIANCE: "VARIANCE", 统计所选字段的方差
 */
var StatisticMode = exports.StatisticMode = _SuperMap2.default.StatisticMode = {
    AVERAGE: "AVERAGE",
    MAX: "MAX",
    MIN: "MIN",
    STDDEVIATION: "STDDEVIATION",
    SUM: "SUM",
    VARIANCE: "VARIANCE"
};

/**
 * Constant: PixelFormat
 * {Object} 栅格与影像数据存储的像素格式枚举类。
 *
 * BIT16: "BIT16", 每个像元用16个比特(即2个字节)表示
 *
 * BIT32: "BIT32", 每个像元用32个比特(即4个字节)表示
 *
 * BIT64: "BIT64", 每个像元用64个比特(即8个字节)表示，只提供给栅格数据集使用
 *
 * SINGLE: "SINGLE", 每个像元用4个字节来表示，只提供给栅格数据集使用
 *
 * DOUBLE: "DOUBLE", 每个像元用8个字节来表示，只提供给栅格数据集使用
 *
 * UBIT1: "UBIT1", 每个像元用1个比特表示
 *
 * UBIT4: "UBIT4", 每个像元用4个比特来表示
 *
 * UBIT8: "UBIT8", 每个像元用8个比特(即1个字节)来表示
 *
 * UBIT24: "UBIT24", 每个像元用24个比特(即3个字节)来表示
 *
 * UBIT32: "UBIT32", 每个像元用32个比特(即4个字节)来表示
 */
var PixelFormat = exports.PixelFormat = _SuperMap2.default.PixelFormat = {
    BIT16: "BIT16",
    BIT32: "BIT32",
    BIT64: "BIT64",
    SINGLE: "SINGLE",
    DOUBLE: "DOUBLE",
    UBIT1: "UBIT1",
    UBIT4: "UBIT4",
    UBIT8: "UBIT8",
    UBIT24: "UBIT24",
    UBIT32: "UBIT32"
};

/**
 * Constant: SearchMode
 * {Object} 内插时使用的样本点的查找方式枚举
 *
 * KDTREE_FIXED_COUNT: "KDTREE_FIXED_COUNT", 使用 KDTREE 的固定点数方式查找参与内插分析的点
 *
 * KDTREE_FIXED_RADIUS: "KDTREE_FIXED_RADIUS", 使用 KDTREE 的定长方式查找参与内插分析的点
 *
 * NONE: "NONE", 不进行查找，使用所有的输入点进行内插分析
 *
 * QUADTREE: "QUADTREE", 使用 QUADTREE 方式查找参与内插分析的点，仅对样条（RBF）插值和普通克吕金（Kriging）有用
 */
var SearchMode = exports.SearchMode = _SuperMap2.default.SearchMode = {
    KDTREE_FIXED_COUNT: "KDTREE_FIXED_COUNT",
    KDTREE_FIXED_RADIUS: "KDTREE_FIXED_RADIUS",
    NONE: "NONE",
    QUADTREE: "QUADTREE"
};

/**
 * Constant: InterpolationAlgorithmType
 * {Object} 插值分析的算法的类型
 *
 * KRIGING: "KRIGING", 普通克吕金插值法
 *
 * SimpleKriging: "SimpleKriging", 简单克吕金插值法
 *
 * UniversalKriging: "UniversalKriging", 泛克吕金插值法
 */
var InterpolationAlgorithmType = exports.InterpolationAlgorithmType = _SuperMap2.default.InterpolationAlgorithmType = {
    KRIGING: "KRIGING",
    SimpleKriging: "SimpleKriging",
    UniversalKriging: "UniversalKriging"
};

/**
 * Constant: VariogramMode
 * {Object} 克吕金（Kriging）插值时的半变函数类型枚举
 *
 * EXPONENTIAL: "EXPONENTIAL", 指数函数（Exponential Variogram Mode）
 *
 * GAUSSIAN: "GAUSSIAN",  高斯函数（Gaussian Variogram Mode）
 *
 * SPHERICAL: "SPHERICAL", 球型函数（Spherical Variogram Mode）
 */
var VariogramMode = exports.VariogramMode = _SuperMap2.default.VariogramMode = {
    EXPONENTIAL: "EXPONENTIAL",
    GAUSSIAN: "GAUSSIAN",
    SPHERICAL: "SPHERICAL"
};

/**
 * Constant: Exponent
 * {Object} 定义了泛克吕金（UniversalKriging）插值时样点数据中趋势面方程的阶数
 *
 * EXP1: "EXP1", 阶数为1
 *
 * EXP2: "EXP2", 阶数为2
 */
var Exponent = exports.Exponent = _SuperMap2.default.Exponent = {
    EXP1: "EXP1",
    EXP2: "EXP2"
};
var ServerType = exports.ServerType = _SuperMap2.default.ServerType = {
    ISERVER: "ISERVER",
    IPORTAL: "IPORTAL",
    ONLINE: "ONLINE"
};
/**
 * token申请的客户端标识类型
 * @type {{IP: string, REFERER: string, REQUESTIP: string, NONE: string}}
 */
var ClientType = exports.ClientType = _SuperMap2.default.ClientType = {
    IP: "IP",
    REFERER: "Referer",
    REQUESTIP: "RequestIP",
    NONE: "NONE",
    SERVER: "SERVER",
    WEB: "WEB"
};
/**
 * 客户端专题图图表类型
 * @type {{BAR: string, BAR3D: string, CIRCLE: string, PIE: string, POINT: string, LINE: string, RING: string}}
 */
var ChartType = exports.ChartType = _SuperMap2.default.ChartType = {
    BAR: "Bar",
    BAR3D: "Bar3D",
    CIRCLE: "Circle",
    PIE: "Pie",
    POINT: "Point",
    LINE: "Line",
    RING: "Ring"
};
/**
 * 裁剪分析模式
 * @type {{CLIP: string, INTERSECT: string}}
 */
var ClipAnalystMode = exports.ClipAnalystMode = _SuperMap2.default.ClipAnalystMode = {
    CLIP: "clip",
    INTERSECT: "intersect"
};
/**
 * 分布式分析面积单位
 * @type {{SQUAREMETER: string, SQUAREKILOMETER: string, HECTARE: string, ARE: string, ACRE: string, SQUAREFOOT: string, SQUAREYARD: string, SQUAREMILE: string}}
 */
var AnalystAreaUnit = exports.AnalystAreaUnit = _SuperMap2.default.AnalystAreaUnit = {
    "SQUAREMETER": "SquareMeter",
    "SQUAREKILOMETER": "SquareKiloMeter",
    "HECTARE": "Hectare",
    "ARE": "Are",
    "ACRE": "Acre",
    "SQUAREFOOT": "SquareFoot",
    "SQUAREYARD": "SquareYard",
    "SQUAREMILE": "SquareMile"
};
/**
 * 分布式分析单位
 * @type {{METER: string, KILOMETER: string, YARD: string, FOOT: string, MILE: string}}
 */
var AnalystSizeUnit = exports.AnalystSizeUnit = _SuperMap2.default.AnalystSizeUnit = {
    "METER": "Meter",
    "KILOMETER": "Kilometer",
    "YARD": "Yard",
    "FOOT": "Foot",
    "MILE": "Mile"
};
/**
 * 分布式分析统计模式
 * @type {{MAX: string, MIN: string, AVERAGE: string, SUM: string, VARIANCE: string, STDDEVIATION: string}}
 */
var StatisticAnalystMode = exports.StatisticAnalystMode = _SuperMap2.default.StatisticAnalystMode = {
    "MAX": "max",
    "MIN": "min",
    "AVERAGE": "average",
    "SUM": "sum",
    "VARIANCE": "variance",
    "STDDEVIATION": "stdDeviation"
};
/**
 * 分布式分析聚合类型
 * @type {{SUMMARYMESH: string, SUMMARYREGION: string}}
 */
var SummaryType = exports.SummaryType = _SuperMap2.default.SummaryType = {
    "SUMMARYMESH": "SUMMARYMESH",
    "SUMMARYREGION": "SUMMARYREGION"

};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FetchRequest = __webpack_require__(41);

__webpack_require__(155);

__webpack_require__(153);

__webpack_require__(271);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.CommonServiceBase
 * @classdesc common服务基类
 * @param url - {string} 与客户端交互的服务地址。
 * @param options - {Object} 参数。如：<br>
 *        events - {SuperMap.Events} 处理所有事件的对象。<br>
 *        eventListeners - {Object} 听器对象。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        index - {number}服务访问地址在数组中的位置。<br>
 *        length - {number}服务访问地址数组长度。
 */
var CommonServiceBase = function () {

    /*
     * Property: _processFailed
     * {Function} 请求参数中失败回调函数。
     */


    /**
     * @member SuperMap.CommonServiceBase.prototype.POLLING_TIMES -{Integer}
     * @description 默认请求失败次数。
     */


    /**
     * @member SuperMap.CommonServiceBase.prototype.options -{Object}
     * @description 请求参数。
     */


    /**
     * @member SuperMap.CommonServiceBase.prototype.index -{number}
     * @description 服务访问地址在数组中的位置。
     */


    /**
     * @member SuperMap.CommonServiceBase.prototype.urls -{Array}
     * @description 服务访问地址数组。
     */


    /*
     * @member SuperMap.CommonServiceBase.prototype.eventListeners -{Object}
     * @description: 听器对象，在构造函数中设置此参数（可选），对 MapService 支持的两个事件 processCompleted 、processFailed 进行监听，相当于调用 SuperMap.Events.on(eventListeners)。
     */


    /*
     * @constant: EVENT_TYPES- {Array<string>}
     * @description 此类支持的事件类型
     * - *processCompleted* 服务端返回信息成功触发该事件 。
     * - *processFailed* 服务端返回信息失败触发该事件 。
     */
    function CommonServiceBase(url, options) {
        _classCallCheck(this, CommonServiceBase);

        this.EVENT_TYPES = ["processCompleted", "processFailed"];
        this.events = null;
        this.eventListeners = null;
        this.url = null;
        this.urls = null;
        this.serverType = null;
        this.index = null;
        this.length = null;
        this.options = null;
        this.totalTimes = null;
        this.POLLING_TIMES = 3;
        this._processSuccess = null;
        this._processFailed = null;
        this.isInTheSameDomain = null;
        this.CLASS_NAME = "SuperMap.CommonServiceBase";

        var me = this;

        if (_SuperMap2.default.Util.isArray(url)) {
            me.urls = url;
            me.length = url.length;
            me.totalTimes = me.length;
            if (me.length === 1) {
                me.url = url[0];
            } else {
                me.index = parseInt(Math.random() * me.length);
                me.url = url[me.index];
            }
        } else {
            me.totalTimes = 1;
            me.url = url;
        }

        if (_SuperMap2.default.Util.isArray(url) && !me.isServiceSupportPolling()) {
            me.url = url[0];
            me.totalTimes = 1;
        }

        me.serverType = me.serverType || _SuperMap2.default.ServerType.ISERVER;

        options = options || {};

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }

        me.isInTheSameDomain = _SuperMap2.default.Util.isInTheSameDomain(me.url);

        me.events = new _SuperMap2.default.Events(me, null, me.EVENT_TYPES, true);
        if (me.eventListeners instanceof Object) {
            me.events.on(me.eventListeners);
        }
    }

    /**
     * @function SuperMap.CommonServiceBase.prototype.destroy
     * @description: 释放资源，将引用的资源属性置空。
     */


    /**
     * @member SuperMap.CommonServiceBase.prototype.isInTheSameDomain -{boolean}
     * @description 是否在同一领域内
     */


    /*
     * @member SuperMap.CommonServiceBase.prototype._processSuccess -{Function}
     * @description 请求参数中成功回调函数。
     */


    /**
     *  @member SuperMap.CommonServiceBase.prototype.totalTimes -{Integer}
     *  @description 实际请求失败次数。
     */


    /**
     * @member SuperMap.CommonServiceBase.prototype.length -{number}
     * @description 服务访问地址数组长度。
     */


    /**
     * @member SuperMap.CommonServiceBase.prototype.serverType -{SuperMap.ServerType}
     * @description 服务器类型，iServer|iPortal|Online
     */


    /*
     * @member SuperMap.CommonServiceBase.prototype.url -{string}|{Array}
     * @description: 服务访问地址或者服务访问地址数组。
     * @example
     * var url1 = "http://localhost:8090/iserver/services/map-world/rest/maps/World";
     * var url2 = ["http://192.168.17.168:8090/iserver/services/map-world/rest/maps/World",
     *            "http://192.168.17.169:8091/iserver/services/map-world/rest/maps/World"];
     */


    /*
     * @member SuperMap.CommonServiceBase.prototype.events -{SuperMap.Events}
     * @description: 处理所有事件的对象，支持processCompleted 、processFailed 两种事件
     *               服务端成功返回地图信息结果时触发 processCompleted事件，服务端返回信息结果时触发 processFailed 事件。
     */


    _createClass(CommonServiceBase, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (_SuperMap2.default.Util.isArray(me.urls)) {
                me.urls = null;
                me.index = null;
                me.length = null;
                me.totalTimes = null;
            }
            me.url = null;
            me.options = null;
            me._processSuccess = null;
            me._processFailed = null;
            me.isInTheSameDomain = null;

            me.EVENT_TYPES = null;
            if (me.events) {
                me.events.destroy();
                me.events = null;
            }
            if (me.eventListeners) {
                me.eventListeners = null;
            }
        }

        /**
         * @function  SuperMap.CommonServiceBase.prototype.request
         * @description: 该方法用于向服务发送请求。
         * @param options - {Object} 参数。
         *        method - {string} 请求方式，包括GET，POST，PUT， DELETE。<br>
         *        url - {string}  发送请求的地址。<br>
         *        params - {Object} 作为查询字符串添加到url中的一组键值对，此参数只适用于GET方式发送的请求。<br>
         *        data - {String } 发送到服务器的数据。<br>
         *        success - {function} 请求成功后的回调函数。<br>
         *        failure - {function} 请求失败后的回调函数。<br>
         *        scope - {Object} 如果回调函数是对象的一个公共方法，设定该对象的范围。<br>
         *        isInTheSameDomain - {boolean} 请求是否在当前域中。<br>
         */

    }, {
        key: 'request',
        value: function request(options) {
            var me = this;
            options.url = options.url || me.url;
            options.isInTheSameDomain = me.isInTheSameDomain;
            //为url添加安全认证信息片段
            var credential = this.getCredential(options.url);
            if (credential) {
                //当url中含有?，并且?在url末尾的时候直接添加token *网络分析等服务请求url会出现末尾是?的情况*
                //当url中含有?，并且?不在url末尾的时候添加&token
                //当url中不含有?，在url末尾添加?token
                var endStr = options.url.substring(options.url.length - 1, options.url.length);
                if (options.url.indexOf("?") > -1 && endStr === "?") {
                    options.url += credential.getUrlParameters();
                } else if (options.url.indexOf("?") > -1 && endStr !== "?") {
                    options.url += "&" + credential.getUrlParameters();
                } else {
                    options.url += "?" + credential.getUrlParameters();
                }
            }
            me.calculatePollingTimes();
            me._processSuccess = options.success;
            me._processFailed = options.failure;
            options.scope = me;
            options.success = me.getUrlCompleted;
            options.failure = me.getUrlFailed;
            me.options = options;
            me._commit(me.options);
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.getCredential
         * @description  获取凭据信息
         * @param url - {string} 服务地址。
         */

    }, {
        key: 'getCredential',
        value: function getCredential(url) {
            var keyUrl = url,
                credential = void 0,
                value = void 0;
            switch (this.serverType) {
                case _SuperMap2.default.ServerType.ISERVER:
                    value = _SuperMap2.default.SecurityManager.getToken(keyUrl);
                    credential = value ? new _SuperMap2.default.Credential(value, "token") : null;
                    break;
                case _SuperMap2.default.ServerType.IPORTAL:
                    value = _SuperMap2.default.SecurityManager.getToken(keyUrl);
                    credential = value ? new _SuperMap2.default.Credential(value, "token") : null;
                    if (!credential) {
                        value = _SuperMap2.default.SecurityManager.getKey(keyUrl);
                        credential = value ? new _SuperMap2.default.Credential(value, "key") : null;
                    }
                    break;
                case _SuperMap2.default.ServerType.ONLINE:
                    value = _SuperMap2.default.SecurityManager.getKey(keyUrl);
                    credential = value ? new _SuperMap2.default.Credential(value, "key") : null;
                    break;
                default:
                    value = _SuperMap2.default.SecurityManager.getToken(keyUrl);
                    credential = value ? new _SuperMap2.default.Credential(value, "token") : null;
                    break;
            }
            return credential;
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.getUrlCompleted
         * @description 请求成功后执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'getUrlCompleted',
        value: function getUrlCompleted(result) {
            var me = this;
            me._processSuccess(result);
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.getUrlFailed
         * @description 请求失败后执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'getUrlFailed',
        value: function getUrlFailed(result) {
            var me = this;
            if (me.totalTimes > 0) {
                me.totalTimes--;
                me.ajaxPolling();
            } else {
                me._processFailed(result);
            }
        }

        /**
         *
         * @function SuperMap.CommonServiceBase.prototype.ajaxPolling
         * @description 请求失败后，如果剩余请求失败次数不为0，重新获取url发送请求
         */

    }, {
        key: 'ajaxPolling',
        value: function ajaxPolling() {
            var me = this,
                url = me.options.url,
                re = /^http:\/\/([a-z]{9}|(\d+\.){3}\d+):\d{0,4}/;
            me.index = parseInt(Math.random() * me.length);
            me.url = me.urls[me.index];
            url = url.replace(re, re.exec(me.url)[0]);
            me.options.url = url;
            me.options.isInTheSameDomain = _SuperMap2.default.Util.isInTheSameDomain(url);
            me._commit(me.options);
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.calculatePollingTimes
         * @description 计算剩余请求失败执行次数。
         */

    }, {
        key: 'calculatePollingTimes',
        value: function calculatePollingTimes() {
            var me = this;
            if (me.times) {
                if (me.totalTimes > me.POLLING_TIMES) {
                    if (me.times > me.POLLING_TIMES) {
                        me.totalTimes = me.POLLING_TIMES;
                    } else {
                        me.totalTimes = me.times;
                    }
                } else {
                    if (me.times < me.totalTimes) {
                        me.totalTimes = me.times;
                    }
                }
            } else {
                if (me.totalTimes > me.POLLING_TIMES) {
                    me.totalTimes = me.POLLING_TIMES;
                }
            }
            me.totalTimes--;
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.isServiceSupportPolling
         * @description 判断服务是否支持轮询。
         */

    }, {
        key: 'isServiceSupportPolling',
        value: function isServiceSupportPolling() {
            var me = this;
            return !(me.CLASS_NAME === "SuperMap.REST.ThemeService" || me.CLASS_NAME === "SuperMap.REST.EditFeaturesService");
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.serviceProcessCompleted
         * @description 状态完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            result = _SuperMap2.default.Util.transformResult(result);
            this.events.triggerEvent("processCompleted", { result: result });
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.serviceProcessFailed
         * @description 状态失败，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessFailed',
        value: function serviceProcessFailed(result) {
            result = _SuperMap2.default.Util.transformResult(result);
            var error = result.error || result;
            this.events.triggerEvent("processFailed", { error: error });
        }
    }, {
        key: '_commit',
        value: function _commit(options) {
            if (options.method === "POST" || options.method === "PUT") {
                if (options.params) {
                    options.url = _SuperMap2.default.Util.urlAppend(options.url, _SuperMap2.default.Util.getParameterString(options.params || {}));
                }
                options.params = options.data;
            }
            _FetchRequest.FetchRequest.commit(options.method, options.url, options.params, {
                headers: options.headers,
                withCredentials: options.withCredentials,
                timeout: options.async ? 0 : null,
                proxy: options.proxy
            }).then(function (response) {
                return response.text();
            }).then(function (text) {
                var result = new _SuperMap2.default.Format.JSON().read(text);
                if (!result) {
                    result = { error: text };
                }
                if (result.error) {
                    var failure = options.scope ? _SuperMap2.default.Function.bind(options.failure, options.scope) : options.failure;
                    failure(result.error);
                } else {
                    result.succeed = result.succeed == undefined ? true : result.succeed;
                    var success = options.scope ? _SuperMap2.default.Function.bind(options.success, options.scope) : options.success;
                    success(result);
                }
            });
        }
    }]);

    return CommonServiceBase;
}();

exports.default = CommonServiceBase;


_SuperMap2.default.CommonServiceBase = CommonServiceBase;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;
var sign = __webpack_require__(36);

module.exports = function(x) {
  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Util = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

__webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Util = exports.Util = _SuperMap2.default.Util = _SuperMap2.default.Util || {};
/**
 * @name Util
 * @memberOf SuperMap
 * @namespace
 * @description common工具类
 */

/**
 * @description 复制源对象的所有属性到目标对象上，源对象上的没有定义的属性在目标对象上也不会被设置。
 * @example
 * 要复制SuperMap.Size对象的所有属性到自定义对象上，使用方法如下:
 *     var size = new SuperMap.Size(100, 100);
 *     var obj = {}；
 *     SuperMap.Util.extend(obj, size);
 * @param destination - {Object} 目标对象。
 * @param source - {Object} 源对象，其属性将被设置到目标对象上。
 * @returns {Object} 目标对象。
 */

_SuperMap2.default.Util.extend = function (destination, source) {
    destination = destination || {};
    if (source) {
        for (var property in source) {
            var value = source[property];
            if (value !== undefined) {
                destination[property] = value;
            }
        }

        /**
         * IE doesn't include the toString property when iterating over an object's
         * properties with the for(property in object) syntax.  Explicitly check if
         * the source has its own toString property.
         */

        /*
         * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
         * prototype object" when calling hawOwnProperty if the source object
         * is an instance of window.Event.
         */

        var sourceIsEvt = typeof window.Event === "function" && source instanceof window.Event;

        if (!sourceIsEvt && source.hasOwnProperty && source.hasOwnProperty("toString")) {
            destination.toString = source.toString;
        }
    }
    return destination;
};
/**
 * @description 对象拷贝
 * @param des - {Object} 目标对象。
 * @param soc - {Object} 源对象
 */
_SuperMap2.default.Util.copy = function (des, soc) {
    des = des || {};
    var v;
    if (soc) {
        for (var p in des) {
            v = soc[p];
            if (typeof v !== 'undefined') {
                des[p] = v;
            }
        }
    }
};
/**
 * @description 销毁对象，将其属性置空
 * @param obj - {Object} 目标对象。
 */
_SuperMap2.default.Util.reset = function (obj) {
    obj = obj || {};
    for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
            if (_typeof(obj[p]) === "object" && obj[p] instanceof Array) {
                for (var i in obj[p]) {
                    if (obj[p][i].destroy) {
                        obj[p][i].destroy();
                    }
                }
                obj[p].length = 0;
            } else if (_typeof(obj[p]) === "object" && obj[p] instanceof Object) {
                if (obj[p].destroy) {
                    obj[p].destroy();
                }
            }
            obj[p] = null;
        }
    }
};

/**
 * @description This is the old $() from prototype
 * @param argument - {String | HTMLElement | Window}
 * @returns {Array<HTMLElement>}
 */
_SuperMap2.default.Util.getElement = function () {
    var elements = [];

    for (var i = 0, len = arguments.length; i < len; i++) {
        var element = arguments[i];
        if (typeof element === 'string') {
            element = document.getElementById(element);
        }
        if (arguments.length === 1) {
            return element;
        }
        elements.push(element);
    }
    return elements;
};

/**
 * @description A cross-browser implementation of "e instanceof Element".
 * @param o - {Object} The object to test.
 * @returns {Boolean}
 */
_SuperMap2.default.Util.isElement = function (o) {
    return !!(o && o.nodeType === 1);
};

/**
 * @description Tests that the provided object is an array.
 * This test handles the cross-IFRAME case not caught
 * by "a instanceof Array" and should be used instead.
 * @param a - {Object} the object test.
 * @returns {Boolean} true if the object is an array.
 */
_SuperMap2.default.Util.isArray = function (a) {
    return Object.prototype.toString.call(a) === '[object Array]';
};

/**
 * @description Remove an object from an array. Iterates through the array
 *     to find the item, then removes it.
 * @param array - {Array}
 * @param item - {Object}
 * @returns {Array} A reference to the array
 */
_SuperMap2.default.Util.removeItem = function (array, item) {
    for (var i = array.length - 1; i >= 0; i--) {
        if (array[i] === item) {
            array.splice(i, 1);
            //break;more than once??
        }
    }
    return array;
};

/**
 * @description Seems to exist already in FF, but not in MOZ.
 * @param array - {Array}
 * @param obj - {*}
 * @returns {number} The index at, which the first object was found in the array.
 *           If not found, returns -1.
 */
_SuperMap2.default.Util.indexOf = function (array, obj) {
    if (array == null) {
        return -1;
    } else {
        // use the build-in function if available.
        if (typeof array.indexOf === "function") {
            return array.indexOf(obj);
        } else {
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === obj) {
                    return i;
                }
            }
            return -1;
        }
    }
};

/**
 * @description Modifies many properties of a DOM element all at once.  Passing in
 * null to an individual parameter will avoid setting the attribute.
 * @param element - {HTMLElement} DOM element to modify.
 * @param id - {string} The element id attribute to set.
 * @param px - {SuperMap.Pixel} The left and top style position.
 * @param sz - {SuperMap.Size}  The width and height style attributes.
 * @param position - {string} The position attribute.  eg: absolute,relative, etc.
 * @param border - {string}  The style.border attribute.  eg:solid black 2px
 * @param overflow - {string} The style.overview attribute.
 * @param opacity - {number}  Fractional value (0.0 - 1.0)
 */
_SuperMap2.default.Util.modifyDOMElement = function (element, id, px, sz, position, border, overflow, opacity) {

    if (id) {
        element.id = id;
    }
    if (px) {
        element.style.left = px.x + "px";
        element.style.top = px.y + "px";
    }
    if (sz) {
        element.style.width = sz.w + "px";
        element.style.height = sz.h + "px";
    }
    if (position) {
        element.style.position = position;
    }
    if (border) {
        element.style.border = border;
    }
    if (overflow) {
        element.style.overflow = overflow;
    }
    if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {
        element.style.filter = 'alpha(opacity=' + opacity * 100 + ')';
        element.style.opacity = opacity;
    } else if (parseFloat(opacity) === 1.0) {
        element.style.filter = '';
        element.style.opacity = '';
    }
};

/**
 * @description Creates a new div and optionally set some standard attributes.
 * Null may be passed to each parameter if you do not wish to
 * set a particular attribute.
 * Note - zIndex is NOT set on the resulting div.
 * @param id - {string} An identifier for this element.  If no id is
 *               passed an identifier will be created
 *               automatically.
 * @param px - {SuperMap.Pixel} The element left and top position.
 * @param sz - {SuperMap.Size} The element width and height.
 * @param imgURL - {string} A url pointing to an image to use as a
 *                   background image.
 * @param position - {string} The style.position value. eg: absolute,
 *                     relative etc.
 * @param border - {string} The the style.border value.
 *                   eg: 2px solid black
 * @param overflow - {string} The style.overflow value. Eg. hidden
 * @param opacity - {number} Fractional value (0.0 - 1.0)
 *
 * @returns {HTMLElement} A DOM Div created with the specified attributes.
 */
_SuperMap2.default.Util.createDiv = function (id, px, sz, imgURL, position, border, overflow, opacity) {

    var dom = document.createElement('div');

    if (imgURL) {
        dom.style.backgroundImage = 'url(' + imgURL + ')';
    }

    //set generic properties
    if (!id) {
        id = _SuperMap2.default.Util.createUniqueID("SuperMapDiv");
    }
    if (!position) {
        position = "absolute";
    }
    _SuperMap2.default.Util.modifyDOMElement(dom, id, px, sz, position, border, overflow, opacity);

    return dom;
};

/**
 * @description  Creates an img element with specific attribute values.
 * @param id - {string} The id field for the img.  If none assigned one will be
 *               automatically generated.
 * @param px - {SuperMap.Pixel} The left and top positions.
 * @param sz - {SuperMap.Size} The style.width and style.height values.
 * @param imgURL - {string} The url to use as the image source.
 * @param position - {string} The style.position value.
 * @param border - {string} The border to place around the image.
 * @param opacity - {number} Fractional value (0.0 - 1.0)
 * @param delayDisplay - {Boolean} If true waits until the image has been
 *                          loaded.
 * @returns {HTMLElement} A DOM Image created with the specified attributes.
 */
_SuperMap2.default.Util.createImage = function (id, px, sz, imgURL, position, border, opacity, delayDisplay) {

    var image = document.createElement("img");

    //set generic properties
    if (!id) {
        id = _SuperMap2.default.Util.createUniqueID("SuperMapDiv");
    }
    if (!position) {
        position = "relative";
    }
    _SuperMap2.default.Util.modifyDOMElement(image, id, px, sz, position, border, null, opacity);

    if (delayDisplay) {
        image.style.display = "none";
        _SuperMap2.default.Event.observe(image, "load", _SuperMap2.default.Function.bind(_SuperMap2.default.Util.onImageLoad, image));
        _SuperMap2.default.Event.observe(image, "error", _SuperMap2.default.Function.bind(_SuperMap2.default.Util.onImageLoadError, image));
    }

    //set special properties
    image.style.alt = id;
    image.galleryImg = "no";
    if (imgURL) {
        image.src = imgURL;
    }

    return image;
};

/**
 * @description Bound to image load events.  For all images created with <createImage> or
 *     <createAlphaImageDiv>, this function will be bound to the load event.
 */
_SuperMap2.default.Util.onImageLoad = function () {
    // The complex check here is to solve issues described in #480.
    // Every time a map view changes, it increments the 'viewRequestID' 
    // property. As the requests for the images for the new map view are sent
    // out, they are tagged with this unique viewRequestID. 
    // 
    // If an image has no viewRequestID property set, we display it regardless, 
    // but if it does have a viewRequestID property, we check that it matches 
    // the viewRequestID set on the map.
    // 
    // If the viewRequestID on the map has changed, that means that the user
    // has changed the map view since this specific request was sent out, and
    // therefore this tile does not need to be displayed (so we do not execute
    // this code that turns its display on).
    //
    if (!this.viewRequestID || this.map && this.viewRequestID === this.map.viewRequestID) {
        this.style.display = "";
    }
    _SuperMap2.default.Element.removeClass(this, "smImageLoadError");
};

/**
 * @memberOf SuperMap
 * @description How many times should we try to reload an image before giving up? Default is 0
 * @type {number}
 * @default 0
 */
_SuperMap2.default.IMAGE_RELOAD_ATTEMPTS = 0;

/**
 * @description onImageLoadError
 */
_SuperMap2.default.Util.onImageLoadError = function () {
    this._attempts = this._attempts ? this._attempts + 1 : 1;
    if (this._attempts <= _SuperMap2.default.IMAGE_RELOAD_ATTEMPTS) {
        var urls = this.urls;
        if (urls && _SuperMap2.default.Util.isArray(urls) && urls.length > 1) {
            var src = this.src.toString();
            var current_url, k;
            for (k = 0; current_url = urls[k]; k++) {
                if (src.indexOf(current_url) !== -1) {
                    break;
                }
            }
            var guess = Math.floor(urls.length * Math.random());
            var new_url = urls[guess];
            k = 0;
            while (new_url === current_url && k++ < 4) {
                guess = Math.floor(urls.length * Math.random());
                new_url = urls[guess];
            }
            this.src = src.replace(current_url, new_url);
        } else {
            this.src = this.src;
        }
    } else {
        _SuperMap2.default.Element.addClass(this, "smImageLoadError");
    }
    this.style.display = "";
};

/**
 * @description  true if the png alpha hack is necessary and possible, false otherwise.
 * @type {Boolean}
 * @default null
 */
_SuperMap2.default.Util.alphaHackNeeded = null;

/**
 * @description Checks whether it's necessary (and possible) to use the png alpha
 * hack which allows alpha transparency for png images under Internet
 * Explorer.
 *
 * @returns {Boolean} true if the png alpha hack is necessary and possible, false otherwise.
 */
_SuperMap2.default.Util.alphaHack = function () {
    if (_SuperMap2.default.Util.alphaHackNeeded == null) {
        var arVersion = navigator.appVersion.split("MSIE");
        var version = parseFloat(arVersion[1]);
        var filter = false;

        // IEs4Lin dies when trying to access document.body.filters, because 
        // the property is there, but requires a DLL that can't be provided. This
        // means that we need to wrap this in a try/catch so that this can
        // continue.

        try {
            filter = !!document.body.filters;
        } catch (e) {}

        _SuperMap2.default.Util.alphaHackNeeded = filter && version >= 5.5 && version < 7;
    }
    return _SuperMap2.default.Util.alphaHackNeeded;
};

/**
 * @param div - {HTMLElement} Div containing Alpha-adjusted Image
 * @param id - {string}
 * @param px - {SuperMap.Pixel}
 * @param sz - {SuperMap.Size}
 * @param imgURL - {string}
 * @param position - {string}
 * @param border - {string}
 * @param sizing - {string} 'crop', 'scale', or 'image'. Default is "scale"
 * @param opacity - {number} Fractional value (0.0 - 1.0)
 * @param display - {string}
 */
_SuperMap2.default.Util.modifyAlphaImageDiv = function (div, id, px, sz, imgURL, position, border, sizing, opacity, display) {

    _SuperMap2.default.Util.modifyDOMElement(div, id, px, sz, position, null, null, opacity);

    var img = div.childNodes[0];

    if (imgURL) {
        img.src = imgURL;
    }
    if (!!display) {
        img.style.display = display;
    }
    _SuperMap2.default.Util.modifyDOMElement(img, div.id + "_innerImage", null, sz, position, border);

    if (_SuperMap2.default.Util.alphaHack()) {
        if (div.style.display !== "none") {
            div.style.display = "inline-block";
        }
        if (sizing == null) {
            sizing = "scale";
        }

        div.style.filter = "progid:DXImageTransform.Microsoft" + ".AlphaImageLoader(src='" + img.src + "', " + "sizingMethod='" + sizing + "')";
        if (parseFloat(div.style.opacity) >= 0.0 && parseFloat(div.style.opacity) < 1.0) {
            div.style.filter += " alpha(opacity=" + div.style.opacity * 100 + ")";
        }

        img.style.filter = "alpha(opacity=0)";
    }
};

/**
 * @param id - {string}
 * @param px - {SuperMap.Pixel}
 * @param sz - {SuperMap.Size}
 * @param imgURL - {string}
 * @param position - {string}
 * @param border - {string}
 * @param sizing - {string} 'crop', 'scale', or 'image'. Default is "scale"
 * @param opacity - {number} Fractional value (0.0 - 1.0)
 * @param delayDisplay - {Boolean} If true waits until the image has been
 *                          loaded.
 *
 * @returns {HTMLElement} A DOM Div created with a DOM Image inside it. If the hack is
 *              needed for transparency in IE, it is added.
 */
_SuperMap2.default.Util.createAlphaImageDiv = function (id, px, sz, imgURL, position, border, sizing, opacity, delayDisplay) {

    var div = _SuperMap2.default.Util.createDiv();
    var img = _SuperMap2.default.Util.createImage(null, null, null, null, position, null, null, delayDisplay);

    img.className = "olAlphaImg";
    div.appendChild(img);

    _SuperMap2.default.Util.modifyAlphaImageDiv(div, id, px, sz, imgURL, position, border, sizing, opacity, "block");

    return div;
};

/**
 * @description Creates a new hashtable and copies over all the keys from the
 *     passed-in object, but storing them under an uppercased
 *     version of the key at which they were stored.
 * @param object - {Object}
 * @returns {Object} A new Object with all the same keys but uppercased
 */
_SuperMap2.default.Util.upperCaseObject = function (object) {
    var uObject = {};
    for (var key in object) {
        uObject[key.toUpperCase()] = object[key];
    }
    return uObject;
};

/**
 * @description Takes an object and copies any properties that don't exist from
 *     another properties, by analogy with SuperMap.Util.extend() from
 *     Prototype.js.
 * @param to - {Object} The destination object.
 * @param from - {Object} The source object.  Any properties of this object that
 *     are undefined in the to object will be set on the to object.
 *
 * @returns {Object} A reference to the to object.  Note that the to argument is modified
 *     in place and returned by this function.
 */
_SuperMap2.default.Util.applyDefaults = function (to, from) {
    to = to || {};
    /*
     * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
     * prototype object" when calling hawOwnProperty if the source object is an
     * instance of window.Event.
     */
    var fromIsEvt = typeof window.Event === "function" && from instanceof window.Event;

    for (var key in from) {
        if (to[key] === undefined || !fromIsEvt && from.hasOwnProperty && from.hasOwnProperty(key) && !to.hasOwnProperty(key)) {
            to[key] = from[key];
        }
    }
    /**
     * IE doesn't include the toString property when iterating over an object's
     * properties with the for(property in object) syntax.  Explicitly check if
     * the source has its own toString property.
     */
    if (!fromIsEvt && from && from.hasOwnProperty && from.hasOwnProperty('toString') && !to.hasOwnProperty('toString')) {
        to.toString = from.toString;
    }

    return to;
};

/**
 * @param params - {Object}
 * @returns {string} A concatenation of the properties of an object in
 *          http parameter notation.
 * @example
 * "key1=value1&key2=value2&key3=value3"
 *
 * If a parameter is actually a list, that parameter will then
 * be set to a comma-seperated list of values (foo,bar) instead
 * of being URL escaped (foo%3Abar).
 */
_SuperMap2.default.Util.getParameterString = function (params) {
    var paramsArray = [];

    for (var key in params) {
        var value = params[key];
        if (value != null && typeof value !== 'function') {
            var encodedValue;
            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Array) {
                /* value is an array; encode items and separate with "," */
                var encodedItemArray = [];
                var item;
                for (var itemIndex = 0, len = value.length; itemIndex < len; itemIndex++) {
                    item = value[itemIndex];
                    encodedItemArray.push(encodeURIComponent(item === null || item === undefined ? "" : item));
                }
                encodedValue = encodedItemArray.join(",");
            } else {
                /* value is a string; simply encode */
                encodedValue = encodeURIComponent(value);
            }
            paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
        }
    }

    return paramsArray.join("&");
};

/**
 * @description Appends a parameter string to a url. This function includes the logic for
 * using the appropriate character (none, & or ?) to append to the url before
 * appending the param string.
 *
 * @param url - {string} The url to append to
 * @param paramStr - {string} The param string to append
 *
 * @returns {string} The new url
 */
_SuperMap2.default.Util.urlAppend = function (url, paramStr) {
    var newUrl = url;
    if (paramStr) {
        var parts = (url + " ").split(/[?&]/);
        newUrl += parts.pop() === " " ? paramStr : parts.length ? "&" + paramStr : "?" + paramStr;
    }
    return newUrl;
};

/**
 * @memberOf SuperMap
 * @description 设置控件图片的路径。该变量需在控件初始化之前设置。默认为 ""。
 * @type {SuperMap.ImgPath}
 * @default ""
 */
_SuperMap2.default.ImgPath = '';

/**
 * @returns {string} The fully formatted image location string
 */
_SuperMap2.default.Util.getImagesLocation = function () {
    return _SuperMap2.default.ImgPath || _SuperMap2.default._getScriptLocation() + "../theme/images/";
};

/**
 * @description  Execute functions until one of them doesn't throw an error.
 *     Capitalized because "try" is a reserved word in JavaScript.
 *     Taken directly from SuperMap.Util.Try()
 * @param arguments - {Function} Any number of parameters may be passed to Try()
 *    It will attempt to execute each of them until one of them
 *    successfully executes.
 *    If none executes successfully, returns null.
 *
 * @returns {*} The value returned by the first successfully executed function.
 */
_SuperMap2.default.Util.Try = function () {
    var returnValue = null;

    for (var i = 0, len = arguments.length; i < len; i++) {
        var lambda = arguments[i];
        try {
            returnValue = lambda();
            break;
        } catch (e) {}
    }

    return returnValue;
};

/**
 * @param node - {XMLNode}
 * @returns {string} The text value of the given node, without breaking in firefox or IE
 */
_SuperMap2.default.Util.getXmlNodeValue = function (node) {
    var val = null;
    _SuperMap2.default.Util.Try(function () {
        val = node.text;
        if (!val) {
            val = node.textContent;
        }
        if (!val) {
            val = node.firstChild.nodeValue;
        }
    }, function () {
        val = node.textContent;
    });
    return val;
};

/**
 * @param evt - {Event}
 * @param div - {HTMLDivElement}
 * @returns {Boolean}
 */
_SuperMap2.default.Util.mouseLeft = function (evt, div) {
    // start with the element to which the mouse has moved
    var target = evt.relatedTarget ? evt.relatedTarget : evt.toElement;
    // walk up the DOM tree.
    while (target !== div && target != null) {
        target = target.parentNode;
    }
    // if the target we stop at isn't the div, then we've left the div.
    return target !== div;
};

/**
 * @description The number of significant digits to retain to avoid
 * floating point precision errors.
 *
 * We use 14 as a "safe" default because, although IEEE 754 double floats
 * (standard on most modern operating systems) support up to about 16
 * significant digits, 14 significant digits are sufficient to represent
 * sub-millimeter accuracy in any coordinate system that anyone is likely to
 * use with SuperMap.
 *
 * If DEFAULT_PRECISION is set to 0, the original non-truncating behavior
 * of SuperMap <2.8 is preserved. Be aware that this will cause problems
 * with certain projections, e.g. spherical Mercator.
 * @type {number}
 * @default 14
 */
_SuperMap2.default.Util.DEFAULT_PRECISION = 14;

/**
 * @description Convenience method to cast an object to a Number, rounded to the
 * desired floating point precision.
 * @param number    - {number} The number to cast and round.
 * @param precision - {number} An integer suitable for use with
 *      Number.toPrecision(). Defaults to SuperMap.Util.DEFAULT_PRECISION.
 *      If set to 0, no rounding is performed.
 *
 * @returns {number} The cast, rounded number.
 */
_SuperMap2.default.Util.toFloat = function (number, precision) {
    if (precision == null) {
        precision = _SuperMap2.default.Util.DEFAULT_PRECISION;
    }
    if (typeof number !== "number") {
        number = parseFloat(number);
    }
    return precision === 0 ? number : parseFloat(number.toPrecision(precision));
};

/**
 * @param x - {number}
 * @returns {number}
 */
_SuperMap2.default.Util.rad = function (x) {
    return x * Math.PI / 180;
};

/**
 * @param x - {number}
 * @returns {number}
 */
_SuperMap2.default.Util.deg = function (x) {
    return x * 180 / Math.PI;
};

/**
 * @description Constants for Vincenty functions.
 * @type {Object}
 */
_SuperMap2.default.Util.VincentyConstants = {
    a: 6378137,
    b: 6356752.3142,
    f: 1 / 298.257223563
};

/**
 * @description 给出两个带有地理坐标的点对象，计算这些点在椭球表面上的距离。
 * @param p1 - {SuperMap.LonLat} 带有地理坐标的点对象或者带有经纬度属性的对象。
 * @param p2 - {SuperMap.LonLat} 带有地理坐标的点对象或者带有经纬度属性的对象。
 * @returns {number} 传入的两点在椭球表面上的距离（单位：km）。
 */
_SuperMap2.default.Util.distVincenty = function (p1, p2) {
    var ct = _SuperMap2.default.Util.VincentyConstants;
    var a = ct.a,
        b = ct.b,
        f = ct.f;

    var L = _SuperMap2.default.Util.rad(p2.lon - p1.lon);
    var U1 = Math.atan((1 - f) * Math.tan(_SuperMap2.default.Util.rad(p1.lat)));
    var U2 = Math.atan((1 - f) * Math.tan(_SuperMap2.default.Util.rad(p2.lat)));
    var sinU1 = Math.sin(U1),
        cosU1 = Math.cos(U1);
    var sinU2 = Math.sin(U2),
        cosU2 = Math.cos(U2);
    var lambda = L,
        lambdaP = 2 * Math.PI;
    var iterLimit = 20;
    while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {
        var sinLambda = Math.sin(lambda),
            cosLambda = Math.cos(lambda);
        var sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
        if (sinSigma == 0) {
            return 0; // co-incident points
        }
        var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
        var sigma = Math.atan2(sinSigma, cosSigma);
        var alpha = Math.asin(cosU1 * cosU2 * sinLambda / sinSigma);
        var cosSqAlpha = Math.cos(alpha) * Math.cos(alpha);
        var cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
        var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
        lambdaP = lambda;
        lambda = L + (1 - C) * f * Math.sin(alpha) * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
    }
    if (iterLimit == 0) {
        return NaN; // formula failed to converge
    }
    var uSq = cosSqAlpha * (a * a - b * b) / (b * b);
    var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
    var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
    var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
    var s = b * A * (sigma - deltaSigma);
    var d = s.toFixed(3) / 1000; // round to 1mm precision
    return d;
};

/**
 * @description 根据传入的起始点计算目标点的经纬度(度)、角方向（度）和距离(米)。
 * @param lonlat  - {SuperMap.LonLat} (或者带有经纬度属性的任何对象)起点。
 * @param brng  - {number} 角方向(度)。
 * @param dist  - {number} 距离(米)。
 *
 * @returns {SuperMap.LonLat} 目标点。
 */
_SuperMap2.default.Util.destinationVincenty = function (lonlat, brng, dist) {
    var u = _SuperMap2.default.Util;
    var ct = u.VincentyConstants;
    var a = ct.a,
        b = ct.b,
        f = ct.f;

    var lon1 = lonlat.lon;
    var lat1 = lonlat.lat;

    var s = dist;
    var alpha1 = u.rad(brng);
    var sinAlpha1 = Math.sin(alpha1);
    var cosAlpha1 = Math.cos(alpha1);

    var tanU1 = (1 - f) * Math.tan(u.rad(lat1));
    var cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1),
        sinU1 = tanU1 * cosU1;
    var sigma1 = Math.atan2(tanU1, cosAlpha1);
    var sinAlpha = cosU1 * sinAlpha1;
    var cosSqAlpha = 1 - sinAlpha * sinAlpha;
    var uSq = cosSqAlpha * (a * a - b * b) / (b * b);
    var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
    var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));

    var sigma = s / (b * A),
        sigmaP = 2 * Math.PI;
    while (Math.abs(sigma - sigmaP) > 1e-12) {
        var cos2SigmaM = Math.cos(2 * sigma1 + sigma);
        var sinSigma = Math.sin(sigma);
        var cosSigma = Math.cos(sigma);
        var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
        sigmaP = sigma;
        sigma = s / (b * A) + deltaSigma;
    }

    var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;
    var lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));
    var lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1);
    var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
    var L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));

    var revAz = Math.atan2(sinAlpha, -tmp); // final bearing

    return new _SuperMap2.default.LonLat(lon1 + u.deg(L), u.deg(lat2));
};

/**
 * @description Parse the parameters from a URL or from the current page itself into a
 *     JavaScript Object. Note that parameter values with commas are separated
 *     out into an Array.
 * @param url - {string} Optional url used to extract the query string.
 *                If url is null or is not supplied, query string is taken
 *                from the page location.
 *
 * @returns {Object} An object of key/value pairs from the query string.
 */
_SuperMap2.default.Util.getParameters = function (url) {
    // if no url specified, take it from the location bar
    url = url === null || url === undefined ? window.location.href : url;

    //parse out parameters portion of url string
    var paramsString = "";
    if (_SuperMap2.default.String.contains(url, '?')) {
        var start = url.indexOf('?') + 1;
        var end = _SuperMap2.default.String.contains(url, "#") ? url.indexOf('#') : url.length;
        paramsString = url.substring(start, end);
    }

    var parameters = {};
    var pairs = paramsString.split(/[&;]/);
    for (var i = 0, len = pairs.length; i < len; ++i) {
        var keyValue = pairs[i].split('=');
        if (keyValue[0]) {

            var key = keyValue[0];
            try {
                key = decodeURIComponent(key);
            } catch (err) {
                key = unescape(key);
            }

            // being liberal by replacing "+" with " "
            var value = (keyValue[1] || '').replace(/\+/g, " ");

            try {
                value = decodeURIComponent(value);
            } catch (err) {
                value = unescape(value);
            }

            // follow OGC convention of comma delimited values
            value = value.split(",");

            //if there's only one value, do not return as array                    
            if (value.length == 1) {
                value = value[0];
            }

            parameters[key] = value;
        }
    }
    return parameters;
};

/**
 * @description The ever-incrementing count variable.
 *           Used for generating unique ids.
 * @type {number}
 * @default 0
 */
_SuperMap2.default.Util.lastSeqID = 0;

/**
 * @description Create a unique identifier for this session.  Each time this function
 *     is called, a counter is incremented.  The return will be the optional
 *     prefix (defaults to "id_") appended with the counter value.
 * @param prefix {string} Optionsal string to prefix unique id. Default is "id_".
 * @returns {string} A unique id string, built on the passed in prefix.
 */
_SuperMap2.default.Util.createUniqueID = function (prefix) {
    if (prefix == null) {
        prefix = "id_";
    }
    _SuperMap2.default.Util.lastSeqID += 1;
    return prefix + _SuperMap2.default.Util.lastSeqID;
};

/**
 * @memberOf SuperMap
 * @description 每单位的英尺数。
 * @type {Object}
 * @constant
 */
_SuperMap2.default.INCHES_PER_UNIT = {
    'inches': 1.0,
    'ft': 12.0,
    'mi': 63360.0,
    'm': 39.3701,
    'km': 39370.1,
    'dd': 4374754,
    'yd': 36
};
_SuperMap2.default.INCHES_PER_UNIT["in"] = _SuperMap2.default.INCHES_PER_UNIT.inches;
_SuperMap2.default.INCHES_PER_UNIT["degrees"] = _SuperMap2.default.INCHES_PER_UNIT.dd;
_SuperMap2.default.INCHES_PER_UNIT["nmi"] = 1852 * _SuperMap2.default.INCHES_PER_UNIT.m;

// Units from CS-Map
_SuperMap2.default.METERS_PER_INCH = 0.02540005080010160020;
_SuperMap2.default.Util.extend(_SuperMap2.default.INCHES_PER_UNIT, {
    "Inch": _SuperMap2.default.INCHES_PER_UNIT.inches,
    "Meter": 1.0 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9001
    "Foot": 0.30480060960121920243 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9003
    "IFoot": 0.30480000000000000000 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9002
    "ClarkeFoot": 0.3047972651151 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9005
    "SearsFoot": 0.30479947153867624624 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9041
    "GoldCoastFoot": 0.30479971018150881758 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9094
    "IInch": 0.02540000000000000000 / _SuperMap2.default.METERS_PER_INCH,
    "MicroInch": 0.00002540000000000000 / _SuperMap2.default.METERS_PER_INCH,
    "Mil": 0.00000002540000000000 / _SuperMap2.default.METERS_PER_INCH,
    "Centimeter": 0.01000000000000000000 / _SuperMap2.default.METERS_PER_INCH,
    "Kilometer": 1000.00000000000000000000 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9036
    "Yard": 0.91440182880365760731 / _SuperMap2.default.METERS_PER_INCH,
    "SearsYard": 0.914398414616029 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9040
    "IndianYard": 0.91439853074444079983 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9084
    "IndianYd37": 0.91439523 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9085
    "IndianYd62": 0.9143988 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9086
    "IndianYd75": 0.9143985 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9087
    "IndianFoot": 0.30479951 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9080
    "IndianFt37": 0.30479841 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9081
    "IndianFt62": 0.3047996 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9082
    "IndianFt75": 0.3047995 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9083
    "Mile": 1609.34721869443738887477 / _SuperMap2.default.METERS_PER_INCH,
    "IYard": 0.91440000000000000000 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9096
    "IMile": 1609.34400000000000000000 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9093
    "NautM": 1852.00000000000000000000 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9030
    "Lat-66": 110943.316488932731 / _SuperMap2.default.METERS_PER_INCH,
    "Lat-83": 110946.25736872234125 / _SuperMap2.default.METERS_PER_INCH,
    "Decimeter": 0.10000000000000000000 / _SuperMap2.default.METERS_PER_INCH,
    "Millimeter": 0.00100000000000000000 / _SuperMap2.default.METERS_PER_INCH,
    "Dekameter": 10.00000000000000000000 / _SuperMap2.default.METERS_PER_INCH,
    "Decameter": 10.00000000000000000000 / _SuperMap2.default.METERS_PER_INCH,
    "Hectometer": 100.00000000000000000000 / _SuperMap2.default.METERS_PER_INCH,
    "GermanMeter": 1.0000135965 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9031
    "CaGrid": 0.999738 / _SuperMap2.default.METERS_PER_INCH,
    "ClarkeChain": 20.1166194976 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9038
    "GunterChain": 20.11684023368047 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9033
    "BenoitChain": 20.116782494375872 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9062
    "SearsChain": 20.11676512155 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9042
    "ClarkeLink": 0.201166194976 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9039
    "GunterLink": 0.2011684023368047 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9034
    "BenoitLink": 0.20116782494375872 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9063
    "SearsLink": 0.2011676512155 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9043
    "Rod": 5.02921005842012 / _SuperMap2.default.METERS_PER_INCH,
    "IntnlChain": 20.1168 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9097
    "IntnlLink": 0.201168 / _SuperMap2.default.METERS_PER_INCH, //EPSG:9098
    "Perch": 5.02921005842012 / _SuperMap2.default.METERS_PER_INCH,
    "Pole": 5.02921005842012 / _SuperMap2.default.METERS_PER_INCH,
    "Furlong": 201.1684023368046 / _SuperMap2.default.METERS_PER_INCH,
    "Rood": 3.778266898 / _SuperMap2.default.METERS_PER_INCH,
    "CapeFoot": 0.3047972615 / _SuperMap2.default.METERS_PER_INCH,
    "Brealey": 375.00000000000000000000 / _SuperMap2.default.METERS_PER_INCH,
    "ModAmFt": 0.304812252984505969011938 / _SuperMap2.default.METERS_PER_INCH,
    "Fathom": 1.8288 / _SuperMap2.default.METERS_PER_INCH,
    "NautM-UK": 1853.184 / _SuperMap2.default.METERS_PER_INCH,
    "50kilometers": 50000.0 / _SuperMap2.default.METERS_PER_INCH,
    "150kilometers": 150000.0 / _SuperMap2.default.METERS_PER_INCH
});

//unit abbreviations supported by PROJ.4
_SuperMap2.default.Util.extend(_SuperMap2.default.INCHES_PER_UNIT, {
    "mm": _SuperMap2.default.INCHES_PER_UNIT["Meter"] / 1000.0,
    "cm": _SuperMap2.default.INCHES_PER_UNIT["Meter"] / 100.0,
    "dm": _SuperMap2.default.INCHES_PER_UNIT["Meter"] * 100.0,
    "km": _SuperMap2.default.INCHES_PER_UNIT["Meter"] * 1000.0,
    "kmi": _SuperMap2.default.INCHES_PER_UNIT["nmi"], //International Nautical Mile
    "fath": _SuperMap2.default.INCHES_PER_UNIT["Fathom"], //International Fathom
    "ch": _SuperMap2.default.INCHES_PER_UNIT["IntnlChain"], //International Chain
    "link": _SuperMap2.default.INCHES_PER_UNIT["IntnlLink"], //International Link
    "us-in": _SuperMap2.default.INCHES_PER_UNIT["inches"], //U.S. Surveyor's Inch
    "us-ft": _SuperMap2.default.INCHES_PER_UNIT["Foot"], //U.S. Surveyor's Foot
    "us-yd": _SuperMap2.default.INCHES_PER_UNIT["Yard"], //U.S. Surveyor's Yard
    "us-ch": _SuperMap2.default.INCHES_PER_UNIT["GunterChain"], //U.S. Surveyor's Chain
    "us-mi": _SuperMap2.default.INCHES_PER_UNIT["Mile"], //U.S. Surveyor's Statute Mile
    "ind-yd": _SuperMap2.default.INCHES_PER_UNIT["IndianYd37"], //Indian Yard
    "ind-ft": _SuperMap2.default.INCHES_PER_UNIT["IndianFt37"], //Indian Foot
    "ind-ch": 20.11669506 / _SuperMap2.default.METERS_PER_INCH //Indian Chain
});

/**
 * @memberOf SuperMap
 * @description 分辨率与比例尺之间转换的常量，默认值96。
 * @type {Object}
 * @default 96
 */
_SuperMap2.default.DOTS_PER_INCH = 96;

/**
 * @param scale - {number}
 * @returns {number} A normalized scale value, in 1 / X format.
 *         This means that if a value less than one ( already 1/x) is passed
 *         in, it just returns scale directly. Otherwise, it returns
 *         1 / scale
 */
_SuperMap2.default.Util.normalizeScale = function (scale) {
    var normScale = scale > 1.0 ? 1.0 / scale : scale;
    return normScale;
};

/**
 * @param scale - {number}
 * @param units - {string} Index into SuperMap.INCHES_PER_UNIT hashtable.
 *                  Default is degrees
 *
 * @returns {number} The corresponding resolution given passed-in scale and unit
 *     parameters.  If the given scale is falsey, the returned resolution will
 *     be undefined.
 */
_SuperMap2.default.Util.getResolutionFromScale = function (scale, units) {
    var resolution;
    if (scale) {
        if (units == null) {
            units = "degrees";
        }
        var normScale = _SuperMap2.default.Util.normalizeScale(scale);
        resolution = 1 / (normScale * _SuperMap2.default.INCHES_PER_UNIT[units] * _SuperMap2.default.DOTS_PER_INCH);
    }
    return resolution;
};

/**
 * @param resolution - {number}
 * @param units - {string} Index into SuperMap.INCHES_PER_UNIT hashtable.
 *                  Default is degrees
 *
 * @returns {number} The corresponding scale given passed-in resolution and unit
 *         parameters.
 */
_SuperMap2.default.Util.getScaleFromResolution = function (resolution, units) {

    if (units == null) {
        units = "degrees";
    }

    var scale = resolution * _SuperMap2.default.INCHES_PER_UNIT[units] * _SuperMap2.default.DOTS_PER_INCH;
    return scale;
};

/**
 * @description Test two URLs for equivalence.
 *
 * Setting 'ignoreCase' allows for case-independent comparison.
 *
 * Comparison is based on:
 *  - Protocol
 *  - Host (evaluated without the port)
 *  - Port (set 'ignorePort80' to ignore "80" values)
 *  - Hash ( set 'ignoreHash' to disable)
 *  - Pathname (for relative <-> absolute comparison)
 *  - Arguments (so they can be out of order)
 * @param url1 - {string}
 * @param url2 - {string}
 * @param options - {Object} Allows for customization of comparison:
 *                    'ignoreCase' - Default is True
 *                    'ignorePort80' - Default is True
 *                    'ignoreHash' - Default is True
 *
 * @returns {Boolean} Whether or not the two URLs are equivalent
 */
_SuperMap2.default.Util.isEquivalentUrl = function (url1, url2, options) {
    options = options || {};

    _SuperMap2.default.Util.applyDefaults(options, {
        ignoreCase: true,
        ignorePort80: true,
        ignoreHash: true
    });

    var urlObj1 = _SuperMap2.default.Util.createUrlObject(url1, options);
    var urlObj2 = _SuperMap2.default.Util.createUrlObject(url2, options);

    //compare all keys except for "args" (treated below)
    for (var key in urlObj1) {
        if (key !== "args") {
            if (urlObj1[key] !== urlObj2[key]) {
                return false;
            }
        }
    }

    // compare search args - irrespective of order
    for (var key in urlObj1.args) {
        if (urlObj1.args[key] !== urlObj2.args[key]) {
            return false;
        }
        delete urlObj2.args[key];
    }
    // urlObj2 shouldn't have any args left
    for (var key in urlObj2.args) {
        return false;
    }

    return true;
};

/**
 * @param url - {string}
 * @param options - {Object} A hash of options.  Can be one of:
 *            ignoreCase: lowercase url,
 *            ignorePort80: don't include explicit port if port is 80,
 *            ignoreHash: Don't include part of url after the hash (#).
 *
 * @returns {Object} An object with separate url, a, port, host, and args parsed out
 *          and ready for comparison
 */
_SuperMap2.default.Util.createUrlObject = function (url, options) {
    options = options || {};

    // deal with relative urls first
    if (!/^\w+:\/\//.test(url)) {
        var loc = window.location;
        var port = loc.port ? ":" + loc.port : "";
        var fullUrl = loc.protocol + "//" + loc.host.split(":").shift() + port;
        if (url.indexOf("/") === 0) {
            // full pathname
            url = fullUrl + url;
        } else {
            // relative to current path
            var parts = loc.pathname.split("/");
            parts.pop();
            url = fullUrl + parts.join("/") + "/" + url;
        }
    }

    if (options.ignoreCase) {
        url = url.toLowerCase();
    }

    var a = document.createElement('a');
    a.href = url;

    var urlObject = {};

    //host (without port)
    urlObject.host = a.host.split(":").shift();

    //protocol
    urlObject.protocol = a.protocol;

    //port (get uniform browser behavior with port 80 here)
    if (options.ignorePort80) {
        urlObject.port = a.port === "80" || a.port == "0" ? "" : a.port;
    } else {
        urlObject.port = a.port == "" || a.port == "0" ? "80" : a.port;
    }

    //hash
    urlObject.hash = options.ignoreHash || a.hash === "#" ? "" : a.hash;

    //args
    var queryString = a.search;
    if (!queryString) {
        var qMark = url.indexOf("?");
        queryString = qMark !== -1 ? url.substr(qMark) : "";
    }
    urlObject.args = _SuperMap2.default.Util.getParameters(queryString);

    //pathname (uniform browser behavior with leading "/")
    urlObject.pathname = a.pathname.charAt(0) === "/" ? a.pathname : "/" + a.pathname;

    return urlObject;
};

/**
 * @description Takes a url and removes everything after the ? and #
 * @param url - {string} The url to process
 *
 * @returns {string} The string with all queryString and Hash removed
 */
_SuperMap2.default.Util.removeTail = function (url) {
    var head = null;

    var qMark = url.indexOf("?");
    var hashMark = url.indexOf("#");

    if (qMark == -1) {
        head = hashMark !== -1 ? url.substr(0, hashMark) : url;
    } else {
        head = hashMark !== -1 ? url.substr(0, Math.min(qMark, hashMark)) : url.substr(0, qMark);
    }
    return head;
};

/**
 * @memberOf SuperMap
 * @description 如果userAgent捕获到浏览器使用的是Gecko引擎则返回true。
 * @constant
 */
_SuperMap2.default.IS_GECKO = function () {
    var ua = navigator.userAgent.toLowerCase();
    return ua.indexOf("webkit") === -1 && ua.indexOf("gecko") !== -1;
}();

/**
 * @memberOf SuperMap
 * @description 浏览器名称，依赖于userAgent属性，BROWSER_NAME可以是空，或者以下浏览器：
 *     * "opera" -- Opera
 *     * "msie"  -- Internet Explorer
 *     * "safari" -- Safari
 *     * "firefox" -- Firefox
 *     * "mozilla" -- Mozilla
 * @constant
 */
_SuperMap2.default.Browser = function () {
    var name = '',
        version = '',
        device = 'pc',
        uaMatch;
    //以下进行测试
    var ua = navigator.userAgent.toLowerCase();
    if (ua.indexOf("msie") > -1 || ua.indexOf("trident") > -1 && ua.indexOf("rv") > -1) {
        name = 'msie';
        uaMatch = ua.match(/msie ([\d.]+)/) || ua.match(/rv:([\d.]+)/);
    } else if (ua.indexOf("chrome") > -1) {
        name = 'chrome';
        uaMatch = ua.match(/chrome\/([\d.]+)/);
    } else if (ua.indexOf("firefox") > -1) {
        name = 'firefox';
        uaMatch = ua.match(/firefox\/([\d.]+)/);
    } else if (ua.indexOf("opera") > -1) {
        name = 'opera';
        uaMatch = ua.match(/version\/([\d.]+)/);
    } else if (ua.indexOf("safari") > -1) {
        name = 'safari';
        uaMatch = ua.match(/version\/([\d.]+)/);
    }
    version = uaMatch ? uaMatch[1] : '';

    if (ua.indexOf("ipad") > -1 || ua.indexOf("ipod") > -1 || ua.indexOf("iphone") > -1) {
        device = 'apple';
    } else if (ua.indexOf("android") > -1) {
        uaMatch = ua.match(/version\/([\d.]+)/);
        version = uaMatch ? uaMatch[1] : '';
        device = 'android';
    }
    return { name: name, version: version, device: device };
}();

/**
 * @returns {Object} 获取浏览器名称、版本、设备名称。对应的属性分别为 name, version, device。
 *
 *           支持的浏览器包括：
 *           * 'opera' -- Opera
 *           * 'msie'  -- Internet Explorer
 *           * 'safari' -- Safari
 *           * 'firefox' -- Firefox
 */
_SuperMap2.default.Util.getBrowser = function () {
    return _SuperMap2.default.Browser;
};

_SuperMap2.default.Util.isSupportCanvas = function () {
    var checkRes = true,
        broz = _SuperMap2.default.Util.getBrowser();
    if (document.createElement("canvas").getContext) {
        if (broz.name === 'firefox' && parseFloat(broz.version) < 5) {
            checkRes = false;
        }
        if (broz.name === 'safari' && parseFloat(broz.version) < 4) {
            checkRes = false;
        }
        if (broz.name === 'opera' && parseFloat(broz.version) < 10) {
            checkRes = false;
        }
        if (broz.name === 'msie' && parseFloat(broz.version) < 9) {
            checkRes = false;
        }
    } else {
        checkRes = false;
    }
    return checkRes;
}();

/**
 * @returns {Boolean} 获取当前浏览器是否支持 HTML5 Canvas 。
 */
_SuperMap2.default.Util.supportCanvas = function () {
    return _SuperMap2.default.Util.isSupportCanvas;
};

/**
 * @description Renders the contentHTML offscreen to determine actual dimensions for
 *     popup sizing. As we need layout to determine dimensions the content
 *     is rendered -9999px to the left and absolute to ensure the
 *     scrollbars do not flicker
 * @param contentHTML
 * @param size - {SuperMap.Size} If either the 'w' or 'h' properties is
 *     specified, we fix that dimension of the div to be measured. This is
 *     useful in the case where we have a limit in one dimension and must
 *     therefore meaure the flow in the other dimension.
 * @param options - {Object}
 *
 * Allowed Options:
 *     displayClass - {string} Optional parameter.  A CSS class name(s) string
 *         to provide the CSS context of the rendered content.
 *     containerElement - {HTMLElement} Optional parameter. Insert the HTML to
 *         this node instead of the body root when calculating dimensions.
 *
 * @returns {SuperMap.Size}
 */
_SuperMap2.default.Util.getRenderedDimensions = function (contentHTML, size, options) {

    var w, h;

    // create temp container div with restricted size
    var container = document.createElement("div");
    container.style.visibility = "hidden";

    var containerElement = options && options.containerElement ? options.containerElement : document.body;

    // Opera and IE7 can't handle a node with position:aboslute if it inherits
    // position:absolute from a parent.
    var parentHasPositionAbsolute = false;
    var superContainer = null;
    var parent = containerElement;
    while (parent && parent.tagName.toLowerCase() !== "body") {
        var parentPosition = _SuperMap2.default.Element.getStyle(parent, "position");
        if (parentPosition === "absolute") {
            parentHasPositionAbsolute = true;
            break;
        } else if (parentPosition && parentPosition !== "static") {
            break;
        }
        parent = parent.parentNode;
    }
    /*if(parentHasPositionAbsolute && (containerElement.clientHeight === 0 ||
        containerElement.clientWidth === 0) ){
        superContainer = document.createElement("div");
        superContainer.style.visibility = "hidden";
        superContainer.style.position = "absolute";
        superContainer.style.overflow = "visible";
        superContainer.style.width = document.body.clientWidth + "px";
        superContainer.style.height = document.body.clientHeight + "px";
        superContainer.appendChild(container);
    }*/
    if (!parentHasPositionAbsolute) {
        container.style.position = "absolute";
    }

    //fix a dimension, if specified.
    if (size) {
        if (size.w) {
            w = size.w;
            container.style.width = w + "px";
        } else if (size.h) {
            h = size.h;
            container.style.height = h + "px";
        }
    }

    //add css classes, if specified
    if (options && options.displayClass) {
        container.className = options.displayClass;
    }

    // create temp content div and assign content
    var content = document.createElement("div");
    content.innerHTML = contentHTML;

    // we need overflow visible when calculating the size
    content.style.overflow = "visible";
    if (content.childNodes) {
        for (var i = 0, l = content.childNodes.length; i < l; i++) {
            if (!content.childNodes[i].style) continue;
            content.childNodes[i].style.overflow = "visible";
        }
    }

    // add content to restricted container 
    container.appendChild(content);

    // append container to body for rendering
    containerElement.appendChild(container);

    // append container to body for rendering
    /*if (superContainer) {
        containerElement.appendChild(superContainer);
    } else {
        containerElement.appendChild(container);
    }*/
    containerElement.appendChild(container);
    // calculate scroll width of content and add corners and shadow width
    if (!w) {
        w = parseInt(content.scrollWidth);

        // update container width to allow height to adjust
        container.style.width = w + "px";
    }
    // capture height and add shadow and corner image widths
    if (!h) {
        h = parseInt(content.scrollHeight);
    }

    // remove elements
    container.removeChild(content);

    containerElement.removeChild(container);

    return new _SuperMap2.default.Size(w, h);
};

/**
 * @returns {number} 返回scrollbarWidth。
 */
_SuperMap2.default.Util.getScrollbarWidth = function () {

    var scrollbarWidth = _SuperMap2.default.Util._scrollbarWidth;

    if (scrollbarWidth == null) {
        var scr = null;
        var inn = null;
        var wNoScroll = 0;
        var wScroll = 0;

        // Outer scrolling div
        scr = document.createElement('div');
        scr.style.position = 'absolute';
        scr.style.top = '-1000px';
        scr.style.left = '-1000px';
        scr.style.width = '100px';
        scr.style.height = '50px';
        // Start with no scrollbar
        scr.style.overflow = 'hidden';

        // Inner content div
        inn = document.createElement('div');
        inn.style.width = '100%';
        inn.style.height = '200px';

        // Put the inner div in the scrolling div
        scr.appendChild(inn);
        // Append the scrolling div to the doc
        document.body.appendChild(scr);

        // Width of the inner div sans scrollbar
        wNoScroll = inn.offsetWidth;

        // Add the scrollbar
        scr.style.overflow = 'scroll';
        // Width of the inner div width scrollbar
        wScroll = inn.offsetWidth;

        // Remove the scrolling div from the doc
        document.body.removeChild(document.body.lastChild);

        // Pixel width of the scroller
        _SuperMap2.default.Util._scrollbarWidth = wNoScroll - wScroll;
        scrollbarWidth = _SuperMap2.default.Util._scrollbarWidth;
    }

    return scrollbarWidth;
};

/**
 * @description 格式化字符串。
 * @param coordinate - {number} 要格式化的坐标值。
 * @param axis - {string} 将要被格式化的axis，可以是经度，纬度，默认为纬度，经度则为"lon"。
 * @param dmsOption - {string} 指定的输出精度，可以是：
 *           'dms'显示度、分、秒；
 *           'dm'显示度、分；
 *           'd'显示度；
 *
 * @returns {string} 格式化为字符串的坐标值。
 */
_SuperMap2.default.Util.getFormattedLonLat = function (coordinate, axis, dmsOption) {
    if (!dmsOption) {
        dmsOption = 'dms'; //default to show degree, minutes, seconds
    }

    coordinate = (coordinate + 540) % 360 - 180; // normalize for sphere being round

    var abscoordinate = Math.abs(coordinate);
    var coordinatedegrees = Math.floor(abscoordinate);

    var coordinateminutes = (abscoordinate - coordinatedegrees) / (1 / 60);
    var tempcoordinateminutes = coordinateminutes;
    coordinateminutes = Math.floor(coordinateminutes);
    var coordinateseconds = (tempcoordinateminutes - coordinateminutes) / (1 / 60);
    coordinateseconds = Math.round(coordinateseconds * 10);
    coordinateseconds /= 10;

    if (coordinateseconds >= 60) {
        coordinateseconds -= 60;
        coordinateminutes += 1;
        if (coordinateminutes >= 60) {
            coordinateminutes -= 60;
            coordinatedegrees += 1;
        }
    }

    if (coordinatedegrees < 10) {
        coordinatedegrees = "0" + coordinatedegrees;
    }
    var str = coordinatedegrees + '\xB0';

    if (dmsOption.indexOf('dm') >= 0) {
        if (coordinateminutes < 10) {
            coordinateminutes = "0" + coordinateminutes;
        }
        str += coordinateminutes + "'";

        if (dmsOption.indexOf('dms') >= 0) {
            if (coordinateseconds < 10) {
                coordinateseconds = "0" + coordinateseconds;
            }
            str += coordinateseconds + '"';
        }
    }

    if (axis === "lon") {
        str += coordinate < 0 ? _SuperMap2.default.i18n("W") : _SuperMap2.default.i18n("E");
    } else {
        str += coordinate < 0 ? _SuperMap2.default.i18n("S") : _SuperMap2.default.i18n("N");
    }
    return str;
};

//将服务端的地图单位转成SuperMap的地图单位
_SuperMap2.default.INCHES_PER_UNIT["degree"] = _SuperMap2.default.INCHES_PER_UNIT.dd;
_SuperMap2.default.INCHES_PER_UNIT["meter"] = _SuperMap2.default.INCHES_PER_UNIT.m;
_SuperMap2.default.INCHES_PER_UNIT["foot"] = _SuperMap2.default.INCHES_PER_UNIT.ft;
_SuperMap2.default.INCHES_PER_UNIT["inch"] = _SuperMap2.default.INCHES_PER_UNIT.inches;
_SuperMap2.default.INCHES_PER_UNIT["mile"] = _SuperMap2.default.INCHES_PER_UNIT.mi;
_SuperMap2.default.INCHES_PER_UNIT["kilometer"] = _SuperMap2.default.INCHES_PER_UNIT.km;
_SuperMap2.default.INCHES_PER_UNIT["yard"] = _SuperMap2.default.INCHES_PER_UNIT.yd;

/**
 * @description 判断一个 URL 请求是否在当前域中。
 * @param url - {string}  URL 请求字符串。
 *
 * @returns {Boolean} URL 请求是否在当前域中。
 */
_SuperMap2.default.Util.isInTheSameDomain = function (url) {
    if (!url) {
        return true;
    }
    var index = url.indexOf("//");
    var documentUrl = document.location.toString();
    var documentIndex = documentUrl.indexOf("//");
    if (index === -1) {
        return true;
    } else {
        var protocol;
        var substring = protocol = url.substring(0, index);
        var documentSubString = documentUrl.substring(documentIndex + 2);
        documentIndex = documentSubString.indexOf("/");
        var documentPortIndex = documentSubString.indexOf(":");
        var documentDomainWithPort = documentSubString.substring(0, documentIndex);
        var documentPort;

        var documentprotocol = document.location.protocol;
        if (documentPortIndex !== -1) {
            documentPort = +documentSubString.substring(documentPortIndex, documentIndex);
        } else {
            documentDomainWithPort += ':' + (documentprotocol.toLowerCase() === 'http:' ? 80 : 443);
        }
        if (documentprotocol.toLowerCase() !== substring.toLowerCase()) {
            return false;
        }
        substring = url.substring(index + 2);
        var portIndex = substring.indexOf(":");
        index = substring.indexOf("/");
        var domainWithPort = substring.substring(0, index);
        var domain;
        if (portIndex !== -1) {
            domain = substring.substring(0, portIndex);
        } else {
            domain = substring.substring(0, index);
            domainWithPort += ':' + (protocol.toLowerCase() === 'http:' ? 80 : 443);
        }
        var documentDomain = document.domain;
        if (domain === documentDomain && domainWithPort === documentDomainWithPort) {
            return true;
        }
    }
    return false;
};

/**
 * @description 计算iServer服务的REST图层的显示分辨率，需要从iServer的REST图层表述中获取viewBounds、viewer、scale、coordUnit、datumAxis 五个参数，
 * 来进行计算。
 * @param viewBounds - {SuperMap.Bounds} 地图的参照可视范围，即地图初始化时默认的地图显示范围。
 * @param viewer - {SuperMap.Size} 地图初始化时默认的地图图片的尺寸。
 * @param scale - {number} 地图初始化时默认的显示比例尺。
 * @param coordUnit - {string} 投影坐标系统的地图单位。
 * @param datumAxis - {number} 地理坐标系统椭球体长半轴。用户自定义地图的Options时，若未指定该参数的值，
 * 则系统默认为WGS84参考系的椭球体长半轴6378137。
 *
 * @returns {number} 返回图层显示分辨率。
 */
_SuperMap2.default.Util.calculateDpi = function (viewBounds, viewer, scale, coordUnit, datumAxis) {
    //10000 是 0.1毫米与米的转换。DPI的计算公式：Viewer / DPI *  0.0254 * 10000 = ViewBounds * scale ，公式中的10000是为了提高计算结果的精度，以下出现的ratio皆为如此。
    if (!viewBounds || !viewer || !scale) {
        return;
    }
    var ratio = 10000,
        rvbWidth = viewBounds.getWidth(),
        rvbHeight = viewBounds.getHeight(),
        rvWidth = viewer.w,
        rvHeight = viewer.h;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || "degrees";
    if (coordUnit.toLowerCase() === "degree" || coordUnit.toLowerCase() === "degrees" || coordUnit.toLowerCase() === "dd") {
        var num1 = rvbWidth / rvWidth,
            num2 = rvbHeight / rvHeight,
            resolution = num1 > num2 ? num1 : num2,
            dpi = 0.0254 * ratio / resolution / scale / (Math.PI * 2 * datumAxis / 360) / ratio;
        return dpi;
    } else {
        var resolution = rvbWidth / rvWidth,
            dpi = 0.0254 * ratio / resolution / scale / ratio;
        return dpi;
    }
};

/**
 * @description 将对象转换成 JSON 字符串。
 * @param obj - {Object} 要转换成 JSON 的 Object 对象。
 *
 * @returns {string} 返回转换后的 JSON 对象。
 */
_SuperMap2.default.Util.toJSON = function (obj) {
    var objInn = obj;
    if (objInn == null) {
        return null;
    }
    switch (objInn.constructor) {
        case String:
            //s = "'" + str.replace(/(["\\])/g, "\\$1") + "'";   string含有单引号出错
            objInn = '"' + objInn.replace(/(["\\])/g, '\\$1') + '"';
            objInn = objInn.replace(/\n/g, "\\n");
            objInn = objInn.replace(/\r/g, "\\r");
            objInn = objInn.replace("<", "&lt;");
            objInn = objInn.replace(">", "&gt;");
            objInn = objInn.replace(/%/g, "%25");
            objInn = objInn.replace(/&/g, "%26");
            return objInn;
        case Array:
            var arr = [];
            for (var i = 0, len = objInn.length; i < len; i++) {
                arr.push(_SuperMap2.default.Util.toJSON(objInn[i]));
            }
            return "[" + arr.join(",") + "]";
        case Number:
            return isFinite(objInn) ? String(objInn) : null;
        case Boolean:
            return String(objInn);
        case Date:
            var dateStr = "{" + "'__type':\"System.DateTime\"," + "'Year':" + objInn.getFullYear() + "," + "'Month':" + (objInn.getMonth() + 1) + "," + "'Day':" + objInn.getDate() + "," + "'Hour':" + objInn.getHours() + "," + "'Minute':" + objInn.getMinutes() + "," + "'Second':" + objInn.getSeconds() + "," + "'Millisecond':" + objInn.getMilliseconds() + "," + "'TimezoneOffset':" + objInn.getTimezoneOffset() + "}";
            return dateStr;
        default:
            if (objInn["toJSON"] != null && typeof objInn["toJSON"] === "function") {
                return objInn.toJSON();
            }
            if ((typeof objInn === 'undefined' ? 'undefined' : _typeof(objInn)) === "object") {
                if (objInn.length) {
                    var arr = [];
                    for (var i = 0, len = objInn.length; i < len; i++) {
                        arr.push(_SuperMap2.default.Util.toJSON(objInn[i]));
                    }return "[" + arr.join(",") + "]";
                }
                var arr = [];
                for (var attr in objInn) {
                    //为解决SuperMap.Geometry类型头json时堆栈溢出的问题，attr == "parent"时不进行json转换
                    if (typeof objInn[attr] !== "function" && attr !== "CLASS_NAME" && attr !== "parent") {
                        arr.push("'" + attr + "':" + _SuperMap2.default.Util.toJSON(objInn[attr]));
                    }
                }

                if (arr.length > 0) {
                    return "{" + arr.join(",") + "}";
                } else {
                    return "{}";
                }
            }
            return objInn.toString();
    }
};

/**
 * @description 根据比例尺和dpi计算屏幕分辨率。
 * @param scale - {number} 比例尺。
 * @param dpi - {number} 图像分辨率，表示每英寸内的像素个数。
 * @param coordUnit - {string} 投影坐标系统的地图单位。
 * @param datumAxis - {number} 地理坐标系统椭球体长半轴。用户自定义地图的Options时，若未指定该参数的值，
 * 则DPI默认按照WGS84参考系的椭球体长半轴6378137来计算。
 *
 * @returns {number} 返回当前比例尺下的屏幕分辨率。
 */
_SuperMap2.default.Util.getResolutionFromScaleDpi = function (scale, dpi, coordUnit, datumAxis) {
    var resolution = null,
        ratio = 10000;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || "";
    if (scale > 0 && dpi > 0) {
        scale = _SuperMap2.default.Util.normalizeScale(scale);
        if (coordUnit.toLowerCase() === "degree" || coordUnit.toLowerCase() === "degrees" || coordUnit.toLowerCase() === "dd") {
            //scale = SuperMap.Util.normalizeScale(scale);
            resolution = 0.0254 * ratio / dpi / scale / (Math.PI * 2 * datumAxis / 360) / ratio;
            return resolution;
        } else {
            resolution = 0.0254 * ratio / dpi / scale / ratio;
            return resolution;
        }
    }
    return -1;
};

/**
 * @description 根据resolution、dpi、coordUnit和datumAxis计算比例尺。
 * @param resolution - {number} 用于计算比例尺的地图分辨率。
 * @param dpi - {number} 图像分辨率，表示每英寸内的像素个数。
 * @param coordUnit - {string} 投影坐标系统的地图单位。
 * @param datumAxis - {number} 地理坐标系统椭球体长半轴。用户自定义地图的Options时，若未指定该参数的值，
 * 则DPI默认按照WGS84参考系的椭球体长半轴6378137来计算。
 *
 * @returns {number} 返回当前屏幕分辨率下的比例尺。
 */
_SuperMap2.default.Util.getScaleFromResolutionDpi = function (resolution, dpi, coordUnit, datumAxis) {
    var scale = null,
        ratio = 10000;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || "";
    if (resolution > 0 && dpi > 0) {
        if (coordUnit.toLowerCase() === "degree" || coordUnit.toLowerCase() === "degrees" || coordUnit.toLowerCase() === "dd") {
            scale = 0.0254 * ratio / dpi / resolution / (Math.PI * 2 * datumAxis / 360) / ratio;
            return scale;
        } else {
            scale = 0.0254 * ratio / dpi / resolution / ratio;
            return scale;
        }
    }
    return -1;
};

/**
 * @description 判断一个url字符串的字节长度是否过长。
 * @param url - {string} url字符串。
 *
 * @returns {Boolean} url字符串的字节长度是否过长。
 */
_SuperMap2.default.Util.urlIsLong = function (url) {
    //当前url的字节长度。
    var totalLength = 0,
        charCode = null;
    for (var i = 0, len = url.length; i < len; i++) {
        //转化为Unicode编码
        charCode = url.charCodeAt(i);
        if (charCode < 0x007f) {
            totalLength++;
        } else if (0x0080 <= charCode && charCode <= 0x07ff) {
            totalLength += 2;
        } else if (0x0800 <= charCode && charCode <= 0xffff) {
            totalLength += 3;
        }
    }
    return totalLength < 2000 ? false : true;
};

/**
 * @de 与服务器进行通信。
 * @param options - {Object} 参数。<br>
 *        method - {string} 请求方式，包括GET，POST，PUT， DELETE。<br>
 *        url - {string} 发送请求的地址。<br>
 *        params - {Object} 作为查询字符串添加到url中的一组键值对，此参数只适用于GET方式发送的请求。<br>
 *        data - {Object } 除GET请求外其他类型请求，发送到服务器的数据。<br>
 *        success - {Function} 请求成功后的回调函数。<br>
 *        failure - {Function} 请求失败后的回调函数。<br>
 *        scope - {Object} 如果回调函数是对象的一个公共方法，设定该对象的范围。<br>
 *        isInTheSameDomain - {Boolean} 请求是否在当前域中。
 */
_SuperMap2.default.Util.committer = function (options) {
    if (!options) {
        return;
    }

    var url = options.url,
        separator = url.indexOf("?") > -1 ? "&" : "?",
        end = url.substr(url.length - 1, 1);

    //判断当前脚本运行于本地上下文中或者是Web上下文中，由于在本地上下文中脚本可以调用Windows运行时，我们姑且使用Windows对象来区分两者
    if (typeof Windows === "undefined") {
        //url编码
        options.url = window.encodeURI(options.url);
        options.isInTheSameDomain = options.isInTheSameDomain || _SuperMap2.default.Util.isInTheSameDomain(options.url);
        if (options.isInTheSameDomain) {
            if (options.method === "GET" && options.params) {
                var params = options.params,
                    paramString = _SuperMap2.default.Util.getParameterString(params);
                if (_SuperMap2.default.Util.urlIsLong(paramString)) {
                    var data = options.data;
                    options.method = "POST";
                    options.url += separator + "_method=GET";

                    data = "{";
                    for (var key in params) {
                        data += "'" + key + "':" + encodeURIComponent(params[key]) + ",";
                    }
                    data += "}";
                    options.data = data;
                } else {
                    if (paramString.length > 0) {
                        url += separator + paramString;
                    }
                    options.url = url;
                }
                delete options.params;
            }
            /*if(options.proxy){
                options.url = options.proxy + encodeURIComponent(options.url);
            }*/

            //iServer 6R 服务端只支持["Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"] 的post
            //现在只加在POST的请求头里面，PUT和DELETE有需要再加。
            var headers = options.headers || {};
            options.headers = headers;
            switch (options.method) {
                case "GET":
                    _SuperMap2.default.Request.GET(options);
                    break;
                case "POST":
                    headers["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";
                    _SuperMap2.default.Request.POST(options);
                    break;
                case "PUT":
                    //options.url += (end === "?") ? "_method=PUT" : "&_method=PUT";
                    headers["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";
                    _SuperMap2.default.Request.PUT(options);
                    break;
                case "DELETE":
                    //options.url += (end === "?") ? "_method=DELETE" : "&_method=DELETE";
                    //同域请求的时候因为使用的方法中标记了请求类型，因此无图添加模拟字段
                    headers["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";
                    _SuperMap2.default.Request.DELETE(options);
                    break;
            }
        } else {
            switch (options.method) {
                case "GET":
                    _SuperMap2.default.Util.RequestJSONP.GET(options);
                    break;
                case "POST":
                    options.url += separator + "_method=POST";
                    _SuperMap2.default.Util.RequestJSONP.POST(options);
                    break;
                case "PUT":
                    options.url += separator + "_method=PUT";
                    _SuperMap2.default.Util.RequestJSONP.PUT(options);
                    break;
                case "DELETE":
                    options.url += separator + "_method=DELETE";
                    _SuperMap2.default.Util.RequestJSONP.DELETE(options);
                    break;
            }
        }
    } else {
        var urlParams = "",
            isFirstKey = true;
        if (options.params && options.method === "GET") {
            for (var key in options.params) {
                if (!isFirstKey) {
                    urlParams += "&" + key + "=" + options.params[key];
                } else {
                    isFirstKey = false;
                    urlParams += key + "=" + options.params[key];
                }
            }
        }
        options.url = options.url.replace(/jsonp/, "json");
        if (urlParams) {
            options.url += separator + urlParams;
        }
        if (options.proxy) {
            options.url = options.proxy + encodeURIComponent(options.url);
        } else {
            options.url = window.encodeURI(options.url);
        }
        WinJS.xhr({
            url: options.url,
            type: options.method,
            data: options.data,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
            }
        }).then(function (result) {
            var success = options.scope ? _SuperMap2.default.Function.bind(options.success, options.scope) : options.success;
            success(result);
        }, function (error) {
            var failure = options.scope ? _SuperMap2.default.Function.bind(options.failure, options.scope) : options.failure;
            failure(error);
        });
    }
};

_SuperMap2.default.Util.RequestJSONP = {
    limitLength: 1500,
    queryKeys: [],
    queryValues: [],
    supermap_callbacks: {},
    addQueryStrings: function addQueryStrings(values) {
        var me = this;
        for (var key in values) {
            me.queryKeys.push(key);
            if (typeof values[key] !== "string") {
                values[key] = _SuperMap2.default.Util.toJSON(values[key]);
            }
            var tempValue = encodeURIComponent(values[key]);
            //防止将“=”先转义成%3D后，下文无法将其再转换成“&eq;”
            // tempValue = tempValue.replace("%3D", "&eq;");              
            me.queryValues.push(tempValue);
            /*if (document.attachEvent) {
                var tempValue = encodeURIComponent(values[i]);
                //防止将“=”先转义成%3D后，下文无法将其再转换成“&eq;”
                tempValue = tempValue.replace("%3D", "&eq;");              
                me.queryValues.push(tempValue);
            
            } else {
                var tempValue = encodeURIComponent(values[i]);
                //防止将“=”先转义成%3D后，下文无法将其再转换成“&eq;”
                tempValue = tempValue.replace("%3D", "&eq;");              
                me.queryValues.push(tempValue);
            }*/
        }
    },
    issue: function issue(config) {
        //url, method, params, data, scope, success, failure, userContext,isInTheSameDomain
        var me = this,
            uid = me.getUid(),
            url = config.url,
            success = null,
            failure = null,
            splitQuestUrl = [];
        if (config.success) {
            success = config.scope ? _SuperMap2.default.Function.bind(config.success, config.scope) : config.success;
        }
        if (config.failure) {
            failure = config.scope ? _SuperMap2.default.Function.bind(config.failure, config.scope) : config.failure;
        }
        me.supermap_callbacks[uid] = function (json) {
            var result = _SuperMap2.default.Util.transformResult(json);
            result.succeed = result.succeed == undefined ? true : result.succeed;
            if (result.succeed && success) {
                success(json);
            } else if (failure) {
                failure(json);
            }
            delete me.supermap_callbacks[uid];
        };
        me.addQueryStrings({ callback: "SuperMap.Util.RequestJSONP.supermap_callbacks[" + uid + "]" });
        var queryKeys = me.queryKeys,
            sectionURL = url,
            keysCount = 0; //此次sectionURL中有多少个key
        var length = me.queryKeys ? me.queryKeys.length : 0;
        for (var i = 0; i < length; i++) {
            if (sectionURL.length + me.queryKeys[i].length + 2 >= me.limitLength) {
                //+2 for ("&"or"?")and"="
                if (keysCount == 0) {
                    return false;
                }
                if (splitQuestUrl == null) {
                    splitQuestUrl = new Array();
                }
                splitQuestUrl.push(sectionURL);
                sectionURL = url;
                keysCount = 0;
                i--;
            } else {
                if (sectionURL.length + me.queryKeys[i].length + 2 + me.queryValues[i].length > me.limitLength) {
                    var leftValue = me.queryValues[i];
                    while (leftValue.length > 0) {
                        var leftLength = me.limitLength - sectionURL.length - me.queryKeys[i].length - 2; //+2 for ("&"or"?")and"="
                        if (sectionURL.indexOf("?") > -1) {
                            sectionURL += "&";
                        } else {
                            sectionURL += "?";
                        }
                        var tempLeftValue = leftValue.substring(0, leftLength);
                        //避免 截断sectionURL时，将类似于%22这样的符号截成两半，从而导致服务端组装sectionURL时发生错误
                        if (tempLeftValue.substring(leftLength - 1, leftLength) === "%") {
                            leftLength -= 1;
                            tempLeftValue = leftValue.substring(0, leftLength);
                        } else if (tempLeftValue.substring(leftLength - 2, leftLength - 1) === "%") {
                            leftLength -= 2;
                            tempLeftValue = leftValue.substring(0, leftLength);
                        }

                        sectionURL += me.queryKeys[i] + "=" + tempLeftValue;
                        leftValue = leftValue.substring(leftLength);
                        if (tempLeftValue.length > 0) {
                            if (splitQuestUrl == null) {
                                splitQuestUrl = new Array();
                            }
                            splitQuestUrl.push(sectionURL);
                            sectionURL = url;
                            keysCount = 0;
                        }
                    }
                } else {
                    keysCount++;
                    if (sectionURL.indexOf("?") > -1) {
                        sectionURL += "&";
                    } else {
                        sectionURL += "?";
                    }
                    var tempLeftValue = me.queryValues[i];
                    sectionURL += me.queryKeys[i] + "=" + tempLeftValue;
                }
            }
        }
        if (splitQuestUrl == null) {
            splitQuestUrl = new Array();
        }
        sectionURL !== url && splitQuestUrl.push(sectionURL);
        me.send(splitQuestUrl, config && config.proxy);
    },

    getUid: function getUid() {
        var uid = new Date().getTime(),
            random = Math.floor(Math.random() * 1e17);
        return uid * 1000 + random;
    },

    send: function send(splitQuestUrl, proxy) {
        var len = splitQuestUrl.length;
        if (len > 0) {
            var jsonpUserID = new Date().getTime();
            for (var i = 0; i < len; i++) {
                var script = document.createElement("script");
                var url = splitQuestUrl[i];
                if (url.indexOf("?") > -1) {
                    url += "&";
                } else {
                    url += "?";
                }
                url += "sectionCount=" + len;
                url += "&sectionIndex=" + i;
                url += "&jsonpUserID=" + jsonpUserID;
                if (proxy) {
                    url = decodeURIComponent(url);
                    url = proxy + encodeURIComponent(url);
                }
                script.setAttribute("src", url);
                script.setAttribute("type", "text/javascript");

                if (navigator.userAgent.indexOf("IE") >= 0) {
                    script.onreadystatechange = function () {
                        if (this && ("loaded" === this.readyState || "complete" === this.readyState)) {
                            this.onreadystatechange = null;
                            try {
                                document.body.removeChild(this);
                            } catch (e) {
                                if (this.parentNode) {
                                    this.parentNode.removeChild(this);
                                }
                                delete this;
                            }
                        }
                    };
                } else {
                    script.onload = function () {
                        this.onload = null;
                        document.body.removeChild(this);
                    };
                }
                document.body.appendChild(script);
            }
        }
    },

    GET: function GET(config) {
        var me = this;
        me.queryKeys.length = 0;
        me.queryValues.length = 0;
        me.addQueryStrings(config.params);
        me.issue(config);
    },

    POST: function POST(config) {
        var me = this;
        me.queryKeys.length = 0;
        me.queryValues.length = 0;
        me.addQueryStrings({ requestEntity: config.data });
        me.issue(config);
    },

    PUT: function PUT(config) {
        var me = this;
        me.queryKeys.length = 0;
        me.queryValues.length = 0;
        me.addQueryStrings({ requestEntity: config.data });
        me.issue(config);
    },
    DELETE: function DELETE(config) {
        var me = this;
        me.queryKeys.length = 0;
        me.queryValues.length = 0;
        me.addQueryStrings({ requestEntity: config.data });
        me.issue(config);
    }
};

/**
 * @description 转换查询结果。
 * @param result - {Object} 查询结果。
 *
 * @returns {Object} 转换后的查询结果。
 */
_SuperMap2.default.Util.transformResult = function (result) {
    if (result.responseText && typeof result.responseText === "string") {
        //支持JSON对象的浏览器Firefox 3.1 + ，IE 8 RC1 +
        if (typeof JSON != 'undefined' && JSON.parse) {
            result = JSON.parse(result.responseText);
        } else {
            result = eval("(" + result.responseText + ")");
        }
    }
    return result;
};

/**
 * @description 属性拷贝，不拷贝方法类名(CLASS_NAME)等。
 * @param destination - {Object} 拷贝目标。
 * source {Object} 属性拷贝源对象。
 *
 */
_SuperMap2.default.Util.copyAttributes = function (destination, source) {
    destination = destination || {};
    if (source) {
        for (var property in source) {
            var value = source[property];
            if (value !== undefined && property !== "CLASS_NAME" && typeof value !== "function") {
                destination[property] = value;
            }
        }
    }
    return destination;
};

/**
 * @description 将源对象上的属性拷贝到目标对象上。（不拷贝 CLASS_NAME 和方法）
 * @param destination - {Object} 目标对象。
 * @param source - {Object} 源对象。
 * @param clip - {Array<string>} 源对象中禁止拷贝到目标对象的属性，目的是防止目标对象上不可修改的属性被篡改。
 *
 */
_SuperMap2.default.Util.copyAttributesWithClip = function (destination, source, clip) {
    destination = destination || {};
    if (source) {
        for (var property in source) {
            //去掉禁止拷贝的属性
            var isInClip = false;
            if (clip && clip.length) {
                for (var i = 0, len = clip.length; i < len; i++) {
                    if (property === clip[i]) {
                        isInClip = true;
                        break;
                    }
                }
            }
            if (isInClip === true) {
                continue;
            }

            var value = source[property];
            if (value !== undefined && property !== "CLASS_NAME" && typeof value !== "function") {
                destination[property] = value;
            }
        }
    }
    return destination;
};

/**
 * @description JSON对象拷贝，所有新属性信息等。
 * @param destination - {Object} 拷贝目标。
 * source {Object} 属性拷贝源对象。
 *
 */
_SuperMap2.default.Util.JSONClone = function (destination, source) {
    destination = destination || {};
    if (source) {
        if (source instanceof Array) {
            destination = [];
            for (var index = 0, len = source.length; index < len; index++) {
                var iObject = source[index];
                destination.push(_SuperMap2.default.Util.JSONClone({}, iObject));
            }
        } else {
            for (var property in source) {
                var value = source[property];
                if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === "object") {
                    var tempObj = {};
                    destination[property] = _SuperMap2.default.Util.JSONClone(tempObj, value);
                }
                destination[property] = value;
            }
        }
    }
    return destination;
};
/**
 * @description 设置该应用为移动端应用。
 * @param isApp - {Boolean}  是否是移动项目。
 *
 */
_SuperMap2.default.Util.setApp = function (isApp) {
    _SuperMap2.default.isApp = !!isApp;
};
/**
 * @description 克隆一份Object对象
 * @param obj - {Object}  需要克隆的对象。
 * @returns {Object} 返回对象的拷贝对象，注意是新的对象，不是指向
 */
_SuperMap2.default.Util.cloneObject = function (obj) {
    // Handle the 3 simple types, and null or undefined
    if (null === obj || "object" !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;

    // Handle Date
    if (obj instanceof Date) {
        var copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
        var copy = obj.slice(0);
        return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
        var copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) {
                copy[attr] = _SuperMap2.default.Util.cloneObject(obj[attr]);
            }
        }
        return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
};

/**
 * @description 判断两条线段是不是有交点
 * @param a1 - {SuperMap.Geometry.Point}  第一条线段的起始节点。
 * @param a2 - {SuperMap.Geometry.Point}  第一条线段的结束节点。
 * @param b1 - {SuperMap.Geometry.Point}  第二条线段的起始节点。
 * @param b2 - {SuperMap.Geometry.Point}  第二条线段的结束节点。
 * @returns {Object} 如果相交返回交点，如果不相交返回两条线段的位置关系
 */
_SuperMap2.default.Util.lineIntersection = function (a1, a2, b1, b2) {
    var intersectValue = null;
    var k1;
    var k2;
    var b = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
    var a = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
    var ab = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    //ab==0代表两条线断的斜率一样
    if (ab != 0) {
        k1 = b / ab;
        k2 = a / ab;

        if (k1 >= 0 && k2 <= 1 && k1 <= 1 && k2 >= 0) {
            intersectValue = new _SuperMap2.default.Geometry.Point(a1.x + k1 * (a2.x - a1.x), a1.y + k1 * (a2.y - a1.y));
        } else {
            intersectValue = "No Intersection";
        }
    } else {

        if (b == 0 && a == 0) {
            var maxy = Math.max(a1.y, a2.y);
            var miny = Math.min(a1.y, a2.y);
            var maxx = Math.max(a1.x, a2.x);
            var minx = Math.min(a1.x, a2.x);
            if ((b1.y >= miny && b1.y <= maxy || b2.y >= miny && b2.y <= maxy) && b1.x >= minx && b1.x <= maxx || b2.x >= minx && b2.x <= maxx) {
                intersectValue = "Coincident"; //重合
            } else {
                intersectValue = "Parallel"; //平行
            }
        } else {
            intersectValue = "Parallel"; //平行
        }
    }
    return intersectValue;
};

/**
 * @description 用矩形对线段进行裁剪
 * @param startPt - {SuperMap.Geometry.Point}  线段的起始节点。
 * @param endPt - {SuperMap.Geometry.Point}  线段的结束节点。
 * @param rect - {SuperMap.Bounds}  矩形。
 * @returns {Array<SuperMap.Geometry.Point>} 返回交点数组（可能是0个、1个或2个）
 */
_SuperMap2.default.Util.clipLineRect = function (startPt, endPt, rect) {
    var aryRect = [];
    var lbPoint = new _SuperMap2.default.Geometry.Point(rect.left, rect.bottom);
    var rtPoint = new _SuperMap2.default.Geometry.Point(rect.right, rect.top);
    var rbPoint = new _SuperMap2.default.Geometry.Point(rect.right, rect.bottom);
    var ltPoint = new _SuperMap2.default.Geometry.Point(rect.left, rect.top);

    var aryPoints = [];
    aryPoints.push(_SuperMap2.default.Util.lineIntersection(lbPoint, rbPoint, startPt, endPt));
    aryPoints.push(_SuperMap2.default.Util.lineIntersection(rbPoint, rtPoint, startPt, endPt));
    aryPoints.push(_SuperMap2.default.Util.lineIntersection(rtPoint, ltPoint, startPt, endPt));
    aryPoints.push(_SuperMap2.default.Util.lineIntersection(ltPoint, lbPoint, startPt, endPt));

    var i = 0;
    while (i < aryPoints.length) {
        if (aryPoints[i].CLASS_NAME === "SuperMap.Geometry.Point") {
            aryRect.push(aryPoints[i]);
        }
        i++;
    }
    return aryRect;
};
/**
 * @description 用矩形对LineString或LinearRing进行裁剪
 * @param lineStr - {SuperMap.Geometry.LineString}  需要进行裁剪的线串（也可以是LinearRing）。
 * @param rect - {SuperMap.Bounds}  矩形。
 * @param isRetArr - {Boolean} 是否返回LineString的数组形式，默认为true。一般情况矩形裁剪线后都可能是多段的，所以数组形式比较合理，如果设置为false，那么返回一条折线，中间断开部分会连接起来
 * @param isCloneId - {Boolean} 是否将裁剪前的线的id赋值给裁剪后的线，此属性默认为false，并且只有isRetArr设置为false时此属性才能设置为ture
 * @returns {Array} 返回线串（SuperMap.Geometry.LineString）数组（里面的线串都是一条线段）
 */
_SuperMap2.default.Util.clipLineStringRect = function (lineStr, rect, isRetArr, isCloneId) {
    isRetArr = isRetArr != undefined ? isRetArr : true;
    isCloneId = isCloneId != undefined ? isCloneId : false;
    //不相交返回null
    if (!rect.intersectsBounds(lineStr.getBounds())) {
        return null;
    }
    //图形在矩形内部直接返回
    if (rect.containsBounds(lineStr.getBounds())) {
        return [lineStr];
    }
    var points = lineStr.components;
    var lineStringResult = [];
    for (var i = 0; i < points.length - 1; i++) {
        var point1 = new _SuperMap2.default.Geometry.Point(points[i].x, points[i].y);
        var point2 = new _SuperMap2.default.Geometry.Point(points[i + 1].x, points[i + 1].y);
        var array = _SuperMap2.default.Util.clipLineRect(point1, point2, rect);
        var line;
        //两个交点直接存入
        if (array.length === 2) {
            //两个交点的时候必须拍一下顺序，因为在求交的时候没有考虑交点的先后顺序
            if ((array[0].x - point1.x) * (array[0].x - point1.x) + (array[0].y - point1.y) * (array[0].y - point1.y) > (array[1].x - point1.x) * (array[1].x - point1.x) + (array[1].y - point1.y) * (array[1].y - point1.y)) {
                //如果第一个交点里裁剪起始点远，则把两个交点交换位置
                var a = array[0];
                array[0] = array[1];
                array[1] = a;
            }
            if (isRetArr) {
                line = new _SuperMap2.default.Geometry.LineString(array);
                lineStringResult.push(line);
            } else {
                lineStringResult.push(array[0], array[1]);
            }
        }
        //一个交点，需要保留内部的点
        else if (array.length === 1) {
                //存起始点和相交点
                //不包含边界，因为可能出现刚好是端点相交于边界
                if (rect.contains(point1.x, point1.y, false)) {
                    if (isRetArr) {
                        line = new _SuperMap2.default.Geometry.LineString([point1, array[0]]);
                        lineStringResult.push(line);
                    } else {
                        lineStringResult.push(point1, array[0]);
                    }
                }
                //存相交点和结束点
                //不包含边界，因为可能出现刚好是端点相交于边界
                else if (rect.contains(point2.x, point2.y, false)) {
                        if (isRetArr) {
                            line = new _SuperMap2.default.Geometry.LineString([array[0], point2]);
                            lineStringResult.push(line);
                        } else {
                            lineStringResult.push(array[0], point2);
                        }
                    }
                    //代表交予矩形的顶点或者是线段的端点相交于矩形边界上，那么就不作处理
                    else {}
            }
            //没有交点有两种情况，在外面或者在里面
            else if (array.length == 0) {
                    //都在里面，包括边界重合，将两个点加进去
                    if (rect.contains(point1.x, point1.y) && rect.contains(point2.x, point2.y)) {
                        if (isRetArr) {
                            line = new _SuperMap2.default.Geometry.LineString([point1, point2]);
                            lineStringResult.push(line);
                        } else {
                            lineStringResult.push(point1, point2);
                        }
                    }
                    //都在外面
                    else {}
                }
    }
    if (lineStringResult.length > 0) {
        if (!isRetArr) {
            var lineString = new _SuperMap2.default.Geometry.LineString(lineStringResult);
            if (isCloneId) {
                lineString.id = lineStr.id;
            }
            //此处返回的是一条线
            return lineString;
        } else {
            //对于多线，id后缀_clip_i
            if (isCloneId) {
                lineStringResult[0].id = lineStr.id;
                if (lineStringResult.length > 1) {
                    for (var i = 1; i < lineStringResult.length; i++) {
                        lineStringResult[i].id = lineStr.id + "_clip_" + i;
                    }
                }
            }
        }
        //此处返回的是线数组
        return lineStringResult;
    }
};
/**
 * @description 用矩形对MultiLineString进行裁剪
 * @param multiLineStr - {SuperMap.Geometry.MultiLineString}  需要进行裁剪的多线。
 * @param rect - {SuperMap.Bounds}  矩形。
 * @param isRetArr - {Boolean} MultiLineString是由LineString组成的，此处设置内部进行LineString裁剪时是否返回LineString的数组形式，默认为true。一般情况矩形裁剪线后都可能是多段的，所以数组形式比较合理，如果设置为false，那么返回一条折线，中间断开部分会连接起来
 * @param isCloneId - {Boolean} 是否将裁剪前的线的id赋值给裁剪后的线，此属性默认为false，并且只有isRetArr设置为false时此属性才能设置为ture
 * @returns {SuperMap.Geometry.MultiLineString} 返回多线
 */
_SuperMap2.default.Util.clipMultiLineStringRect = function (multiLineStr, rect, isRetArr, isCloneId) {
    isRetArr = isRetArr != undefined ? isRetArr : true;
    isCloneId = isCloneId != undefined ? isCloneId : false;
    //不相交返回null
    if (!rect.intersectsBounds(multiLineStr.getBounds())) {
        return null;
    }
    //图形在矩形内部直接返回
    if (rect.containsBounds(multiLineStr.getBounds())) {
        return multiLineStr;
    }
    var lineStrs = multiLineStr.components;
    var result = [];
    for (var i = 0; i < lineStrs.length; i++) {
        var arr = _SuperMap2.default.Util.clipLineStringRect(lineStrs[i], rect, isRetArr, isCloneId);
        if (!arr) {
            //为空继续
            continue;
        }
        //此处返回可能是数组可能是一条线
        if (arr instanceof Array) {
            result = result.concat(arr);
        } else {
            result.push(arr);
        }
    }
    if (result.length > 0) {

        var mu = new _SuperMap2.default.Geometry.MultiLineString(result);
        if (isCloneId) {
            mu.id = multiLineStr.id;
            return mu;
        }

        return mu;
    }
};
/**
 * @description 根据待裁剪的多边形的bounds范围将矩形的bounds四条边进行扩展出四条裁剪标准边界
 * @param rect1 - {SuperMap.Bounds}  矩形的bounds。
 * @param rect2 - {SuperMap.Bounds}  待裁剪多边形的bounds。
 * @returns {Array} 返回左、上、右、下四条扩展后的裁剪边界数组
 */
_SuperMap2.default.Util.getIntersectLineArray = function (rect1, rect2) {

    //左边缘的边的下面的点的x保留自身，y取最小的
    var leftLineBottomPoint = new _SuperMap2.default.Geometry.Point(rect1.left, rect1.bottom < rect2.bottom ? rect1.bottom : rect2.bottom);
    //左边缘的边的上面的点的x保留自身，y取最大的
    var leftLineTopPoint = new _SuperMap2.default.Geometry.Point(rect1.left, rect1.top > rect2.top ? rect1.top : rect2.top);
    //按照顺时针添加这两个点
    //左边缘的边
    var leftLine = new _SuperMap2.default.Geometry.LineString([leftLineBottomPoint, leftLineTopPoint]);

    //上边缘的边的左边的点的x取最小值，y保留自身
    var topLineLeftPoint = new _SuperMap2.default.Geometry.Point(rect1.left < rect2.left ? rect1.left : rect2.left, rect1.top);
    //上边缘的边的右边的点的x取最大值，y保留自身
    var topLineRightPoint = new _SuperMap2.default.Geometry.Point(rect1.right > rect2.right ? rect1.right : rect2.right, rect1.top);
    //按照顺时针添加这两个点
    //上边缘的边
    var topLine = new _SuperMap2.default.Geometry.LineString([topLineLeftPoint, topLineRightPoint]);

    var rightLineTopPoint = new _SuperMap2.default.Geometry.Point(rect1.right, rect1.top > rect2.top ? rect1.top : rect2.top);
    var rightLineBottomPoint = new _SuperMap2.default.Geometry.Point(rect1.right, rect1.bottom < rect2.bottom ? rect1.bottom : rect2.bottom);
    //按照顺时针添加这两个点
    var rightLine = new _SuperMap2.default.Geometry.LineString([rightLineTopPoint, rightLineBottomPoint]);

    var bottomLineRightPoint = new _SuperMap2.default.Geometry.Point(rect1.right > rect2.right ? rect1.right : rect2.right, rect1.bottom);
    var bottomLineLeftPoint = new _SuperMap2.default.Geometry.Point(rect1.left < rect2.left ? rect1.left : rect2.left, rect1.bottom);
    //按照顺时针添加这两个点
    var bottomLine = new _SuperMap2.default.Geometry.LineString([bottomLineRightPoint, bottomLineLeftPoint]);

    return [leftLine, topLine, rightLine, bottomLine];
};

_SuperMap2.default.Util.isInside = function (point, rect, side) {
    if (side == 0 && point.x >= rect.left) {
        return true;
    } else if (side === 1 && point.y <= rect.top) {
        return true;
    } else if (side === 2 && point.x <= rect.right) {
        return true;
    } else if (side === 3 && point.y >= rect.bottom) {
        return true;
    }
    return false;
};

/**
 * @description 用矩形对多边形进行裁剪
 * @param polygon - {SuperMap.Geometry.Polygon}  待裁剪的多边形。
 * @param rect - {SuperMap.Bounds}  作为裁剪标准的bounds。
 * @param isCloneId - {Boolean} 是否将裁剪前的面的id以及面内部的线环的id赋值给裁剪后的面以及线环（裁剪后的线环不会变成多个，所以和裁剪线不同），此属性默认为false。
 * @returns {SuperMap.Geometry.Polygon} 返回裁剪后的多边形
 */
_SuperMap2.default.Util.clipPolygonRect = function (polygon, rect, isCloneId) {

    //不相交返回null
    if (!rect.intersectsBounds(polygon.getBounds())) {
        return null;
    }
    //图形在矩形内部直接返回
    if (rect.containsBounds(polygon.getBounds())) {
        return polygon;
    }
    isCloneId = isCloneId != undefined ? isCloneId : false;
    var polygonResult = [];
    //获取线环数组
    var linearRings = polygon.components;
    for (var i = 0; i < linearRings.length; i++) {
        //当前线环在bounds内直接添加进行
        if (rect.containsBounds(linearRings[i].getBounds())) {
            polygonResult.push(linearRings[i]);
            continue;
        }
        //将矩形的四个点取出根据面的bounds计算出一个能够延长到面的bounds边缘的四条线，给后面线线求交提供基础
        var intersectLines = _SuperMap2.default.Util.getIntersectLineArray(rect, linearRings[i].getBounds());
        var pointArray = linearRings[i].components;

        var cur = [],
            result = [],
            resultPoints = [];

        var rectSize = 4,
            pointSize = pointArray.length;

        var S = pointArray[pointSize - 1];

        for (var j = 0; j < pointSize; j++) {
            result.push(pointArray[j]);
        }

        var flag;
        // flag=false点在内侧，true点在外侧
        for (var j = 0; j < rectSize; j++) {
            if (_SuperMap2.default.Util.isInside(S, rect, j)) {
                flag = false;
            } else {
                flag = true;
            }

            var resultSize = result.length;
            for (var k = 0; k < resultSize; k++) {
                //证明其在vector内
                if (_SuperMap2.default.Util.isInside(result[k], rect, j)) {
                    //如果前一个点在外侧，则将他们的交点加入结果集
                    if (flag) {
                        flag = false;
                        cur.push(_SuperMap2.default.Util.lineIntersection(S, result[k], intersectLines[j].components[0], intersectLines[j].components[1]));
                    }
                    //并将他们当前节点加入结果集
                    cur.push(result[k]);
                } else {
                    if (!flag) {
                        //如果前一个点在内侧，则将他们的交点加入结果集
                        flag = true;
                        cur.push(_SuperMap2.default.Util.lineIntersection(S, result[k], intersectLines[j].components[0], intersectLines[j].components[1]));
                    }
                }
                //更新首次比较的节点
                S = result[k];
            }

            var curLength = cur.length;
            result.length = 0;
            //将本次结果拷贝出来作为下次对比的样本
            for (var l = 0; l < curLength; l++) {
                result.push(cur[l]);
            }
            cur.length = 0;
        }

        for (var j = 0; j < result.length; j++) {
            resultPoints.push(result[j]);
        }

        if (resultPoints.length > 2) {
            var linear = new _SuperMap2.default.Geometry.LinearRing(resultPoints);
            if (isCloneId) {
                linear.id = linearRings[i].id;
            }
            polygonResult.push(linear);
        }
    }
    if (polygonResult.length > 0) {
        var reg = new _SuperMap2.default.Geometry.Polygon(polygonResult);
        if (isCloneId) {

            reg.id = polygon.id;
            return reg;
        }
        return reg;
    }
};
/**
 * @description 用矩形对MultiPolygon进行裁剪
 * @param multiPolygon - {SuperMap.Geometry.MultiPolygon}  待裁剪的MultiPolygon。
 * @param rect - {SuperMap.Bounds}  作为裁剪标准的bounds。
 * @param isCloneId - {Boolean} 是否将裁剪前的多面的id以及多面内部的面和线环的id赋值给裁剪后的多的id以及面和线环（裁剪后的线环不会变成多个，所以和裁剪线不同），此属性默认为false。
 * @returns {SuperMap.Geometry.MultiPolygon} 返回裁剪后的MultiPolygon
 */
_SuperMap2.default.Util.clipMultiPolygonRect = function (multiPolygon, rect, isCloneId) {
    //不相交返回null
    if (!rect.intersectsBounds(multiPolygon.getBounds())) {
        return null;
    }
    //图形在矩形内部直接返回
    if (rect.containsBounds(multiPolygon.getBounds())) {
        return multiPolygon;
    }

    isCloneId = isCloneId != undefined ? isCloneId : false;
    var resultMultiPolygon = [];
    for (var i = 0; i < multiPolygon.components.length; i++) {
        var polygon = _SuperMap2.default.Util.clipPolygonRect(multiPolygon.components[i], rect, isCloneId);
        if (polygon) {
            resultMultiPolygon.push(polygon);
        }
    }
    if (resultMultiPolygon.length > 0) {
        var mp = new _SuperMap2.default.Geometry.MultiPolygon(resultMultiPolygon);
        if (isCloneId) {
            mp.id = multiPolygon.id;
        }
        return mp;
    }
};
/**
 * @description 用矩形对Geometry进行裁剪（主要针对线和面）
 * 支持对 LineString  LinearRing  MultiLineString   Polygon   MultiPolygon的裁剪
 * @param geometry - {SuperMap.Geometry}  需要进行裁剪的 Geometry
 * @param rect - {SuperMap.Bounds}  矩形。
 * @param isRetArr - {Boolean} 此参数只在对线裁剪时有用，如果设置为ture，那就是默认的，一般线被裁剪后都会变成多线，如果设置为false，会将多线组合成为一条线。一般情况矩形裁剪线后都可能是多段的，所以数组形式比较合理，如果设置为false，那么返回一条折线，中间断开部分会连接起来
 * @param isCloneId - {Boolean} 是否将裁剪前的Geometryid赋值给裁剪后的Geometry，此属性默认为false
 * @returns {SuperMap.Geometry} 返回裁剪后的SuperMap.Geometry
 */
_SuperMap2.default.Util.clipGeometryRect = function (geometry, rect, isRetArr, isCloneId) {
    if (geometry) {
        isRetArr = isRetArr != undefined ? isRetArr : true;
        isCloneId = isCloneId != undefined ? isCloneId : false;
        if ((geometry.CLASS_NAME === "SuperMap.Geometry.LineString" || geometry.CLASS_NAME === "SuperMap.Geometry.LinearRing") && geometry.components.length > 1) {
            var arr = _SuperMap2.default.Util.clipLineStringRect(geometry, rect, isRetArr, isCloneId);
            if (arr) {
                //返回的一条折线
                if (arr.length === 1) {
                    return arr[0];
                }
                //返回的是一条多线
                else {
                        //进入此处那么必然返回的是线数组了，那么id也没意义了，不用赋值
                        return new _SuperMap2.default.Geometry.MultiLineString(arr);
                    }
            }
        } else if (geometry.CLASS_NAME === "SuperMap.Geometry.MultiLineString" && geometry.components.length > 0 && geometry.components[0].components.length > 1) {
            return _SuperMap2.default.Util.clipMultiLineStringRect(geometry, rect, isRetArr, isCloneId);
        } else if (geometry.CLASS_NAME === "SuperMap.Geometry.Polygon" && geometry.components.length > 0 && geometry.components[0].components.length > 2) {
            return _SuperMap2.default.Util.clipPolygonRect(geometry, rect, isCloneId);
        } else if (geometry.CLASS_NAME === "SuperMap.Geometry.MultiPolygon" && geometry.components.length > 0) {
            return _SuperMap2.default.Util.clipMultiPolygonRect(geometry, rect, true);
        } else {
            return geometry;
        }
    }
};

/**
 * @description 获取文本外接矩形宽度与高度
 * @param style - {SuperMap.Style}  文本样式
 * @param text - {string} 文本内容
 * @param element - {DOMObject} DOM元素
 * @returns {Object} 返回裁剪后的宽度，高度信息
 */
_SuperMap2.default.Util.getTextBounds = function (style, text, element) {
    document.body.appendChild(element);
    element.style.width = 'auto';
    element.style.height = 'auto';
    if (style.fontSize) element.style.fontSize = style.fontSize;
    if (style.fontFamily) element.style.fontFamily = style.fontFamily;
    if (style.fontWeight) element.style.fontWeight = style.fontWeight;
    element.style.position = 'relative';
    element.style.visibility = 'hidden';
    //fix 在某些情况下，element内的文本变成竖起排列，导致宽度计算不正确的bug
    element.style.display = 'inline-block';
    element.innerHTML = text;
    var textWidth = element.clientWidth;
    var textHeight = element.clientHeight;
    document.body.removeChild(element);
    return {
        textWidth: textWidth,
        textHeight: textHeight
    };
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SpatialAnalystBase
 * @classdesc 空间分析服务基类。
 * @param url -{string} 地址d。
 * @param options -{Object} 参数。
 * @extends SuperMap.CommonServiceBase
 */
var SpatialAnalystBase = function (_CommonServiceBase) {
    _inherits(SpatialAnalystBase, _CommonServiceBase);

    function SpatialAnalystBase(url, options) {
        _classCallCheck(this, SpatialAnalystBase);

        var _this = _possibleConstructorReturn(this, (SpatialAnalystBase.__proto__ || Object.getPrototypeOf(SpatialAnalystBase)).call(this, url, options));

        _this.format = _REST.DataFormat.GEOJSON;
        _this.CLASS_NAME = "SuperMap.SpatialAnalystBase";

        if (options && options.format) {
            _this.format = options.format.toUpperCase();
        }
        return _this;
    }

    /**
     * @inheritDoc
     *
     */

    /**
     * @member SuperMap.SpatialAnalystBase.prototype.format -{string}
     * @description 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式，参数格式为"ISERVER","GEOJSON",GEOJSON
     */


    _createClass(SpatialAnalystBase, [{
        key: 'destroy',
        value: function destroy() {
            _get(SpatialAnalystBase.prototype.__proto__ || Object.getPrototypeOf(SpatialAnalystBase.prototype), 'destroy', this).call(this);
            this.format = null;
        }

        /**
         * @function SuperMap.SpatialAnalystBase.prototype.serviceProcessCompleted
         * @description 分析完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this,
                analystResult;
            result = _SuperMap2.default.Util.transformResult(result);
            if (result && me.format === _REST.DataFormat.GEOJSON && typeof me.toGeoJSONResult === 'function') {
                analystResult = me.toGeoJSONResult(result);
            }
            if (!analystResult) {
                analystResult = result;
            }
            me.events.triggerEvent("processCompleted", { result: analystResult });
        }

        /**
         * @function SuperMap.SpatialAnalystBase.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         *
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON2.default();
            if (result.recordsets) {
                for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
                    if (recordsets[i].features) {
                        recordsets[i].features = JSON.parse(geoJSONFormat.write(recordsets[i].features));
                    }
                }
            } else if (result.recordset && result.recordset.features) {
                result.recordset.features = JSON.parse(geoJSONFormat.write(result.recordset.features));
            }
            if (result.resultGeometry) {
                result.resultGeometry = JSON.parse(geoJSONFormat.write(result.resultGeometry));
            }

            return result;
        }
    }]);

    return SpatialAnalystBase;
}(_CommonServiceBase3.default);

exports.default = SpatialAnalystBase;

_SuperMap2.default.SpatialAnalystBase = SpatialAnalystBase;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _JSON = __webpack_require__(163);

var _JSON2 = _interopRequireDefault(_JSON);

var _Point = __webpack_require__(11);

var _Point2 = _interopRequireDefault(_Point);

var _MultiPoint = __webpack_require__(46);

var _MultiPoint2 = _interopRequireDefault(_MultiPoint);

var _LineString = __webpack_require__(23);

var _LineString2 = _interopRequireDefault(_LineString);

var _MultiLineString = __webpack_require__(63);

var _MultiLineString2 = _interopRequireDefault(_MultiLineString);

var _LinearRing = __webpack_require__(38);

var _LinearRing2 = _interopRequireDefault(_LinearRing);

var _Polygon = __webpack_require__(47);

var _Polygon2 = _interopRequireDefault(_Polygon);

var _MultiPolygon = __webpack_require__(64);

var _MultiPolygon2 = _interopRequireDefault(_MultiPolygon);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Format.GeoJSON
 * @description GeoJSON 的读和写。使用 <SuperMap.Format.GeoJSON> 构造器创建一个GeoJSON解析器.
 * @augments SuperMap.Format.JSON
 * @param options - {Object} 选项对象，
 */
var GeoJSON = function (_JSONFormat) {
    _inherits(GeoJSON, _JSONFormat);

    function GeoJSON() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, GeoJSON);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = GeoJSON.__proto__ || Object.getPrototypeOf(GeoJSON)).call.apply(_ref, [this].concat(args))), _this), _this.ignoreExtraDims = false, _this.parseCoords = {
            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.point
             * @description 将一组坐标成一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的一组坐标。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "point": function point(array) {
                if (this.ignoreExtraDims == false && array.length != 2) {
                    throw "Only 2D points are supported: " + array;
                }
                return new _Point2.default(array[0], array[1]);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.multipoint
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "multipoint": function multipoint(array) {
                var points = [];
                var p = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        p = this.parseCoords["point"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    points.push(p);
                }
                return new _MultiPoint2.default(points);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.linestring
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "linestring": function linestring(array) {
                var points = [];
                var p = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        p = this.parseCoords["point"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    points.push(p);
                }
                return new _LineString2.default(points);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.multilinestring
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "multilinestring": function multilinestring(array) {
                var lines = [];
                var l = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        l = this.parseCoords["linestring"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    lines.push(l);
                }
                return new _MultiLineString2.default(lines);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.polygon
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "polygon": function polygon(array) {
                var rings = [];
                var r, l;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        l = this.parseCoords["linestring"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    r = new _LinearRing2.default(l.components);
                    rings.push(r);
                }
                return new _Polygon2.default(rings);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.multipolygon
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "multipolygon": function multipolygon(array) {
                var polys = [];
                var p = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        p = this.parseCoords["polygon"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    polys.push(p);
                }
                return new _MultiPolygon2.default(polys);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.box
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "box": function box(array) {
                if (array.length != 2) {
                    throw "GeoJSON box coordinates must have 2 elements";
                }
                return new _Polygon2.default([new _LinearRing2.default([new _Point2.default(array[0][0], array[0][1]), new _Point2.default(array[1][0], array[0][1]), new _Point2.default(array[1][0], array[1][1]), new _Point2.default(array[0][0], array[1][1]), new _Point2.default(array[0][0], array[0][1])])]);
            }

        }, _this.extract = {
            /**
             * @function SuperMap.Format.GeoJSON.extract.feature
             * @description 返回一个表示单个要素对象的GeoJSON的一部分。
             * @param feature - iServer要素对象
             * @return {Object} 一个表示点的对象。
             */
            'feature': function feature(_feature) {
                var geom = this.extract.geometry.apply(this, [_feature.geometry]);
                var json = {
                    "type": "Feature",
                    "properties": this.createAttributes(_feature),
                    "geometry": geom
                };

                if (_feature.geometry && _feature.geometry.type === 'TEXT') {
                    json.properties.texts = _feature.geometry.texts;
                    json.properties.textStyle = _feature.geometry.textStyle;
                }
                if (_feature.fid !== null) {
                    json.id = _feature.fid;
                }
                if (_feature.ID !== null) {
                    json.id = _feature.ID;
                }
                return json;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.geometry
             * @description 返回一个表示单个几何对象的GeoJSON的一部分。
             * @param geometry -iServer 几何对象
             * @return {Object} 一个表示几何体的对象。
             */
            'geometry': function geometry(_geometry) {
                if (_geometry == null) {
                    return null;
                }
                var geo = this.toGeometry(_geometry);
                var geometryType = geo.type;
                var data = this.extract[geometryType.toLowerCase()].apply(this, [geo]);
                geometryType = geometryType === 'TEXT' ? 'Point' : geometryType;
                var json;
                if (geometryType === "Collection") {
                    json = {
                        "type": "GeometryCollection",
                        "geometries": data
                    };
                } else {
                    json = {
                        "type": geometryType,
                        "coordinates": data
                    };
                }
                return json;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.point
             * @description 从一个点对象中返回一个坐标组。
             * @param point - {SuperMap.Geometry.Point} 一个点对象。
             * @return {Array} 一个表示一个点的坐标组。
             */
            'point': function point(_point) {
                var p = [_point.x, _point.y];
                for (var name in _point) {
                    if (name !== "x" && name !== "y" && !isNaN(_point[name])) {
                        p.push(_point[name]);
                    }
                }
                return p;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.point
             * @description 从一个文本对象中返回一个坐标组。
             * @param geo 一个文本对象。
             * @return {Array} 一个表示一个点的坐标组。
             */
            'text': function text(geo) {
                return [geo.points[0].x, geo.points[0].y];
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.multipoint
             * @description 从一个多点对象中返一个坐标组数组。
             * @param multipoint - {SuperMap.Geometry.MultiPoint} 多点对象。
             * @return {Array} 一个表示多点的坐标组数组。
             */
            'multipoint': function multipoint(_multipoint) {
                var array = [];
                for (var i = 0, len = _multipoint.components.length; i < len; ++i) {
                    array.push(this.extract.point.apply(this, [_multipoint.components[i]]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.linestring
             * @description 从一个线对象中返回一个坐标组数组。
             * @param linestring - {SuperMap.Geometry.Linestring} 线对象。
             * @return {Array} 一个表示线对象的坐标组数组。
             */
            'linestring': function linestring(_linestring) {
                var array = [];
                for (var i = 0, len = _linestring.components.length; i < len; ++i) {
                    array.push(this.extract.point.apply(this, [_linestring.components[i]]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.multilinestring
             * @description 从一个多线对象中返回一个线数组。
             * @param multilinestring - {SuperMap.Geometry.MultiLinestring} 多线对象
             *
             * @return {Array} 一个表示多线的线数组。
             */
            'multilinestring': function multilinestring(_multilinestring) {
                var array = [];
                for (var i = 0, len = _multilinestring.components.length; i < len; ++i) {
                    array.push(this.extract.linestring.apply(this, [{ components: _multilinestring.components[i] }]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.polygon
             * @description 从一个面对象中返回一组线环。
             * @polygon - {SuperMap.Geometry.Polygon} 面对象。
             * @return {Array} 一组表示面的线环。
             */
            'polygon': function polygon(_polygon) {
                var array = [];
                for (var i = 0, len = _polygon.components.length; i < len; ++i) {
                    array.push(this.extract.linestring.apply(this, [{ components: _polygon.components[i] }]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.multipolygon
             * @description 从一个多面对象中返回一组面。
             * @param multipolygon - {SuperMap.Geometry.MultiPolygon} 多面对象。
             * @return {Array} 一组表示多面的面。
             */
            'multipolygon': function multipolygon(_multipolygon) {
                var array = [];
                for (var i = 0, len = _multipolygon.components.length; i < len; ++i) {
                    array.push(this.extract.polygon.apply(this, [{ components: _multipolygon.components[i] }]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.collection
             * @description 从一个几何要素集合中一组几何要素数组。
             * @param collection - {SuperMap.Geometry.Collection} 几何要素集合。
             * @return {Array} 一组表示几何要素集合的几何要素数组。
             */
            'collection': function collection(_collection) {
                var len = _collection.components.length;
                var array = new Array(len);
                for (var i = 0; i < len; ++i) {
                    array[i] = this.extract.geometry.apply(this, [{
                        type: "Collection",
                        components: _collection.components[i]
                    }]);
                }
                return array;
            }
        }, _this.CLASS_NAME = "SuperMap.Format.GeoJSON", _temp), _possibleConstructorReturn(_this, _ret);
    }

    /**
     * APIProperty: ignoreExtraDims
     * {Boolean} 忽略维度超过2的几何要素
     */


    _createClass(GeoJSON, [{
        key: 'read',


        /**
         * @function SuperMap.Format.GeoJSON.read
         * @description 反序列化一个 GeoJSON 字符串
         *
         * @param json - {string}  GeoJSON 字符串
         * @param type - {string} 可选的字符串，它决定了输出的格式。
         *     支持的值有："Geometry","Feature",和"FeatureCollection",
         *     如果此值为null，则会使用默认值"FeaureCollection"。
         * @param filter - {Function} 对象中每个层次每个键值对都会调用此函数得出一个结果。
         *     每个值都会被filter函数的结果所替换掉。这个函数可被用来将某些对象转化成
         *     某个类相应的对象，或者将日期字符串转化成Date对象。
         *
         * @return {Object}
         *    返回值依赖于type参数的值。如果type等于"FeatureCollection"（默认值），
         *     返回值将会是 <SuperMap.Feature.Vector> 数组。如果type为"Geometry",
         *     输入的json对象必须表示一个唯一的几何体，然后返回值就会是 <SuperMap.Feature.Geometry>
         *     如果type为"Feature"，输入的json对象也必须表示的一个要素，这样返回值才会是<SuperMap.Feature.Vector> 。
         */
        value: function read(json, type, filter) {
            type = type ? type : "FeatureCollection";
            var results = null;
            var obj = null;
            if (typeof json == "string") {
                obj = _get(GeoJSON.prototype.__proto__ || Object.getPrototypeOf(GeoJSON.prototype), 'read', this).call(this, json, filter);
            } else {
                obj = json;
            }
            if (!obj) {
                //SuperMap.Console.error("Bad JSON: " + json);
            } else if (typeof obj.type != "string") {
                //SuperMap.Console.error("Bad GeoJSON - no type: " + json);
            } else if (this.isValidType(obj, type)) {
                switch (type) {
                    case "Geometry":
                        try {
                            results = this.parseGeometry(obj);
                        } catch (err) {
                            //SuperMap.Console.error(err);
                        }
                        break;
                    case "Feature":
                        try {
                            results = this.parseFeature(obj);
                            results.type = "Feature";
                        } catch (err) {
                            //SuperMap.Console.error(err);
                        }
                        break;
                    case "FeatureCollection":
                        // for type FeatureCollection, we allow input to be any type
                        results = [];
                        switch (obj.type) {
                            case "Feature":
                                try {
                                    results.push(this.parseFeature(obj));
                                } catch (err) {
                                    results = null;
                                    //SuperMap.Console.error(err);
                                }
                                break;
                            case "FeatureCollection":
                                for (var i = 0, len = obj.features.length; i < len; ++i) {
                                    try {
                                        results.push(this.parseFeature(obj.features[i]));
                                    } catch (err) {
                                        results = null;
                                        // SuperMap.Console.error(err);
                                    }
                                }
                                break;
                            default:
                                try {
                                    var geom = this.parseGeometry(obj);
                                    results.push(new _SuperMap2.default.Feature.Vector(geom));
                                } catch (err) {
                                    results = null;
                                    //SuperMap.Console.error(err);
                                }
                        }
                        break;
                    default:
                        break;
                }
            }
            return results;
        }

        /**
         *  @function SuperMap.Format.GeoJSON.isValidType
         *  @description 检查一个GeoJSON对象是否和给定的类型相符的合法的对象。
         *  @return {Boolean} GeoJSON是否是给定类型的合法对象。
         */

    }, {
        key: 'isValidType',
        value: function isValidType(obj, type) {
            var valid = false;
            switch (type) {
                case "Geometry":
                    if (_SuperMap2.default.Util.indexOf(["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "Box", "GeometryCollection"], obj.type) == -1) {
                        // unsupported geometry type
                        //SuperMap.Console.error("Unsupported geometry type: " +
                        // obj.type);
                    } else {
                        valid = true;
                    }
                    break;
                case "FeatureCollection":
                    // allow for any type to be converted to a feature collection
                    valid = true;
                    break;
                default:
                    // for Feature types must match
                    if (obj.type == type) {
                        valid = true;
                    } else {
                        //SuperMap.Console.error("Cannot convert types from " +
                        //obj.type + " to " + type);
                    }
            }
            return valid;
        }

        /**
         * @function SuperMap.Format.GeoJSON.parseFeature
         * @description 将一个GeoJSON中的feature转化成<SuperMap.Feature.Vector>对象。
         * @param obj - {Object} 从GeoJSON对象中创建一个对象。
         * @return {SuperMap.Feature.Vector} 一个要素。
         */

    }, {
        key: 'parseFeature',
        value: function parseFeature(obj) {
            var feature, geometry, attributes, bbox;
            attributes = obj.properties ? obj.properties : {};
            bbox = obj.geometry && obj.geometry.bbox || obj.bbox;
            try {
                geometry = this.parseGeometry(obj.geometry);
            } catch (err) {
                // deal with bad geometries
                throw err;
            }
            feature = new _SuperMap2.default.Feature.Vector(geometry, attributes);
            if (bbox) {
                feature.bounds = _SuperMap2.default.Bounds.fromArray(bbox);
            }
            if (obj.id) {
                feature.fid = obj.id;
            }
            return feature;
        }

        /**
         * @function SuperMap.Format.GeoJSON.parseGeometry
         * @description将一个GeoJSON中的几何要素转化成<SuperMap.Geometry>对象。
         * @param obj - {Object} 从GeoJSON对象中创建一个对象。
         * @return {SuperMap.Geometry} 一个几何要素。
         */

    }, {
        key: 'parseGeometry',
        value: function parseGeometry(obj) {
            if (obj == null) {
                return null;
            }
            var geometry,
                collection = false;
            if (obj.type == "GeometryCollection") {
                if (!_SuperMap2.default.Util.isArray(obj.geometries)) {
                    throw "GeometryCollection must have geometries array: " + obj;
                }
                var numGeom = obj.geometries.length;
                var components = new Array(numGeom);
                for (var i = 0; i < numGeom; ++i) {
                    components[i] = this.parseGeometry.apply(this, [obj.geometries[i]]);
                }
                geometry = new _SuperMap2.default.Geometry.Collection(components);
                collection = true;
            } else {
                if (!_SuperMap2.default.Util.isArray(obj.coordinates)) {
                    throw "Geometry must have coordinates array: " + obj;
                }
                if (!this.parseCoords[obj.type.toLowerCase()]) {
                    throw "Unsupported geometry type: " + obj.type;
                }
                try {
                    geometry = this.parseCoords[obj.type.toLowerCase()].apply(this, [obj.coordinates]);
                } catch (err) {
                    // deal with bad coordinates
                    throw err;
                }
            }
            // We don't reproject collections because the children are reprojected
            // for us when they are created.
            if (this.internalProjection && this.externalProjection && !collection) {
                geometry.transform(this.externalProjection, this.internalProjection);
            }
            return geometry;
        }

        /**
         * Property: parseCoords
         * 一个属性名对应着GeoJSON对象的几何类型的对象。每个属性其实都是一个实际上做解析用的方法。
         */

    }, {
        key: 'write',


        /**
         * @function SuperMap.Format.GeoJSON.write
         * @description 序列化一个要素对象，几何对象，要素对象数组为一个GeoJSON字符串。
         * @param obj - {Object} 一个 <SuperMap.Feature.Vector> 对象，一个 <SuperMap.Geometry> 对象或者一个要素对象数组。
         * @param pretty - {boolean} 是否使用换行和缩进来控制输出。默认值为false。
         * @return {string} 一个GeoJSON字符串，它表示了输入的几何对象，要素对象，或者要素对象数组。
         */
        value: function write(obj, pretty) {
            var geojson = {
                "type": null
            };
            if (_SuperMap2.default.Util.isArray(obj)) {
                geojson.type = "FeatureCollection";
                var numFeatures = obj.length;
                geojson.features = new Array(numFeatures);
                for (var i = 0; i < numFeatures; ++i) {
                    var element = obj[i];
                    if (isGeometry(element)) {
                        var feature = {};
                        feature.geometry = element;
                        geojson.features[i] = this.extract.feature.apply(this, [feature]);
                    } else {
                        geojson.features[i] = this.extract.feature.apply(this, [element]);
                    }
                }
            } else if (isGeometry(obj)) {
                var feature = {};
                feature.geometry = obj;
                geojson = this.extract.feature.apply(this, [feature]);
            }

            function isGeometry(input) {
                return input.hasOwnProperty("parts") && input.hasOwnProperty("points");
            }

            return _get(GeoJSON.prototype.__proto__ || Object.getPrototypeOf(GeoJSON.prototype), 'write', this).call(this, geojson, pretty);
        }

        /**
         * @function SuperMap.Format.GeoJSON.createCRSObject
         * @description 从一个要素对象中创建一个坐标参考系对象。
         * @param object - {SuperMap.Feature.Vector} 要素对象
         * @return {Object} 一个可作为GeoJSON对象的crs属性使用的对象。
         */

    }, {
        key: 'createCRSObject',
        value: function createCRSObject(object) {
            var proj = object.layer.projection.toString();
            var crs = {};
            if (proj.match(/epsg:/i)) {
                var code = parseInt(proj.substring(proj.indexOf(":") + 1));
                if (code == 4326) {
                    crs = {
                        "type": "name",
                        "properties": {
                            "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
                        }
                    };
                } else {
                    crs = {
                        "type": "name",
                        "properties": {
                            "name": "EPSG:" + code
                        }
                    };
                }
            }
            return crs;
        }

        /**
         * Property: extract
         * 一个属性名对应着GeoJSON类型的对象。其值为相应的实际的解析方法。
         */

    }, {
        key: 'createAttributes',
        value: function createAttributes(feature) {
            if (!feature) {
                return null;
            }
            var attr = {};
            processFieldsAttributes(feature, attr);
            var exceptKeys = ["fieldNames", "fieldValues", "geometry"];
            for (var key in feature) {
                if (exceptKeys.indexOf(key) > -1) {
                    continue;
                }
                attr[key] = feature[key];
            }

            function processFieldsAttributes(feature, attributes) {
                if (!(feature.hasOwnProperty("fieldNames") && feature.hasOwnProperty("fieldValues"))) {
                    return;
                }
                var names = feature.fieldNames,
                    values = feature.fieldValues;
                for (var i in names) {
                    attributes[names[i]] = values[i];
                }
            }

            return attr;
        }
    }, {
        key: 'toGeometry',
        value: function toGeometry(geometry) {
            var me = this,
                geoType = geometry.type;
            if (geoType === 'polygon') {
                geoType = _REST.GeometryType.REGION;
            }
            switch (geoType.toUpperCase()) {
                case _REST.GeometryType.POINT:
                    return me.toGeoPoint(geometry);
                case _REST.GeometryType.LINE:
                    return me.toGeoLine(geometry);
                case _REST.GeometryType.LINEM:
                    return me.toGeoLinem(geometry);
                case _REST.GeometryType.REGION:
                    return me.toGeoRegion(geometry);
                case _REST.GeometryType.POINTEPS:
                    return me.toGeoPoint(geometry);
                // case GeometryType.LINEEPS:
                //     return me.toGeoLineEPS();
                // case GeometryType.REGIONEPS:
                //     return me.toGeoRegionEPS();
                default:
                    return geometry;
            }
        }

        /**
         * @function SuperMap.Format.GeoJSON.toGeoPoint
         * @description 将服务端的点几何对象转换为几何对象
         */

    }, {
        key: 'toGeoPoint',
        value: function toGeoPoint(geometry) {
            var geoPoints = geometry.points || [],
                geoParts = geometry.parts || [geoPoints.length],
                len = geoParts.length;
            if (len < 1) {
                return null;
            }
            if (len === 1) {
                return { type: "Point", x: parseFloat(geoPoints[0].x), y: parseFloat(geoPoints[0].y) };
            } else {
                for (var i = 0, pointList = []; i < len; i++) {
                    pointList.push({ x: parseFloat(geoPoints[i].x), y: parseFloat(geoPoints[i].y) });
                }
                return { type: "MultiPoint", components: pointList };
            }
        }

        /**
         *
         * @function SuperMap.Format.GeoJSON.toGeoPoint
         * @description 将服务端的线几何对象转换为几何对象。
         */

    }, {
        key: 'toGeoLine',
        value: function toGeoLine(geometry) {
            var me = this,
                geoPoints = geometry.points || [],
                geoParts = geometry.parts || [geoPoints.length],
                len = geoParts.length;
            if (len < 1) {
                return null;
            }
            if (len === 1) {
                for (var i = 0, pointList = []; i < geoParts[0]; i++) {
                    pointList.push({ x: parseFloat(geoPoints[i].x), y: parseFloat(geoPoints[i].y) });
                }
                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                if (me.isPointsEquals(pointList[0], pointList[geoParts[0] - 1])) {
                    pointList.pop();
                    pointList.push(pointList[0]);
                }
                return { type: "LineString", components: pointList };
            } else {
                for (var k = 0, lineList = []; k < len; k++) {
                    for (var j = 0, pointArr = []; j < geoParts[k]; j++) {
                        pointArr.push({ x: parseFloat(geoPoints[j].x), y: parseFloat(geoPoints[j].y) });
                    }
                    lineList.push(pointArr);
                    geoPoints.splice(0, geoParts[k]);
                }
                return { type: "MultiLineString", components: lineList };
            }
        }

        /**
         *
         * @function SuperMap.Format.GeoJSON.toGeoLinem
         * @description 将服务端的路由线几何对象转换为几何对象。
         */

    }, {
        key: 'toGeoLinem',
        value: function toGeoLinem(geometry) {
            var me = this,
                geoPoints = geometry.points || [],
                geoParts = geometry.parts || [geoPoints.length],
                len = geoParts.length,
                lineList = [],
                type;
            if (len < 1) {
                return null;
            }
            for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {
                for (var j = 0; j < geoParts[i]; j++) {
                    pointList.push({
                        x: parseFloat(geoPoints[pointIndex + j].x),
                        y: parseFloat(geoPoints[pointIndex + j].y),
                        measure: parseFloat(geoPoints[pointIndex + j].measure)
                    });
                }
                pointIndex += geoParts[i];
                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                if (me.isPointsEquals(pointList[0], pointList[geoParts[0] - 1])) {
                    pointList.pop();
                    pointList.push(pointList[0]);
                }
                lineList.push(pointList);
                pointList = [];
            }
            return { type: "MultiLineString", components: lineList };
        }

        /**
         *
         * @function SuperMap.Format.GeoJSON.toGeoRegion
         * @description 将服务端的面几何对象转换为几何对象。
         */

    }, {
        key: 'toGeoRegion',
        value: function toGeoRegion(geometry) {
            var CCWArray = [],
                geoPoints = geometry.points || [],
                geoParts = geometry.parts || [geoPoints.length],
                len = geoParts.length;
            if (len < 1) {
                return null;
            }
            var polygonArray = new Array();
            for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {
                for (var j = 0; j < geoParts[i]; j++) {
                    pointList.push({
                        x: parseFloat(geoPoints[pointIndex + j].x),
                        y: parseFloat(geoPoints[pointIndex + j].y)
                    });
                }

                pointIndex += geoParts[i];
                var linearRing = pointList.concat();
                linearRing.pop();
                linearRing.push(linearRing[0]);

                if (this.isClockWise(linearRing) > 0) {
                    CCWArray.push(linearRing);
                } else {
                    polygonArray.push([linearRing]);
                }

                if (i === len - 1) {
                    var polyLength = polygonArray.length;
                    if (!!polyLength) {
                        polygonArray[polyLength - 1] = polygonArray[polyLength - 1].concat(CCWArray);
                    } else {
                        for (var k = 0, length = CCWArray.length; k < length; k++) {
                            polygonArray.push([CCWArray[k]].concat());
                        }
                    }
                }
                pointList = [];
            }
            return { type: "MultiPolygon", components: polygonArray };
        }
    }, {
        key: 'isClockWise',
        value: function isClockWise(points) {
            var length = points.length;
            if (length < 3) {
                return 0.0;
            }
            var s = points[0].y * (points[length - 1].x - points[1].x);
            points.push(points[0]);
            for (var i = 1; i < length; i++) {
                s += points[i].y * (points[i - 1].x - points[i + 1].x);
            }
            return s * 0.5;
        }
    }, {
        key: 'isPointsEquals',
        value: function isPointsEquals(point1, point2) {
            return point1.x === point2.x && point1.y === point2.y;
        }
    }]);

    return GeoJSON;
}(_JSON2.default);

exports.default = GeoJSON;

_SuperMap2.default.Format.GeoJSON = GeoJSON;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Bounds = __webpack_require__(61);

var _Bounds2 = _interopRequireDefault(_Bounds);

var _Point = __webpack_require__(11);

var _Point2 = _interopRequireDefault(_Point);

var _MultiPoint = __webpack_require__(46);

var _MultiPoint2 = _interopRequireDefault(_MultiPoint);

var _LinearRing = __webpack_require__(38);

var _LinearRing2 = _interopRequireDefault(_LinearRing);

var _LineString = __webpack_require__(23);

var _LineString2 = _interopRequireDefault(_LineString);

var _MultiLineString = __webpack_require__(63);

var _MultiLineString2 = _interopRequireDefault(_MultiLineString);

var _Polygon = __webpack_require__(47);

var _Polygon2 = _interopRequireDefault(_Polygon);

var _MultiPolygon = __webpack_require__(64);

var _MultiPolygon2 = _interopRequireDefault(_MultiPolygon);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

var _Route = __webpack_require__(50);

var _Route2 = _interopRequireDefault(_Route);

var _Util = __webpack_require__(4);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** * @class SuperMap.ServerGeometry * @description 服务端几何对象类。 * 该类描述几何对象（矢量）的特征数据（坐标点对、几何对象的类型等）。 * 基于服务端的空间分析、空间关系运算、查询等 GIS 服务功能使用服务端几何对象。 */
var ServerGeometry = function () {

  /**     * Constructor: SuperMap.ServerGeometry     * 服务端几何对象类构造函数。     *     * Parameters:     * options - {Object} 参数。     *     * Allowed options properties:     * id - {String} 服务端几何对象唯一标识符。     * style - {<SuperMap.ServerStyle>}  服务端几何对象的风格。     * parts - {Array(Number)} 服务端几何对象中各个子对象所包含的节点个数。     * points - {Array(<Point>)} 组成几何对象的节点的坐标对数组。     * type - {<SuperMap.GeometryType>} 几何对象的类型。     */

  /**     * APIProperty: type     * {<SuperMap.GeometryType>} 几何对象的类型(GeometryType)。     */

  /**     * APIProperty: parts     * {Array(Number)} 服务端几何对象中各个子对象所包含的节点个数。     * 1.几何对象从结构上可以分为简单几何对象和复杂几何对象。     * 简单几何对象与复杂几何对象的区别：简单的几何对象一般为单一对象，     * 而复杂的几何对象由多个简单对象组成或经过一定的空间运算之后产生，     * 如：矩形为简单的区域对象，而中空的矩形为复杂的区域对象。     * 2.通常情况，一个简单几何对象的子对象就是它本身，     * 因此对于简单对象来说的该字段为长度为1的整型数组，     * 该字段的值就是这个简单对象节点的个数。     * 如果一个几何对象是由几个简单对象组合而成的，     * 例如，一个岛状几何对象由3个简单的多边形组成而成，     * 那么这个岛状的几何对象的 Parts 字段值就是一个长度为3的整型数组，     * 数组中每个成员的值分别代表这三个多边形所包含的节点个数。     */


  /**     * APIProperty: id     * {String} 服务端几何对象唯一标识符。     */
  function ServerGeometry(options) {
    _classCallCheck(this, ServerGeometry);

    this.id = 0;
    this.style = null;
    this.parts = null;
    this.points = null;
    this.type = null;
    this.prjCoordSys = null;
    this.CLASS_NAME = "SuperMap.ServerGeometry";

    if (options) {
      _Util.Util.extend(this, options);
    }
  }

  /**     * APIMethod: destroy     * 释放资源，将引用资源的属性置空。     */

  /**     * APIProperty: prjCoordSys     * {Object}投影坐标参数,现仅在缓冲区分析中有效。     */

  /**     * APIProperty: points     * {Array(<Point>)} 组成几何对象的节点的坐标对数组。     * 1.所有几何对象（点、线、面）都是由一些简单的点坐标组成的，     * 该字段存放了组成几何对象的点坐标的数组。     * 对于简单的面对象，他的起点和终点的坐标点相同。     * 2.对于复杂的几何对象，根据 Parts 属性来确定每一个组成复杂几何对象的简单对象所对应的节点的个数，     * 从而确定 Points 字段中坐标对的分配归属问题。     */


  /**     * APIProperty: style     * {<SuperMap.ServerStyle>} 服务端几何对象的风格(ServerStyle)。     */


  _createClass(ServerGeometry, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.id = null;
      me.style = null;
      me.parts = null;
      me.partTopo = null;
      me.points = null;
      me.type = null;
      me.prjCoordSys = null;
    }

    /**     * APIMethod: toGeometry     * 将服务端几何对象 ServerGeometry 转换为客户端几何对象 Geometry。     *     * Returns     * {<SuperMap.Geometry>} 转换后的客户端几何对象。     */

  }, {
    key: 'toGeometry',
    value: function toGeometry() {
      var me = this,
          geoType = me.type;
      switch (geoType) {
        case _REST.GeometryType.POINT:
          return me.toGeoPoint();
        case _REST.GeometryType.LINE:
          return me.toGeoLine();
        case _REST.GeometryType.LINEM:
          return me.toGeoLinem();
        case _REST.GeometryType.REGION:
          return me.toGeoRegion();
        case _REST.GeometryType.POINTEPS:
          return me.toGeoPoint();
        case _REST.GeometryType.LINEEPS:
          return me.toGeoLineEPS();
        case _REST.GeometryType.REGIONEPS:
          return me.toGeoRegionEPS();
      }
    }

    /**     * Method: toGeoPoint     * 将服务端的点几何对象转换为客户端几何对象。     * 包括 Point 、MultiPoint。     *     * Returns     * {<SuperMap.Geometry>} 转换后的客户端几何对象。     */

  }, {
    key: 'toGeoPoint',
    value: function toGeoPoint() {
      var me = this,
          geoParts = me.parts || [],
          geoPoints = me.points || [],
          len = geoParts.length;
      if (len > 0) {
        if (len === 1) {
          return new _Point2.default(geoPoints[0].x, geoPoints[0].y);
        } else {
          for (var i = 0, pointList = []; i < len; i++) {
            pointList.push(new _Point2.default(geoPoints[i].x, geoPoints[i].y));
          }
          return new _MultiPoint2.default(pointList);
        }
      } else {
        return null;
      }
    }

    /**     * Method: toGeoLine     * 将服务端的线几何对象转换为客户端几何对象。     * 包括LinearRing、LineString、MultiLineString。     *     * Returns     * {<SuperMap.Geometry>} 转换后的客户端几何对象。     */

  }, {
    key: 'toGeoLine',
    value: function toGeoLine() {
      var me = this,
          geoParts = me.parts || [],
          geoPoints = me.points || [],
          len = geoParts.length;
      if (len > 0) {
        if (len === 1) {
          for (var i = 0, pointList = []; i < geoParts[0]; i++) {
            pointList.push(new _Point2.default(geoPoints[i].x, geoPoints[i].y));
          }
          //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
          if (pointList[0].equals(pointList[geoParts[0] - 1])) {
            return new _LinearRing2.default(pointList);
          } else {
            return new _LineString2.default(pointList);
          }
        } else {
          for (var i = 0, lineList = []; i < len; i++) {
            for (var j = 0, pointList = []; j < geoParts[i]; j++) {
              pointList.push(new _Point2.default(geoPoints[j].x, geoPoints[j].y));
            }
            lineList.push(new _LineString2.default(pointList));
            geoPoints.splice(0, geoParts[i]);
          }
          return new _MultiLineString2.default(lineList);
        }
      } else {
        return null;
      }
    }

    /**     * Method: toGeoLineEPS     * 将服务端的线几何对象转换为客户端几何对象。     * 包括LinearRing、LineString、MultiLineString。     *     * Returns     * {<SuperMap.Geometry>} 转换后的客户端几何对象。     */

  }, {
    key: 'toGeoLineEPS',
    value: function toGeoLineEPS() {
      var me = this,
          geoParts = me.parts || [],
          geoPoints = me.points || [],
          i,
          j,
          pointList,
          lineList,
          lineEPS,
          len = geoParts.length;
      if (len > 0) {
        if (len === 1) {
          for (i = 0, pointList = []; i < geoParts[0]; i++) {
            pointList.push(new _Point2.default(geoPoints[i].x, geoPoints[i].y, geoPoints[i].type));
          }
          //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
          if (pointList[0].equals(pointList[geoParts[0] - 1])) {
            lineEPS = _LineString2.default.createLineEPS(pointList);
            return new _SuperMap2.default.Geometry.LineRing(lineEPS);
          } else {
            lineEPS = _LineString2.default.createLineEPS(pointList);
            return new _LineString2.default(lineEPS);
          }
        } else {
          for (i = 0, lineList = []; i < len; i++) {
            for (j = 0, pointList = []; j < geoParts[i]; j++) {
              pointList.push(new _Point2.default(geoPoints[j].x, geoPoints[j].y));
            }
            lineEPS = _LineString2.default.createLineEPS(pointList);
            lineList.push(new _LineString2.default(lineEPS));
            geoPoints.splice(0, geoParts[i]);
          }
          return new _MultiLineString2.default(lineList);
        }
      } else {
        return null;
      }
    }

    /**     * Method: toGeoLine     * 将服务端的路由线几何对象转换为客户端几何对象。     * 包括LinearRing、LineString、MultiLineString。     *     * Returns     * {<SuperMap.Geometry>} 转换后的客户端几何对象。     */

  }, {
    key: 'toGeoLinem',
    value: function toGeoLinem() {
      var me = this;
      return new _Route2.default.fromJson(me);
    }

    /**     * Method: toGeoRegion     * 将服务端的面几何对象转换为客户端几何对象。     * 类型为Polygon。     *     * Returns     * {<SuperMap.Geometry>} 转换后的客户端几何对象。     */

  }, {
    key: 'toGeoRegion',
    value: function toGeoRegion() {
      var me = this,
          geoParts = me.parts || [],
          geoTopo = me.partTopo || [],
          geoPoints = me.points || [],
          len = geoParts.length;
      if (len <= 0) {
        return null;
      }
      var polygonArray = [];
      var pointList = [];
      if (len == 1) {
        for (var i = 0; i < geoPoints.length; i++) {
          pointList.push(new _Point2.default(geoPoints[i].x, geoPoints[i].y));
        }
        polygonArray.push(new _Polygon2.default([new _LinearRing2.default(pointList)]));
        pointList = [];
        return new _MultiPolygon2.default(polygonArray);
      }
      //处理复杂面
      var CCWArray = [];
      var areaArray = [];
      var polygonArrayTemp = [];
      //polyon岛洞标识数组，初始都是岛。
      var CCWIdent = [];
      for (var i = 0, pointIndex = 0; i < len; i++) {
        for (var j = 0; j < geoParts[i]; j++) {
          pointList.push(new _Point2.default(geoPoints[pointIndex + j].x, geoPoints[pointIndex + j].y));
        }
        pointIndex += geoParts[i];
        var polygon = new _Polygon2.default([new _LinearRing2.default(pointList)]);
        pointList = [];
        polygonArrayTemp.push(polygon);
        CCWIdent.push(1);
        areaArray.push(polygon.getArea());
      }
      //根据面积排序
      ServerGeometry.bubbleSort(areaArray, polygonArrayTemp, geoTopo);
      //iServer 9D新增字段
      if (geoTopo.length === 0) {
        //岛洞底层判断原则：将所有的子对象按照面积排序，面积最大的直接判定为岛（1），从面积次大的开始处理，
        // 如果发现该对象在某个面积大于它的对象之中（即被包含），则根据包含它的对象的标识（1 or -1），指定其标识（-1 or 1），
        // 依次处理完所有对象，就得到了一个标识数组，1表示岛，-1表示洞
        //目标polygon索引列表 -1标示没有被任何polygon包含，
        var targetArray = [];
        for (var i = 1; i < polygonArrayTemp.length; i++) {
          for (var j = i - 1; j >= 0; j--) {
            targetArray[i] = -1;
            if (polygonArrayTemp[j].getBounds().containsBounds(polygonArrayTemp[i].getBounds())) {
              CCWIdent[i] = CCWIdent[j] * -1;
              if (CCWIdent[i] < 0) {
                targetArray[i] = j;
              }
              break;
            }
          }
        }
        for (var i = 0; i < polygonArrayTemp.length; i++) {
          if (CCWIdent[i] > 0) {
            polygonArray.push(polygonArrayTemp[i]);
          } else {
            polygonArray[targetArray[i]].components = polygonArray[targetArray[i]].components.concat(polygonArrayTemp[i].components);
            //占位
            polygonArray.push('');
          }
        }
      } else {
        //根据面积排序
        //ServerGeometry.bubbleSort(areaArray, polygonArrayTemp,geoTopo);
        var polygonArray = new Array();
        for (var i = 0; i < polygonArrayTemp.length; i++) {
          if (geoTopo[i] && geoTopo[i] == -1) {
            CCWArray = CCWArray.concat(polygonArrayTemp[i].components);
          } else {
            if (CCWArray.length > 0 && polygonArray.length > 0) {
              polygonArray[polygonArray.length - 1].components = polygonArray[polygonArray.length - 1].components.concat(CCWArray);
              CCWArray = [];
            }
            polygonArray.push(polygonArrayTemp[i]);
          }
          if (i == len - 1) {
            var polyLength = polygonArray.length;
            if (!!polyLength) {
              polygonArray[polyLength - 1].components = polygonArray[polyLength - 1].components.concat(CCWArray);
            } else {
              for (var k = 0, length = CCWArray.length; k < length; k++) {
                polygonArray.push(new _Polygon2.default(CCWArray));
              }
            }
          }
        }
      }
      return new _MultiPolygon2.default(polygonArray);
    }

    /**     * Method: toGeoRegionEPS     * 将服务端的面几何对象转换为客户端几何对象。     * 类型为Polygon。     *     * Returns     * {<SuperMap.Geometry>} 转换后的客户端几何对象。     */

  }, {
    key: 'toGeoRegionEPS',
    value: function toGeoRegionEPS() {
      var me = this,
          geoParts = me.parts || [],
          geoTopo = me.partTopo || [],
          geoPoints = me.points || [],
          len = geoParts.length;

      if (len <= 0) {
        return null;
      }
      var polygonArray = [];
      var pointList = [];
      var lineEPS;
      if (len == 1) {
        for (var i = 0; i < geoPoints.length; i++) {
          pointList.push(new _Point2.default(geoPoints[i].x, geoPoints[i].y));
        }

        lineEPS = _LineString2.default.createLineEPS(pointList);
        polygonArray.push(new _Polygon2.default([new _LinearRing2.default(lineEPS)]));
        pointList = [];
        return new _MultiPolygon2.default(polygonArray);
      }
      //处理复杂面
      var CCWArray = [];
      var areaArray = [];
      var polygonArrayTemp = [];
      //polyon岛洞标识数组，初始都是岛。
      var CCWIdent = [];
      for (var i = 0, pointIndex = 0; i < len; i++) {
        for (var j = 0; j < geoParts[i]; j++) {
          pointList.push(new _Point2.default(geoPoints[pointIndex + j].x, geoPoints[pointIndex + j].y));
        }
        pointIndex += geoParts[i];

        lineEPS = _LineString2.default.createLineEPS(pointList);
        var polygon = new _Polygon2.default([new _LinearRing2.default(lineEPS)]);
        pointList = [];
        polygonArrayTemp.push(polygon);
        CCWIdent.push(1);
        areaArray.push(polygon.getArea());
      }
      //根据面积排序
      ServerGeometry.bubbleSort(areaArray, polygonArrayTemp, geoTopo);
      //iServer 9D新增字段
      if (geoTopo.length === 0) {
        //岛洞底层判断原则：将所有的子对象按照面积排序，面积最大的直接判定为岛（1），从面积次大的开始处理，
        // 如果发现该对象在某个面积大于它的对象之中（即被包含），则根据包含它的对象的标识（1 or -1），指定其标识（-1 or 1），
        // 依次处理完所有对象，就得到了一个标识数组，1表示岛，-1表示洞
        //目标polygon索引列表 -1标示没有被任何polygon包含，
        var targetArray = [];
        for (var i = 1; i < polygonArrayTemp.length; i++) {
          for (var j = i - 1; j >= 0; j--) {
            targetArray[i] = -1;
            if (polygonArrayTemp[j].getBounds().containsBounds(polygonArrayTemp[i].getBounds())) {
              CCWIdent[i] = CCWIdent[j] * -1;
              if (CCWIdent[i] < 0) {
                targetArray[i] = j;
              }
              break;
            }
          }
        }
        for (var i = 0; i < polygonArrayTemp.length; i++) {
          if (CCWIdent[i] > 0) {
            polygonArray.push(polygonArrayTemp[i]);
          } else {
            polygonArray[targetArray[i]].components = polygonArray[targetArray[i]].components.concat(polygonArrayTemp[i].components);
            //占位
            polygonArray.push('');
          }
        }
      } else {
        //根据面积排序
        var polygonArray = new Array();
        for (var i = 0; i < polygonArrayTemp.length; i++) {
          if (geoTopo[i] && geoTopo[i] == -1) {
            CCWArray = CCWArray.concat(polygonArrayTemp[i].components);
          } else {
            if (CCWArray.length > 0 && polygonArray.length > 0) {
              polygonArray[polygonArray.length - 1].components = polygonArray[polygonArray.length - 1].components.concat(CCWArray);
              CCWArray = [];
            }
            polygonArray.push(polygonArrayTemp[i]);
          }
          if (i == len - 1) {
            var polyLength = polygonArray.length;
            if (!!polyLength) {
              polygonArray[polyLength - 1].components = polygonArray[polyLength - 1].components.concat(CCWArray);
            } else {
              for (var k = 0, length = CCWArray.length; k < length; k++) {
                polygonArray.push(new _Polygon2.default(CCWArray));
              }
            }
          }
        }
      }
      return new _MultiPolygon2.default(polygonArray);
    }

    /**     * Function: ServerGeometry.fromJson     * 将 JSON 对象表示服务端几何对象转换为 ServerGeometry。     *     * Parameters:     * jsonObject - {Object} 要转换的 JSON 对象。     *     * Returns:     * {<SuperMap.ServerGeometry>} 转化后的 ServerGeometry 对象。     */

  }], [{
    key: 'fromJson',
    value: function fromJson(jsonObject) {
      if (!jsonObject) {
        return;
      }
      return new ServerGeometry({
        id: jsonObject.id,
        style: _ServerStyle2.default.fromJson(jsonObject.style),
        parts: jsonObject.parts,
        partTopo: jsonObject.partTopo,
        points: jsonObject.points,
        center: jsonObject.center,
        length: jsonObject.length,
        maxM: jsonObject.maxM,
        minM: jsonObject.minM,
        type: jsonObject.type
      });
    }
  }, {
    key: 'fromGeometry',


    /**     * Function: ServerGeometry.fromGeometry     * 将客户端Geometry转换成服务端ServerGeometry。     *     * Parameters:     * geometry - {<SuperMap.Geometry>} 要转换的客户端Geometry对象。     *     * Returns:     * {<SuperMap.ServerGeometry>} 转化后的 ServerGeometry 对象。     */
    value: function fromGeometry(geometry) {
      if (!geometry) {
        return;
      }
      var id = 0,
          parts = [],
          points = [],
          type = null,
          icomponents = geometry.components,
          className = geometry.CLASS_NAME,
          prjCoordSys = { "epsgCode": geometry.SRID };

      if (!isNaN(geometry.id)) {
        id = geometry.id;
      }
      //坑爹的改法，没法，为了支持态势标绘，有时间就得全改
      if (className != "SuperMap.Geometry.LinearRing" && className != "SuperMap.Geometry.LineString" && (geometry instanceof _MultiPoint2.default || geometry instanceof _MultiLineString2.default)) {
        var ilen = icomponents.length;
        for (var i = 0; i < ilen; i++) {
          var partPointsCount = icomponents[i].getVertices().length;
          parts.push(partPointsCount);
          for (var j = 0; j < partPointsCount; j++) {
            points.push(new _Point2.default(icomponents[i].getVertices()[j].x, icomponents[i].getVertices()[j].y));
          }
        }
        //这里className不是多点就全部是算线
        type = className == "SuperMap.Geometry.MultiPoint" ? _REST.GeometryType.POINT : _REST.GeometryType.LINE;
      } else if (geometry instanceof _MultiPolygon2.default) {
        var ilen = icomponents.length;
        for (var i = 0; i < ilen; i++) {
          var polygon = icomponents[i],
              linearRingOfPolygon = polygon.components,
              linearRingOfPolygonLen = linearRingOfPolygon.length;
          for (var j = 0; j < linearRingOfPolygonLen; j++) {
            var partPointsCount = linearRingOfPolygon[j].getVertices().length + 1;
            parts.push(partPointsCount);
            for (var k = 0; k < partPointsCount - 1; k++) {
              points.push(new _Point2.default(linearRingOfPolygon[j].getVertices()[k].x, linearRingOfPolygon[j].getVertices()[k].y));
            }
            points.push(new _Point2.default(linearRingOfPolygon[j].getVertices()[0].x, linearRingOfPolygon[j].getVertices()[0].y));
          }
        }
        type = _REST.GeometryType.REGION;
      } else if (geometry instanceof _Polygon2.default) {
        var ilen = icomponents.length;
        for (var i = 0; i < ilen; i++) {
          var partPointsCount = icomponents[i].getVertices().length + 1;
          parts.push(partPointsCount);
          for (var j = 0; j < partPointsCount - 1; j++) {
            points.push(new _Point2.default(icomponents[i].getVertices()[j].x, icomponents[i].getVertices()[j].y));
          }
          points.push(new _Point2.default(icomponents[i].getVertices()[0].x, icomponents[i].getVertices()[0].y));
        }
        type = _REST.GeometryType.REGION;
      } else {
        var geometryVerticesCount = geometry.getVertices().length;
        for (var j = 0; j < geometryVerticesCount; j++) {
          points.push(new _Point2.default(geometry.getVertices()[j].x, geometry.getVertices()[j].y));
        }
        if (geometry instanceof _LinearRing2.default) {
          points.push(new _Point2.default(geometry.getVertices()[0].x, geometry.getVertices()[0].y));
          geometryVerticesCount++;
        }
        parts.push(geometryVerticesCount);
        type = geometry instanceof _Point2.default ? _REST.GeometryType.POINT : _REST.GeometryType.LINE;
      }

      return new ServerGeometry({
        id: id,
        style: null,
        parts: parts,
        points: points,
        type: type,
        prjCoordSys: prjCoordSys
      });
    }
  }, {
    key: 'IsClockWise',


    /**     * Function: SuperMap.Geometry.IsClockWise     * 判断linearRing中的点的顺序，顺时针？逆时针     * 返回值大于0, 逆时针; 小于0, 顺时针     *     * Parameters:     * geometry - {<SuperMap.Geometry>} 要转换的客户端Geometry对象。     *     * Returns:     * {<Number>}。     */
    value: function IsClockWise(points) {
      var length = points.length;
      if (length < 3) {
        return 0.0;
      }
      var s = points[0].y * (points[length - 1].x - points[1].x);
      points.push(points[0]);
      for (var i = 1; i < length; i++) {
        s += points[i].y * (points[i - 1].x - points[i + 1].x);
      }
      return s * 0.5;
    }
  }, {
    key: 'bubbleSort',
    value: function bubbleSort(areaArray, pointList, geoTopo) {
      for (var i = 0; i < areaArray.length; i++) {
        for (var j = 0; j < areaArray.length; j++) {
          if (areaArray[i] > areaArray[j]) {
            var d = areaArray[j];
            areaArray[j] = areaArray[i];
            areaArray[i] = d;
            var b = pointList[j];
            pointList[j] = pointList[i];
            pointList[i] = b;
            if (geoTopo && geoTopo.length > 0) {
              var c = geoTopo[j];
              geoTopo[j] = geoTopo[i];
              geoTopo[i] = c;
            }
          }
        }
      }
    }
  }]);

  return ServerGeometry;
}();

exports.default = ServerGeometry;


_SuperMap2.default.ServerGeometry = ServerGeometry;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerColor = __webpack_require__(12);

var _ServerColor2 = _interopRequireDefault(_ServerColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ServerStyle
 * @classdesc 服务端矢量要素风格类。
 * @description 该类用于定义点状符号、线状符号、填充符号风格及其相关属性。
 * @param options - {Object} 可选参数。如：<br>
 *        fillBackColor - {SuperMap.ServerColor} 填充背景颜色。<br>
 *        fillBackOpaque - {boolean} 背景是否不透明。<br>
 *        fillForeColor - {SuperMap.ServerColor} 填充颜色。<br>
 *        fillGradientMode - {FillGradientMode} 渐变填充风格的渐变类型。<br>
 *        fillGradientAngle - {number}渐变填充的旋转角度。<br>
 *        fillGradientOffsetRatioX - {number}渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。<br>
 *        fillGradientOffsetRatioY - {number}填充中心点相对于填充区域范围中心点的垂直偏移百分比。<br>
 *        fillOpaqueRate - {number}填充不透明度。<br>
 *        fillSymbolID - {Integer} 填充符号的编码。<br>
 *        lineColor - {SuperMap.ServerColor} 矢量要素的边线颜色。<br>
 *        lineSymbolID - {Integer} 线状符号的编码。<br>
 *        lineWidth - {number}边线的宽度。<br>
 *        markerAngle - {number}点状符号的旋转角度。<br>
 *        markerSize - {number}点状符号的大小。<br>
 *        markerSymbolID - {Integer} 点状符号的编码。
 */
var ServerStyle = function () {

    /**
     * @member SuperMap.ServerStyle.prototype.markerSize -{number}
     * @description 点状符号的大小。单位为毫米，精度为0.1，默认值为1.0。当该属性设置为0时，采用符号默认大小1.0显示。
     *              当该属性设置为非法值时，交由服务器默认处理。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.lineWidth -{number}
     * @description 边线的宽度。单位为毫米，精度到0.1，默认值为1.0。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.lineColor -{SuperMap.ServerColor}
     * @description 矢量要素的边线颜色。默认为黑色。如果等级符号是点符号，点符号的颜色由lineColor控制
     */


    /**
     * @member SuperMap.ServerStyle.prototype.fillOpaqueRate -{number}
     * @description 填充不透明度。合法值为0--100的数值。其中为0表示完全透明；
     *              100表示完全不透明。赋值小于0时按照0处理，大于100时按照100处理。默认值为 100。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.fillGradientOffsetRatioX -{number}
     * @description 渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。它们的关系如下：设填充区域范围中心点的坐标为（x0, y0），
     *              填充中心点的坐标为（x, y），填充区域范围的宽度为 a，水平偏移百分比为 dx，则 x=x0 + a*dx/100。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.fillGradientMode -{FillGradientMode}
     * @description 渐变填充风格的渐变类型。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.fillBackOpaque -{boolean}
     * @description 背景是否不透明。false 表示透明。默认值为 false。
     */
    function ServerStyle(options) {
        _classCallCheck(this, ServerStyle);

        this.fillBackColor = null;
        this.fillBackOpaque = false;
        this.fillForeColor = null;
        this.fillGradientMode = null;
        this.fillGradientAngle = 0;
        this.fillGradientOffsetRatioX = 0;
        this.fillGradientOffsetRatioY = 0;
        this.fillOpaqueRate = 100;
        this.fillSymbolID = 0;
        this.lineColor = null;
        this.lineSymbolID = 0;
        this.lineWidth = 1;
        this.markerAngle = 0;
        this.markerSize = 1;
        this.markerSymbolID = -1;
        this.CLASS_NAME = "SuperMap.ServerStyle";

        var me = this;
        me.fillBackColor = new _ServerColor2.default(255, 255, 255);
        me.fillForeColor = new _ServerColor2.default(255, 0, 0);
        me.lineColor = new _ServerColor2.default(0, 0, 0);
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ServerStyle.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.markerSymbolID -{Integer}
     * @description 点状符号的编码。此编码用于唯一标识各点状符号。默认为 -1。
     *              关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.markerAngle -{number}
     * @description 点状符号的旋转角度。以度为单位，精确到0.1度，逆时针方向为正方向，默认值为0。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.lineSymbolID -{Integer}
     * @description 线状符号的编码。此编码用于唯一标识各普通填充风格的填充符号，默认值为0。
     *              关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.fillSymbolID -{Integer}
     * @description 填充符号的编码。此编码用于唯一标识各普通填充风格的填充符号。
     *              关于填充符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.fillGradientOffsetRatioY -{number}
     * @function 填充中心点相对于填充区域范围中心点的垂直偏移百分比。它们的关系如下：<br>
     *           设填充区域范围中心点的坐标为（x0, y0），填充中心点的坐标为（x, y），填充区域范围的高度为 b，垂直偏移百分比为 dy，则 y=y0 + b*dx/100。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.fillGradientAngle -{number}
     * @description 渐变填充的旋转角度。单位为度，精确到0.1度，逆时针方向为正方向。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.fillForeColor -{SuperMap.ServerColor}
     * @description 填充颜色。当填充模式为渐变填充时，该颜色为填充起始颜色。默认为红色。
     */


    /**
     * @member SuperMap.ServerStyle.prototype.fillBackColor -{SuperMap.ServerColor}
     * @description 填充背景颜色。当填充模式为渐变填充时，该颜色为填充终止色。默认为白色。
     */


    _createClass(ServerStyle, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.fillBackColor) {
                me.fillBackColor.destroy();
                me.fillBackColor = null;
            }
            me.fillBackOpaque = null;

            if (me.fillForeColor) {
                me.fillForeColor.destroy();
                me.fillForeColor = null;
            }
            me.fillGradientMode = null;
            me.fillGradientAngle = null;
            me.fillGradientOffsetRatioX = null;
            me.fillGradientOffsetRatioY = null;
            me.fillOpaqueRate = null;
            me.fillSymbolID = null;
            if (me.lineColor) {
                me.lineColor.destroy();
                me.lineColor = null;
            }
            me.lineSymbolID = null;
            me.lineWidth = null;
            me.markerAngle = null;
            me.markerSize = null;
            me.markerSymbolID = null;
        }

        /**
         * @function SuperMap.ServerStyle.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var styleObj = {};
            styleObj = _SuperMap2.default.Util.copyAttributes(styleObj, this);
            //暂时先忽略serverColor往Json的转换
            return styleObj;
        }

        /**
         * @function SuperMap.ServerStyle.fromJson
         * @description 将JSON对象转换为 SuperMap.ServerStyle 对象。
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         * @return {SuperMap.ServerStyle} 转化后的 SuperMap.ServerStyle 对象。
         */

    }], [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }
            return new _SuperMap2.default.ServerStyle({
                fillBackColor: _ServerColor2.default.fromJson(jsonObject.fillBackColor),
                fillBackOpaque: jsonObject.fillBackOpaque,
                fillForeColor: _ServerColor2.default.fromJson(jsonObject.fillForeColor),
                fillGradientMode: jsonObject.fillGradientMode,
                fillGradientAngle: jsonObject.fillGradientAngle,
                fillGradientOffsetRatioX: jsonObject.fillGradientOffsetRatioX,
                fillGradientOffsetRatioY: jsonObject.fillGradientOffsetRatioY,
                fillOpaqueRate: jsonObject.fillOpaqueRate,
                fillSymbolID: jsonObject.fillSymbolID,
                lineColor: _ServerColor2.default.fromJson(jsonObject.lineColor),
                lineSymbolID: jsonObject.lineSymbolID,
                lineWidth: jsonObject.lineWidth,
                markerAngle: jsonObject.markerAngle,
                markerSize: jsonObject.markerSize,
                markerSymbolID: jsonObject.markerSymbolID
            });
        }
    }]);

    return ServerStyle;
}();

exports.default = ServerStyle;


_SuperMap2.default.ServerStyle = ServerStyle;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.NetworkAnalystServiceBase
 * @description 网络分析服务基类。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 网络分析服务地址
 * @param options - {Object} 网络分析可选参数。如：<br>
 *        format - {string} 查询结果返回格式
 *
 */
var NetworkAnalystServiceBase = function (_CommonServiceBase) {
    _inherits(NetworkAnalystServiceBase, _CommonServiceBase);

    function NetworkAnalystServiceBase(url, options) {
        _classCallCheck(this, NetworkAnalystServiceBase);

        var _this = _possibleConstructorReturn(this, (NetworkAnalystServiceBase.__proto__ || Object.getPrototypeOf(NetworkAnalystServiceBase)).call(this, url, options));

        _this.format = _REST.DataFormat.GEOJSON;
        _this.CLASS_NAME = "SuperMap.NetworkAnalystServiceBase";

        if (options && options.format) {
            _this.format = options.format.toUpperCase();
        }
        return _this;
    }

    /**
     * @function SuperMap.NetworkAnalystServiceBase.prototype.destroy
     * @description 释放资源，将引用的资源属性置空。
     */


    /**
     * @member SuperMap.NetworkAnalystServiceBase.prototype.format -{string}
     * @description 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
     *              参数格式为"ISERVER","GEOJSON",GEOJSON
     */


    _createClass(NetworkAnalystServiceBase, [{
        key: 'destroy',
        value: function destroy() {
            _get(NetworkAnalystServiceBase.prototype.__proto__ || Object.getPrototypeOf(NetworkAnalystServiceBase.prototype), 'destroy', this).call(this);
            this.format = null;
        }

        /**
         * @function SuperMap.NetworkAnalystServiceBase.prototype.serviceProcessCompleted
         * @description 分析完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this,
                analystResult;
            result = _SuperMap2.default.Util.transformResult(result);
            if (result && me.format === _REST.DataFormat.GEOJSON && typeof me.toGeoJSONResult === 'function') {
                analystResult = me.toGeoJSONResult(result);
            }
            if (!analystResult) {
                analystResult = result;
            }
            me.events.triggerEvent("processCompleted", { result: analystResult });
        }

        /**
         * @function SuperMap.NetworkAnalystServiceBase.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。只处理结果中的路由，由子类实现
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            return null;
        }
    }]);

    return NetworkAnalystServiceBase;
}(_CommonServiceBase3.default);

exports.default = NetworkAnalystServiceBase;

_SuperMap2.default.NetworkAnalystServiceBase = NetworkAnalystServiceBase;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _JoinItem = __webpack_require__(48);

var _JoinItem2 = _interopRequireDefault(_JoinItem);

var _LinkItem = __webpack_require__(221);

var _LinkItem2 = _interopRequireDefault(_LinkItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** * @class SuperMap.FilterParameter * @classdesc 查询过滤条件参数类。该类用于设置查询数据集的查询过滤参数。 * @param options - {Object} 可選参数。如: *        attributeFilter - {string} 属性过滤条件。</br> *        name - {string} 查询数据集名称或者图层名称。</br> *        joinItems - {Array<SuperMap.JoinItem>} 与外部表的连接信息 SuperMap.JoinItem 数组。</br> *        linkItems - {Array<SuperMap.LinkItem>} 与外部表的关联信息 SuperMap.LinkItem 数组。</br> *        ids - {Array<string>} 查询 id 数组，即属性表中的 SmID 值。</br> *        orderBy - {string} 查询排序的字段, orderBy 的字段须为数值型的。</br> *        groupBy - {string} 查询分组条件的字段。</br> *        fields - {Array<string>} 查询字段数组。</br> */
var FilterParameter = function () {

  /**     * @member SuperMap.FilterParameter.prototype.groupBy -{string}     * @description 查询分组条件的字段。     * 相当于 SQL 语句中的 GROUP BY 子句，其格式为：GROUP BY <列名>，     * 列名即属性表中每一列的名称，列又可称为属性，在 SuperMap 中又称为字段。     * 对单个字段分组时，该字段的用法为 groupBy = "字段名"；     * 对多个字段分组时，字段之间以英文逗号进行分割，用法为 groupBy = "字段名1, 字段名2"。     * 例如，现有一个全球城市数据集，该数据集有两个字段分别为“Continent”和“Country”，     * 分别表示某个城市所属的洲和国家。     * 如果要按照国家对全球的城市进行分组， 可以设置 groupBy = "Country"；     * 如果以洲和国家对城市进行分组，设置 groupBy = "Continent, Country"。     */


  /**     * @member SuperMap.FilterParameter.prototype.ids -{Array<string>}     * @description 查询 id 数组，即属性表中的 SmID 值。     */


  /**     * @member SuperMap.FilterParameter.prototype.joinItems -{Array<SuperMap.JoinItem>}     * @description 与外部表的连接信息 SuperMap.JoinItem 数组。     */


  /**     * @member SuperMap.FilterParameter.prototype.attributeFilter -{string}     * @description 属性过滤条件。     *     * 相当于 SQL 语句中的 WHERE 子句，其格式为：WHERE <条件表达式>，     * attributeFilter 就是其中的“条件表达式”。     * 该字段的用法为 attributeFilter = "过滤条件"。     * 例如，要查询字段 fieldValue 小于100的记录，设置 attributeFilter = "fieldValue < 100"；     * 要查询字段 name 的值为“酒店”的记录，设置 attributeFilter = "name like '%酒店%'"，等等。     */
  function FilterParameter(options) {
    _classCallCheck(this, FilterParameter);

    this.attributeFilter = null;
    this.name = null;
    this.joinItems = null;
    this.linkItems = null;
    this.ids = null;
    this.orderBy = null;
    this.groupBy = null;
    this.fields = null;
    this.CLASS_NAME = "SuperMap.FilterParameter";

    if (options) {
      _SuperMap2.default.Util.extend(this, options);
    }
  }

  /**     * @function SuperMap.FilterParameter.prototype.destroy     * @description 释放资源，将引用资源的属性置空。     */


  /**     * @member SuperMap.FilterParameter.prototype.fields -{Array<string>}     * @description 查询字段数组，如果不设置则使用系统返回的所有字段。     */


  /**     * @member SuperMap.FilterParameter.prototype.orderBy -{string}     * @description 查询排序的字段,orderBy的字段须为数值型的。     * 相当于 SQL 语句中的 ORDER BY 子句，其格式为：ORDER BY <列名>，     * 列名即属性表中每一列的名称，列又可称为属性，在 SuperMap 中又称为字段。     * 对单个字段排序时，该字段的用法为 orderBy = "字段名"；     * 对多个字段排序时，字段之间以英文逗号进行分割，用法为 orderBy = "字段名1, 字段名2"。     * 例如，现有一个国家数据集，它有两个字段分别为“SmArea”和“pop_1994”，     * 分别表示国家的面积和1994年的各国人口数量。     * 如果要按照各国人口数量对记录进行排序，则 orderBy = "pop_1994"；     * 如果要以面积和人口进行排序，则 orderBy = "SmArea, pop_1994"。     */


  /**     * @member SuperMap.FilterParameter.prototype.linkItems -{Array<SuperMap.LinkItem>}     * @description 与外部表的关联信息 LinkItem 数组。     */


  /**     * @member SuperMap.FilterParameter.prototype.name -{string}     * @description 查询数据集名称或者图层名称，根据实际的查询对象而定，必设属性。     * 一般情况下该字段为数据集名称，但在进行与地图相关功能的操作时，     * 需要设置为图层名称（图层名称格式：数据集名称@数据源别名）。     * 因为一个地图的图层可能是来自于不同数据源的数据集，     * 而不同的数据源中可能存在同名的数据集，     * 使用数据集名称不能唯一的确定数据集，     * 所以在进行与地图相关功能的操作时，该值需要设置为图层名称。     */


  _createClass(FilterParameter, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.attributeFilter = null;
      me.name = null;
      if (me.joinItems) {
        for (var i = 0, joinItems = me.joinItems, len = joinItems.length; i < len; i++) {
          joinItems[i].destroy();
        }
        me.joinItems = null;
      }
      if (me.linkItems) {
        for (var i = 0, linkItems = me.linkItems, len = linkItems.length; i < len; i++) {
          linkItems[i].destroy();
        }
        me.linkItems = null;
      }
      me.ids = null;
      me.orderBy = null;
      me.groupBy = null;
      me.fields = null;
    }
  }]);

  return FilterParameter;
}();

exports.default = FilterParameter;

_SuperMap2.default.FilterParameter = FilterParameter;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Geometry2 = __webpack_require__(62);

var _Geometry3 = _interopRequireDefault(_Geometry2);

var _Projection = __webpack_require__(22);

var _Projection2 = _interopRequireDefault(_Projection);

var _Bounds = __webpack_require__(61);

var _Bounds2 = _interopRequireDefault(_Bounds);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.Point
 * @classdesc 点几何对象类。
 * @extends {SuperMap.Geometry}
 * @param  x - {float} x-坐标
 * @param y - {float} y-坐标
 * @param type - {string} 用来存储点的类型
 * @param tag -  {float} 用来存储额外的属性，比如差值分析中的Z值。
 * @example
 * var point = new SuperMap.Geometry.Point(-111.04, 45.68);
 */
var Point = function (_Geometry) {
    _inherits(Point, _Geometry);

    /**
     * @member SuperMap.Geometry.Point.prototype.tag -{string}
     * @description  用来存储额外的属性，比如差值分析中的Z值。
     */


    /**
     * @member SuperMap.Geometry.Point.prototype.x -{float}
     * @description 横坐标。
     */
    function Point(x, y, type, tag) {
        _classCallCheck(this, Point);

        var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this, x, y, type, tag));

        _this.x = null;
        _this.y = null;
        _this.tag = null;
        _this.type = null;
        _this.CLASS_NAME = "SuperMap.Geometry.Point";


        _this.x = parseFloat(x);
        _this.y = parseFloat(y);
        if (tag || tag == 0) {
            _this.tag = parseFloat(tag);
        }
        _this.type = type || "NONE";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.Point.prototype.clone
     * @description 克隆点对象。
     * @returns {SuperMap.Geometry.Point} 克隆后的点对象。
     */


    /**
     * @member SuperMap.Geometry.Point.prototype.tag -{string}
     * @description  用来存储点的类型
     */


    /**
     * @member SuperMap.Geometry.Point.prototype.y -{float}
     * @description 纵坐标。
     */


    _createClass(Point, [{
        key: 'clone',
        value: function clone(obj) {
            if (obj == null) {
                obj = new Point(this.x, this.y);
            }

            // catch any randomly tagged-on properties
            _Util.Util.applyDefaults(obj, this);

            return obj;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.calculateBounds
         * @description 计算点对象的范围。
         */

    }, {
        key: 'calculateBounds',
        value: function calculateBounds() {
            this.bounds = new _Bounds2.default(this.x, this.y, this.x, this.y);
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.distanceTo
         * @description 计算两个点对象间的最小距离（x-y平面坐标系下）。
         * @param geometry - {SuperMap.Geometry} 目标点对象。
         * @param options - {Object} 计算距离时需要设置的可选属性。有效的选项取决于特定的几何类型。<br>
         *
         * Valid options:<br>
         * details - {Boolean} 返回距离计算的细节。默认为false。<br>
         * edge - {Boolean} 计算一个几何对象到目标几何对象边缘的最近距离。默认为true。 如果设为true，
         * 一个几何对象完全包含在目标几何对象中时，调用distanceTo返回非零结果，如果false，两个几何对象相交情况下
         * 调用distanceTo结果返回0，而且如果false，将不返距离。
         *
         * @returns {number | Object} 返回一个几何对象到目标几何对象的距离。
         */

    }, {
        key: 'distanceTo',
        value: function distanceTo(geometry, options) {
            var edge = !(options && options.edge === false);
            var details = edge && options && options.details;
            var distance, x0, y0, x1, y1, result;
            if (geometry instanceof Point) {
                x0 = this.x;
                y0 = this.y;
                x1 = geometry.x;
                y1 = geometry.y;
                distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
                result = !details ? distance : { x0: x0, y0: y0, x1: x1, y1: y1, distance: distance };
            } else {
                result = geometry.distanceTo(this, options);
                if (details) {
                    // switch coord order since this geom is target
                    result = {
                        x0: result.x1, y0: result.y1,
                        x1: result.x0, y1: result.y0,
                        distance: result.distance
                    };
                }
            }
            return result;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.equals
         * @description 判断两个点对象是否相等。如果两个点对象具有相同的坐标，则认为是相等的。
         * @example
         * var point= new SuperMap.Geometry.Point(0,0);
         * var point1={x:0,y:0};
         * var result= point.equals(point1);
         * @param geom - {SuperMap.Geometry.Point} 需要判断的点对象。
         *
         * @returns {Boolean} 两个点对象是否相等（true为相等，false为不等）。
         */

    }, {
        key: 'equals',
        value: function equals(geom) {
            var equals = false;
            if (geom != null) {
                equals = this.x === geom.x && this.y === geom.y || isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y);
            }
            return equals;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.toShortString
         * @returns {string} 字符串代表点对象。(ex. <i>"5, 42"</i>)
         */

    }, {
        key: 'toShortString',
        value: function toShortString() {
            return this.x + ", " + this.y;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.move
         * @description 沿着x、y轴的正方向上按照给定的位移移动点对象，move 不仅改变了几何对象的位置并且清理了边界缓存。
         * @param x - {float} x轴正方向上的偏移量。
         * @param  y - {float} y轴正方向上偏移量。
         * @example
         * var point = new SuperMap.Geometry.Point(10,20);
         * var dx = 10*Math.random();
         * var dy = 10*Math.random();
         * point.move(dx,dy);
         */

    }, {
        key: 'move',
        value: function move(x, y) {
            this.x = this.x + x;
            this.y = this.y + y;
            this.clearBounds();
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.rotate
         * @description 围绕中心点旋转点对象。
         * @param angle - {float} 旋转角的度数（沿着x轴正方向的逆时针方向）。
         * @param origin - {SuperMap.Geometry.Point} 旋转的中心点 。
         * @example
         * var point = new SuperMap.Geometry.Point(10,20);
         * var rotateOrigin = new SuperMap.Geometry.Point(5,10);
         * point.rotate(360,rotateOrigin);
         */

    }, {
        key: 'rotate',
        value: function rotate(angle, origin) {
            angle *= Math.PI / 180;
            var radius = this.distanceTo(origin);
            var theta = angle + Math.atan2(this.y - origin.y, this.x - origin.x);
            this.x = origin.x + radius * Math.cos(theta);
            this.y = origin.y + radius * Math.sin(theta);
            this.clearBounds();
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.getCentroid
         * @description 获取点对象的质心。
         * @returns {SuperMap.Geometry.Point} 点对象的质心。
         */

    }, {
        key: 'getCentroid',
        value: function getCentroid() {
            return new Point(this.x, this.y);
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.resize
         * @description 调整几何对象相对于原点的大小。
         * @param scale - {float} resize之后到原点的距离与resize之前到原点的距离比。
         * @param origin - {SuperMap.Geometry.Point} 调整的起始点。
         * @param ratio - {float} 点对象自身x与y的比值：ratio=x/y，默认的比例为1，不推荐设置。
         *
         * @returns {SuperMap.Geometry} - 当前几何对象。
         * @example
         * var point = new SuperMap.Geometry.Point(10,10);
         * var origin = new SuperMap.Geometry.Point(0,0);
         * point.resize(2,origin,4);
         */

    }, {
        key: 'resize',
        value: function resize(scale, origin, ratio) {
            ratio = ratio == undefined ? 1 : ratio;
            //所有的线和面最终都是控制点
            this.x = origin.x + scale * ratio * (this.x - origin.x);

            this.y = origin.y + scale * (this.y - origin.y);
            this.clearBounds();
            return this;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.intersects
         * @description 判断两个几何对象是否相交。
         * @param geometry - {SuperMap.Geometry} 任意类型的几何对象。
         *
         * @returns {Boolean} 传入的几何对象与当前几何对象相交。
         */

    }, {
        key: 'intersects',
        value: function intersects(geometry) {
            var intersect = false;
            if (geometry.CLASS_NAME === "SuperMap.Geometry.Point") {
                intersect = this.equals(geometry);
            } else {
                intersect = geometry.intersects(this);
            }
            return intersect;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.transform
         * @description 投影转换。
         * @param source - {SuperMap.Projection} 源对象投影。
         * @param dest - {SuperMap.Projection} 目标对象投影。
         *
         * @returns {SuperMap.Geometry.Point}转换后的点对象。
         * @example
         * var point = new SuperMap.Geometry.Point(10,20);
         * point.transform(new SuperMap.Projection("EPSG:4326"),new SuperMap.Projection("EPSG:900913"));
         */

    }, {
        key: 'transform',
        value: function transform(source, dest) {
            if (source && dest) {
                _Projection2.default.transform(this, source, dest);
                this.bounds = null;
            }
            return this;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.destroy
         * @description 释放点对象的资源
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.x = null;
            this.y = null;
            this.tag = null;
            _get(Point.prototype.__proto__ || Object.getPrototypeOf(Point.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.getVertices
         * @description 返回点对象的所有顶点的列表。
         * @param nodes - {Boolean} 对于点对象此参数不起作用，直接返回点。
         *
         * @returns {Array} 几何图形的顶点列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {
            return [this];
        }
    }]);

    return Point;
}(_Geometry3.default);

exports.default = Point;

_SuperMap2.default.Geometry.Point = Point;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ServerColor
 * @classdesc 颜色类。该类使用三原色（ RGB ）来表达颜色。
 * @param options - {Object} 可选参数。如：<br>
 *        red - {number}获取或设置红色值,默认值为255。<br>
 *        green - {number}获取或设置绿色值,默认值为0。<br>
 *        blue - {number}获取或设置蓝色值,默认值为0。
 */
var ServerColor = function () {

    /**
     * @member SuperMap.ServerColor.prototype.green -{number}
     * @description 获取或设置绿色值,默认值为0。
     */
    function ServerColor(red, green, blue) {
        _classCallCheck(this, ServerColor);

        this.red = 255;
        this.green = 0;
        this.blue = 0;
        this.CLASS_NAME = "SuperMap.ServerColor";

        if (!red && red != 0) {
            this.red = 255;
        } else {
            this.red = red;
        }

        if (!green && green != 0) {
            this.green = 0;
        } else {
            this.green = green;
        }

        if (!blue && blue != 0) {
            this.blue = 0;
        } else {
            this.blue = blue;
        }
    }

    /**
     * @function SuperMap.ServerColor.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ServerColor.prototype.blue -{number}
     * @description 获取或设置蓝色值,默认值为0。
     */


    /**
     * @member SuperMap.ServerColor.prototype.red -{number}
     * @description 获取或设置红色值,默认值为255。
     */


    _createClass(ServerColor, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.red = null;
            me.green = null;
            me.blue = null;
        }

        /**
         * @function SuperMap.ServerColor.formJson
         * @description 将JSON对象转化为ServerColor对象。
         * @param jsonObject - {Object} 要转换的JSON对象
         * @return { SuperMap.ServerColor} 转化后的ServerColor对象。
         */

    }], [{
        key: "fromJson",
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }
            var color = new ServerColor();
            var red = 255;
            if (jsonObject.red !== null) {
                red = Number(jsonObject.red);
            }
            color.red = red;

            var green = 0;
            if (jsonObject.green !== null) {
                green = Number(jsonObject.green);
            }
            color.green = green;

            var blue = 0;
            if (jsonObject.blue !== null) {
                blue = Number(jsonObject.blue);
            }
            color.blue = blue;
            return color;
        }
    }]);

    return ServerColor;
}();

exports.default = ServerColor;


_SuperMap2.default.ServerColor = ServerColor;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ThemeMemoryData = __webpack_require__(256);

var _ThemeMemoryData2 = _interopRequireDefault(_ThemeMemoryData);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Theme
 * @classdesc 专题图基类。
 * @param  type - {string} 专题图类型。
 * @param options - {Object} 可选参数。如：<br>
 *        memoryData - {SuperMap.ThemeMemoryData} 专题图内存数据。
 */
var Theme = function () {

    /**
     * @member SuperMap.Theme.prototype.memoryData -{SuperMap.ThemeMemoryData}
     * @description 专题图内存数据。<br>
     *              用内存数据制作专题图的方式与表达式制作专题图的方式互斥，前者优先级较高。
     *              第一个参数代表专题值，即数据集中用来做专题图的字段或表达式的值；第二个参数代表外部值。在制作专题图时，会用外部值代替专题值来制作相应的专题图。
     */
    function Theme(type, options) {
        _classCallCheck(this, Theme);

        this.memoryData = null;
        this.type = null;
        this.CLASS_NAME = "SuperMap.Theme";

        if (!type) {
            return this;
        }
        this.type = type;
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.Theme.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.Theme.prototype.type -{string}
     * @description 专题图类型。
     */


    _createClass(Theme, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.memoryData) {
                me.memoryData.destroy();
                me.memoryData = null;
            }
            me.type = null;
        }

        /**
         * @function SuperMap.Theme.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            //return 子类实现
            return;
        }
    }]);

    return Theme;
}();

exports.default = Theme;


_SuperMap2.default.Theme = Theme;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Point = __webpack_require__(11);

var _Point2 = _interopRequireDefault(_Point);

var _Geometry2 = __webpack_require__(62);

var _Geometry3 = _interopRequireDefault(_Geometry2);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.Collection
 * @classdesc 几何对象集合类，存储在本地的 components 属性中（可作为参数传递给构造函数）。<br>
 *            随着新的几何图形添加到集合中，将不能被克隆，当移动几何图形时，需要指定参照物。<br>
 *            getArea和getLength函数只能通过遍历存储几何对象的 components 数组，总计所有几何图形的面积和长度。
 *
 * @extends SuperMap.Geometry
 * @param components - {SuperMap.Geometry[]}几何对象数组。
 * @example
 * var point1 = new SuperMap.Geometry.Point(10,20);
 * var point2 = new SuperMap.Geometry.Point(30,40);
 * var col = new SuperMap.Geometry.Collection([point1,point2]);
 */
var Collection = function (_Geometry) {
    _inherits(Collection, _Geometry);

    /**
     * @description 存储几何对象的数组。
     * @member SuperMap.Geometry.Collection.prototype.components -{Array<SuperMap.Geometry>}
     */
    function Collection(components) {
        _classCallCheck(this, Collection);

        var _this = _possibleConstructorReturn(this, (Collection.__proto__ || Object.getPrototypeOf(Collection)).call(this));

        _this.components = null;
        _this.componentTypes = null;
        _this.CLASS_NAME = "SuperMap.Geometry.Collection";

        _this.components = [];
        if (components != null) {
            _this.addComponents(components);
        }
        return _this;
    }

    /**
     * @function SuperMap.Geometry.Collection.prototype.destroy
     * @description 销毁几何图形。
     */


    /**
     * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
     * @member SuperMap.Geometry.Collection.prototype.componentTypes -{Array<string>}
     */


    _createClass(Collection, [{
        key: 'destroy',
        value: function destroy() {
            this.components.length = 0;
            this.components = null;
            _get(Collection.prototype.__proto__ || Object.getPrototypeOf(Collection.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.clone
         * @description 克隆当前几何对象。
         * @returns {SuperMap.Geometry.Collection} 克隆的几何对象集合。
         */

    }, {
        key: 'clone',
        value: function clone() {
            var geometry = eval("new " + this.CLASS_NAME + "()");
            for (var i = 0, len = this.components.length; i < len; i++) {
                geometry.addComponent(this.components[i].clone());
            }

            // catch any randomly tagged-on properties
            _Util.Util.applyDefaults(geometry, this);

            return geometry;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getComponentsString
         * @description 获取components字符串
         * @returns {string} components字符串
         */

    }, {
        key: 'getComponentsString',
        value: function getComponentsString() {
            var strings = [];
            for (var i = 0, len = this.components.length; i < len; i++) {
                strings.push(this.components[i].toShortString());
            }
            return strings.join(",");
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.calculateBounds
         * @description 通过遍历数组重新计算边界，在遍历每一子项中时调用 extend 方法。
         */

    }, {
        key: 'calculateBounds',
        value: function calculateBounds() {
            this.bounds = null;
            var bounds = new _SuperMap2.default.Bounds();
            var components = this.components;
            if (components) {
                for (var i = 0, len = components.length; i < len; i++) {
                    bounds.extend(components[i].getBounds());
                }
            }
            // to preserve old behavior, we only set bounds if non-null
            // in the future, we could add bounds.isEmpty()
            if (bounds.left != null && bounds.bottom != null && bounds.right != null && bounds.top != null) {
                this.setBounds(bounds);
            }
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.addComponents
         * @description 给几何图形对象添加元素。
         * @param components -{Array<SuperMap.Geometry>} 几何对象组件。
         * @example
         * var collection = new SuperMap.Geometry.Collection();
         * collection.addComponents(new SuerpMap.Geometry.Point(10,10));
         */

    }, {
        key: 'addComponents',
        value: function addComponents(components) {
            if (!_Util.Util.isArray(components)) {
                components = [components];
            }
            for (var i = 0, len = components.length; i < len; i++) {
                this.addComponent(components[i]);
            }
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.addComponent
         * @description 添加一个几何对象到集合中。如果设置了componentTypes类型，则添加的几何对象必须是componentTypes中的类型
         *
         * @param component - {SuperMap.Geometry} 待添加的几何对象
         * @param index - {int} 几何对象插入的位置
         *
         * @returns {Boolean} 是否添加成功
         */

    }, {
        key: 'addComponent',
        value: function addComponent(component, index) {
            var added = false;
            if (component) {
                if (this.componentTypes == null || _Util.Util.indexOf(this.componentTypes, component.CLASS_NAME) > -1) {

                    if (index != null && index < this.components.length) {
                        var components1 = this.components.slice(0, index);
                        var components2 = this.components.slice(index, this.components.length);
                        components1.push(component);
                        this.components = components1.concat(components2);
                    } else {
                        this.components.push(component);
                    }
                    component.parent = this;
                    this.clearBounds();
                    added = true;
                }
            }
            return added;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.removeComponents
         * @description 清除几何对象。
         *
         * @param components -{Array<SuperMap.Geometry>} 需要清除的几何对象。
         * @returns {Boolean} 元素是否被删除。
         */

    }, {
        key: 'removeComponents',
        value: function removeComponents(components) {
            var removed = false;

            if (!_Util.Util.isArray(components)) {
                components = [components];
            }
            for (var i = components.length - 1; i >= 0; --i) {
                removed = this.removeComponent(components[i]) || removed;
            }
            return removed;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.removeComponent
         * @description 从集合中移除一个几何对象
         * @param component -{SuperMap.Geometry} 要移除的几何对象
         * @returns {Boolean} 几何对象是否移除成功
         */

    }, {
        key: 'removeComponent',
        value: function removeComponent(component) {
            _Util.Util.removeItem(this.components, component);

            // clearBounds() so that it gets recalculated on the next call
            // to this.getBounds();
            this.clearBounds();
            return true;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getLength
         * @description 计算几何对象长度。
         * @returns {number} 几何对象长度（所有几何对象长度总和）。
         */

    }, {
        key: 'getLength',
        value: function getLength() {
            var length = 0.0;
            for (var i = 0, len = this.components.length; i < len; i++) {
                length += this.components[i].getLength();
            }
            return length;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getArea
         * @description 计算几何对象的面积。注意，这个方法在 <SuperMap.Geometry.Polygon> 类中需要重写。
         * @returns {number} 几何图形的面积，是几何对象中所有组成部分的面积之和。
         */

    }, {
        key: 'getArea',
        value: function getArea() {
            var area = 0.0;
            for (var i = 0, len = this.components.length; i < len; i++) {
                area += this.components[i].getArea();
            }
            return area;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getGeodesicArea
         * @description 计算多边形投影到球面上的近似面积。
         * @param projection - {SuperMap.Projection} 空间参考系统的几何坐标。如果没有设置，默认 WGS84。
         * @returns {number} 几何图形的近似测地面积。
         */

    }, {
        key: 'getGeodesicArea',
        value: function getGeodesicArea(projection) {
            var area = 0.0;
            for (var i = 0, len = this.components.length; i < len; i++) {
                area += this.components[i].getGeodesicArea(projection);
            }
            return area;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getCentroid
         * @description  计算几何图形集合的质心。
         * @param weighted -{Boolean} 执行getCentroid方法进行递归计算，返回此几何图形集合中的面积加权平均值。
         * @returns {SuperMap.Geometry.Point} 质心。
         */

    }, {
        key: 'getCentroid',
        value: function getCentroid(weighted) {
            if (!weighted) {
                return this.components.length && this.components[0].getCentroid();
            }
            var len = this.components.length;
            if (!len) {
                return false;
            }

            var areas = [];
            var centroids = [];
            var areaSum = 0;
            var minArea = Number.MAX_VALUE;
            var component;
            for (var i = 0; i < len; ++i) {
                component = this.components[i];
                var area = component.getArea();
                var centroid = component.getCentroid(true);
                if (isNaN(area) || isNaN(centroid.x) || isNaN(centroid.y)) {
                    continue;
                }
                areas.push(area);
                areaSum += area;
                minArea = area < minArea && area > 0 ? area : minArea;
                centroids.push(centroid);
            }
            len = areas.length;
            if (areaSum === 0) {
                // all the components in this collection have 0 area
                // probably a collection of points -- weight all the points the same
                for (var i = 0; i < len; ++i) {
                    areas[i] = 1;
                }
                areaSum = areas.length;
            } else {
                // normalize all the areas where the smallest area will get
                // a value of 1
                for (var i = 0; i < len; ++i) {
                    areas[i] /= minArea;
                }
                areaSum /= minArea;
            }

            var xSum = 0,
                ySum = 0,
                centroid,
                area;
            for (var i = 0; i < len; ++i) {
                centroid = centroids[i];
                area = areas[i];
                xSum += centroid.x * area;
                ySum += centroid.y * area;
            }

            return new _Point2.default(xSum / areaSum, ySum / areaSum);
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getGeodesicLength
         * @description  计算投影到球面上的几何图形的近似测地长度。
         * @param projection -{SuperMap.Projection} 空间参考系统的几何坐标。如果没有设置，默认 WGS84。
         * @returns {number} 几何图形的近似测地长度。
         */

    }, {
        key: 'getGeodesicLength',
        value: function getGeodesicLength(projection) {
            var length = 0.0;
            for (var i = 0, len = this.components.length; i < len; i++) {
                length += this.components[i].getGeodesicLength(projection);
            }
            return length;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.move
         * @description  沿着x、y轴的正方向上按照给定的位移移动几何图形，move 不仅改变了几何图形的位置并且清理了边界缓存。
         * @param x -{number} x轴正方向上移动的距离。
         * @param y - {number} y轴正方向上移动的距离。
         */

    }, {
        key: 'move',
        value: function move(x, y) {
            for (var i = 0, len = this.components.length; i < len; i++) {
                this.components[i].move(x, y);
            }
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.rotate
         * @description 围绕中心点旋转几何图形。
         * @param angle -{number} 旋转角的度数（沿着x轴正方向逆时针测量）。
         * @param origin - {SuperMap.Geometry.Point} 旋转中心点。
         */

    }, {
        key: 'rotate',
        value: function rotate(angle, origin) {
            for (var i = 0, len = this.components.length; i < len; ++i) {
                this.components[i].rotate(angle, origin);
            }
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.resize
         * @description  调整几何对象大小。
         * @param scale - {number} 几何图形缩放的比例系数，是几何图形维数的两倍。（如，对于线来说将以线2倍的长度拉长，对于多边形来说，将以面积的4倍变化）。
         * @param origin - {SuperMap.Geometry.Point} 调整大小选定的起始原点。
         * @param ratio - {number} 可选的x,y的比例，默认的比例为1。
         * @returns {SuperMap.Geometry} 几何图形。
         */

    }, {
        key: 'resize',
        value: function resize(scale, origin, ratio) {
            for (var i = 0; i < this.components.length; ++i) {
                this.components[i].resize(scale, origin, ratio);
            }
            return this;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.distanceTo
         * @description 计算两个几个图形间的最小距离（x-y平面坐标系下）。
         * @param geometry - {SuperMap.Geometry} 目标几何图形。
         * @param options - {Object} 距离计算需要设置的可选属性。有效的选项取决于特定的几何类型。<br>
         *     details - {Boolean} 返回距离计算的细节。默认为false。<br>
         *     edge - {Boolean} 计算一个几何图形到目标几何图形边缘的最近距离。默认为true。<br>
         *     如果设为true，一个几何图形完全包含在目标几何图形中时，调用distanceTo返回非零结果，<br>
         *     如果false，两个几何图形相交情况下调用distanceTo结果返回0，而且如果false，将不返距离值。
         * @returns {(number | Object)} 返回一个几何图形到目标几何图形的距离。
         */

    }, {
        key: 'distanceTo',
        value: function distanceTo(geometry, options) {
            var edge = !(options && options.edge === false);
            var details = edge && options && options.details;
            var result, best, distance;
            var min = Number.POSITIVE_INFINITY;
            for (var i = 0, len = this.components.length; i < len; ++i) {
                result = this.components[i].distanceTo(geometry, options);
                distance = details ? result.distance : result;
                if (distance < min) {
                    min = distance;
                    best = result;
                    if (min == 0) {
                        break;
                    }
                }
            }
            return best;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.equals
         * @description 判断两个几何图形是否相等。如果所有的 components 具有相同的坐标，则认为是相等的。
         * @param geometry - {SuperMap.Geometry} 需要判断的几何图形。
         * @returns {Boolean} 输入的几何图形与当前几何图形是否相等。
         */

    }, {
        key: 'equals',
        value: function equals(geometry) {
            var equivalent = true;
            if (!geometry || !geometry.CLASS_NAME || this.CLASS_NAME !== geometry.CLASS_NAME) {
                equivalent = false;
            } else if (!_Util.Util.isArray(geometry.components) || geometry.components.length !== this.components.length) {
                equivalent = false;
            } else {
                for (var i = 0, len = this.components.length; i < len; ++i) {
                    if (!this.components[i].equals(geometry.components[i])) {
                        equivalent = false;
                        break;
                    }
                }
            }
            return equivalent;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.transform
         * @description 投影转换。
         * @param source - {SuperMap.Projection} 源对象投影。
         * @param dest - {SuperMap.Projection} 目标对象投影。
         * @returns {SuperMap.Geometry} this
         */

    }, {
        key: 'transform',
        value: function transform(source, dest) {
            if (source && dest) {
                for (var i = 0, len = this.components.length; i < len; i++) {
                    var component = this.components[i];
                    component.transform(source, dest);
                }
                this.bounds = null;
            }
            return this;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.intersects
         * @description 判断输入的几何对象是否与当前几何对象相交。
         * @param geometry - {SuperMap.Geometry} 任意的几何类型。
         * @returns {Boolean} 输入几何对象与当前几何对象相交。
         */

    }, {
        key: 'intersects',
        value: function intersects(geometry) {
            var intersect = false;
            for (var i = 0, len = this.components.length; i < len; ++i) {
                intersect = geometry.intersects(this.components[i]);
                if (intersect) {
                    break;
                }
            }
            return intersect;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getVertices
         * @description 返回几何对象的所有结点的列表。
         * @param nodes - {Boolean} 对于线来说，仅仅返回作为端点的顶点，如果设为false，则返回非端点的顶点如果没有设置此参数，则返回所有顶点。
         * @returns {Array} 几何对象的顶点列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {
            var vertices = [];
            for (var i = 0, len = this.components.length; i < len; ++i) {
                Array.prototype.push.apply(vertices, this.components[i].getVertices(nodes));
            }
            return vertices;
        }
    }]);

    return Collection;
}(_Geometry3.default);

exports.default = Collection;

_SuperMap2.default.Geometry.Collection = Collection;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.QueryParameters
 * @classdesc 查询参数基类。距离查询、SQL 查询、几何地物查询等各自的参数均继承此类。
 * @param options - {Object} 可选参数。如：<br>
 *         customParams - {string} 自定义参数，供扩展使用。<br>
 *         prjCoordSys -{Object} 自定义参数，供isueprmap提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br>
 *         expectCount - {number}期望返回结果记录个数。<br>
 *         networkType - {SuperMap.GeometryType} 网络数据集对应的查询类型。<br>
 *         queryOption - {SuperMap.QueryOption} 查询结果类型枚举类。<br>
 *         queryParams -  {Array<SuperMap.FilterParameter>} 查询过滤条件参数数组。<br>
 *         startRecord - {number}查询起始记录号。<br>
 *         holdTime - {number}资源在服务端保存的时间。<br>
 *         returnCustomResult -{boolean} 仅供三维使用。
 */
var QueryParameters = function () {

    /**
     * @member SuperMap.QueryParameters.prototype.holdTime -{number}
     * @description 资源在服务端保存的时间。默认为10（分钟）。
     */


    /**
     * @member SuperMap.QueryParameters.prototype.queryParams -{Array<SuperMap.FilterParameter>}
     * @description 查询过滤条件参数数组。
     *               该类用于设置查询数据集的查询过滤参数。
     */


    /**
     * @member SuperMap.QueryParameters.prototype.networkType -{SuperMap.GeometryType}
     * @description 网络数据集对应的查询类型，
     *               分为点和线两种类型，默认为线几何对象类型，即SuperMap.GeometryType.LINE。
     */


    /**
     * @member SuperMap.QueryParameters.prototype.prjCoordSys -{Object}
     * @description 自定义参数，供isueprmap提供的动态投影查询扩展使用。如 {"epsgCode":3857}
     */
    function QueryParameters(options) {
        _classCallCheck(this, QueryParameters);

        this.customParams = null;
        this.prjCoordSys = null;
        this.expectCount = 100000;
        this.networkType = _REST.GeometryType.LINE;
        this.queryOption = _REST.QueryOption.ATTRIBUTEANDGEOMETRY;
        this.queryParams = null;
        this.startRecord = 0;
        this.holdTime = 10;
        this.returnCustomResult = false;
        this.CLASS_NAME = "SuperMap.QueryParameters";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.QueryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.QueryParameters.prototype.returnCustomResult -{boolean}
     * @description 仅供三维使用。
     */


    /**
     * @member SuperMap.QueryParameters.prototype.startRecord -{number}
     * @description 查询起始记录号，默认值为0。
     */


    /**
     * @member SuperMap.QueryParameters.prototype.queryOption -{SuperMap.QueryOption}
     * @description 查询结果类型枚举类。
     *               该类描述查询结果返回类型，包括只返回属性、
     *               只返回几何实体以及返回属性和几何实体。
     */


    /**
     * @member SuperMap.QueryParameters.prototype.expectCount -{number}
     * @description 期望返回结果记录个数，默认返回100000条查询记录，
     *               如果实际不足100000条则返回实际记录条数。
     */


    /**
     * @member SuperMap.QueryParameters.prototype.customParams -{string}
     * @description 自定义参数，供扩展使用。
     */


    _createClass(QueryParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.customParams = null;
            me.expectCount = null;
            me.networkType = null;
            me.queryOption = null;
            if (me.queryParams) {
                for (var i = 0, qps = me.queryParams, len = qps.length; i < len; i++) {
                    qps[i].destroy();
                }
                me.queryParams = null;
            }
            me.startRecord = null;
            me.holdTime = null;
            me.returnCustomResult = null;
            me.prjCoordSys = null;
        }
    }]);

    return QueryParameters;
}();

exports.default = QueryParameters;


_SuperMap2.default.QueryParameters = QueryParameters;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _ServerColor = __webpack_require__(12);

var _ServerColor2 = _interopRequireDefault(_ServerColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ServerTextStyle
 * @classdesc 服务端文本风格类
 * @description 该类用于定义文本风格的相关属性。
 * @param options - {Object} 可选参数。如：<br>
 *        align - {TextAlignment} 文本的对齐方式。<br>
 *        backColor - {SuperMap.ServerColor} 文本的背景色。<br>
 *        foreColor - {SuperMap.ServerColor} 文本的前景色。<br>
 *        backOpaque - {boolean} 文本背景是否不透明。<br>
 *        sizeFixed - {boolean} 文本大小是否固定。<br>
 *        fontHeight - {number}文本字体的高度。<br>
 *        fontWidth - {number}文本字体的宽度。<br>
 *        fontWeight - {Integer} 文本字体的磅数。<br>
 *        fontName - {string} 文本字体的名称。<br>
 *        bold - {boolean} 文本是否为粗体字。<br>
 *        italic - {boolean}文本是否采用斜体。<br>
 *        italicAngle - {number}字体倾斜角度。<br>
 *        shadow - {boolean} 文本是否有阴影。<br>
 *        strikeout - {boolean} 文本字体是否加删除线。<br>
 *        outline - {boolean} 是否以轮廓的方式来显示文本的背景。<br>
 *        opaqueRate - {number}注记文字的不透明度。<br>
 *        underline - {boolean} 文本字体是否加下划线。<br>
 *        rotation -  {number} 文本旋转的角度。
 */
var ServerTextStyle = function () {

    /**
     * @member SuperMap.ServerTextStyle.prototype.underline -{boolean}
     * @description 文本字体是否加下划线。true 表示加下划线。默认为 false。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.outline -{boolean}
     * @description 是否以轮廓的方式来显示文本的背景。true 表示以轮廓的方式来显示文本的背景。默认值为 false，表示不以轮廓的方式来显示文本的背景。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.shadow -{boolean}
     * @description 文本是否有阴影。true 表示给文本增加阴影。默认值为 false，即文本没有阴影。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.italic -{boolean}
     * @description 文本是否采用斜体。true 表示采用斜体。默认为 false。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.fontName -{string}
     * @description 文本字体的名称。默认值为 Times New Roman。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.fontWidth -{number}
     * @description 文本字体的宽度。字体的宽度以英文字符为标准，由于一个中文字符相当于两个英文字符，默认为0地图坐标单位。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.sizeFixed -{boolean}
     * @description 文本大小是否固定。默认为 true，表示图片为固定像素大小，具体大小请参考 fontHeight。当设为 false 时，图片会随着地图缩放而缩放。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.foreColor -{SuperMap.ServerColor}
     * @description 文本的前景色。默认为黑色。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.align -{TextAlignment}
     * @description 文本的对齐方式。默认为 SuperMap.TextAlignment.BASELINECENTER（基准线居中对齐）。
     */
    function ServerTextStyle(options) {
        _classCallCheck(this, ServerTextStyle);

        this.align = _REST.TextAlignment.BASELINECENTER;
        this.backColor = null;
        this.foreColor = null;
        this.backOpaque = false;
        this.sizeFixed = true;
        this.fontHeight = 6;
        this.fontWidth = 0;
        this.fontWeight = 400;
        this.fontName = "Times New Roman";
        this.bold = false;
        this.italic = false;
        this.italicAngle = 0;
        this.shadow = false;
        this.strikeout = false;
        this.outline = false;
        this.opaqueRate = 0;
        this.underline = false;
        this.rotation = 0.0;
        this.CLASS_NAME = "SuperMap.ServerTextStyle";

        var me = this;
        me.backColor = new _ServerColor2.default(255, 255, 255);
        me.foreColor = new _ServerColor2.default(0, 0, 0);
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ServerTextStyle.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.rotation -{number}
     * @description 文本旋转的角度。逆时针方向为正方向，单位为度，精确到0.1度。默认值为0.0。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.opaqueRate -{number}
     * @description 注记文字的不透明度。不透明度的范围为0-100。默认为0，表示透明。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.strikeout -{boolean}
     * @description 文本字体是否加删除线。true 表示加删除线。默认值为 false，即文本字体不加删除线。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.italicAngle -{number}
     * @description 字体倾斜角度。正负度之间，以度为单位，精确到0.1度，默认为0度。当倾斜角度为0度，为系统默认的字体倾斜样式。
     *              正负度是指以纵轴为起始零度线，其纵轴左侧为正，右侧为负。允许的最大角度为60，最小-60。大于60按照60处理，小于-60按照-60处理。目前只对标签专题图有效。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.bold -{boolean}
     * @description 文本是否为粗体字。true 表示为粗体。默认值为 false，即文本不是粗体字。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.fontWeight -{Integer}
     * @description 文本字体的磅数。表示粗体的具体数值。取值范围为从0－900之间的整百数，默认值为400。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.fontHeight -{number}
     * @description 文本字体的高度，默认为6，单位与 sizeFixed 有关，当 sizeFixed 为 False 时，即非固定文本大小时使用地图坐标单位，
     *              如地理坐标系下的地图中单位为度；当 sizeFixed 为 True 时，单位为毫米（mm）。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.backOpaque -{boolean}
     * @description 文本背景是否不透明。true 表示文本背景不透明。
     */


    /**
     * @member SuperMap.ServerTextStyle.prototype.backColor -{SuperMap.ServerColor}
     * @description 文本的背景色。默认为白色。
     */


    _createClass(ServerTextStyle, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.align = null;
            if (me.backColor) {
                me.backColor.destroy();
                me.backColor = null;
            }
            if (me.foreColor) {
                me.foreColor.destroy();
                me.foreColor = null;
            }
            me.backOpaque = null;
            me.sizeFixed = null;
            me.fontHeight = null;
            me.fontWidth = null;
            me.fontWeight = null;
            me.fontName = null;
            me.bold = null;
            me.italic = null;
            me.italicAngle = null;
            me.shadow = null;
            me.strikeout = null;
            me.outline = null;
            me.opaqueRate = null;
            me.underline = null;
            me.rotation = null;
        }

        /**
         * @function SuperMap.ServerTextStyle.fromObj
         * @description 从传入对象获服务端文本风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ServerTextStyle}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ServerTextStyle(obj);
            _SuperMap2.default.Util.copy(res, obj);
            res.backColor = _ServerColor2.default.fromJson(obj.backColor);
            res.foreColor = _ServerColor2.default.fromJson(obj.foreColor);
            return res;
        }
    }]);

    return ServerTextStyle;
}();

exports.default = ServerTextStyle;


_SuperMap2.default.ServerTextStyle = ServerTextStyle;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _TransportationAnalystResultSetting = __webpack_require__(263);

var _TransportationAnalystResultSetting2 = _interopRequireDefault(_TransportationAnalystResultSetting);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** * @class SuperMap.TransportationAnalystParameter * @classdesc 交通网络分析通用参数类。 * 该类主要用来提供交通网络分析所需的通用参数。 * 通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息，还可以对分析结果包含的内容进行一些设置。 * @param options - {Object} 可选参数。如:</br> *        barrierEdgeIDs - {Array<number>} 网络分析中障碍弧段的 ID 数组。</br> *        barrierNodeIDs - {Array<number>} 网络分析中障碍点的 ID 数组。</br> *        barrierPoints - {Array<Point>} 网络分析中 Point2D 类型的障碍点数组。</br> *                         点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br> *        weightFieldName - {string} 阻力字段的名称。</br> *        turnWeightField - {string} 转向权重字段的名称。</br> *        resultSetting - {SuperMap.TransportationAnalystResultSetting} 分析结果返回内容。 */
var TransportationAnalystParameter = function () {

  /**     * @member SuperMap.TransportationAnalystParameter.prototype.turnWeightField -{string}     * @description 转向权重字段的名称。     */


  /**     * @member SuperMap.TransportationAnalystParameter.prototype.barrierPoints -{Array<Point>}     * @description 网络分析中 Point2D 类型的障碍点数组。障碍点表示任何方向都不能通过此点。</br>     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>     * 当各网络分析参数类中的 isAnalyzeById 属性设置为 false 时，该属性才生效。     */


  /**     * @member SuperMap.TransportationAnalystParameter.prototype.barrierEdgeIDs -{Array<number>}     * @description 网络分析中障碍弧段的 ID 数组。弧段设置为障碍边之后，表示双向都不通。     */
  function TransportationAnalystParameter(options) {
    _classCallCheck(this, TransportationAnalystParameter);

    this.barrierEdgeIDs = null;
    this.barrierNodeIDs = null;
    this.barrierPoints = null;
    this.weightFieldName = null;
    this.turnWeightField = null;
    this.resultSetting = null;
    this.CLASS_NAME = "SuperMap.TransportationAnalystParameter";

    var me = this;
    me.resultSetting = new _TransportationAnalystResultSetting2.default();
    if (!options) {
      return;
    }
    _SuperMap2.default.Util.extend(this, options);
  }

  /**     * @function SuperMap.TransportationAnalystParameter.prototype.destroy     * @description 释放资源，将引用资源的属性置空。     */


  /**     *  @member SuperMap.TransportationAnalystParameter.prototype.resultSetting -{SuperMap.TransportationAnalystResultSetting}     *  @description 分析结果返回内容。     */


  /**     * @member SuperMap.TransportationAnalystParameter.prototype.weightFieldName -{string}     * @description 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，例如表示时间、长度等的字段都可以用作阻力字段。     * 该字段默值为服务器发布的所有耗费字段的第一个字段。     */


  /**     * @member SuperMap.TransportationAnalystParameter.prototype.barrierNodeIDs -{Array<number>}     * @description 网络分析中障碍点的 ID 数组。结点设置为障碍点之后，表示任何方向都不能通过此结点。     */


  _createClass(TransportationAnalystParameter, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.barrierEdgeIDs = null;
      me.barrierNodeIDs = null;
      me.weightFieldName = null;
      me.turnWeightField = null;
      if (me.resultSetting) {
        me.resultSetting.destroy();
        me.resultSetting = null;
      }
      if (me.barrierPoints && me.barrierPoints.length) {
        for (var i in me.barrierPoints) {
          me.barrierPoints.destroy();
        }
      }
      me.barrierPoints = null;
    }
  }]);

  return TransportationAnalystParameter;
}();

exports.default = TransportationAnalystParameter;

_SuperMap2.default.TransportationAnalystParameter = TransportationAnalystParameter;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = function(x) {
  if (Math.abs(x) > 1) {
    x = (x > 1) ? 1 : -1;
  }
  return Math.asin(x);
};

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = function(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / (Math.sqrt(1 - con * con));
};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = mapboxgl;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ArrayExt = exports.FunctionExt = exports.NumberExt = exports.StringExt = undefined;

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *@namespace SuperMap
 */

/**
 * @description In addition to the mandatory C and P parameters, an arbitrary number of
 * objects can be passed, which will extend C.
 * @memberOf SuperMap
 * @param C - {Object} the class that inherits
 * @param P - {Object} the superclass to inherit from
 */
_SuperMap2.default.inherit = function (C, P) {
    var F = function F() {};
    F.prototype = P.prototype;
    C.prototype = new F();
    var i, l, o;
    for (i = 2, l = arguments.length; i < l; i++) {
        o = arguments[i];
        if (typeof o === "function") {
            o = o.prototype;
        }
        _SuperMap2.default.Util.extend(C.prototype, o);
    }
};

/**
 * @description 实现多重继承
 * @memberOf SuperMap
 * @param ...mixins {Class|Object}继承的类
 */
_SuperMap2.default.mixin = function () {
    for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
        mixins[_key] = arguments[_key];
    }

    var Mix = function Mix(options) {
        _classCallCheck(this, Mix);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = mixins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var mixin = _step.value;

                copyProperties(this, new mixin(options));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {

        for (var _iterator2 = mixins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var mixin = _step2.value;

            copyProperties(Mix, mixin);
            copyProperties(Mix.prototype, mixin.prototype);
            copyProperties(Mix.prototype, new mixin());
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return Mix;

    function copyProperties(target, source) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = Reflect.ownKeys(source)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var key = _step3.value;

                if (key !== "constructor" && key !== "prototype" && key !== "name") {
                    var desc = Object.getOwnPropertyDescriptor(source, key);
                    Object.defineProperty(target, key, desc);
                }
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }
    }
};

/**
 * @name String
 * @memberOf SuperMap
 * @namespace
 * @description 字符串操作的一系列常用扩展函数.
 */
var StringExt = exports.StringExt = _SuperMap2.default.String = {

    /**
     * @description 判断目标字符串是否以指定的子字符串开头.
     * @param str - {string} 目标字符串.
     * @param sub - {string} 查找的子字符串.
     * @returns {Boolean} 目标字符串以指定的子字符串开头,则返回true;否则返回false.
     */
    startsWith: function startsWith(str, sub) {
        return str.indexOf(sub) == 0;
    },

    /**
     * @description 判断目标字符串是否包含指定的子字符串.
     * @param str - {string} 目标字符串.
     * @param sub - {string} 查找的子字符串.
     * @returns {Boolean} 目标字符串中包含指定的子字符串,则返回true;否则返回false.
     */
    contains: function contains(str, sub) {
        return str.indexOf(sub) != -1;
    },

    /**
     * @description 删除一个字符串的开头和结尾处的所有空白字符.
     * @param str - {string} (可能)存在空白字符填塞的字符串.
     * @returns {string} 删除开头和结尾处空白字符后的字符串.
     */
    trim: function trim(str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    },

    /**
     * @description 骆驼式("-")连字符的字符串处理.
     * 例如: "chicken-head" becomes "chickenHead",
     *       "-chicken-head" becomes "ChickenHead".
     * @param str - {string} 要处理的字符串,原始内容不应被修改.
     * @returns {string}
     */
    camelize: function camelize(str) {
        var oStringList = str.split('-');
        var camelizedString = oStringList[0];
        for (var i = 1, len = oStringList.length; i < len; i++) {
            var s = oStringList[i];
            camelizedString += s.charAt(0).toUpperCase() + s.substring(1);
        }
        return camelizedString;
    },

    /**
     * @description 提供带 ${token} 标记的字符串, 返回context对象属性中指定标记的属性值.
     * @example
     * 示例:
     * (code)
     * 1、template = "${value,getValue}";
     *         context = {value: {getValue:function(){return Math.max.apply(null,argument);}}};
     *         args = [2,23,12,36,21];
     *       返回值:36
     * (end)
     * 示例:
     * (code)
     * 2、template = "$${{value,getValue}}";
     *         context = {value: {getValue:function(){return Math.max.apply(null,argument);}}};
     *         args = [2,23,12,36,21];
     *       返回值:"${36}"
     * (end)
     * 示例:
     * (code)
     * 3、template = "${a,b}";
     *         context = {a: {b:"format"}};
     *         args = null;
     *       返回值:"format"
     * (end)
     * 示例:
     * (code)
     * 3、template = "${a,b}";
     *         context = null;
     *         args = null;
     *       返回值:"${a.b}"
     * (end)
     * @param template - {string} 带标记的字符串将要被替换.参数 template 格式为"${token}",此处的 token 标记会替换为 context["token"] 属性的值
     * @param context - {Object} 带有属性的可选对象的属性用于匹配格式化字符串中的标记.如果该参数为空,将使用 window 对象.
     * @param args - {Array} 可选参数传递给在context对象上找到的函数.
     * @returns {string} 从 context 对象属性中替换字符串标记位的字符串.
     */
    format: function format(template, context, args) {
        if (!context) {
            context = window;
        }

        // Example matching:
        // str   = ${foo.bar}
        // match = foo.bar
        var replacer = function replacer(str, match) {
            var replacement;

            // Loop through all subs. Example: ${a.b.c}
            // 0 -> replacement = context[a];
            // 1 -> replacement = context[a][b];
            // 2 -> replacement = context[a][b][c];
            var subs = match.split(/\.+/);
            for (var i = 0; i < subs.length; i++) {
                if (i == 0) {
                    replacement = context;
                }

                replacement = replacement[subs[i]];
            }

            if (typeof replacement === "function") {
                replacement = args ? replacement.apply(null, args) : replacement();
            }

            // If replacement is undefined, return the string 'undefined'.
            // This is a workaround for a bugs in browsers not properly
            // dealing with non-participating groups in regular expressions:
            // http://blog.stevenlevithan.com/archives/npcg-javascript
            if (typeof replacement == 'undefined') {
                return 'undefined';
            } else {
                return replacement;
            }
        };

        return template.replace(_SuperMap2.default.String.tokenRegEx, replacer);
    },

    /**
     * @description Used to find tokens in a string.
     * @example
     * Examples: ${a}, ${a.b.c}, ${a-b}, ${5}
     */
    tokenRegEx: /\$\{([\w.]+?)\}/g,

    /**
     * @description Used to test strings as numbers.
     */
    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,

    /**
     * @description 判断一个字符串是否只包含一个数值.
     * @example
     * (code)
     * SuperMap.String.isNumeric("6.02e23") // true
     * SuperMap.String.isNumeric("12 dozen") // false
     * SuperMap.String.isNumeric("4") // true
     * SuperMap.String.isNumeric(" 4 ") // false
     * (end)
     * @returns {Boolean} 字符串包含唯一的数值,返回true;否则返回false.
     */
    isNumeric: function isNumeric(value) {
        return _SuperMap2.default.String.numberRegEx.test(value);
    },

    /**
     * @description 把一个看似数值型的字符串转化为一个数值.
     *
     * @returns {Number|String} 如果能转换为数值则返回数值,否则返回字符串本身.
     */
    numericIf: function numericIf(value) {
        return _SuperMap2.default.String.isNumeric(value) ? parseFloat(value) : value;
    }

};

/**
 * @name Number
 * @memberOf SuperMap
 * @namespace
 * @description 数值操作的一系列常用扩展函数.
 */
var NumberExt = exports.NumberExt = _SuperMap2.default.Number = {

    /**
     *  @description 格式化数字时默认的小数点分隔符.
     */
    decimalSeparator: ".",

    /**
     *  @description 格式化数字时默认的千位分隔符.
     */
    thousandsSeparator: ",",

    /**
     * @description 限制浮点数的有效数字位数.
     * @param num - {number}
     * @param sig - {Integer}
     * @returns {number} 将数字四舍五入到指定数量的有效位数.
     */
    limitSigDigs: function limitSigDigs(num, sig) {
        var fig = 0;
        if (sig > 0) {
            fig = parseFloat(num.toPrecision(sig));
        }
        return fig;
    },

    /**
     * @description 数字格式化输出.
     * @param num  - {number}
     * @param dec  - {Integer} 数字的小数部分四舍五入到指定的位数.默认为 0. 设置为null值时小数部分不变.
     * @param tsep - {string} 千位分隔符. 默认为",".
     * @param dsep - {string} 小数点分隔符. 默认为".".
     * @returns {string} 数字格式化后的字符串.
     */
    format: function format(num, dec, tsep, dsep) {
        dec = typeof dec != "undefined" ? dec : 0;
        tsep = typeof tsep != "undefined" ? tsep : _SuperMap2.default.Number.thousandsSeparator;
        dsep = typeof dsep != "undefined" ? dsep : _SuperMap2.default.Number.decimalSeparator;

        if (dec != null) {
            num = parseFloat(num.toFixed(dec));
        }

        var parts = num.toString().split(".");
        if (parts.length === 1 && dec == null) {
            // integer where we do not want to touch the decimals
            dec = 0;
        }

        var integer = parts[0];
        if (tsep) {
            var thousands = /(-?[0-9]+)([0-9]{3})/;
            while (thousands.test(integer)) {
                integer = integer.replace(thousands, "$1" + tsep + "$2");
            }
        }

        var str;
        if (dec == 0) {
            str = integer;
        } else {
            var rem = parts.length > 1 ? parts[1] : "0";
            if (dec != null) {
                rem = rem + new Array(dec - rem.length + 1).join("0");
            }
            str = integer + dsep + rem;
        }
        return str;
    }
};

if (!Number.prototype.limitSigDigs) {
    /**
     * APIMethod: Number.limitSigDigs
     * 限制浮点数的有效数字位数.
     * @param sig - {Integer}
     * @returns {Integer} 将数字四舍五入到指定数量的有效位数.
     *           如果传入值为 null、0、或者是负数, 返回值 0
     */
    Number.prototype.limitSigDigs = function (sig) {
        return NumberExt.limitSigDigs(this, sig);
    };
}

/**
 * @name Function
 * @memberOf SuperMap
 * @namespace
 * @description 函数操作的一系列常用扩展函数.
 */
var FunctionExt = exports.FunctionExt = _SuperMap2.default.Function = {
    /**
     * @description 绑定函数到对象.方便创建this的作用域.
     * @param func - {Function} 输入函数.
     * @param object - {Object} 对象绑定到输入函数(作为输入函数的this对象).
     * @returns {Function} object参数作为func函数的this对象.
     */
    bind: function bind(func, object) {
        // create a reference to all arguments past the second one
        var args = Array.prototype.slice.apply(arguments, [2]);
        return function () {
            // Push on any additional arguments from the actual function call.
            // These will come after those sent to the bind call.
            var newArgs = args.concat(Array.prototype.slice.apply(arguments, [0]));
            return func.apply(object, newArgs);
        };
    },

    /**
     * @description 绑定函数到对象,在调用该函数时配置并使用事件对象作为第一个参数.
     * @param func - {Function} 用于监听事件的函数.
     * @param object - {Object} this 对象的引用.
     * @returns {Function}
     */
    bindAsEventListener: function bindAsEventListener(func, object) {
        return function (event) {
            return func.call(object, event || window.event);
        };
    },

    /**
     * @description 该函数仅仅返回false.该函数主要是避免在IE8以下浏览中DOM事件句柄的匿名函数问题.
     * @example
     * document.onclick = SuperMap.Function.False;
     * @returns {Boolean}
     */
    False: function False() {
        return false;
    },

    /**
     * @description 该函数仅仅返回true.该函数主要是避免在IE8以下浏览中DOM事件句柄的匿名函数问题.
     * @example
     * document.onclick = SuperMap.Function.True;
     * @returns {Boolean}
     */
    True: function True() {
        return true;
    },

    /**
     * @description 可重用函数,仅仅返回"undefined".
     * @returns {undefined}
     */
    Void: function Void() {}

};

/**
 * @name Array
 * @memberOf SuperMap
 * @namespace
 * @description 数组操作的一系列常用扩展函数.
 */
var ArrayExt = exports.ArrayExt = _SuperMap2.default.Array = {

    /**
     * @description 过滤数组.提供了ECMA-262标准中Array.prototype.filter函数的扩展.
     * @see {@link http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter}
     * @param array - {Array} 要过滤的数组..
     * @param callback - {Function} 数组中的每一个元素调用该函数.<br>
     *     如果函数的返回值为true,该元素将包含在返回的数组中.该函数有三个参数: 数组中的元素,元素的索引,数组自身.<br>
     *     如果设置了可选参数caller,在调用callback时,使用可选参数caller设置为callback的参数.<br>
     * @param caller - {Object} 在调用callback时,使用可选参数caller设置为callback的参数.
     * @returns {Array} callback函数返回true时的元素将作为返回数组中的元素.
     */
    filter: function filter(array, callback, caller) {
        var selected = [];
        if (Array.prototype.filter) {
            selected = array.filter(callback, caller);
        } else {
            var len = array.length;
            if (typeof callback != "function") {
                throw new TypeError();
            }
            for (var i = 0; i < len; i++) {
                if (i in array) {
                    var val = array[i];
                    if (callback.call(caller, val, i, array)) {
                        selected.push(val);
                    }
                }
            }
        }
        return selected;
    }

};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _proj = __webpack_require__(291);

var _proj2 = _interopRequireDefault(_proj);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  SuperMap.Projection
 * @description 坐标转换类。这个类封装了与 proj4js 投影对象进行交互的几种方法。
 *
 * SuperMap 默认支持 EPSG:4326, CRS:84, urn:ogc:def:crs:EPSG:6.6:4326, EPSG:900913, EPSG:3857,
 * EPSG:102113, EPSG:102100 投影间的转换。
 *
 * 对于 SuperMap 不支持或者用户想要自定义投影类型，可通过下载 proj4js 产品包，并引入产品包中的 proj4js.js
 * 实现自定义的投影转换。
 * 具体方法可以参见开发指南《坐标投影转换》。
 *
 * 目前 proj4js 支持的投影种类有：
 * WGS84, EPSG:4326, EPSG:4269, EPSG:3875, EPSG:3785, EPSG4139,EPSG:4181, EPSG:4272, EPSG:4302, EPSG:21781,
 * EPSG:102113,EPSG:26591,EPSG:26912, EPSG:27200, EPSG:27563, EPSG:41001, EPSG:42304,EPSG:102067, EPSG:102757,
 * EPSG:102758, EPSG:900913, GOOGLE
 *
 */
var Projection = function () {

    /**
     * Constructor: SuperMap.Projection
     *
     * Parameters:
     * projCode - {String} 投影编码。
     * options - {Object} 设置图层上的的附加属性。
     *
     * (code)
     * var geographic = new SuperMap.Projection("EPSG:4326");
     * (end)
     *
     * Returns:
     * {<SuperMap.Projection>} 投影对象。
     */


    /**
     * APIProperty: projCode
     * {String} 投影编码。
     */
    function Projection(projCode, options) {
        _classCallCheck(this, Projection);

        this.proj = null;
        this.projCode = null;
        this.titleRegEx = /\+title=[^\+]*/;
        this.CLASS_NAME = "SuperMap.Projection";

        _Util.Util.extend(this, options);
        this.projCode = projCode;
        if (window.Proj4js) {
            this.proj = new _proj2.default(projCode);
        }
    }

    /**
     * APIMethod: getCode
     * 获取SRS代码字符串。
     *
     * Returns:
     * {String} SRS代码。
     */


    /**
     * Property: titleRegEx
     * {RegExp} regular expression to strip the title from a proj4js definition
     */


    /**
     * Property: proj
     * {Object} Proj4js.Proj instance.
     */


    _createClass(Projection, [{
        key: 'getCode',
        value: function getCode() {
            return this.proj ? this.proj.srsCode : this.projCode;
        }

        /**
         * APIMethod: getUnits
         * 获取投影的单位字符串。如果 proj4js 不可用则返回null。
         *
         * Returns:
         * {String} 获取的单位。
         */

    }, {
        key: 'getUnits',
        value: function getUnits() {
            return this.proj ? this.proj.units : null;
        }

        /**
         * Method: toString
         * 将投影转换为字符串(内部封装了getCode方法)
         *
         * Returns:
         * {String} 投影代码。
         */

    }, {
        key: 'toString',
        value: function toString() {
            return this.getCode();
        }

        /**
         * Method: equals
         * Test equality of two projection instances.  Determines equality based
         *     soley on the projection code.
         *
         * Returns:
         * {Boolean} The two projections are equivalent.
         */

    }, {
        key: 'equals',
        value: function equals(projection) {
            var p = projection,
                equals = false;
            if (p) {
                if (!(p instanceof Projection)) {
                    p = new Projection(p);
                }
                if (window.Proj4js && this.proj.defData && p.proj.defData) {
                    equals = this.proj.defData.replace(this.titleRegEx, "") === p.proj.defData.replace(this.titleRegEx, "");
                } else if (p.getCode) {
                    var source = this.getCode(),
                        target = p.getCode();
                    equals = source === target || !!Projection.transforms[source] && Projection.transforms[source][target] === Projection.nullTransform;
                }
            }
            return equals;
        }

        /* Method: destroy
         * Destroy projection object.
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            delete this.proj;
            delete this.projCode;
        }

        /**
         * Property: transforms
         * Transforms is an object, with from properties, each of which may
         * have a to property. This allows you to define projections without
         * requiring support for proj4js to be included.
         *
         * This object has keys which correspond to a 'source' projection object.  The
         * keys should be strings, corresponding to the projection.getCode() value.
         * Each source projection object should have a set of destination projection
         * keys included in the object.
         *
         * Each value in the destination object should be a transformation function,
         * where the function is expected to be passed an object with a .x and a .y
         * property.  The function should return the object, with the .x and .y
         * transformed according to the transformation function.
         *
         * Note - Properties on this object should not be set directly.  To add a
         *     transform method to this object, use the <addTransform> method.  For an
         *     example of usage, see the SuperMap.Layer.SphericalMercator file.
         */

        /**
         * APIProperty: defaults
         * {Object} SuperMap 默认支持 EPSG:4326, CRS:84, urn:ogc:def:crs:EPSG:6.6:4326, EPSG:900913, EPSG:3857,
         * EPSG:102113, EPSG:102100 投影间的转换。defaults 定义的关键字为坐标系统编码，相应的属性值为
         * units, maxExtent(坐标系统的有效范围)和yx(当坐标系统有反向坐标轴时为true)
         */


        /**
         * APIMethod: addTransform
         * 设置自定义投影转换方法。在proj4js库不可用或者自定义的投影需要处理时使用此方法。
         *
         * Parameters:
         * from - {String} 源投影代码。
         * to - {String} 目标投影代码。
         * method - {Function} 将作为参数的点的源投影转化为目标投影的方法。
         */


        /**
         * APIMethod: transform
         * 点投影转换。
         *
         * Parameters:
         * point - {<SuperMap.Geometry.Point> | Object} 带有x,y坐标的点对象。
         * source - {SuperMap.Projection} 源地图坐标系统。
         * dest - {SuperMap.Projection} 目标地图坐标系统。
         *
         * Returns:
         * point - {object} 转换后的坐标。
         */


        /**
         * APIFunction: nullTransform
         * 空转换，有用的定义投影的别名时proj4js不可用：当proj4js不可用时，用来定义投影的别名。
         *
         * (code)
         * SuperMap.Projection.addTransform("EPSG:4326", "EPSG:3857",
         *     SuperMap.Layer.SphericalMercator.projectForward);
         * SuperMap.Projection.addTransform("EPSG:3857", "EPSG:3857",
         *     SuperMap.Layer.SphericalMercator.projectInverse);
         * SuperMap.Projection.addTransform("EPSG:3857", "EPSG:900913",
         *     SuperMap.Projection.nullTransform);
         * SuperMap.Projection.addTransform("EPSG:900913", "EPSG:3857",
         *     SuperMap.Projection.nullTransform);
         * (end)
         */

    }]);

    return Projection;
}();

Projection.transforms = {};
Projection.defaults = {
    "EPSG:4326": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90],
        yx: true
        //maxResolution:1.40625
    },
    "CRS:84": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90]
    },
    "EPSG:900913": {
        units: "m",
        maxExtent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
    },
    "EPSG:3857": {
        units: "m",
        maxExtent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
    }
};

Projection.addTransform = function (from, to, method) {
    if (method === Projection.nullTransform) {
        var defaults = Projection.defaults[from];
        if (defaults && !Projection.defaults[to]) {
            Projection.defaults[to] = defaults;
        }
    }
    if (!Projection.transforms[from]) {
        Projection.transforms[from] = {};
    }
    Projection.transforms[from][to] = method;
};

Projection.transform = function (point, source, dest) {
    if (source && dest) {
        if (!(source instanceof Projection)) {
            source = new Projection(source);
        }
        if (!(dest instanceof Projection)) {
            dest = new Projection(dest);
        }
        if (source.proj && dest.proj) {
            point = (0, _proj2.default)(source.proj, dest.proj, point);
        } else {
            var sourceCode = source.getCode();
            var destCode = dest.getCode();
            var transforms = Projection.transforms;
            if (transforms[sourceCode] && transforms[sourceCode][destCode]) {
                transforms[sourceCode][destCode](point);
            }
        }
    }
    return point;
};

Projection.nullTransform = function (point) {
    return point;
};

exports.default = Projection;

_SuperMap2.default.Projection = Projection;
/**
 * Note: Transforms for web mercator <-> geographic
 * SuperMap recognizes EPSG:3857, EPSG:900913, EPSG:102113 and EPSG:102100.
 * SuperMap originally started referring to EPSG:900913 as web mercator.
 * The EPSG has declared EPSG:3857 to be web mercator.
 * ArcGIS 10 recognizes the EPSG:3857, EPSG:102113, and EPSG:102100 as
 * equivalent.  See http://blogs.esri.com/Dev/blogs/arcgisserver/archive/2009/11/20/ArcGIS-Online-moving-to-Google-_2F00_-Bing-tiling-scheme_3A00_-What-does-this-mean-for-you_3F00_.aspx#12084.
 * For geographic, SuperMap recognizes EPSG:4326, CRS:84 and
 * urn:ogc:def:crs:EPSG:6.6:4326. SuperMap also knows about the reverse axis
 * order for EPSG:4326.
 */
(function () {

    var pole = 20037508.34;

    function inverseMercator(xy) {
        xy.x = 180 * xy.x / pole;
        xy.y = 180 / Math.PI * (2 * Math.atan(Math.exp(xy.y / pole * Math.PI)) - Math.PI / 2);
        return xy;
    }

    function forwardMercator(xy) {
        xy.x = xy.x * pole / 180;
        //xy.y = xy.y<-90?-89.99:xy.y;//经纬度转换为墨卡托，当纬度值小于-90时，转换后的结果为NaN，故不能超过范围
        //xy.y = xy.y>90?89.99:xy.y;
        xy.y = Math.log(Math.tan((90 + xy.y) * Math.PI / 360)) / Math.PI * pole;
        return xy;
    }

    function map(base, codes) {
        var add = Projection.addTransform;
        var same = Projection.nullTransform;
        var i, len, code, other, j;
        for (i = 0, len = codes.length; i < len; ++i) {
            code = codes[i];
            add(base, code, forwardMercator);
            add(code, base, inverseMercator);
            for (j = i + 1; j < len; ++j) {
                other = codes[j];
                add(code, other, same);
                add(other, code, same);
            }
        }
    }

    // list of equivalent codes for web mercator
    var mercator = ["EPSG:900913", "EPSG:3857", "EPSG:102113", "EPSG:102100"],
        geographic = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326", "EPSG:4326"],
        i;
    for (i = mercator.length - 1; i >= 0; --i) {
        map(mercator[i], geographic);
    }
    for (i = geographic.length - 1; i >= 0; --i) {
        map(geographic[i], mercator);
    }
})();

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Point = __webpack_require__(11);

var _Point2 = _interopRequireDefault(_Point);

var _Collection = __webpack_require__(14);

var _Collection2 = _interopRequireDefault(_Collection);

var _Curve2 = __webpack_require__(161);

var _Curve3 = _interopRequireDefault(_Curve2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.LineString
 * @classdesc 几何对象线串类。
 * @param points - {Array<SuperMap.Geometry.Point>} 用来生成线串的点数组。
 * @extends {SuperMap.Geometry.Curve}
 *
 * @example
 * var points = [new SuperMap.Geometry.Point(4933.319287022352, -3337.3849141502124),
 *     new SuperMap.Geometry.Point(4960.9674060199022, -3349.3316322355736),
 *     new SuperMap.Geometry.Point(5006.0235999418364, -3358.8890067038628),
 *     new SuperMap.Geometry.Point(5075.3145648369318, -3378.0037556404409),
 *     new SuperMap.Geometry.Point(5305.19551436013, -3376.9669111768926)],
 * var roadLine = new SuperMap.Geometry.LineString(points)；
 */
var LineString = function (_Curve) {
    _inherits(LineString, _Curve);

    function LineString(points) {
        _classCallCheck(this, LineString);

        var _this = _possibleConstructorReturn(this, (LineString.__proto__ || Object.getPrototypeOf(LineString)).call(this, points));

        _this.CLASS_NAME = "SuperMap.Geometry.LineString";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.LineString.prototype.removeComponent
     * @description 只有在线串上有三个或更多的点的时候，才会允许移除点（否则结果将会是单一的点）。
     * @param point - {SuperMap.Geometry.Point} 将被删除的点。
     * @returns {Boolean} 删除的点。
     */


    _createClass(LineString, [{
        key: 'removeComponent',
        value: function removeComponent(point) {
            var removed = this.components && this.components.length > 2;
            if (removed) {
                _Collection2.default.prototype.removeComponent.apply(this, arguments);
            }
            return removed;
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.intersects
         * @description 判断两个几何图形是否相交。
         * @param geometry - {SuperMap.Geometry} 任意的几何类型。
         * @returns {Boolean} 输入几何图形与当前几何图形是否相交。
         */

    }, {
        key: 'intersects',
        value: function intersects(geometry) {
            var intersect = false;
            var type = geometry.CLASS_NAME;
            if (type === "SuperMap.Geometry.LineString" || type === "SuperMap.Geometry.LinearRing" || type === "SuperMap.Geometry.Point") {
                var segs1 = this.getSortedSegments();
                var segs2;
                if (type === "SuperMap.Geometry.Point") {
                    segs2 = [{
                        x1: geometry.x, y1: geometry.y,
                        x2: geometry.x, y2: geometry.y
                    }];
                } else {
                    segs2 = geometry.getSortedSegments();
                }
                var seg1, seg1x1, seg1x2, seg1y1, seg1y2, seg2, seg2y1, seg2y2;
                // sweep right
                outer: for (var i = 0, len = segs1.length; i < len; ++i) {
                    seg1 = segs1[i];
                    seg1x1 = seg1.x1;
                    seg1x2 = seg1.x2;
                    seg1y1 = seg1.y1;
                    seg1y2 = seg1.y2;
                    inner: for (var j = 0, jlen = segs2.length; j < jlen; ++j) {
                        seg2 = segs2[j];
                        if (seg2.x1 > seg1x2) {
                            // seg1 still left of seg2
                            break;
                        }
                        if (seg2.x2 < seg1x1) {
                            // seg2 still left of seg1
                            continue;
                        }
                        seg2y1 = seg2.y1;
                        seg2y2 = seg2.y2;
                        if (Math.min(seg2y1, seg2y2) > Math.max(seg1y1, seg1y2)) {
                            // seg2 above seg1
                            continue;
                        }
                        if (Math.max(seg2y1, seg2y2) < Math.min(seg1y1, seg1y2)) {
                            // seg2 below seg1
                            continue;
                        }
                        if (_SuperMap2.default.Geometry.segmentsIntersect(seg1, seg2)) {
                            intersect = true;
                            break outer;
                        }
                    }
                }
            } else {
                intersect = geometry.intersects(this);
            }
            return intersect;
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.getSortedSegments
         * @returns {Array} An array of segment objects.  Segment objects have properties
         *     x1, y1, x2, and y2.  The start point is represented by x1 and y1.
         *     The end point is represented by x2 and y2.  Start and end are
         *     ordered so that x1 < x2.
         */

    }, {
        key: 'getSortedSegments',
        value: function getSortedSegments() {
            var numSeg = this.components.length - 1;
            var segments = new Array(numSeg),
                point1,
                point2;
            for (var i = 0; i < numSeg; ++i) {
                point1 = this.components[i];
                point2 = this.components[i + 1];
                if (point1.x < point2.x) {
                    segments[i] = {
                        x1: point1.x,
                        y1: point1.y,
                        x2: point2.x,
                        y2: point2.y
                    };
                } else {
                    segments[i] = {
                        x1: point2.x,
                        y1: point2.y,
                        x2: point1.x,
                        y2: point1.y
                    };
                }
            }

            // more efficient to define this somewhere static
            function byX1(seg1, seg2) {
                return seg1.x1 - seg2.x1;
            }

            return segments.sort(byX1);
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.splitWithSegment
         * @description Split this geometry with the given segment.
         * @param seg - {Object} An object with x1, y1, x2, and y2 properties referencing
         *     segment endpoint coordinates.
         * @param options - {Object} Properties of this object will be used to determine
         *     how the split is conducted.<br>
         * Valid options:<br>
         * edge - {Boolean} Allow splitting when only edges intersect.  Default is
         *     true.  If false, a vertex on the source segment must be within the
         *     tolerance distance of the intersection to be considered a split.<br>
         * tolerance - {number} If a non-null value is provided, intersections
         *     within the tolerance distance of one of the source segment's
         *     endpoints will be assumed to occur at the endpoint.
         *
         * @returns {Object} An object with *lines* and *points* properties.  If the given
         *     segment intersects this linestring, the lines array will reference
         *     geometries that result from the split.  The points array will contain
         *     all intersection points.  Intersection points are sorted along the
         *     segment (in order from x1,y1 to x2,y2).
         */

    }, {
        key: 'splitWithSegment',
        value: function splitWithSegment(seg, options) {
            var edge = !(options && options.edge === false);
            var tolerance = options && options.tolerance;
            var lines = [];
            var verts = this.getVertices();
            var points = [];
            var intersections = [];
            var split = false;
            var vert1, vert2, point;
            var node, vertex, target;
            var interOptions = { point: true, tolerance: tolerance };
            var result = null;
            for (var i = 0, stop = verts.length - 2; i <= stop; ++i) {
                vert1 = verts[i];
                points.push(vert1.clone());
                vert2 = verts[i + 1];
                target = { x1: vert1.x, y1: vert1.y, x2: vert2.x, y2: vert2.y };
                point = _SuperMap2.default.Geometry.segmentsIntersect(seg, target, interOptions);
                if (point instanceof _Point2.default) {
                    if (point.x === seg.x1 && point.y === seg.y1 || point.x === seg.x2 && point.y === seg.y2 || point.equals(vert1) || point.equals(vert2)) {
                        vertex = true;
                    } else {
                        vertex = false;
                    }
                    if (vertex || edge) {
                        // push intersections different than the previous
                        if (!point.equals(intersections[intersections.length - 1])) {
                            intersections.push(point.clone());
                        }
                        if (i === 0) {
                            if (point.equals(vert1)) {
                                continue;
                            }
                        }
                        if (point.equals(vert2)) {
                            continue;
                        }
                        split = true;
                        if (!point.equals(vert1)) {
                            points.push(point);
                        }
                        lines.push(new LineString(points));
                        points = [point.clone()];
                    }
                }
            }
            if (split) {
                points.push(vert2.clone());
                lines.push(new LineString(points));
            }
            if (intersections.length > 0) {
                // sort intersections along segment
                var xDir = seg.x1 < seg.x2 ? 1 : -1;
                var yDir = seg.y1 < seg.y2 ? 1 : -1;
                result = {
                    lines: lines,
                    points: intersections.sort(function (p1, p2) {
                        return xDir * p1.x - xDir * p2.x || yDir * p1.y - yDir * p2.y;
                    })
                };
            }
            return result;
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.split
         * @description Use this geometry (the source) to attempt to split a target geometry.
         * @param target - {SuperMap.Geometry} The target geometry.
         * @param options - {Object} Properties of this object will be used to determine
         *     how the split is conducted.
         *
         * Valid options:
         * mutual - {Boolean} Split the source geometry in addition to the target
         *     geometry.  Default is false.
         * edge - {Boolean} Allow splitting when only edges intersect.  Default is
         *     true.  If false, a vertex on the source must be within the tolerance
         *     distance of the intersection to be considered a split.
         * tolerance - {number} If a non-null value is provided, intersections
         *     within the tolerance distance of an existing vertex on the source
         *     will be assumed to occur at the vertex.
         *
         * @returns {Array} A list of geometries (of this same type as the target) that
         *     result from splitting the target with the source geometry.  The
         *     source and target geometry will remain unmodified.  If no split
         *     results, null will be returned.  If mutual is true and a split
         *     results, return will be an array of two arrays - the first will be
         *     all geometries that result from splitting the source geometry and
         *     the second will be all geometries that result from splitting the
         *     target geometry.
         */

    }, {
        key: 'split',
        value: function split(target, options) {
            var results = null;
            var mutual = options && options.mutual;
            var sourceSplit, targetSplit, sourceParts, targetParts;
            if (target instanceof LineString) {
                var verts = this.getVertices();
                var vert1, vert2, seg, splits, lines, point;
                var points = [];
                sourceParts = [];
                for (var i = 0, stop = verts.length - 2; i <= stop; ++i) {
                    vert1 = verts[i];
                    vert2 = verts[i + 1];
                    seg = {
                        x1: vert1.x, y1: vert1.y,
                        x2: vert2.x, y2: vert2.y
                    };
                    targetParts = targetParts || [target];
                    if (mutual) {
                        points.push(vert1.clone());
                    }
                    for (var j = 0; j < targetParts.length; ++j) {
                        splits = targetParts[j].splitWithSegment(seg, options);
                        if (splits) {
                            // splice in new features
                            lines = splits.lines;
                            if (lines.length > 0) {
                                lines.unshift(j, 1);
                                Array.prototype.splice.apply(targetParts, lines);
                                j += lines.length - 2;
                            }
                            if (mutual) {
                                for (var k = 0, len = splits.points.length; k < len; ++k) {
                                    point = splits.points[k];
                                    if (!point.equals(vert1)) {
                                        points.push(point);
                                        sourceParts.push(new LineString(points));
                                        if (point.equals(vert2)) {
                                            points = [];
                                        } else {
                                            points = [point.clone()];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (mutual && sourceParts.length > 0 && points.length > 0) {
                    points.push(vert2.clone());
                    sourceParts.push(new LineString(points));
                }
            } else {
                results = target.splitWith(this, options);
            }
            if (targetParts && targetParts.length > 1) {
                targetSplit = true;
            } else {
                targetParts = [];
            }
            if (sourceParts && sourceParts.length > 1) {
                sourceSplit = true;
            } else {
                sourceParts = [];
            }
            if (targetSplit || sourceSplit) {
                if (mutual) {
                    results = [sourceParts, targetParts];
                } else {
                    results = targetParts;
                }
            }
            return results;
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.splitWith
         * @description Split this geometry (the target) with the given geometry (the source).
         * @param geometry - {SuperMap.Geometry} A geometry used to split this
         *     geometry (the source).
         * @param options - {Object} Properties of this object will be used to determine
         *     how the split is conducted.
         *
         * Valid options:
         * mutual - {Boolean} Split the source geometry in addition to the target
         *     geometry.  Default is false.
         * edge - {Boolean} Allow splitting when only edges intersect.  Default is
         *     true.  If false, a vertex on the source must be within the tolerance
         *     distance of the intersection to be considered a split.
         * tolerance - {number} If a non-null value is provided, intersections
         *     within the tolerance distance of an existing vertex on the source
         *     will be assumed to occur at the vertex.
         *
         * @returns {Array} A list of geometries (of this same type as the target) that
         *     result from splitting the target with the source geometry.  The
         *     source and target geometry will remain unmodified.  If no split
         *     results, null will be returned.  If mutual is true and a split
         *     results, return will be an array of two arrays - the first will be
         *     all geometries that result from splitting the source geometry and
         *     the second will be all geometries that result from splitting the
         *     target geometry.
         */

    }, {
        key: 'splitWith',
        value: function splitWith(geometry, options) {
            return geometry.split(this, options);
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.getVertices
         * @description 返回几何图形的所有顶点的列表。
         * @param nodes - {Boolean} 对于线来说，仅仅返回作为端点的顶点，如果设为false，则返回非端点的顶点
         * 如果没有设置此参数，则返回所有顶点。
         * @returns {Array} 几何图形的顶点列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {
            var vertices;
            if (nodes === true) {
                vertices = [this.components[0], this.components[this.components.length - 1]];
            } else if (nodes === false) {
                vertices = this.components.slice(1, this.components.length - 1);
            } else {
                vertices = this.components.slice();
            }
            return vertices;
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.distanceTo
         * @description 计算两个几个图形间的最小距离（x-y平面坐标系下）。
         * @param geometry - {SuperMap.Geometry} 目标几何图形。
         * @param options - {Object}距离计算需要设置的可选属性。有效的选项取决于特定的几何类型。
         *
         * Valid options:
         * details - {Boolean} 返回距离计算的细节，默认为false。
         * edge - {Boolean} 计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果设为true，
         * 一个几何图形完全包含在目标几何图形中时，调用distanceTo返回非零结果，如果false，两个几何图形相交情况下
         * 调用distanceTo结果返回0，而且如果false，将不返距离。
         * @returns {number | Object} 返回一个几何图形到目标几何图形的距离。
         */

    }, {
        key: 'distanceTo',
        value: function distanceTo(geometry, options) {
            var edge = !(options && options.edge === false);
            var details = edge && options && options.details;
            var result,
                best = {};
            var min = Number.POSITIVE_INFINITY;
            if (geometry instanceof _Point2.default) {
                var segs = this.getSortedSegments();
                var x = geometry.x;
                var y = geometry.y;
                var seg;
                for (var i = 0, len = segs.length; i < len; ++i) {
                    seg = segs[i];
                    result = Supermap.Geometry.distanceToSegment(geometry, seg);
                    if (result.distance < min) {
                        min = result.distance;
                        best = result;
                        if (min === 0) {
                            break;
                        }
                    } else {
                        // if distance increases and we cross y0 to the right of x0, no need to keep looking.
                        if (seg.x2 > x && (y > seg.y1 && y < seg.y2 || y < seg.y1 && y > seg.y2)) {
                            break;
                        }
                    }
                }
                if (details) {
                    best = {
                        distance: best.distance,
                        x0: best.x, y0: best.y,
                        x1: x, y1: y
                    };
                } else {
                    best = best.distance;
                }
            } else if (geometry instanceof LineString) {
                var segs0 = this.getSortedSegments();
                var segs1 = geometry.getSortedSegments();
                var seg0, seg1, intersection, x0, y0;
                var len1 = segs1.length;
                var interOptions = { point: true };
                outer: for (var i = 0, len = segs0.length; i < len; ++i) {
                    seg0 = segs0[i];
                    x0 = seg0.x1;
                    y0 = seg0.y1;
                    for (var j = 0; j < len1; ++j) {
                        seg1 = segs1[j];
                        intersection = Supermap.Geometry.segmentsIntersect(seg0, seg1, interOptions);
                        if (intersection) {
                            min = 0;
                            best = {
                                distance: 0,
                                x0: intersection.x, y0: intersection.y,
                                x1: intersection.x, y1: intersection.y
                            };
                            break outer;
                        } else {
                            result = Supermap.Geometry.distanceToSegment({ x: x0, y: y0 }, seg1);
                            if (result.distance < min) {
                                min = result.distance;
                                best = {
                                    distance: min,
                                    x0: x0, y0: y0,
                                    x1: result.x, y1: result.y
                                };
                            }
                        }
                    }
                }
                if (!details) {
                    best = best.distance;
                }
                if (min !== 0) {
                    // check the final vertex in this line's sorted segments
                    if (seg0) {
                        result = geometry.distanceTo(new _Point2.default(seg0.x2, seg0.y2), options);
                        var dist = details ? result.distance : result;
                        if (dist < min) {
                            if (details) {
                                best = {
                                    distance: min,
                                    x0: result.x1, y0: result.y1,
                                    x1: result.x0, y1: result.y0
                                };
                            } else {
                                best = dist;
                            }
                        }
                    }
                }
            } else {
                best = geometry.distanceTo(this, options);
                // swap since target comes from this line
                if (details) {
                    best = {
                        distance: best.distance,
                        x0: best.x1, y0: best.y1,
                        x1: best.x0, y1: best.y0
                    };
                }
            }
            return best;
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.simplify
         * @description 这个函数返回一个简化的线串，基于道格拉斯 - 普克简化算法进行简化。
         * @param tolerance - {number} 地图单位上的简化的阈值。
         * @returns {SuperMap.Geometry.LineString} 被简化的线串。
         */

    }, {
        key: 'simplify',
        value: function simplify(tolerance) {
            if (this && this !== null) {
                var points = this.getVertices();
                if (points.length < 3) {
                    return this;
                }

                var compareNumbers;
                a, b;
                {
                    return a - b;
                }
                ;

                var firstPoint = 0;
                var lastPoint = points.length - 1;
                var pointIndexsToKeep = [];

                /**
                 * Private function calculating the perpendicular distance
                 * TODO: check whether SuperMap.Geometry.LineString::distanceTo() is faster or slower
                 */
                var perpendicularDistance;
                point1, point2, point;
                {
                    //Area = |(1/2)(x1y2 + x2y3 + x3y1 - x2y1 - x3y2 - x1y3)|   *Area of triangle
                    //Base = v((x1-x2)²+(x1-x2)²)                               *Base of Triangle*
                    //Area = .5*Base*H                                          *Solve for height
                    //Height = Area/.5/Base

                    var area = Math.abs(0.5 * (point1.x * point2.y + point2.x * point.y + point.x * point1.y - point2.x * point1.y - point.x * point2.y - point1.x * point.y));
                    var bottom = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
                    var height = area / bottom * 2;

                    return height;
                }
                ;

                /**
                 * Private function doing the Douglas-Peucker reduction
                 */
                var douglasPeuckerReduction;
                points, firstPoint, lastPoint, tolerance;
                {
                    var maxDistance = 0;
                    var indexFarthest = 0;

                    for (var index = firstPoint, distance; index < lastPoint; index++) {
                        distance = perpendicularDistance(points[firstPoint], points[lastPoint], points[index]);
                        if (distance > maxDistance) {
                            maxDistance = distance;
                            indexFarthest = index;
                        }
                    }

                    if (maxDistance > tolerance && indexFarthest !== firstPoint) {
                        //Add the largest point that exceeds the tolerance
                        pointIndexsToKeep.push(indexFarthest);
                        douglasPeuckerReduction(points, firstPoint, indexFarthest, tolerance);
                        douglasPeuckerReduction(points, indexFarthest, lastPoint, tolerance);
                    }
                }
                ;

                //Add the first and last index to the keepers
                pointIndexsToKeep.push(firstPoint);
                pointIndexsToKeep.push(lastPoint);

                //The first and the last point cannot be the same
                while (points[firstPoint].equals(points[lastPoint])) {
                    lastPoint--;
                    //Addition: the first point not equal to first point in the LineString is kept as well
                    pointIndexsToKeep.push(lastPoint);
                }

                douglasPeuckerReduction(points, firstPoint, lastPoint, tolerance);
                var returnPoints = [];
                pointIndexsToKeep.sort(compareNumbers);
                for (var index = 0; index < pointIndexsToKeep.length; index++) {
                    returnPoints.push(points[pointIndexsToKeep[index]]);
                }
                return new LineString(returnPoints);
            } else {
                return this;
            }
        }

        /**
         * @function SuperMap.Geometry.LineString.createCurve
         * @description 创建扇形对象。
         * @param points - {Array<SuperMap.Geometry.Point>} 曲线经过的点串。
         * @param method - {String} 曲线类型，目前支持的有："lanczos","cubic","linear",默认为"lanczos"。
         * @param filterSize - {number} 曲线平滑曲度，在2~10之间的数值，默认为10，不支持method为"linear"的类型。
         * @param lineLength - {number} 曲线拟合的线数目，默认是80。
         * 备注：需要依赖Smooth.js
         * @returns {SuperMap.Geometry.LineString} 几何线对象
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(11983722.7315,3942864.5449));
         * points.push(new SuperMap.Geometry.Point(11986722.7315, 3946864.5449));
         * points.push(new SuperMap.Geometry.Point(11989722.7315, 3949864.5449));
         * var curve = SuperMap.Geometry.LineString.createCurve(points);
         */

    }], [{
        key: 'createCurve',
        value: function createCurve(points, method, filterSize, lineLength) {
            var methodCurve = "lanczos";
            if (method != undefined) methodCurve = method;

            var filterSizeCurve = 10;
            if (filterSize != undefined) filterSizeCurve = filterSize;

            var smoothConfig = {
                method: methodCurve,
                clip: 'mirror',
                lanczosFilterSize: filterSizeCurve,
                cubicTension: 0
            };

            var pp = [];
            for (var i = 0; i < points.length; i++) {
                pp.push([points[i].x, points[i].y]);
            }

            var distance;
            a, b;
            {
                return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
            }

            var averageLineLengthCurve = 80;
            if (lineLength != undefined) averageLineLengthCurve = lineLength;

            var pointList = [];
            var averageLineLength, du, end, pieceCount, pieceLength, s, start, t, u, _ref, _ref2, _ref3;
            averageLineLength = distance(pp[0], pp[pp.length - 1]) / averageLineLengthCurve;
            pieceCount = 2;
            s = Smooth(pp, smoothConfig);
            for (t = 0, _ref = 1 / pieceCount; t < 1; t += _ref) {
                _ref2 = [s(i + t), s(i + t + 1 / pieceCount)], start = _ref2[0], end = _ref2[1];
                pieceLength = distance(start, end);
                du = averageLineLength / pieceLength;
                for (u = 0, _ref3 = 1 / pieceCount; 0 <= _ref3 ? u < _ref3 : u > _ref3; u += du) {
                    var p = s(i + t + u);
                    pointList.push(new _Point2.default(p[0], p[1]));
                }
            }

            var p = s(i + 1);
            pointList.push(new _Point2.default(p[0], p[1]));

            return new LineString(pointList);
        }
    }, {
        key: 'createBspline',


        /**
         * @function SuperMap.Geometry.LineString.createBspline
         * @description 创建B样条曲线。此曲线会穿过所有的点。
         * @param points - {Array<SuperMap.Geometry.Point>} 曲线经过的点串。
         * @param filterSize - {number} 曲线平滑曲度，默认为10。
         * @returns {SuperMap.Geometry.LineString} 几何线对象
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(116, 39.4));
         * points.push(new SuperMap.Geometry.Point(118, 39.8));
         * points.push(new SuperMap.Geometry.Point(119, 39));
         *
         * var curve = SuperMap.Geometry.LineString.createBspline(points,5);
         */
        value: function createBspline(points, filterSize) {
            //一个点无效，至少需要两个点
            if (points.length < 2) {
                return null;
            }
            //曲线内部的所有点数组
            var pointListDraw = [];
            //设置曲线平滑曲度
            var k = 10;
            if (filterSize != undefined) {
                k = filterSize;
            }
            var i, j, a0, a1, a2, dt, t1, t2;
            var t_x, t_y;
            dt = 1.0 / k;
            //计算起始点，
            var value = Math.sqrt((Math.pow(points[1].x - points[0].x, 2) + Math.pow(points[1].y - points[0].y, 2)) / 2); //取的点数组中前两个点粗略计算出的一个值
            //此为第一个控制点，此点以后可能会开放出来
            var pointFirst = new _Point2.default(points[0].x - value, points[0].y - value);
            //初始化一个点数组，存放所有的控制点
            var pointListControl = [];
            //第一个控制点也就是起始点pointFirst
            pointListControl[0] = pointFirst;
            //循环用户传进的点数组
            for (i = 0; i < points.length - 1; i++) {
                //定义一个零时数组，只需要三个元素，后期用于调用贝茨曲线划线（由首尾两个挤出点和中间的控制点组成的）
                var pointList = [];
                //
                pointList[0] = points[i];
                //由前一个控制点和当前的点生成的后一个控制点
                var point = new _Point2.default(points[i].x * 2 - pointListControl[i].x, points[i].y * 2 - pointListControl[i].y);
                pointList[1] = point;
                pointListControl[i + 1] = point;
                pointList[2] = points[i + 1];
                //将此控制点存起来
                pointListDraw.push(pointList[0]);
                //生成当前曲线中的所有点
                for (j = 0; j <= k; j++) {
                    t1 = j * dt;
                    t2 = t1 * t1;

                    a0 = (t2 - 2 * t1 + 1) / 2.0;
                    a1 = (2 * t1 - 2 * t2 + 1) / 2.0;
                    a2 = t2 / 2.0;

                    t_x = a0 * pointList[0].x + a1 * pointList[1].x + a2 * pointList[2].x;
                    t_y = a0 * pointList[0].y + a1 * pointList[1].y + a2 * pointList[2].y;
                    pointListDraw.push(new _Point2.default(t_x, t_y));
                }
            }
            //将最后一个用户的点存进去才能达到曲线通过所有的点
            pointListDraw.push(points[points.length - 1]);
            return new LineString(pointListDraw);
        }

        /**
         * @function SuperMap.Geometry.LineString.createBezier1
         * @description 创建1次贝塞尔曲线。
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @param precision -{number} 拆分精度，表示贝塞尔曲线上任意两点间横向或纵向的最大距离。
         *                     决定贝塞尔曲线的平滑程度。取值越小曲线越平滑。取值为大于1的整数。
         * @param part -{number} 平滑度。取值越大，曲线越平滑。取值为大于1的整数。
         * @returns {SuperMap.Geometry.LineString} 几何线对象
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50));
         * points.push(new SuperMap.Geometry.Point(2,60));
         * points.push(new SuperMap.Geometry.Point(8,20));
         *
         * var bezier = SuperMap.Geometry.LineString.createBezier1(points, 20);
         */

    }, {
        key: 'createBezier1',
        value: function createBezier1(points, precision, part) {
            if (part) {
                return LineString.createBezier3(points, part);
            }
            //获取待拆分的点
            var bezierPts = [];
            for (var m = 0; m < points.length; m++) {
                bezierPts[m] = points[m];
            }
            //获取输入点的数量
            var i;
            var k;
            var j = 0;
            var bExit;
            var count = bezierPts.length;
            var ptBuffer = [];
            var ok = true;
            while (ok) {
                bExit = true;
                //贝塞尔分解是按4个点为一组进行的，所以小于4个点就再不进行分解
                for (i = 0; i < count - 3; i += 3) {
                    //对输入点数组进行分解
                    //判断bezierPts[i]到bezierPts[i+4]是否达到精度
                    if (GetBezierGap(bezierPts, i) > precision) {
                        bExit = false;
                        //对未达到精度的bezierPts[i]到bezierPts[i+4]进行计算，得到新的ptBuffer点数组
                        InciseBezier(bezierPts, i, ptBuffer);
                        //去除已使用过的2个控制点
                        bezierPts.splice(i + 1, 2);
                        //将本次计算得到的5个新的点插入到bezierPts[i]位置之后，得到新的bezierPts点数组
                        for (k = 0; k < 5; k++) {
                            bezierPts.splice(i + 1 + k, 0, ptBuffer[k + 1]);
                        }
                        //bezierPts[i]到bezierPts[i+4]没有达到精度，所以不能跳过，i需回归初始
                        i -= 3;
                        count = bezierPts.length;
                    }
                    if (bExit) break;
                }
                //对分解得出的新bezierPts点数组进行优化，除去相同的点
                while (j < count - 1) {
                    if (bezierPts[j] === bezierPts[j + 1]) {
                        bezierPts.splice(j + 1, 1);
                        count--;
                    }
                    j++;
                }
                ok = false;
            }

            return new LineString(bezierPts);
        }

        /**
         * @function SuperMap.Geometry.LineString.calculatePointsFBZ2
         * @description 计算2次贝塞尔曲线的点
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串（必须为三个点）。
         * @param part -{number} 平滑度。取值越大，曲线越平滑。取值为大于1的整数。
         * @returns {Array<SuperMap.Geometry.Point>} 2次贝塞尔曲线的所有点
         */

    }, {
        key: 'calculatePointsFBZ2',
        value: function calculatePointsFBZ2(points, part) {
            if (!part) part = 20;

            //获取待拆分的点
            var bezierPts = [];
            var scale = 0.05;
            if (part > 0) {
                scale = 1 / part;
            }

            for (var i = 0; i < points.length - 2;) {
                //起始点
                var pointS = points[i];
                //控制点
                var pointC = points[i + 1];
                //结束点
                var pointE = points[i + 2];

                bezierPts.push(pointS);
                for (var t = 0; t < 1;) {
                    //二次贝塞尔曲线公式
                    var x = (1 - t) * (1 - t) * pointS.x + 2 * t * (1 - t) * pointC.x + t * t * pointE.x;
                    var y = (1 - t) * (1 - t) * pointS.y + 2 * t * (1 - t) * pointC.y + t * t * pointE.y;
                    var point = new _Point2.default(x, y);
                    bezierPts.push(point);
                    t += scale;
                }

                i += 2;
                if (i >= points.length) {
                    bezierPts.push(pointS);
                }
            }

            //需要判定一下最后一个点是否存在
            var poRE = bezierPts[bezierPts.length - 1];
            var popE = points[points.length - 1];
            if (!poRE.equals(popE)) {
                bezierPts.push(popE.clone());
            }

            return bezierPts;
        }

        /**
         * @function SuperMap.Geometry.LineString.calculatePointsFBZ3
         * 计算3次贝塞尔曲线的点
         *
         * points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串(四个)。
         * part -{number} 平滑度。取值越大，曲线越平滑。取值为大于1的整数。
         * @returns {Array<SuperMap.Geometry.Point>} 3次贝塞尔曲线的所有点
         */

    }, {
        key: 'calculatePointsFBZ3',
        value: function calculatePointsFBZ3(points, part) {
            if (!part) part = 20;
            //获取待拆分的点
            var bezierPts = [];
            var scale = 0.05;

            if (part > 0) {
                scale = 1 / part;
            }

            for (var i = 0; i < points.length - 3;) {
                //起始点
                var pointS = points[i];
                //第一个控制点
                var pointC1 = points[i + 1];
                //第二个控制点
                var pointC2 = points[i + 2];
                //结束点
                var pointE = points[i + 3];

                bezierPts.push(pointS);
                for (var t = 0; t < 1;) {
                    //三次贝塞尔曲线公式
                    var x = (1 - t) * (1 - t) * (1 - t) * pointS.x + 3 * t * (1 - t) * (1 - t) * pointC1.x + 3 * t * t * (1 - t) * pointC2.x + t * t * t * pointE.x;
                    var y = (1 - t) * (1 - t) * (1 - t) * pointS.y + 3 * t * (1 - t) * (1 - t) * pointC1.y + 3 * t * t * (1 - t) * pointC2.y + t * t * t * pointE.y;
                    var point = new _Point2.default(x, y);
                    bezierPts.push(point);
                    t += scale;
                }

                i += 3;
                if (i >= points.length) {
                    bezierPts.push(pointS);
                }
            }

            //需要判定一下最后一个点是否存在
            var poRE = bezierPts[bezierPts.length - 1];
            var popE = points[points.length - 1];
            if (!poRE.equals(popE)) {
                bezierPts.push(popE.clone());
            }
            return bezierPts;
        }

        /**
         * @function SuperMap.Geometry.LineString.calculatePointsFBZN
         * @description 计算N次贝塞尔曲线的插值点
         * 计算N次贝塞尔曲线需要N+1个点,也就是传入 points ，得到的是points.length-1次贝塞尔曲线
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @param part -{number} 平滑度。取值越大，曲线越平滑。取值为大于1的整数。
         * @returns {Array<SuperMap.Geometry.Point>} N次贝塞尔曲线的所有点
         */

    }, {
        key: 'calculatePointsFBZN',
        value: function calculatePointsFBZN(points, part) {
            if (!part) part = points.length * 8;

            //获取待拆分的点
            var bezierPts = [];
            var scale = 0.05;
            if (part > 0) {
                scale = 1 / part;
            }
            for (var t = 0; t <= 1;) {
                var x = 0;
                var y = 0;
                var n = points.length;
                for (var i = 0; i < points.length; i++) {
                    var b = LineString.BEZ(n - 1, i, t);
                    x += points[i].x * b;
                    y += points[i].y * b;
                }
                var point = new _Point2.default(x, y);
                bezierPts.push(point);
                t += scale;
            }
            //需要判定一下最后一个点是否存在
            var poRE = bezierPts[bezierPts.length - 1];
            var popE = points[points.length - 1];
            if (!poRE.equals(popE)) {
                bezierPts.push(popE.clone());
            }
            return bezierPts;
        }

        /**
         * @function SuperMap.Geometry.LineString.createBezier2
         * @description 创建2次贝塞尔曲线。
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串（必须为三个点）。
         * @param part -{number} 平滑度。取值越大，曲线越平滑。取值为大于1的整数。
         * @returns {SuperMap.Geometry.LineString} 几何线对象
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50));
         * points.push(new SuperMap.Geometry.Point(2,60));
         *
         * var bezier = SuperMap.Geometry.LineString.createBezier2(points, 20);
         */

    }, {
        key: 'createBezier2',
        value: function createBezier2(points, part) {

            var bezierPts = LineString.calculatePointsFBZ2(points, part);
            return new LineString(bezierPts);
        }

        /**
         * @function SuperMap.Geometry.LineString.createBezier3
         * @description 创建3次贝塞尔曲线。
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。(必须为四个点)
         * @param precision -{number} 拆分精度，表示贝塞尔曲线上任意两点间横向或纵向的最大距离。
         *                     决
         * @returns {SuperMap.Geometry.LineString} 几何线对象
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50));
         * points.push(new SuperMap.Geometry.Point(2,60));
         * points.push(new SuperMap.Geometry.Point(8,20));
         *
         * var bezier = SuperMap.Geometry.LineString.createBezier3(points, 20);
         */

    }, {
        key: 'createBezier3',
        value: function createBezier3(points, part) {

            var bezierPts = LineString.calculatePointsFBZ3(points, part);
            return new LineString(bezierPts);
        }

        /**
         * @function SuperMap.Geometry.LineString.createBezier
         * @description 创建3次贝塞尔曲线。
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @param precision -{number} 拆分精度，表示贝塞尔曲线上任意两点间横向或纵向的最大距离。
         *                     决定贝塞尔曲线的平滑程度。取值越小曲线越平滑。取值为大于1的整数。
         * @returns {SuperMap.Geometry.LineString} 几何线对象
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50));
         * points.push(new SuperMap.Geometry.Point(2,60));
         * points.push(new SuperMap.Geometry.Point(8,20));
         *
         * var bezier = SuperMap.Geometry.LineString.createBezier(points,1);
         */

    }, {
        key: 'createBezier',
        value: function createBezier(points, precision) {
            //获取待拆分的点
            var bezierPts = [];
            for (var m = 0; m < points.length; m++) {
                bezierPts[m] = points[m];
            }
            //获取输入点的数量
            var i,
                k,
                j = 0,
                bExit,
                count = bezierPts.length;
            var ptBuffer = [];
            while (true) {
                bExit = true;
                //贝塞尔分解是按4个点为一组进行的，所以小于4个点就再不进行分解
                for (i = 0; i < count - 3; i += 3) {
                    //对输入点数组进行分解
                    //判断bezierPts[i]到bezierPts[i+4]是否达到精度
                    if (GetBezierGap(bezierPts, i) > precision) {
                        bExit = false;
                        //对未达到精度的bezierPts[i]到bezierPts[i+4]进行计算，得到新的ptBuffer点数组
                        InciseBezier(bezierPts, i, ptBuffer);
                        //去除已使用过的2个控制点
                        bezierPts.splice(i + 1, 2);
                        //将本次计算得到的5个新的点插入到bezierPts[i]位置之后，得到新的bezierPts点数组
                        for (k = 0; k < 5; k++) {
                            bezierPts.splice(i + 1 + k, 0, ptBuffer[k + 1]);
                        }
                        //bezierPts[i]到bezierPts[i+4]没有达到精度，所以不能跳过，i需回归初始
                        i -= 3;
                        count = bezierPts.length;
                    }
                    if (bExit) break;
                }
                //对分解得出的新bezierPts点数组进行优化，除去相同的点
                while (j < count - 1) {
                    if (bezierPts[j] === bezierPts[j + 1]) {
                        bezierPts.splice(j + 1, 1);
                        count--;
                    }
                    j++;
                }
                //返回分解完成的新的bezierPts点数组
                return new LineString(bezierPts);
            }
        }

        /**
         * @function SuperMap.Geometry.LineString.createBezierN
         * @description 创建N次贝塞尔曲线。
         * 创建N次贝塞尔曲线需要N+1个点,也就是传入 points ，得到的是points.length-1次贝塞尔曲线
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @param part -{number} 平滑度。取值越大，曲线越平滑。取值为大于1的整数，默认为20。
         * @returns {SuperMap.Geometry.LineString} 几何线对象
         * @example
         * //创建3次贝塞尔曲线
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50));
         * points.push(new SuperMap.Geometry.Point(2,60));
         * points.push(new SuperMap.Geometry.Point(8,20));
         *
         * var bezier = SuperMap.Geometry.LineString.createBezierN(points, 20);
         * //创建4次贝塞尔曲线
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50));
         * points.push(new SuperMap.Geometry.Point(2,60));
         * points.push(new SuperMap.Geometry.Point(8,20));
         * points.push(new SuperMap.Geometry.Point(50,20));
         *
         * var bezier = SuperMap.Geometry.LineString.createBezierN(points, 30);
         * ......
         */

    }, {
        key: 'createBezierN',
        value: function createBezierN(points, part) {
            var bezierPts = LineString.calculatePointsFBZN(points, part);
            return new LineString(bezierPts);
        }

        /**
         * @function SuperMap.Geometry.LineString.BEZ
         * @description 基函数
         * @param n -{number}
         * @param k -{number}
         * @param t -{number} 0-1之间的一个数，
         * @returns {number} 基函数的值
         *
         */

    }, {
        key: 'BEZ',
        value: function BEZ(n, k, t) {
            return LineString.combSort(n, k) * Math.pow(t, k) * Math.pow(1 - t, n - k);
        }

        /**
         * @function SuperMap.Geometry.LineString.combSort
         * @description 组合排序,计算从1*2*...*n/(1*2*...*k*1*2*...*(n-k))的值
         * @param n -{number} 贝塞尔曲线的次数n
         * @param k -{number} 小于N的一个数k
         * @returns {number} 组合排序的值
         *
         */

    }, {
        key: 'combSort',
        value: function combSort(n, k) {
            var son = LineString.factorial(n);
            var mother = LineString.factorial(k) * LineString.factorial(n - k);
            return son / mother;
        }

        /**
         * @function SuperMap.Geometry.LineString.factorial
         * @description 阶乘,计算从1*2*3*4*...*n的值
         * @param n -{number}
         * @returns {number} 阶乘的值
         *
         */

    }, {
        key: 'factorial',
        value: function factorial(n) {
            var result = 1;
            for (var i = 1; i <= n; i++) {
                result *= i;
            }
            return result;
        }

        /**
         * @function SuperMap.Geometry.LineString.calculateCardinalPoints
         * @description 创建Cardinal控制点。
         * 利用输入的点数组计算出相应的Cardinal控制点，再使用贝塞尔曲线3创建经过所有Cardinal控制点的圆滑曲线。
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @returns {Array<SuperMap.Geometry.Point>} 计算出相应的Cardinal控制点。
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50));
         * points.push(new SuperMap.Geometry.Point(2,60));
         * points.push(new SuperMap.Geometry.Point(8,20));
         *
         * var cardinal = SuperMap.Geometry.LineString.createCloseCardinal(points);
         */

    }, {
        key: 'calculateCardinalPoints',
        value: function calculateCardinalPoints(points) {
            if (points == null || points.length < 3) {
                return points;
            }
            //定义传入的点数组，将在点数组中央（每两个点）插入两个控制点
            var cPoints = points;
            //包含输入点和控制点的数组
            var cardinalPoints = [];

            //这些都是相关资料测出的经验数值
            //定义张力系数，取值在0<t<0.5
            var t = 0.4;
            //为端点张力系数因子，取值在0<b<1
            var b = 0.5;
            //误差控制，是一个大于等于0的数，用于三点非常趋近与一条直线时，减少计算量
            var e = 0.005;

            //传入的点数量，至少有三个，n至少为2
            var n = cPoints.length - 1;
            //从开始遍历到倒数第二个，其中倒数第二个用于计算起点（终点）的插值控制点

            for (var k = 0; k <= n + 1 - 3; k++) {
                //三个基础输入点
                var p0 = cPoints[k];
                var p1 = cPoints[k + 1];
                var p2 = cPoints[k + 2];
                //定义p1的左控制点和右控制点
                var p1l = new _Point2.default();
                var p1r = new _Point2.default();
                //通过p0、p1、p2计算p1点的做控制点p1l和又控制点p1r
                //计算向量p0_p1和p1_p2
                var p0_p1 = new _Point2.default(p1.x - p0.x, p1.y - p0.y);
                var p1_p2 = new _Point2.default(p2.x - p1.x, p2.y - p1.y);
                //并计算模
                var d01 = Math.sqrt(p0_p1.x * p0_p1.x + p0_p1.y * p0_p1.y);
                var d12 = Math.sqrt(p1_p2.x * p1_p2.x + p1_p2.y * p1_p2.y);
                //向量单位化
                var p0_p1_1 = new _Point2.default(p0_p1.x / d01, p0_p1.y / d01);
                var p1_p2_1 = new _Point2.default(p1_p2.x / d12, p1_p2.y / d12);
                //计算向量p0_p1和p1_p2的夹角平分线向量
                var p0_p1_p2 = new _Point2.default(p0_p1_1.x + p1_p2_1.x, p0_p1_1.y + p1_p2_1.y);
                //计算向量 p0_p1_p2 的模
                var d012 = Math.sqrt(p0_p1_p2.x * p0_p1_p2.x + p0_p1_p2.y * p0_p1_p2.y);
                //单位化向量p0_p1_p2
                var p0_p1_p2_1 = new _Point2.default(p0_p1_p2.x / d012, p0_p1_p2.y / d012);
                //判断p0、p1、p2是否共线，这里判定向量p0_p1和p1_p2的夹角的余弦和1的差值小于e就认为三点共线
                var cosE_p0p1p2 = (p0_p1_1.x * p1_p2_1.x + p0_p1_1.y * p1_p2_1.y) / 1;
                //共线
                if (Math.abs(1 - cosE_p0p1p2) < e) {
                    //计算p1l的坐标
                    p1l.x = p1.x - p1_p2_1.x * d01 * t;
                    p1l.y = p1.y - p1_p2_1.y * d01 * t;
                    //计算p1r的坐标
                    p1r.x = p1.x + p0_p1_1.x * d12 * t;
                    p1r.y = p1.y + p0_p1_1.y * d12 * t;
                }
                //非共线
                else {
                        //计算p1l的坐标
                        p1l.x = p1.x - p0_p1_p2_1.x * d01 * t;
                        p1l.y = p1.y - p0_p1_p2_1.y * d01 * t;
                        //计算p1r的坐标
                        p1r.x = p1.x + p0_p1_p2_1.x * d12 * t;
                        p1r.y = p1.y + p0_p1_p2_1.y * d12 * t;
                    }
                //记录下这三个控制点
                cardinalPoints[k * 3 + 2 + 0] = p1l;
                cardinalPoints[k * 3 + 2 + 1] = p1;
                cardinalPoints[k * 3 + 2 + 2] = p1r;

                //当为起始点时需要计算第一个点的右控制点
                if (k == 0) {
                    //定义p0的右控制点
                    var p0r = new _Point2.default();

                    //计算向量p0_p1l
                    var po_p1l = new _Point2.default(p1l.x - p0.x, p1l.y - p0.y);
                    //计算模
                    var d01l = Math.sqrt(po_p1l.x * po_p1l.x + po_p1l.y * po_p1l.y);
                    //单位化
                    var po_p1l_1 = new _Point2.default(po_p1l.x / d01l, po_p1l.y / d01l);
                    //计算p0r
                    p0r.x = p0.x + po_p1l_1.x * d01 * t * b;
                    p0r.y = p0.y + po_p1l_1.y * d01 * t * b;

                    cardinalPoints[k * 3 + 0] = p0;
                    cardinalPoints[k * 3 + 1] = p0r;
                }
                //当为倒数第三个点时需要计算最后点的左控制点
                if (k == n + 1 - 3) {
                    //定义 p2的做控制点p2l
                    var p2l = new _Point2.default();

                    //计算向量p2_p1r
                    var p2_p1r = new _Point2.default(p1r.x - p2.x, p1r.y - p2.y);
                    //并取模
                    var d21r = Math.sqrt(p2_p1r.x * p2_p1r.x + p2_p1r.y * p2_p1r.y);
                    //单位化
                    var p2_p1r_1 = new _Point2.default(p2_p1r.x / d21r, p2_p1r.y / d21r);
                    //计算p2l
                    p2l.x = p2.x + p2_p1r_1.x * d12 * t * b;
                    p2l.y = p2.y + p2_p1r_1.y * d12 * t * b;

                    cardinalPoints[k * 3 + 2 + 3] = p2l;
                    cardinalPoints[k * 3 + 2 + 4] = p2;
                }
            }
            return cardinalPoints;
        }

        /**
         * @function SuperMap.Geometry.LineString.createCloseCardinal
         * @description 创建闭合Cardinal的控制点。
         * 利用输入的点数组计算出相应的Cardinal控制点，再使用贝塞尔曲线3创建经过所有Cardinal控制点的圆滑闭合曲线。
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @returns {Array<SuperMap.Geometry.Point>} 计算出相应的Cardinal控制点。
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50));
         * points.push(new SuperMap.Geometry.Point(2,60));
         * points.push(new SuperMap.Geometry.Point(8,20));
         *
         * var cardinal = SuperMap.Geometry.LineString.createCloseCardinal(points);
         */

    }, {
        key: 'createCloseCardinal',
        value: function createCloseCardinal(points) {
            if (points == null || points.length < 3) {
                return points;
            }
            //获取起点，作为终点，以闭合曲线。
            var lastP = points[0];
            points.push(lastP);

            //定义传入的点数组，将在点数组中央（每两个点）插入两个控制点
            var cPoints = points;
            //包含输入点和控制点的数组
            var cardinalPoints = [];

            //至少三个点以上
            //这些都是相关资料测出的经验数值
            //定义张力系数，取值在0<t<0.5
            var t = 0.4;
            //为端点张力系数因子，取值在0<b<1
            var b = 0.5;
            //误差控制，是一个大于等于0的数，用于三点非常趋近与一条直线时，减少计算量
            var e = 0.005;

            //传入的点数量，至少有三个，n至少为2
            var n = cPoints.length - 1;
            //从开始遍历到倒数第二个，其中倒数第二个用于计算起点（终点）的插值控制点
            for (var k = 0; k <= n - 1; k++) {
                //计算起点（终点）的左右控制点
                if (k == n - 1) {
                    //三个基础输入点
                    var p0 = cPoints[n - 1];
                    var p1 = cPoints[0];
                    var p2 = cPoints[1];
                } else {
                    var p0 = cPoints[k];
                    var p1 = cPoints[k + 1];
                    var p2 = cPoints[k + 2];
                }

                //定义p1的左控制点和右控制点
                var p1l = new _Point2.default();
                var p1r = new _Point2.default();
                //通过p0、p1、p2计算p1点的做控制点p1l和又控制点p1r
                //计算向量p0_p1和p1_p2
                var p0_p1 = new _Point2.default(p1.x - p0.x, p1.y - p0.y);
                var p1_p2 = new _Point2.default(p2.x - p1.x, p2.y - p1.y);
                //并计算模
                var d01 = Math.sqrt(p0_p1.x * p0_p1.x + p0_p1.y * p0_p1.y);
                var d12 = Math.sqrt(p1_p2.x * p1_p2.x + p1_p2.y * p1_p2.y);
                //向量单位化
                var p0_p1_1 = new _Point2.default(p0_p1.x / d01, p0_p1.y / d01);
                var p1_p2_1 = new _Point2.default(p1_p2.x / d12, p1_p2.y / d12);
                //计算向量p0_p1和p1_p2的夹角平分线向量
                var p0_p1_p2 = new _Point2.default(p0_p1_1.x + p1_p2_1.x, p0_p1_1.y + p1_p2_1.y);
                //计算向量 p0_p1_p2 的模
                var d012 = Math.sqrt(p0_p1_p2.x * p0_p1_p2.x + p0_p1_p2.y * p0_p1_p2.y);
                //单位化向量p0_p1_p2
                var p0_p1_p2_1 = new _Point2.default(p0_p1_p2.x / d012, p0_p1_p2.y / d012);
                //判断p0、p1、p2是否共线，这里判定向量p0_p1和p1_p2的夹角的余弦和1的差值小于e就认为三点共线
                var cosE_p0p1p2 = (p0_p1_1.x * p1_p2_1.x + p0_p1_1.y * p1_p2_1.y) / 1;
                //共线
                if (Math.abs(1 - cosE_p0p1p2) < e) {
                    //计算p1l的坐标
                    p1l.x = p1.x - p1_p2_1.x * d01 * t;
                    p1l.y = p1.y - p1_p2_1.y * d01 * t;
                    //计算p1r的坐标
                    p1r.x = p1.x + p0_p1_1.x * d12 * t;
                    p1r.y = p1.y + p0_p1_1.y * d12 * t;
                }
                //非共线
                else {
                        //计算p1l的坐标
                        p1l.x = p1.x - p0_p1_p2_1.x * d01 * t;
                        p1l.y = p1.y - p0_p1_p2_1.y * d01 * t;
                        //计算p1r的坐标
                        p1r.x = p1.x + p0_p1_p2_1.x * d12 * t;
                        p1r.y = p1.y + p0_p1_p2_1.y * d12 * t;
                    }

                //记录起点（终点）的左右插值控制点及倒数第二个控制点
                if (k == n - 1) {
                    cardinalPoints[0] = p1;
                    cardinalPoints[1] = p1r;
                    cardinalPoints[(n - 2) * 3 + 2 + 3] = p1l;
                    cardinalPoints[(n - 2) * 3 + 2 + 4] = cPoints[n];
                } else {
                    //记录下这三个控制点
                    cardinalPoints[k * 3 + 2 + 0] = p1l;
                    cardinalPoints[k * 3 + 2 + 1] = p1;
                    cardinalPoints[k * 3 + 2 + 2] = p1r;
                }
            }
            return cardinalPoints;
        }

        /**
         * @function SuperMap.Geometry.LineString.calculateCircle
         * @description 三点画圆弧
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @returns {Array<SuperMap.Geometry.Point>} 计算出相应的圆弧控制点。
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50));
         * points.push(new SuperMap.Geometry.Point(2,60));
         *
         * var circle = SuperMap.Geometry.LineString.calculateCircle(points);
         */

    }, {
        key: 'calculateCircle',
        value: function calculateCircle(points) {
            if (points.length < 3) {
                return points;
            }
            var len = points.length,
                centerPoint = {},
                p1 = points[0],
                p2 = points[1],
                p3 = points[2];
            var R = 0,
                dStep = 0,
                direc = true,
                dRotation = 0,
                dRotationBegin = 0,
                dRotationAngle = 0,
                nSegmentCount = 72,
                centerPoint = {},
                circlePoints = [];

            var KTan13 = (p3.y - p1.y) / (p3.x - p1.x);
            var B13 = p3.y - KTan13 * p3.x;
            if (p3.x != p1.x && p3.y != p1.y && p2.y == KTan13 * p2.x + B13 || p3.x == p1.x && p2.x == p1.x || p3.y == p1.y && p2.y == p1.y || p3.x == p1.x && p3.y == p1.y || p3.x == p2.x && p3.y == p2.y || p1.x == p2.x && p1.y == p2.y) {
                circlePoints.push(p1);
                circlePoints.push(p2);
                circlePoints.push(p3);
            } else {
                var D = (p2.x * p2.x + p2.y * p2.y - (p1.x * p1.x + p1.y * p1.y)) * (2 * (p3.y - p1.y)) - (p3.x * p3.x + p3.y * p3.y - (p1.x * p1.x + p1.y * p1.y)) * (2 * (p2.y - p1.y));
                var E = 2 * (p2.x - p1.x) * (p3.x * p3.x + p3.y * p3.y - (p1.x * p1.x + p1.y * p1.y)) - 2 * (p3.x - p1.x) * (p2.x * p2.x + p2.y * p2.y - (p1.x * p1.x + p1.y * p1.y));
                var F = 4 * ((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y));
                centerPoint.x = D / F;
                centerPoint.y = E / F;
                R = Math.sqrt((p1.x - centerPoint.x) * (p1.x - centerPoint.x) + (p1.y - centerPoint.y) * (p1.y - centerPoint.y));

                var dis = (p1.x - p3.x) * (p1.x - p3.x) + (p1.y - p3.y) * (p1.y - p3.y);
                var cons = (2 * R * R - dis) / (2 * R * R);
                cons = cons >= 1 ? 1 : cons;
                cons = cons <= -1 ? -1 : cons;
                dRotationAngle = Math.acos(cons) * 180 / Math.PI;

                if (p3.x == p1.x) {
                    dRotationAngle = centerPoint.x > p1.x && p2.x > p1.x || centerPoint.x < p1.x && p2.x < p1.x ? 360 - dRotationAngle : dRotationAngle;
                } else {
                    dRotationAngle = centerPoint.y > KTan13 * centerPoint.x + B13 && p2.y > KTan13 * p2.x + B13 || centerPoint.y < KTan13 * centerPoint.x + B13 && p2.y < KTan13 * p2.x + B13 ? 360 - dRotationAngle : dRotationAngle;
                }
                dStep = dRotationAngle / 72;

                if (p3.y != p1.y) {
                    if (p3.x == p1.x) {
                        if (p3.y > p1.y) {
                            if (p2.x < p1.x) {
                                direc = false;
                            }
                        } else {
                            if (p2.x > p1.x) {
                                direc = false;
                            }
                        }
                    } else if (p3.x < p1.x) {
                        if (p2.y < KTan13 * p2.x + B13) {
                            direc = false;
                        }
                    } else {
                        if (p2.y > KTan13 * p2.x + B13) {
                            direc = false;
                        }
                    }
                } else {
                    if (p3.x > p1.x) {
                        if (p2.y > p1.y) {
                            direc = false;
                        }
                    } else {
                        if (p2.y < p1.y) {
                            direc = false;
                        }
                    }
                }

                var K10 = (p1.y - centerPoint.y) / (p1.x - centerPoint.x);
                var atan10 = K10 >= 0 ? Math.atan(K10) * 180 / Math.PI : Math.abs(Math.atan(K10) * 180 / Math.PI) + 90;

                var CY = Math.abs(centerPoint.y);
                if (p1.y == CY && CY == p3.y) {
                    if (p1.x < p3.x) {
                        atan10 = atan10 + 180;
                    }
                }

                var newPY = p1.y - centerPoint.y;
                circlePoints.push(p1);
                for (var i = 1; i < nSegmentCount; i++) {
                    dRotation = dStep * i;
                    dRotationBegin = atan10;

                    if (direc) {
                        if (newPY >= 0) {
                            if (K10 >= 0) {
                                dRotationBegin = dRotationBegin + dRotation;
                            } else {
                                dRotationBegin = 180 - (dRotationBegin - 90) + dRotation;
                            }
                        } else {
                            if (K10 > 0) {
                                dRotationBegin = dRotationBegin - 180 + dRotation;
                            } else {
                                dRotationBegin = 90 - dRotationBegin + dRotation;
                            }
                        }
                    } else {
                        if (newPY >= 0) {
                            if (K10 >= 0) {
                                dRotationBegin = dRotationBegin - dRotation;
                            } else {
                                dRotationBegin = 180 - (dRotationBegin - 90) - dRotation;
                            }
                        } else {
                            if (K10 >= 0) {
                                dRotationBegin = dRotationBegin - 180 - dRotation;
                            } else {
                                dRotationBegin = 90 - dRotationBegin - dRotation;
                            }
                        }
                    }

                    dRotationBegin = dRotationBegin * Math.PI / 180;
                    var x = centerPoint.x + R * Math.cos(dRotationBegin);
                    var y = centerPoint.y + R * Math.sin(dRotationBegin);
                    circlePoints.push(new _Point2.default(x, y));
                }
                circlePoints.push(p3);
            }
            return circlePoints;
        }

        /**
         * @function SuperMap.Geometry.LineString.createLineEPS
         * @description 根据点的类型画出不同类型的曲线
         * 点的类型有三种, LTypeArc, LTypeCurve, NONE
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @returns {Array<SuperMap.Geometry.Point>} 计算出相应的lineEPS控制点。
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-50,30));
         * points.push(new SuperMap.Geometry.Point(-30,50,"LTypeArc"));
         * points.push(new SuperMap.Geometry.Point(2,60));
         * points.push(new SuperMap.Geometry.Point(8,20));
         *
         * var lineEPS = SuperMap.Geometry.LineString.createLineEPS(points);
         */

    }, {
        key: 'createLineEPS',
        value: function createLineEPS(points) {
            var list = [],
                part = 0,
                len = points.length;
            if (points == null || len < 2) {
                return points;
            }
            for (var i = 0; i < len;) {
                var type = points[i].type;
                if (type == 'LTypeArc') {
                    var listObj = LineString.createLineArc(list, i, len, points);
                    list = listObj[0];
                    i = listObj[1];
                } else {
                    list.push(points[i]);
                    i++;
                }
            }
            return list;
        }
    }, {
        key: 'createLineArc',
        value: function createLineArc(list, i, len, points) {
            if (i == 0) {
                var bezierPtsObj = LineString.addPointEPS(points, i, len, 'LTypeArc');
                Array.prototype.push.apply(list, bezierPtsObj[0]);
                i = bezierPtsObj[1] + 1;
            } else if (i == len - 1) {
                var bezierP = [points[i - 1], points[i]],
                    bezierPts = LineString.calculateCircle(bezierP);
                Array.prototype.push.apply(list, bezierPts);
                i++;
            } else {
                var bezierPtsObj = LineString.addPointEPS(points, i, len, 'LTypeArc');
                list.pop();
                Array.prototype.push.apply(list, bezierPtsObj[0]);
                i = bezierPtsObj[1] + 1;
            }
            return [list, i];
        }
    }, {
        key: 'createLineCurve',
        value: function createLineCurve(list, i, len, points) {
            if (i == 0) {
                var bezierPtsObj = LineString.addPointEPS(points, i, len, 'LTypeCurve');
                Array.prototype.push.apply(list, bezierPtsObj[0]);
                i = bezierPtsObj[1] + 1;
            } else if (i == len - 1) {
                var bezierP = [points[i - 1], points[i]],
                    bezierPts = LineString.calculatePointsFBZN(bezierP);
                Array.prototype.push.apply(list, bezierPts);
                i++;
            } else {
                var bezierPtsObj = LineString.addPointEPS(points, i, len, 'LTypeCurve');
                list.pop();
                Array.prototype.push.apply(list, bezierPtsObj[0]);
                i = bezierPtsObj[1] + 1;
            }
            return [list, i];
        }
    }, {
        key: 'addPointEPS',
        value: function addPointEPS(points, i, len, type) {
            var bezierP = [],
                j = i + 1;
            if (i == 0) {
                Array.prototype.push.apply(bezierP, [points[i], points[i + 1]]);
            } else if (i == len - 1) {
                Array.prototype.push.apply(bezierP, [points[i - 1], points[i]]);
            } else {
                Array.prototype.push.apply(bezierP, [points[i - 1], points[i], points[i + 1]]);
            }
            if (type == 'LTypeCurve') {
                var bezierPts = LineString.calculatePointsFBZN(bezierP);
            } else if (type == 'LTypeArc') {
                var bezierPts = LineString.calculateCircle(bezierP);
            }
            return [bezierPts, j];
        }
    }]);

    return LineString;
}(_Curve3.default);

exports.default = LineString;


_SuperMap2.default.Geometry.LineString = LineString;

/**
 * @private
 * @function InciseBezier
 * 拆分贝赛尔曲线单元
 *
 * pSrcPt -{Array<SuperMap.Geometry.Point>} 传入的待拆分点数组。
 * j - {number} 本次拆分的首点位置，从pSrcPt[j]（包括此点）点向后取4个点进行本次拆分。
 * pDstPt -{Array<SuperMap.Geometry.Point>} 将4个点拆分成7个点，pDstPt是包含此7个点的结果点数组。
 */
function InciseBezier(pSrcPt, j, pDstPt) {
    var buffer = [];
    buffer[0] = [];
    buffer[1] = [];
    buffer[2] = [];
    var i;
    for (i = 0; i < 3; i++) {
        buffer[0][i] = new _Point2.default();
        buffer[0][i].x = (pSrcPt[j + i].x + pSrcPt[j + i + 1].x) / 2;
        buffer[0][i].y = (pSrcPt[j + i].y + pSrcPt[j + i + 1].y) / 2;
    }
    for (i = 0; i < 2; i++) {
        buffer[1][i] = new _Point2.default();
        buffer[1][i].x = (buffer[0][i].x + buffer[0][i + 1].x) / 2;
        buffer[1][i].y = (buffer[0][i].y + buffer[0][i + 1].y) / 2;
    }

    buffer[2][0] = new _Point2.default();
    buffer[2][0].x = (buffer[1][0].x + buffer[1][1].x) / 2;
    buffer[2][0].y = (buffer[1][0].y + buffer[1][1].y) / 2;
    //将输入的四个点拆分成7个点
    pDstPt[0] = pSrcPt[j];
    pDstPt[1] = buffer[0][0];
    pDstPt[2] = buffer[1][0];
    pDstPt[3] = buffer[2][0];
    pDstPt[4] = buffer[1][1];
    pDstPt[5] = buffer[0][2];
    pDstPt[6] = pSrcPt[j + 3];
    return true;
}

/**
 * @private
 * @function GetBezierGap
 * 计算贝赛尔曲线两个顶点的纵向和横向的最大距离，结果用来判断是否达到拆分精度
 *
 * pSrcPt -{Array<SuperMap.Geometry.Point>} 传入的待拆分点数组。
 * j - {number} 本次拆分的首点位置，从pSrcPt[j]（包括此点）点向后取4个点进行距离计算
 */
function GetBezierGap(pSrcPt, j) {
    var gap = 0;
    for (var i = 1; i < 4; i++) {
        if (Math.abs(pSrcPt[j + i].x - pSrcPt[j + i - 1].x) > gap) gap = Math.abs(pSrcPt[j + i].x - pSrcPt[j + i - 1].x);
        if (Math.abs(pSrcPt[j + i].y - pSrcPt[j + i - 1].y) > gap) gap = Math.abs(pSrcPt[j + i].y - pSrcPt[j + i - 1].y);
    }
    return gap;
}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.DataReturnOption
 * @classdesc 数据返回设置类
 */
var DataReturnOption = function () {

    /**
     * @member SuperMap.DataReturnOption.prototype.dataReturnMode -{SuperMap.DataReturnMode}
     * @description 数据返回模式，默认为SuperMap.DataReturnMode.RECORDSET_ONLY。
     */


    /**
     * @member SuperMap.DataReturnOption.prototype.expectCount -{number}
     * @description 设置返回的最大记录数，小于或者等于0时表示返回所有记录数。
     */
    function DataReturnOption(options) {
        _classCallCheck(this, DataReturnOption);

        this.expectCount = 1000;
        this.dataset = null;
        this.dataReturnMode = _REST.DataReturnMode.RECORDSET_ONLY;
        this.deleteExistResultDataset = true;
        this.CLASS_NAME = "SuperMap.DataReturnOption";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.DataReturnOption.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.DataReturnOption.prototype.deleteExistResultDataset -{boolean}
     * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
     */


    /**
     * @member SuperMap.DataReturnOption.prototype.dataset -{string}
     * @description 设置结果数据集标识，当dataReturnMode为 SuperMap.DataReturnMode.DATASET_ONLY
     * 或SuperMap.DataReturnMode.DATASET_AND_RECORDSET时有效，
     * 作为返回数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
     */


    _createClass(DataReturnOption, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.expectCount = null;
            me.dataset = null;
            me.dataReturnMode = null;
            me.deleteExistResultDataset = null;
        }
    }]);

    return DataReturnOption;
}();

exports.default = DataReturnOption;


_SuperMap2.default.DataReturnOption = DataReturnOption;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FacilityAnalyst3DParameters
 * @classdesc 最近设施分析参数基类。<br>
 *               最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。<br>
 *               设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。<br>
 *               例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。<br>
 *               最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
 * @param options - {Object} 可选参数。如：<br>
 *        edgeID - {number}指定的弧段ID。<br>
 *        nodeID - {Integer} 指定的结点ID。<br>
 *        weightName -{string} 指定的权值字段信息对象的名称。<br>
 *        isUncertainDirectionValid -{boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；<br>
 *                                             指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 */
var FacilityAnalyst3DParameters = function () {

    /**
     * @member SuperMap.FacilityAnalyst3DParameters.prototype.weightName -{string}
     * @description 指定的权值字段信息对象的名称
     */


    /**
     * @member SuperMap.FacilityAnalyst3DParameters.prototype.edgeID -{number}
     * @description 指定的弧段ID
     */
    function FacilityAnalyst3DParameters(options) {
        _classCallCheck(this, FacilityAnalyst3DParameters);

        this.edgeID = null;
        this.nodeID = null;
        this.weightName = null;
        this.isUncertainDirectionValid = false;
        this.CLASS_NAME = "SuperMap.FacilityAnalyst3DParameters";

        var me = this;
        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(me, options);
    }

    /**
     * @function SuperMap.FacilityAnalyst3DParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.FacilityAnalyst3DParameters.prototype.isUncertainDirectionValid -{boolean}:
     * @description 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；<br>
     *                指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找
     */


    /**
     * @member SuperMap.FacilityAnalyst3DParameters.prototype.nodeID -{number}
     * @description 指定的结点ID
     */


    _createClass(FacilityAnalyst3DParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.edgeID = null;
            me.nodeID = null;
            me.weightName = null;
            me.isUncertainDirectionValid = null;
        }
    }]);

    return FacilityAnalyst3DParameters;
}();

exports.default = FacilityAnalyst3DParameters;

_SuperMap2.default.FacilityAnalyst3DParameters = FacilityAnalyst3DParameters;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GetFeaturesParametersBase
 * @classdesc 要素查询参数基类
 * @param options - {Object} 参数。如：<br>
 *        datasetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {SuperMap.FilterParameter} 是否直接返回查询结果。</br>
 *        fromIndex - {Integer} 查询结果的最小索引号。</br>
 *        toIndex - {Integer} 查询结果的最大索引号。</br>
 */
var GetFeaturesParametersBase = function () {

    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.returnCountOnly -{boolean}
     * @description 只返回查询结果的总数，默认为false。
     */


    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.fromIndex -{Integer}
     * @description 查询结果的最小索引号。默认值是0，如果该值大于查询结果的最大索引号，则查询结果为空。
     */


    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.datasetName -{Array<string>}
     * @description 数据集集合中的数据集名称列表。
     */
    function GetFeaturesParametersBase(options) {
        _classCallCheck(this, GetFeaturesParametersBase);

        this.datasetNames = null;
        this.returnContent = true;
        this.fromIndex = 0;
        this.toIndex = 19;
        this.returnCountOnly = false;
        this.maxFeatures = null;
        this.CLASS_NAME = "SuperMap.GetFeaturesParametersBase";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     *
     * @function SuperMap.GetFeaturesParametersBase.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.maxFeatures -{Integer}
     * @description 进行SQL查询时，用于设置服务端返回查询结果条目数量，默认为1000。
     */


    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.toIndex -{Integer}
     * @description 查询结果的最大索引号。默认值是19，如果该值大于查询结果的最大索引号，则以查询结果的最大索引号为终止索引号。
     */


    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.returnContent -{boolean}
     * @description 是否立即返回新创建资源的表述还是返回新资源的URI。
     *              如果为 true，则直接返回新创建资源，即查询结果的表述。
     *              如果为 false，则返回的是查询结果资源的 URI。默认为 true。
     */


    _createClass(GetFeaturesParametersBase, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.datasetNames = null;
            me.returnContent = null;
            me.fromIndex = null;
            me.toIndex = null;
            me.maxFeatures = null;
        }
    }]);

    return GetFeaturesParametersBase;
}();

exports.default = GetFeaturesParametersBase;


_SuperMap2.default.GetFeaturesParametersBase = GetFeaturesParametersBase;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesServiceBase
 * @classdesc 数据服务中数据集查询服务基类。
 * 获取结果数据类型为Object。包含 result属性，result的数据格式根据format参数决定为GeoJSON或者iServerJSON
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务，
 * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/</br>
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param options - {Object} 可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @example
 * (start code)
 * var myService = new SuperMap.GetFeaturesServiceBase(url, {
 *     eventListeners: {
 *         "processCompleted": getFeatureCompleted,
 *         "processFailed": getFeatureError
 *     }
 * });
 * (end)
 */
var GetFeaturesServiceBase = function (_CommonServiceBase) {
    _inherits(GetFeaturesServiceBase, _CommonServiceBase);

    /**
     * @member SuperMap.GetFeaturesServiceBase.prototype.maxFeatures -{Integer}
     * @description 进行SQL查询时，用于设置服务端返回查询结果条目数量，默认为1000。
     */


    /**
     * @member SuperMap.GetFeaturesServiceBase.prototype.fromIndex - {Integer}
     * @description 查询结果的最小索引号。
     * 默认值是0，如果该值大于查询结果的最大索引号，则查询结果为空。
     */
    function GetFeaturesServiceBase(url, options) {
        _classCallCheck(this, GetFeaturesServiceBase);

        var _this = _possibleConstructorReturn(this, (GetFeaturesServiceBase.__proto__ || Object.getPrototypeOf(GetFeaturesServiceBase)).call(this, url, options));

        _this.returnContent = true;
        _this.fromIndex = 0;
        _this.toIndex = 19;
        _this.maxFeatures = null;
        _this.format = _REST.DataFormat.GEOJSON;
        _this.CLASS_NAME = "SuperMap.GetFeaturesServiceBase";

        options = options || {};
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        var me = _this,
            end;
        if (options && options.format) {
            me.format = options.format.toUpperCase();
        }

        end = me.url.substr(me.url.length - 1, 1);
        // TODO 待iServer featureResul资源GeoJSON表述bug修复当使用以下注释掉的逻辑
        // if (me.format==="geojson" ) {
        //     me.url += (end == "/") ? "featureResults.geojson?" : "/featureResults.geojson?";
        // } else {
        //     me.url += (end == "/") ? "featureResults.json?" : "/featureResults.json?";
        // }
        me.url += end == "/" ? "featureResults.json?" : "/featureResults.json?";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesServiceBase.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.GetFeaturesServiceBase.prototype.format -{string}
     * @description 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
     *  参数格式为"ISERVER","GEOJSON",GEOJSON
     */


    /**
     * @member SuperMap.GetFeaturesServiceBase.prototype.toIndex - {Integer}
     * @description 查询结果的最大索引号。
     * 如果该值大于查询结果的最大索引号，则以查询结果的最大索引号为终止索引号。
     */

    /**
     * @member SuperMap.GetFeaturesServiceBase.prototype.returnContent - {boolean}
     * @description 是否立即返回新创建资源的表述还是返回新资源的URI。
     *如果为 true，则直接返回新创建资源，即查询结果的表述。
     *如果为 false，则返回的是查询结果资源的 URI。默认为 false。
     */


    _createClass(GetFeaturesServiceBase, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesServiceBase.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesServiceBase.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
            me.fromIndex = null;
            me.toIndex = null;
            me.maxFeatures = null;
            me.format = null;
        }

        /**
         * @function SuperMap.GetFeaturesServiceBase.prototype.processAsync
         * @description  负责将客户端的查询参数传递到服务端。
         * @param params - {GetFeaturesParametersBase} 查询参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonParameters = null,
                firstPara = true;

            me.returnContent = params.returnContent;
            me.fromIndex = params.fromIndex;
            me.toIndex = params.toIndex;
            me.maxFeatures = params.maxFeatures;
            if (me.returnContent) {
                me.url += "returnContent=" + me.returnContent;
                firstPara = false;
            }
            var isValidNumber = me.fromIndex != null && me.toIndex != null && !isNaN(me.fromIndex) && !isNaN(me.toIndex);
            if (isValidNumber && me.fromIndex >= 0 && me.toIndex >= 0 && !firstPara) {
                me.url += "&fromIndex=" + me.fromIndex + "&toIndex=" + me.toIndex;
            }

            if (params.returnCountOnly) me.url += "&returnCountOnly=" + params.returnContent;
            jsonParameters = me.getJsonParameters(params);
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.GetFeaturesServiceBase.prototype.getFeatureComplete
         * @description 查询完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _SuperMap2.default.Util.transformResult(result);
            if (me.format === _REST.DataFormat.GEOJSON && result.features) {
                var geoJSONFormat = new _GeoJSON2.default();
                result.features = JSON.parse(geoJSONFormat.write(result.features));
            }
            me.events.triggerEvent("processCompleted", { result: result });
        }
    }]);

    return GetFeaturesServiceBase;
}(_CommonServiceBase3.default);

exports.default = GetFeaturesServiceBase;


_SuperMap2.default.GetFeaturesServiceBase = GetFeaturesServiceBase;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.InterpolationAnalystParameters
 * @classdesc插值分析参数类。
 * @param options - {Object} 可选参数。如</br>
 *        bounds - {SuperMap.Bounds} 插值分析的范围，用于确定结果栅格数据集的范围。</br>
 *                  Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchRadius - {number}查找半径，即参与运算点的查找范围，与点数据集单位相同。</br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。</br>
 *        zValueScale - {number}用于进行插值分析值的缩放比率，默认为1。</br>
 *        resolution - {number}插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
 *        filterQueryParameter - {SuperMap.FilterParameter} 属性过滤条件。</br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称。</br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。</br>
 *        pixelFormat - {SuperMap.PixelFormat} 指定结果栅格数据集存储的像素格式。</br>
 *        dataset - {string} 用于做插值分析的数据源中数据集的名称。</br>
 *        inputPoints - {Array <Object>}|{Array} 用于做插值分析的离散点集合。</br>
 *                      点类型可以是：SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *        InterpolationAnalystType - {string} 插值分析类型（dataset或geometry），默认为dataset 。</br>
 */
var InterpolationAnalystParameters = function () {

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.InterpolationAnalystType -{string}
     * @description  插值分析类型。差值分析包括数据集插值分析和几何插值分析两类，
     * “dataset”表示对数据集进行插值分析，“geometry”表示对离散点数组进行插值分析，默认值为“dataset”。
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.dataset -{string}
     * @description 用来做插值分析的数据源中数据集的名称，该名称用形如"数据集名称@数据源别名"形式来表示。
     * 当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.outputDatasourceName -{string}
     * @description 插值分析结果数据源的名称。必设参数
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.filterQueryParameter -{SuperMap.FilterParameter}
     * @description 过滤条件，对分析数据集中的点进行过滤，不设置时默认为null，即对数据集中的所有点进行分析。
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.zValueScale -{number}
     * @description 用于进行插值分析值的缩放比率，默认值为1。
     * 参加插值分析的值将乘以该参数值后再进行插值，也就是对进行插值分析的值进行统一的扩大或缩小。
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.searchRadius -{number}
     * @description 查找半径，即参与运算点的查找范围，与点数据集单位相同，默认值为0。</br>
     * 计算某个位置的Z 值时，会以该位置为圆心，以查找范围的值为半径，落在这个范围内的采样点都将参与运算。
     * 该值需要根据待插值点数据的分布状况和点数据集范围进行设置。
     */
    function InterpolationAnalystParameters(options) {
        _classCallCheck(this, InterpolationAnalystParameters);

        this.bounds = null;
        this.searchRadius = 0;
        this.zValueFieldName = null;
        this.zValueScale = 1;
        this.resolution = null;
        this.filterQueryParameter = null;
        this.outputDatasetName = null;
        this.outputDatasourceName = null;
        this.pixelFormat = _REST.PixelFormat.BIT16;
        this.dataset = null;
        this.inputPoints = null;
        this.InterpolationAnalystType = "dataset";
        this.clipParam = null;
        this.CLASS_NAME = "SuperMap.InterpolationAnalystParameters";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.InterpolationAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.clipParam -{SuperMap.ClipParameter}
     * @description 对插值分析结果进行裁剪的参数。
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.inputPoints -{Array<Object>}|{Array<Array>}
     * @description 用于做插值分析的离散点（离散点包括Z值）集合。</br>
     * 点类型可以是：SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
     * 当插值分析类型（InterpolationAnalystType）为 geometry 时，此参数为必设参数。
     * 通过离散点直接进行插值分析不需要指定输入数据集inputDatasourceName，inputDatasetName以及zValueFieldName。
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.pixelFormat -{SuperMap.PixelFormat}
     * @description 指定结果栅格数据集存储的像素格式。
     * 默认值为 SuperMap.PixelFormat.BIT16。
     * 支持存储的像素格式有 BIT16、BIT32、DOUBLE、SINGLE、UBIT1、UBIT4、UBIT8、UBIT24、UBIT32。
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.outputDatasetName -{string}
     * @description 插值分析结果数据集的名称。必设参数
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.resolution -{number}
     * @description 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
     * 该值不能超过待分析数据集的范围边长。
     * 且该值设置时，应该考虑点数据集范围大小来取值，一般为结果栅格行列值（即结果栅格数据集范围除以分辨率），在500以内可以较好地体现密度走势。
     */


    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.zValueFieldName -{string}
     * @description 数据集插值分析中，用于指定进行插值分析的目标字段名，插值分析不支持文本类型的字段。</br>
     * 含义为每个插值点在插值过程中的权重，可以将所有点此字段值设置为1，即所有点在整体插值中权重相同。
     * 当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
     */

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.bounds
     * @description 插值分析的范围，用于确定结果栅格数据集的范围。</br>
     * Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
     * 如果缺省，则默认为原数据集的范围。鉴于此插值方法为内插方法，原数据集的范围内的插值结果才相对有参考价值，
     * 因此建议此参数不大于原数据集范围。
     */


    _createClass(InterpolationAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.bounds = null;
            me.searchRadius = null;
            me.zValueFieldName = null;
            me.zValueScale = null;

            me.resolution = null;
            me.filterQueryParameter = null;
            me.outputDatasetName = null;
            me.pixelFormat = null;
        }

        /**
         * @function SuperMap.InterpolationAnalystParameters.toObject
         * @param interpolationAnalystParameters -{Object} 插值分析参数
         * @param tempObj - {Object} 目标对象
         * @description 生成插值分析对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(interpolationAnalystParameters, tempObj) {
            for (var name in interpolationAnalystParameters) {
                if (name === "inputPoints" && interpolationAnalystParameters.InterpolationAnalystType === "geometry") {
                    var objs = [];
                    for (var i = 0; i < interpolationAnalystParameters.inputPoints.length; i++) {
                        var item = interpolationAnalystParameters.inputPoints[i];
                        var obj = {
                            x: item.x,
                            y: item.y,
                            z: item.tag
                        };
                        objs.push(obj);
                    }
                    tempObj[name] = objs;
                } else {
                    tempObj[name] = interpolationAnalystParameters[name];
                }
            }
        }
    }]);

    return InterpolationAnalystParameters;
}();

exports.default = InterpolationAnalystParameters;


_SuperMap2.default.InterpolationAnalystParameters = InterpolationAnalystParameters;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _FetchRequest = __webpack_require__(41);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ProcessingServiceBase
 * @description 分布式分析服务基类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 分布式分析服务地址。
 * @param options - {Object} 参数。如：<br>
 *        events - {SuperMap.Events} 处理所有事件的对象。<br>
 *        eventListeners - {Object} 听器对象。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        index - {number}服务访问地址在数组中的位置。<br>
 *        length - {number}服务访问地址数组长度。
 */
var ProcessingServiceBase = function (_CommonServiceBase) {
    _inherits(ProcessingServiceBase, _CommonServiceBase);

    function ProcessingServiceBase(url, options) {
        _classCallCheck(this, ProcessingServiceBase);

        options = options || {};
        /*
         * Constant: EVENT_TYPES
         * {Array<string>}
         * 此类支持的事件类型
         * - *processCompleted* 创建成功后触发的事件。
         * - *processFailed* 创建失败后触发的事件 。
         * - *processRunning* 创建过程的整个阶段都会触发的事件，用于获取创建过程的状态 。
         */
        options.EVENT_TYPES = ["processCompleted", "processFailed", "processRunning"];

        var _this = _possibleConstructorReturn(this, (ProcessingServiceBase.__proto__ || Object.getPrototypeOf(ProcessingServiceBase)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.ProcessingServiceBase";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(ProcessingServiceBase, [{
        key: 'destroy',
        value: function destroy() {
            _get(ProcessingServiceBase.prototype.__proto__ || Object.getPrototypeOf(ProcessingServiceBase.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.ProcessingServiceBase.prototype.getJobs
         * @description 获取分布式分析任务。
         * @param url - {string} 资源地址。
         */

    }, {
        key: 'getJobs',
        value: function getJobs(url) {
            var me = this;
            _FetchRequest.FetchRequest.get(url).then(function (response) {
                return response.json();
            }).then(function (result) {
                me.events.triggerEvent("processCompleted", { result: result });
            }).catch(function (e) {
                me.eventListeners.processFailed({ error: e });
            });
        }

        /**
         * @function SuperMap.ProcessingServiceBase.prototype.addJob
         * @description 添加分布式分析任务。
         * @param url - {string} 资源根地址。
         * @param params - {Object} 创建一个空间分析的请求参数。
         * @param paramType - {string} - 请求参数类型。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addJob',
        value: function addJob(url, params, paramType, seconds) {
            var me = this,
                parameterObject = null;
            if (params && params instanceof paramType) {
                parameterObject = new Object();
                paramType.toObject(params, parameterObject);
            }
            var options = {
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
            };
            _FetchRequest.FetchRequest.post(me._processUrl(url), JSON.stringify(parameterObject), options).then(function (response) {
                return response.json();
            }).then(function (result) {
                if (result.succeed) {
                    me.serviceProcessCompleted(result, seconds);
                } else {
                    me.serviceProcessFailed(result);
                }
            }).catch(function (e) {
                me.serviceProcessFailed({ error: e });
            });
        }
    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result, seconds) {
            result = _SuperMap2.default.Util.transformResult(result);
            seconds = seconds || 1000;
            var me = this;
            if (result) {
                var id = setInterval(function () {
                    _FetchRequest.FetchRequest.get(result.newResourceLocation).then(function (response) {
                        return response.json();
                    }).then(function (job) {
                        me.events.triggerEvent("processRunning", { id: job.id, state: job.state });
                        if (job.state.runState === 'LOST') {
                            clearInterval(id);
                            me.events.triggerEvent("processFailed", { error: job.state.errorMsg });
                        }
                        if (job.state.runState === 'FINISHED' && job.setting.serviceInfo) {
                            clearInterval(id);
                            me.events.triggerEvent("processCompleted", { result: job });
                        }
                    }).catch(function (e) {
                        clearInterval(id);
                        me.events.triggerEvent("processFailed", { error: e });
                    });
                }, seconds);
            }
        }
    }, {
        key: 'serviceProcessFailed',
        value: function serviceProcessFailed(result) {
            _get(ProcessingServiceBase.prototype.__proto__ || Object.getPrototypeOf(ProcessingServiceBase.prototype), 'serviceProcessFailed', this).call(this, result);
        }

        //为不是以.json结尾的url加上.json，并且如果有token的话，在.json后加上token参数。

    }, {
        key: '_processUrl',
        value: function _processUrl(url) {
            if (url.indexOf('.json') === -1) {
                url += '.json';
            }
            if (_SuperMap2.default.SecurityManager.getToken(url)) {
                url += '?token=' + _SuperMap2.default.SecurityManager.getToken(url);
            }
            return url;
        }
    }]);

    return ProcessingServiceBase;
}(_CommonServiceBase3.default);

exports.default = ProcessingServiceBase;


_SuperMap2.default.ProcessingServiceBase = ProcessingServiceBase;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var HALF_PI = Math.PI/2;
var sign = __webpack_require__(36);

module.exports = function(x) {
  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
};

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
};

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
};

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return (0.05859375 * x * x * (1 + 0.75 * x));
};

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return (x * x * x * (35 / 3072));
};

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = function(e0, e1, e2, e3, phi) {
  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
};

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return x<0 ? -1 : 1;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Pixel
 * @description 此类用x,y坐标描绘屏幕坐标（像素点）。
 */
var Pixel = function () {

  /**
   * Constructor: SuperMap.Pixel
   * 创建新的SuperMap.Pixel实例。
   *
   * 例如:
   * (start code)
   * //单独创建一个对象
   * var pixcel = new SuperMap.Pixel(100,50);
   *
   * //依据size创建
   *  var size = new SuperMap.Size(21,25);
   *    var offset = new SuperMap.Pixel(-(size.w/2), -size.h);
   * (end)
   *
   * Parameters:
   * x - {Number} x坐标，默认为0.0
   * y - {Number} y坐标，默认为0.0
   * mode - {String} 坐标模式，默认为SuperMap.Pixel.Mode.LeftTop
   *
   * Returns:
   * 返回 <SuperMap.Pixel> 实例。
   */


  /**
   * APIProperty: y
   * {Number} y坐标，默认为0.0
   */
  function Pixel(x, y, mode) {
    _classCallCheck(this, Pixel);

    this.x = 0.0;
    this.y = 0.0;
    this.mode = null;
    this.CLASS_NAME = "SuperMap.Pixel";

    this.x = x ? parseFloat(x) : this.x;
    this.y = y ? parseFloat(y) : this.y;
    this.mode = mode;
  }

  /**
   * APIMethod: toString
   * 返回此对象的字符串形式
   *
   * 例如:
   * (start code)
   * var pixcel = new SuperMap.Pixel(100,50);
   * var str = pixcel.toString();
   * (end)
   *
   * Returns:
   * {String} 例如: "x=200.4,y=242.2"
   */


  /**
   * APIProperty: mode
   * {String} 坐标模式，有左上、右上、右下、左下这几种模式，分别表示相对于左上角、右上角、右下角、左下角的坐标。
   *          值有SuperMap.Pixel.Mode.LeftTop，SuperMap.Pixel.Mode.RightTop，SuperMap.Pixel.Mode.RightBottom，
   *          SuperMap.Pixel.Mode.LeftBottom 这四种,默认值为：SuperMap.Pixel.Mode.LeftTop
   * */


  /**
   * APIProperty: x
   * {Number} x坐标，默认为0.0
   */


  _createClass(Pixel, [{
    key: "toString",
    value: function toString() {
      return "x=" + this.x + ",y=" + this.y;
    }

    /**
     * APIMethod: clone
     * 克隆当前的 pixel 对象。
     *
     * 例如:
     * (start code)
     * var pixcel = new SuperMap.Pixel(100,50);
     * var pixcel2 = pixcel.clone();
     * (end)
     *
     * Returns:
     * {<SuperMap.Pixel>} 返回一个新的与当前 pixel 对象有相同x、y坐标的 pixel 对象。
     */

  }, {
    key: "clone",
    value: function clone() {
      return new Pixel(this.x, this.y, this.mode);
    }

    /**
     * APIMethod: equals
     * 比较两 pixel 是否相等
     *
     * 例如:
     * (start code)
     * var pixcel = new SuperMap.Pixel(100,50);
     * var pixcel2 = new SuperMap.Pixel(100,50);
     * var isEquals = pixcel.equals(pixcel2);
     * (end)
     *
     * Parameters:
     * px - {<SuperMap.Pixel>} 用于比较相等的 pixel 对象。
     *
     * Returns:
     * {Boolean} 如果传入的像素点和当前像素点相同返回true,如果不同或传入参数为NULL则返回false
     */

  }, {
    key: "equals",
    value: function equals(px) {
      var equals = false;
      if (px != null) {
        equals = this.x == px.x && this.y == px.y || isNaN(this.x) && isNaN(this.y) && isNaN(px.x) && isNaN(px.y);
      }
      return equals;
    }

    /**
     * APIMethod: distanceTo
     * 返回两个 pixel 的距离。
     *
     * 例如:
     * (start code)
     * var pixcel = new SuperMap.Pixel(100,50);
     * var pixcel2 = new SuperMap.Pixel(110,30);
     * var distance = pixcel.distanceTo(pixcel2);
     * (end)
     *
     * Parameters:
     * px - {<SuperMap.Pixel>} 用于计算的一个 pixel
     *
     * Returns:
     * {Float} 作为参数传入的像素与当前像素点的距离。
     */

  }, {
    key: "distanceTo",
    value: function distanceTo(px) {
      return Math.sqrt(Math.pow(this.x - px.x, 2) + Math.pow(this.y - px.y, 2));
    }

    /**
     * APIMethod: add
     * 在原来像素坐标基础上，x值加上传入的x参数，y值加上传入的y参数。
     *
     * 例如:
     * (start code)
     * var pixcel = new SuperMap.Pixel(100,50);
     * //pixcel2是新的对象
     * var pixcel2 = pixcel.add(20,30);
     * (end)
     *
     * Parameters:
     * x - {Number} 传入的x值。
     * y - {Number} 传入的y值。
     *
     * Returns:
     * {<SuperMap.Pixel>} 返回一个新的pixel对象，该pixel是由当前的pixel与传
     *      入的x,y相加得到。
     */

  }, {
    key: "add",
    value: function add(x, y) {
      if (x == null || y == null) {
        throw new TypeError('Pixel.add cannot receive null values');
      }
      return new Pixel(this.x + x, this.y + y);
    }

    /**
     * APIMethod: offset
     * 通过传入的 <SuperMap.Pixel> 参数对原屏幕坐标进行偏移。
     *
     * 例如:
     * (start code)
     * var pixcel = new SuperMap.Pixel(100,50);
     * var pixcel2 = new SuperMap.Pixel(130,20);
     * //pixcel3 是新的对象
     * var pixcel3 = pixcel.offset(pixcel2);
     * (end)
     *
     * Parameters
     * px - {<SuperMap.Pixel>}  传入的 <SuperMap.Pixel> 对象。
     *
     * Returns:
     * {<SuperMap.Pixel>} 返回一个新的pixel，该pixel是由当前的pixel对象的x，y
     *      值与传入的Pixel对象的x，y值相加得到。
     */

  }, {
    key: "offset",
    value: function offset(px) {
      var newPx = this.clone();
      if (px) {
        newPx = this.add(px.x, px.y);
      }
      return newPx;
    }

    /**
     *
     * APIMethod: destroy
     * 销毁此对象。
     * 销毁后此对象的所有属性为null，而不是初始值。
     *
     * 例如:
     * (start code)
     * var pixcel = new SuperMap.Pixel(100,50);
     * pixcel.destroy();
     * (end)
     *
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.x = null;
      this.y = null;
      this.mode = null;
    }

    /**
     * Constant:SuperMap.Pixel.Mode.LeftTop
     * 左上模式
     * */

    /**
     * Constant:SuperMap.Pixel.Mode.RightTop
     * 右上模式
     * */

    /**
     * Constant:SuperMap.Pixel.Mode.RightBottom
     * 右下模式
     * */

    /**
     * Constant:SuperMap.Pixel.Mode.LeftBottom
     * 左下模式
     * */

  }]);

  return Pixel;
}();

Pixel.Mode = {
  LeftTop: "lefttop",
  RightTop: "righttop",
  RightBottom: "rightbottom",
  LeftBottom: "leftbottom"
};
exports.default = Pixel;

_SuperMap2.default.Pixel = Pixel;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Collection = __webpack_require__(14);

var _Collection2 = _interopRequireDefault(_Collection);

var _LineString2 = __webpack_require__(23);

var _LineString3 = _interopRequireDefault(_LineString2);

var _Point = __webpack_require__(11);

var _Point2 = _interopRequireDefault(_Point);

var _Projection = __webpack_require__(22);

var _Projection2 = _interopRequireDefault(_Projection);

var _BaseTypes = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class  SuperMap.Geometry.LinearRing
 * @classdesc 几何对象线环类，是一个特殊的封闭的线串，在每次addPoint/removePoint之后会通过添加一个点（此点是复制的第一个点得到的）
 * 作为最后的一个点来自动关闭线环。
 * @extends {SuperMap.Geometry.LineString}
 * @param points {Array<SuperMap.Geometry.Point>} 组成线性环的点。
 * @example
 * var points = [new SuperMap.Geometry.Point(4933.319287022352, -3337.3849141502124),
 *      new SuperMap.Geometry.Point(4960.9674060199022, -3349.3316322355736),
 *      new SuperMap.Geometry.Point(5006.0235999418364, -3358.8890067038628),
 *      new SuperMap.Geometry.Point(5075.3145648369318, -3378.0037556404409),
 *      new SuperMap.Geometry.Point(5305.19551436013, -3376.9669111768926)],
 * var linearRing = new SuperMap.Geometry.LinearRing(points);
 */
var LinearRing = function (_LineString) {
    _inherits(LinearRing, _LineString);

    function LinearRing(points) {
        _classCallCheck(this, LinearRing);

        var _this = _possibleConstructorReturn(this, (LinearRing.__proto__ || Object.getPrototypeOf(LinearRing)).call(this, points));

        _this.componentTypes = ["SuperMap.Geometry.Point"];
        _this.CLASS_NAME = "SuperMap.Geometry.LinearRing";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.LinearRing.prototype.addComponent
     * @description 添加一个点到几何图形数组中，如果这个点将要被添加到组件数组的末端，并且与数组中已经存在的最后一个点相同，
     * 重复的点是不能被添加的。这将影响未关闭环的关闭。
     * 这个方法可以通过将非空索引（组件数组的下标）作为第二个参数重写。
     * @param point - {SuperMap.Geometry.Point} 点对象。
     * @param index - {Integer} 插入组件数组的下标。
     * @returns {Boolean} 点对象是否添加成功。
     */


    /**
     * @member SuperMap.Geometry.LinearRing.prototype.componentTypes -{Array<string>}
     * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
     * @readonly
     * @default ["{@link SuperMap.Geometry.Point}"]
     */


    _createClass(LinearRing, [{
        key: 'addComponent',
        value: function addComponent(point, index) {
            var added = false;

            //remove last point
            var lastPoint = this.components.pop();

            // given an index, add the point
            // without an index only add non-duplicate points
            if (index != null || !point.equals(lastPoint)) {
                added = _Collection2.default.prototype.addComponent.apply(this, arguments);
            }

            //append copy of first point
            var firstPoint = this.components[0];
            _Collection2.default.prototype.addComponent.apply(this, [firstPoint]);

            return added;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.removeComponent
         * @description 从几何组件中删除一个点。
         * @param point - {SuperMap.Geometry.Point} 点对象。
         * @returns {Boolean} 点对象是否删除。
         */

    }, {
        key: 'removeComponent',
        value: function removeComponent(point) {
            var removed = this.components && this.components.length > 3;
            if (removed) {
                //remove last point
                this.components.pop();

                //remove our point
                _Collection2.default.prototype.removeComponent.apply(this, arguments);
                //append copy of first point
                var firstPoint = this.components[0];
                _Collection2.default.prototype.addComponent.apply(this, [firstPoint]);
            }
            return removed;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.move
         * @description 沿着给定的x、y轴正方向按照给定的位移移动一个几何图形，move 不仅改变了几何图形的位置并且清理了边界缓存。
         * @param x - {float} x轴正方向上的偏移量。
         * @param y - {float} y轴正方向上的偏移量。
         */

    }, {
        key: 'move',
        value: function move(x, y) {
            for (var i = 0, len = this.components.length; i < len - 1; i++) {
                this.components[i].move(x, y);
            }
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.rotate
         * @description 围绕中心点旋转几何图形。
         * @param angle - {float} 旋转角的度数（沿着x轴正方向的逆时针方向）。
         * @param origin - {SuperMap.Geometry.Point} 旋转中心点。
         */

    }, {
        key: 'rotate',
        value: function rotate(angle, origin) {
            for (var i = 0, len = this.components.length; i < len - 1; ++i) {
                this.components[i].rotate(angle, origin);
            }
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.resize
         * @description 调整几何对象的大小。
         * @param scale - {float} 几何图形缩放的比例系数，是几何图形维数的两倍。
         * （如：对于线来说将以线2倍的长度拉长，对于多边形来说，将以面积的4倍变化）。
         * @param origin - {SuperMap.Geometry.Point} 调整大小选定的起始原点。
         * @param ratio - {float} 可选的x,y的比例，默认的比例为1。
         * @returns {SuperMap.Geometry} - 当前的几何对象。
         */

    }, {
        key: 'resize',
        value: function resize(scale, origin, ratio) {
            for (var i = 0, len = this.components.length; i < len - 1; ++i) {
                this.components[i].resize(scale, origin, ratio);
            }
            return this;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.transform
         * @description 投影转换。
         * @param source - {SuperMap.Projection} 源对象投影。
         * @param dest - {SuperMap.Projection} 目标对象投影。
         * @returns {SuperMap.Geometry}
         */

    }, {
        key: 'transform',
        value: function transform(source, dest) {
            if (source && dest) {
                for (var i = 0, len = this.components.length; i < len - 1; i++) {
                    var component = this.components[i];
                    component.transform(source, dest);
                }
                this.bounds = null;
            }
            return this;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.getCentroid
         * @description 获取几何对象的质心。
         * @returns {SuperMap.Geometry.Point} 几何图形的质心。
         */

    }, {
        key: 'getCentroid',
        value: function getCentroid() {
            if (this.components) {
                var len = this.components.length;
                if (len > 0 && len <= 2) {
                    return this.components.clone();
                } else if (len > 2) {
                    var sumX = 0.0;
                    var sumY = 0.0;
                    var x0 = this.components[0].x;
                    var y0 = this.components[0].y;
                    var area = -1 * this.getArea();
                    if (area != 0) {
                        for (var i = 0; i < len - 1; i++) {
                            var b = this.components[i];
                            var c = this.components[i + 1];
                            sumX += (b.x + c.x - 2 * x0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                            sumY += (b.y + c.y - 2 * y0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                        }
                        var x = x0 + sumX / (6 * area);
                        var y = y0 + sumY / (6 * area);
                    } else {
                        for (var i = 0; i < len - 1; i++) {
                            sumX += this.components[i].x;
                            sumY += this.components[i].y;
                        }
                        var x = sumX / (len - 1);
                        var y = sumY / (len - 1);
                    }
                    return new _Point2.default(x, y);
                } else {
                    return null;
                }
            }
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.getArea
         * @description 获得当前几何对象区域大小，如果是沿顺时针方向的环则是正值，否则为负值。
         * @returns {float} 环的面积。
         */

    }, {
        key: 'getArea',
        value: function getArea() {
            var area = 0.0;
            if (this.components && this.components.length > 2) {
                var sum = 0.0;
                for (var i = 0, len = this.components.length; i < len - 1; i++) {
                    var b = this.components[i];
                    var c = this.components[i + 1];
                    sum += (b.x + c.x) * (c.y - b.y);
                }
                area = -sum / 2.0;
            }
            return area;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.getGeodesicArea
         * @description 计算投影到球面上的几何对象的近似面积。 如果是沿顺时针方向的环则是正值，否则为负值。
         * @param projection - {SuperMap.Projection} 空间参考系统的几何坐标。如果没有设置，默认 WGS84。
         * @returns {float} 几何图形的近似测地面积。
         */

    }, {
        key: 'getGeodesicArea',
        value: function getGeodesicArea(projection) {
            var ring = this; // so we can work with a clone if needed
            if (projection) {
                var gg = new _Projection2.default("EPSG:4326");
                if (!gg.equals(projection)) {
                    ring = this.clone().transform(projection, gg);
                }
            }
            var area = 0.0;
            var len = ring.components && ring.components.length;
            if (len > 2) {
                var p1, p2;
                for (var i = 0; i < len - 1; i++) {
                    p1 = ring.components[i];
                    p2 = ring.components[i + 1];
                    area += _SuperMap2.default.Util.rad(p2.x - p1.x) * (2 + Math.sin(_SuperMap2.default.Util.rad(p1.y)) + Math.sin(_SuperMap2.default.Util.rad(p2.y)));
                }
                area = area * 6378137.0 * 6378137.0 / 2.0;
            }
            return area;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.containsPoint
         * @description Test if a point is inside a linear ring.  For the case where a point
         *     is coincident with a linear ring edge, returns 1.  Otherwise,
         *     returns boolean.
         * @param point - {SuperMap.Geometry.Point}
         * @returns {Boolean | number} The point is inside the linear ring.  Returns 1 if
         *     the point is coincident with an edge.  Returns boolean otherwise.
         */

    }, {
        key: 'containsPoint',
        value: function containsPoint(point) {
            var approx = _BaseTypes.NumberExt.limitSigDigs;
            var digs = 14;
            var px = approx(point.x, digs);
            var py = approx(point.y, digs);

            function getX(y, x1, y1, x2, y2) {
                return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;
            }

            var numSeg = this.components.length - 1;
            var start, end, x1, y1, x2, y2, cx, cy;
            var crosses = 0;
            for (var i = 0; i < numSeg; ++i) {
                start = this.components[i];
                x1 = approx(start.x, digs);
                y1 = approx(start.y, digs);
                end = this.components[i + 1];
                x2 = approx(end.x, digs);
                y2 = approx(end.y, digs);

                /**
                 * The following conditions enforce five edge-crossing rules:
                 *    1. points coincident with edges are considered contained;
                 *    2. an upward edge includes its starting endpoint, and
                 *    excludes its final endpoint;
                 *    3. a downward edge excludes its starting endpoint, and
                 *    includes its final endpoint;
                 *    4. horizontal edges are excluded; and
                 *    5. the edge-ray intersection point must be strictly right
                 *    of the point P.
                 */
                if (y1 === y2) {
                    // horizontal edge
                    if (py === y1) {
                        // point on horizontal line
                        if (x1 <= x2 && px >= x1 && px <= x2 || // right or vert
                        x1 >= x2 && px <= x1 && px >= x2) {
                            // left or vert
                            // point on edge
                            crosses = -1;
                            break;
                        }
                    }
                    // ignore other horizontal edges
                    continue;
                }
                cx = approx(getX(py, x1, y1, x2, y2), digs);
                if (cx === px) {
                    // point on line
                    if (y1 < y2 && py >= y1 && py <= y2 || // upward
                    y1 > y2 && py <= y1 && py >= y2) {
                        // downward
                        // point on edge
                        crosses = -1;
                        break;
                    }
                }
                if (cx <= px) {
                    // no crossing to the right
                    continue;
                }
                if (x1 !== x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {
                    // no crossing
                    continue;
                }
                if (y1 < y2 && py >= y1 && py < y2 || // upward
                y1 > y2 && py < y1 && py >= y2) {
                    // downward
                    ++crosses;
                }
            }
            var contained = crosses === -1 ?
            // on edge
            1 :
            // even (out) or odd (in)
            !!(crosses & 1);

            return contained;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.intersects
         * @description 判断输入的几何图形是否与当前几何图形相交。
         * @param geometry - {SuperMap.Geometry} 任意的几何对象。
         * @returns {Boolean} 输入几何图形与当前的目标几何图形相交。
         */

    }, {
        key: 'intersects',
        value: function intersects(geometry) {
            var intersect = false;
            if (geometry.CLASS_NAME === "SuperMap.Geometry.Point") {
                intersect = this.containsPoint(geometry);
            } else if (geometry.CLASS_NAME === "SuperMap.Geometry.LineString") {
                intersect = geometry.intersects(this);
            } else if (geometry.CLASS_NAME === "SuperMap.Geometry.LinearRing") {
                intersect = _LineString3.default.prototype.intersects.apply(this, [geometry]);
            } else {
                // check for component intersections
                for (var i = 0, len = geometry.components.length; i < len; ++i) {
                    intersect = geometry.components[i].intersects(this);
                    if (intersect) {
                        break;
                    }
                }
            }
            return intersect;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.getVertices
         * @description 返回几何图形的所有点的列表。
         * @param nodes - {Boolean} 对于线来说，仅仅返回作为端点的顶点，如果设为false，则返回非端点的顶点
         * 如果没有设置此参数，则返回所有顶点。
         * @returns {Array} 几何对象所有点的列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {
            return nodes === true ? [] : this.components.slice(0, this.components.length - 1);
        }
    }]);

    return LinearRing;
}(_LineString3.default);

exports.default = LinearRing;

_SuperMap2.default.Geometry.LinearRing = LinearRing;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _QueryParameters = __webpack_require__(15);

var _QueryParameters2 = _interopRequireDefault(_QueryParameters);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryService
 * @classdesc 查询服务基类。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 服务地址。请求地图查询服务的 URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 * @param options - {Object} 可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @example
 * (start code)
 * var myService = new SuperMap.QueryService(url, {
 *     eventListeners: {
 *	       "processCompleted": queryCompleted,
 *		   "processFailed": queryError
 *		   }
 * };
 * (end)
 */
var QueryService = function (_CommonServiceBase) {
    _inherits(QueryService, _CommonServiceBase);

    /*
     * @function SuperMap.QueryService.prototype.constructor
     * @description 查询服务基类构造函数。
     * @param url - {string} 服务地址。请求地图查询服务的 URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
     * @param options - {Object} 可选参数。如：<br>
     *        eventListeners - {Object} 需要被注册的监听器对象。
     */


    /*
     * Property: returnContent
     * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的URI。
     */
    function QueryService(url, options) {
        _classCallCheck(this, QueryService);

        var _this = _possibleConstructorReturn(this, (QueryService.__proto__ || Object.getPrototypeOf(QueryService)).call(this, url, options));

        _this.returnContent = false;
        _this.format = _REST.DataFormat.GEOJSON;
        _this.CLASS_NAME = "SuperMap.QueryService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        var me = _this,
            end;
        if (!me.url) {
            return _possibleConstructorReturn(_this);
        }
        if (options && options.format) {
            me.format = options.format.toUpperCase();
        }

        end = me.url.substr(me.url.length - 1, 1);

        // TODO 待iServer featureResul资源GeoJSON表述bug修复当使用以下注释掉的逻辑
        // if (this.format==="geojson") {
        //     me.url += (end == "/") ? "featureResults.geojson?" : "/featureResults.geojson?";
        // } else {
        //     me.url += (end == "/") ? "featureResults.json?" : "/featureResults.json?";
        // }
        me.url += end === "/" ? "queryResults.json?" : "/queryResults.json?";
        return _this;
    }

    /**
     * @function SuperMap.QueryService.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /*
     *  Property: format
     *  {string} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
     *  参数格式为"ISERVER","GEOJSON",GEOJSON
     */


    _createClass(QueryService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryService.prototype.__proto__ || Object.getPrototypeOf(QueryService.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
            me.format = null;
        }

        /**
         * @function SuperMap.QueryService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {QueryParameters} 查询参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                returnCustomResult = null,
                jsonParameters = null;
            me.returnContent = params.returnContent;
            jsonParameters = me.getJsonParameters(params);
            if (me.returnContent) {
                me.url += "returnContent=" + me.returnContent;
            } else {
                //仅供三维使用 获取高亮图片的bounds
                returnCustomResult = params.returnCustomResult;
                if (returnCustomResult) {
                    me.url += "returnCustomResult=" + returnCustomResult;
                }
            }
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /*
         * Method: queryComplete
         * 查询完成，执行此方法。
         *
         * Parameters:
         * result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _SuperMap2.default.Util.transformResult(result);
            if (result && result.recordsets && me.format === _SuperMap2.default.DataFormat.GEOJSON) {
                var geoJSONFormat = new _GeoJSON2.default();
                for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
                    if (recordsets[i].features) {
                        recordsets[i].features = JSON.parse(geoJSONFormat.write(recordsets[i].features));
                    }
                }
            }
            me.events.triggerEvent("processCompleted", { result: result });
        }

        /**
         * @function SuperMap.QueryService.prototype.getQueryParameters
         * @description 将 JSON 对象表示的查询参数转化为 QueryParameters 对象。
         * @param params - {Object} JSON 字符串表示的查询参数。
         * @return {QueryParameters} 返回转化后的 QueryParameters 对象。
         */

    }, {
        key: 'getQueryParameters',
        value: function getQueryParameters(params) {
            return new _QueryParameters2.default({
                customParams: params.customParams,
                expectCount: params.expectCount,
                networkType: params.networkType,
                queryOption: params.queryOption,
                queryParams: params.queryParams,
                startRecord: params.startRecord,
                prjCoordSys: params.prjCoordSys,
                holdTime: params.holdTime
            });
        }
    }]);

    return QueryService;
}(_CommonServiceBase3.default);

exports.default = QueryService;


_SuperMap2.default.QueryService = QueryService;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _UGCMapLayer2 = __webpack_require__(265);

var _UGCMapLayer3 = _interopRequireDefault(_UGCMapLayer2);

var _JoinItem = __webpack_require__(48);

var _JoinItem2 = _interopRequireDefault(_JoinItem);

var _DatasetInfo = __webpack_require__(174);

var _DatasetInfo2 = _interopRequireDefault(_DatasetInfo);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.UGCSubLayer
 * @classdesc 地图服务图层属性信息类，影像图层(Image)、专题图层(ServerTheme)、栅格图层(Grid)、矢量图层(Vector)等图层均继承该类。
 * @extends SuperMap.UGCMapLayer
 * @param options - {Object} 可选参数。如：<br>
 *        datasetInfo - {SuperMap.DatasetInfo} 数据集信息。<br>
 *        displayFilter - {string} 图层显示过滤条件。<br>
 *        joinItems - {SuperMap.JoinItem} 连接信息类。<br>
 *        representationField - {string} 存储制图表达信息的字段。<br>
 *        ugcLayerType - {SuperMap.LayerType} 图层类型
 */
var UGCSubLayer = function (_UGCMapLayer) {
    _inherits(UGCSubLayer, _UGCMapLayer);

    /*
     * Constructor: SuperMap.UGCSubLayer
     * 地图服务图层属性信息类构造函数。
     。
     */


    /**
     * @member SuperMap.UGCSubLayer.prototype.representationField -{string}
     * @description 存储制图表达信息的字段。
     */


    /**
     * @member SuperMap.UGCSubLayer.prototype.displayFilter -{string}
     * @description 图层显示过滤条件。
     */
    function UGCSubLayer(options) {
        _classCallCheck(this, UGCSubLayer);

        options = options || {};

        var _this = _possibleConstructorReturn(this, (UGCSubLayer.__proto__ || Object.getPrototypeOf(UGCSubLayer)).call(this, options));

        _this.datasetInfo = null;
        _this.displayFilter = null;
        _this.joinItems = null;
        _this.representationField = null;
        _this.ugcLayerType = null;
        _this.CLASS_NAME = "SuperMap.UGCSubLayer";
        return _this;
    }

    /**
     * @function SuperMap.UGCSubLayer.prototype.fromJson
     * @description 将服务端JSON对象转换成当前客户端对象
     * @param jsonObject - {Object} 要转换的 JSON 对象。
     */


    /**
     * @member SuperMap.UGCSubLayer.prototype.ugcLayerType -{SuperMap.LayerType}
     * @description 图层类型。
     */


    /**
     * @member SuperMap.UGCSubLayer.prototype.joinItems -{SuperMap.JoinItem}
     * @description 连接信息类。
     */


    /**
     * @member SuperMap.UGCSubLayer.prototype.datasetInfo -{SuperMap.DatasetInfo}
     * @description 数据集信息。
     */


    _createClass(UGCSubLayer, [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(UGCSubLayer.prototype.__proto__ || Object.getPrototypeOf(UGCSubLayer.prototype), 'fromJson', this).call(this, jsonObject);
            if (this.datasetInfo) {
                this.datasetInfo = new _DatasetInfo2.default(this.datasetInfo);
            }
            if (this.joinItems && this.joinItems.length) {
                var newJoinItems = [];
                for (var i = 0; i < this.joinItems.length; i++) {
                    newJoinItems[i] = new _JoinItem2.default(this.joinItems[i]);
                }
                this.joinItems = newJoinItems;
            }
        }

        /**
         * @inheritDoc
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            _get(UGCSubLayer.prototype.__proto__ || Object.getPrototypeOf(UGCSubLayer.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.UGCSubLayer.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var jsonObject = _get(UGCSubLayer.prototype.__proto__ || Object.getPrototypeOf(UGCSubLayer.prototype), 'toServerJSONObject', this).call(this);
            if (jsonObject.joinItems) {
                var joinItems = [];
                for (var i = 0; i < jsonObject.joinItems.length; i++) {
                    if (jsonObject.joinItems[i].toServerJSONObject) {
                        joinItems[i] = jsonObject.joinItems[i].toServerJSONObject();
                    }
                }
                jsonObject.joinItems = joinItems;
            }
            if (jsonObject.datasetInfo) {
                if (jsonObject.datasetInfo.toServerJSONObject) {
                    jsonObject.datasetInfo = jsonObject.datasetInfo.toServerJSONObject();
                }
            }
            return jsonObject;
        }
    }]);

    return UGCSubLayer;
}(_UGCMapLayer3.default);

exports.default = UGCSubLayer;


_SuperMap2.default.UGCSubLayer = UGCSubLayer;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchRequest = exports.Support = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _whatwgFetchImportable = __webpack_require__(152);

var _whatwgFetchImportable2 = _interopRequireDefault(_whatwgFetchImportable);

var _fetchJsonp2 = __webpack_require__(151);

var _fetchJsonp3 = _interopRequireDefault(_fetchJsonp2);

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Support = exports.Support = _SuperMap2.default.Support = _SuperMap2.default.Support || {
    cors: window.XMLHttpRequest && 'withCredentials' in new window.XMLHttpRequest()
};
var FetchRequest = exports.FetchRequest = _SuperMap2.default.FetchRequest = {
    commit: function commit(method, url, params, options) {
        method = method ? method.toUpperCase() : method;
        switch (method) {
            case 'GET':
                return this.get(url, params, options);
            case 'POST':
                return this.post(url, params, options);
            case 'PUT':
                return this.put(url, params, options);
            case 'DELETE':
                return this.delete(url, params, options);
            default:
                return this.get(url, params, options);
        }
    },

    get: function get(url, params, options) {
        var type = 'GET';
        url = this._processUrl(url, options);
        url = _SuperMap2.default.Util.urlAppend(url, this._getParameterString(params || {}));
        if (!this.urlIsLong(url)) {
            if (_SuperMap2.default.Util.isInTheSameDomain(url) || Support.cors || options.proxy) {
                return this._fetch(url, params, options, type);
            }
            if (!_SuperMap2.default.Util.isInTheSameDomain(url)) {
                url = url.replace('.json', '.jsonp');
                return this._fetchJsonp(url, options);
            }
        }
        return this._postSimulatie(type, url.substring(0, url.indexOf('?') - 1), params, options);
    },

    delete: function _delete(url, params, options) {
        var type = 'DELETE';
        url = this._processUrl(url, options);
        url = _SuperMap2.default.Util.urlAppend(url, this._getParameterString(params || {}));
        if (!this.urlIsLong(url) && Support.cors) {
            return this._fetch(url, params, options, type);
        }
        return this._postSimulatie(type, url.substring(0, url.indexOf('?') - 1), params, options);
    },

    post: function post(url, params, options) {
        return this._fetch(this._processUrl(url, options), params, options, 'POST');
    },

    put: function put(url, params, options) {
        return this._fetch(this._processUrl(url, options), params, options, 'PUT');
    },
    urlIsLong: function urlIsLong(url) {
        //当前url的字节长度。
        var totalLength = 0,
            charCode = null;
        for (var i = 0, len = url.length; i < len; i++) {
            //转化为Unicode编码
            charCode = url.charCodeAt(i);
            if (charCode < 0x007f) {
                totalLength++;
            } else if (0x0080 <= charCode && charCode <= 0x07ff) {
                totalLength += 2;
            } else if (0x0800 <= charCode && charCode <= 0xffff) {
                totalLength += 3;
            }
        }
        return totalLength < 2000 ? false : true;
    },
    _postSimulatie: function _postSimulatie(type, url, params, options) {
        var separator = url.indexOf("?") > -1 ? "&" : "?";
        url += separator + '_method= ' + type;
        return this.post(url, params, options);
    },

    _processUrl: function _processUrl(url, options) {
        if (this._isMVTRequest(url)) {
            return url;
        }

        if (url.indexOf('.json') === -1) {
            if (url.indexOf("?") < 0) {
                url += '.json';
            } else {
                var urlArrays = url.split("?");
                if (urlArrays.length === 2) {
                    url = urlArrays[0] + ".json?" + urlArrays[1];
                }
            }
        }
        if (options && options.proxy) {
            if (typeof options.proxy === "function") {
                url = options.proxy(url);
            } else {
                url = decodeURIComponent(url);
                url = options.proxy + encodeURIComponent(url);
            }
        }
        return url;
    },

    _fetch: function _fetch(url, params, options, type) {
        options = options || {};
        options.headers = options.headers || {};
        if (!options.headers['Content-Type']) {
            options.headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
        }
        if (options.timeout) {
            return this._timeout(options.timeout, (0, _whatwgFetchImportable2.default)(url, {
                method: type,
                headers: options.headers,
                body: type === 'PUT' || type === 'POST' ? params : undefined,
                credentials: options.withCredentials ? 'include' : 'omit',
                mode: 'cors'
            }).then(function (response) {
                return response;
            }));
        }
        return (0, _whatwgFetchImportable2.default)(url, {
            method: type,
            body: type === 'PUT' || type === 'POST' ? params : undefined,
            headers: options.headers,
            credentials: options.withCredentials ? 'include' : 'omit',
            mode: 'cors'
        }).then(function (response) {
            return response;
        });
    },

    _fetchJsonp: function _fetchJsonp(url, options) {
        options = options || {};
        return (0, _fetchJsonp3.default)(url, { method: 'GET', timeout: options.timeout }).then(function (response) {
            return response;
        });
    },

    _timeout: function _timeout(seconds, promise) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                reject(new Error("timeout"));
            }, seconds);
            promise.then(resolve, reject);
        });
    },

    _getParameterString: function _getParameterString(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if (value != null && typeof value !== 'function') {
                var encodedValue;
                if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Array) {
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex = 0, len = value.length; itemIndex < len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(item === null || item === undefined ? "" : item));
                    }
                    encodedValue = '[' + encodedItemArray.join(",") + ']';
                } else {
                    encodedValue = encodeURIComponent(value);
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }
        return paramsArray.join("&");
    },

    _isMVTRequest: function _isMVTRequest(url) {
        return url.indexOf('.mvt') > -1 || url.indexOf('.pbf') > -1;
    }
};

/***/ }),
/* 42 */
/***/ (function(module, exports) {

var HALF_PI = Math.PI/2;
module.exports = function(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  //console.log("phi2z has NoConvergence");
  return -9999;
};

/***/ }),
/* 43 */
/***/ (function(module, exports) {

var HALF_PI = Math.PI/2;

module.exports = function(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow(((1 - con) / (1 + con)), com);
  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @name Event
 * @memberOf SuperMap
 * @namespace
 * @description 事件处理函数.
 */
exports.default = Event = _SuperMap2.default.Event = {

    /**
     * @description  A hashtable cache of the event observers. Keyed by element._eventCacheID
     * @type {Boolean}
     * @default false
     */
    observers: false,

    /**
     * @description KEY_SPACE
     * @type {number}
     * @default 32
     */
    KEY_SPACE: 32,

    /**
     * @description KEY_BACKSPACE
     * @type {number}
     * @default 8
     */
    KEY_BACKSPACE: 8,

    /**
     * @description KEY_TAB
     * @type {number}
     * @default 9
     */
    KEY_TAB: 9,

    /**
     * @description KEY_RETURN
     * @type {number}
     * @default 13
     */
    KEY_RETURN: 13,

    /**
     * @description KEY_ESC
     * @type {number}
     * @default 27
     */
    KEY_ESC: 27,

    /**
     * @description KEY_LEFT
     * @type {number}
     * @default 37
     */
    KEY_LEFT: 37,

    /**
     * @description KEY_UP
     * @type {number}
     * @default 38
     */
    KEY_UP: 38,

    /**
     * @description KEY_RIGHT
     * @type {number}
     * @default 39
     */
    KEY_RIGHT: 39,

    /**
     * @description KEY_DOWN
     * @type {number}
     * @default 40
     */
    KEY_DOWN: 40,

    /**
     * @description KEY_DELETE
     * @type {number}
     * @default 46
     */
    KEY_DELETE: 46,

    /**
     * @description Cross browser event element detection.
     * @param event - {Event}
     * @returns {HTMLElement} The element that caused the event
     */
    element: function element(event) {
        return event.target || event.srcElement;
    },

    /**
     * @description Determine whether event was caused by a single touch
     * @param event - {Event}
     * @returns {Boolean}
     */
    isSingleTouch: function isSingleTouch(event) {
        return event.touches && event.touches.length === 1;
    },

    /**
     * @description Determine whether event was caused by a multi touch
     * @param event - {Event}
     * @returns {Boolean}
     */
    isMultiTouch: function isMultiTouch(event) {
        return event.touches && event.touches.length > 1;
    },

    /**
     * @description Determine whether event was caused by a left click.
     * @param event - {Event}
     * @returns {Boolean}
     */
    isLeftClick: function isLeftClick(event) {
        return event.which && event.which === 1 || event.button && event.button === 1;
    },

    /**
     * @description Determine whether event was caused by a right mouse click.
     * @param event - {Event}
     * @returns {Boolean}
     */
    isRightClick: function isRightClick(event) {
        return event.which && event.which === 3 || event.button && event.button === 2;
    },

    /**
     * @description Stops an event from propagating.
     * @param event - {Event}
     * @param allowDefault - {Boolean} If true, we stop the event chain but still allow the default browser  behaviour (text selection, radio-button clicking, etc) Default false
     */
    stop: function stop(event, allowDefault) {

        if (!allowDefault) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        }

        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBubble = true;
        }
    },

    /**
     * @param event - {Event}
     * @param tagName - {string} html标签名
     * @returns {HTMLElement} The first node with the given tagName, starting from the node the event was triggered on and traversing the DOM upwards
     */
    findElement: function findElement(event, tagName) {
        var element = _SuperMap2.default.Event.element(event);
        while (element.parentNode && (!element.tagName || element.tagName.toUpperCase() != tagName.toUpperCase())) {
            element = element.parentNode;
        }
        return element;
    },

    /**
     * @description 监听事件，注册事件处理方法。
     * @param elementParam - {HTMLElement | string} 待监听的DOM对象或者其id标识。
     * @param name - {string} 监听事件的类别名称。
     * @param observer - {function} 注册的事件处理方法。
     * @param useCapture - {Boolean} 是否捕获。
     */
    observe: function observe(elementParam, name, observer, useCapture) {
        var element = _Util.Util.getElement(elementParam);
        useCapture = useCapture || false;

        if (name === 'keypress' && (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || element.attachEvent)) {
            name = 'keydown';
        }

        //if observers cache has not yet been created, create it
        if (!this.observers) {
            this.observers = {};
        }

        //if not already assigned, make a new unique cache ID
        if (!element._eventCacheID) {
            var idPrefix = "eventCacheID_";
            if (element.id) {
                idPrefix = element.id + "_" + idPrefix;
            }
            element._eventCacheID = _Util.Util.createUniqueID(idPrefix);
        }

        var cacheID = element._eventCacheID;

        //if there is not yet a hash entry for this element, add one
        if (!this.observers[cacheID]) {
            this.observers[cacheID] = [];
        }

        //add a new observer to this element's list
        this.observers[cacheID].push({
            'element': element,
            'name': name,
            'observer': observer,
            'useCapture': useCapture
        });

        //add the actual browser event listener
        if (element.addEventListener) {
            element.addEventListener(name, observer, useCapture);
        } else if (element.attachEvent) {
            element.attachEvent('on' + name, observer);
        }
    },

    /**
     * @description Given the id of an element to stop observing, cycle through the
     *   element's cached observers, calling stopObserving on each one,
     *   skipping those entries which can no longer be removed.
     *
     * @param elementParam - {HTMLElement | string}
     */
    stopObservingElement: function stopObservingElement(elementParam) {
        var element = _Util.Util.getElement(elementParam);
        var cacheID = element._eventCacheID;

        this._removeElementObservers(_SuperMap2.default.Event.observers[cacheID]);
    },

    /*
     * @param elementObservers - {Array<Object>} Array of (element, name,
     *                                         observer, usecapture) objects,
     *                                         taken directly from hashtable
     */
    _removeElementObservers: function _removeElementObservers(elementObservers) {
        if (elementObservers) {
            for (var i = elementObservers.length - 1; i >= 0; i--) {
                var entry = elementObservers[i];
                var args = new Array(entry.element, entry.name, entry.observer, entry.useCapture);
                var removed = _SuperMap2.default.Event.stopObserving.apply(this, args);
            }
        }
    },

    /**
     * @description 移除事件监听和注册的事件处理方法。注意：事件的移除和监听相对应，移除时的各属性信息必须监听时
     * 保持一致才能确保事件移除成功。
     * @param elementParam - {HTMLElement | string} 被监听的DOM元素或者其id。
     * @param name - {string} 需要移除的被监听事件名称。
     * @param observer - {function} 需要移除的事件处理方法。
     * @param useCapture - {Boolean} 是否捕获。
     * @returns {Boolean} Whether or not the event observer was removed
     */
    stopObserving: function stopObserving(elementParam, name, observer, useCapture) {
        useCapture = useCapture || false;

        var element = _Util.Util.getElement(elementParam);
        var cacheID = element._eventCacheID;

        if (name === 'keypress') {
            if (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || element.detachEvent) {
                name = 'keydown';
            }
        }

        // find element's entry in this.observers cache and remove it
        var foundEntry = false;
        var elementObservers = _SuperMap2.default.Event.observers[cacheID];
        if (elementObservers) {

            // find the specific event type in the element's list
            var i = 0;
            while (!foundEntry && i < elementObservers.length) {
                var cacheEntry = elementObservers[i];

                if (cacheEntry.name === name && cacheEntry.observer === observer && cacheEntry.useCapture === useCapture) {

                    elementObservers.splice(i, 1);
                    if (elementObservers.length == 0) {
                        delete _SuperMap2.default.Event.observers[cacheID];
                    }
                    foundEntry = true;
                    break;
                }
                i++;
            }
        }

        //actually remove the event listener from browser
        if (foundEntry) {
            if (element.removeEventListener) {
                element.removeEventListener(name, observer, useCapture);
            } else if (element && element.detachEvent) {
                element.detachEvent('on' + name, observer);
            }
        }
        return foundEntry;
    },

    /**
     * @description Cycle through all the element entries in the events cache and call
     *   stopObservingElement on each.
     */
    unloadCache: function unloadCache() {
        // check for SuperMap.Event before checking for observers, because
        // SuperMap.Event may be undefined in IE if no map instance was
        // created
        if (_SuperMap2.default.Event && _SuperMap2.default.Event.observers) {
            for (var cacheID in _SuperMap2.default.Event.observers) {
                var elementObservers = _SuperMap2.default.Event.observers[cacheID];
                _SuperMap2.default.Event._removeElementObservers.apply(this, [elementObservers]);
            }
            _SuperMap2.default.Event.observers = false;
        }
    },

    CLASS_NAME: "SuperMap.Event"
};

_SuperMap2.default.Event = Event;
/* prevent memory leaks in IE */
_SuperMap2.default.Event.observe(window, 'unload', _SuperMap2.default.Event.unloadCache, false);

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  SuperMap.Size
 * @description 此类描绘一对高宽值的实例。
 */
var Size = function () {

  /**
   * 创建Size实例。
   *
   * 例如:
   * (start code)
   * var size = new SuperMap.Size(31,46);
   * (end)
   *
   * Parameters:
   * w - {Number} 宽度，默认值为0.0
   * h - {Number} 高度 ，默认值为0.0
   */


  /**
   * APIProperty: w
   * {Number} 宽，默认值为0.0
   */
  function Size(w, h) {
    _classCallCheck(this, Size);

    this.w = 0.0;
    this.h = 0.0;
    this.CLASS_NAME = "SuperMap.Size";

    this.w = w ? parseFloat(w) : this.w;
    this.h = w ? parseFloat(h) : this.h;
  }

  /**
   * APIMethod: toString
   * 返回此对象的字符串形式
   *
   * 例如:
   * (start code)
   * var size = new SuperMap.Size(10,5);
   * var str = size.toString();
   * (end)
   *
   * Returns:
   * {String} 例如："w=10,h=5"
   */


  /**
   * APIProperty: h
   * {Number} 高，默认值为0.0
   */


  _createClass(Size, [{
    key: "toString",
    value: function toString() {
      return "w=" + this.w + ",h=" + this.h;
    }

    /**
     * APIMethod: clone
     * 克隆当前size对象.
     *
     * 例如:
     * (start code)
     * var size = new SuperMap.Size(31,46);
     * var size2 = size.clone();
     * (end)
     *
     * Returns:
     * {<SuperMap.Size>}  返回一个新的与当前size对象有相同宽、高的Size对象。
     */

  }, {
    key: "clone",
    value: function clone() {
      return new Size(this.w, this.h);
    }

    /**
     *
     * APIMethod: equals
     * 比较两个size对象是否相等。
     *
     * 例如:
     * (start code)
     * var size = new SuperMap.Size(31,46);
     * var size2 = new SuperMap.Size(31,46);
     * var isEquals = size.equals(size2);
     * (end)
     *
     * Parameters:
     * sz - {<SuperMap.Size>} 用于比较相等的Size对象。
     *
     * Returns:
     * {Boolean} 传入的size和当前size高宽相等，注意：如果传入的size为空则返回false
     *
     */

  }, {
    key: "equals",
    value: function equals(sz) {
      var equals = false;
      if (sz != null) {
        equals = this.w === sz.w && this.h === sz.h || isNaN(this.w) && isNaN(this.h) && isNaN(sz.w) && isNaN(sz.h);
      }
      return equals;
    }

    /**
     *
     * APIMethod: destroy
     * 销毁此对象。
     * 销毁后此对象的所有属性为null，而不是初始值。
     *
     * 例如:
     * (start code)
     * var size = new SuperMap.Size(31,46);
     * size.destroy();
     * (end)
     *
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.w = null;
      this.h = null;
    }
  }]);

  return Size;
}();

exports.default = Size;

_SuperMap2.default.Size = Size;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Collection2 = __webpack_require__(14);

var _Collection3 = _interopRequireDefault(_Collection2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.MultiPoint
 * @classdesc 几何对象多点类。
 * @extends {SuperMap.Geometry.Collection}
 * @param components - {Array<SuperMap.Geometry.Point>}点对象数组。
 * @example
 * var point1 = new SuperMap.Geometry.Point(5,6);
 * var poine2 = new SuperMap.Geometry.Point(7,8);
 * var multiPoint = new SuperMap.Geometry.MultiPoint([point1,point2]);
 */
var MultiPoint = function (_Collection) {
  _inherits(MultiPoint, _Collection);

  function MultiPoint(components) {
    _classCallCheck(this, MultiPoint);

    var _this = _possibleConstructorReturn(this, (MultiPoint.__proto__ || Object.getPrototypeOf(MultiPoint)).call(this, components));

    _this.componentTypes = ["SuperMap.Geometry.Point"];
    _this.CLASS_NAME = "SuperMap.Geometry.MultiPoint";
    return _this;
  }

  /**
   * @function SuperMap.Geometry.MultiPoint.prototype.addPoint
   * @description 添加点，封装了 {@link SuperMap.Geometry.Collection|SuperMap.Geometry.Collection.addComponent}方法。
   * @param point - {SuperMap.Geometry.Point} 添加的点。
   * @param index - {integer} 可选的下标。
   */


  /**
   * @member SuperMap.Geometry.MultiPoint.prototype.componentTypes -{Array<string>}
   * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
   * @readonly
   * @default ["{@link SuperMap.Geometry.Point}"]
   */


  _createClass(MultiPoint, [{
    key: 'addPoint',
    value: function addPoint(point, index) {
      this.addComponent(point, index);
    }

    /**
     * @function SuperMap.Geometry.MultiPoint.prototype.removePoint
     * @description 移除点,封装了 {@link SuperMap.Geometry.Collection|SuperMap.Geometry.Collection.removeComponent} 方法。
     * @param point - {SuperMap.Geometry.Point} 移除的点对象。
     */

  }, {
    key: 'removePoint',
    value: function removePoint(point) {
      this.removeComponent(point);
    }
  }]);

  return MultiPoint;
}(_Collection3.default);

exports.default = MultiPoint;

_SuperMap2.default.Geometry.MultiPoint = MultiPoint;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Collection2 = __webpack_require__(14);

var _Collection3 = _interopRequireDefault(_Collection2);

var _Point = __webpack_require__(11);

var _Point2 = _interopRequireDefault(_Point);

var _LineString = __webpack_require__(23);

var _LineString2 = _interopRequireDefault(_LineString);

var _LinearRing = __webpack_require__(38);

var _LinearRing2 = _interopRequireDefault(_LinearRing);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.Polygon
 * @classdesc  多边形几何对象类。
 * @extends {SuperMap.Geometry.Collection}
 * @param components - {Array<SuperMap.Geometry.LinearRing>} 用来生成多边形的线环数组。
 * @example
 * var points =[new SuperMap.Geometry.Point(0,4010338),
 *      new SuperMap.Geometry.Point(1063524,4010338),
 *      new SuperMap.Geometry.Point(1063524,3150322),
 *      new SuperMap.Geometry.Point(0,3150322)
 *  ],
 *  var linearRings = new SuperMap.Geometry.LinearRing(points),
 *  var  region = new SuperMap.Geometry.Polygon([linearRings]);
 */
var Polygon = function (_Collection) {
    _inherits(Polygon, _Collection);

    function Polygon(components) {
        _classCallCheck(this, Polygon);

        var _this = _possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, components));

        _this.componentTypes = ["SuperMap.Geometry.LinearRing"];
        _this.CLASS_NAME = "SuperMap.Geometry.Polygon";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.Polygon.prototype.getArea
     * @description 获得区域面积，从区域的外部口径减去计此区域内部口径算所得的面积。
     * @returns {float} 几何对象的面积。
     */


    /**
     * @member SuperMap.Geometry.Polygon.prototype.componentTypes -{Array<string>}
     * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
     * @readonly
     * @default ["{@link SuperMap.Geometry.LinearRing}"]
     */


    _createClass(Polygon, [{
        key: 'getArea',
        value: function getArea() {
            var area = 0.0;
            if (this.components && this.components.length > 0) {
                area += Math.abs(this.components[0].getArea());
                for (var i = 1, len = this.components.length; i < len; i++) {
                    area -= Math.abs(this.components[i].getArea());
                }
            }
            return area;
        }

        /**
         * @function SuperMap.Geometry.Polygon.prototype.getGeodesicArea
         * @description 计算投影到球面上的多边形近似面积。
         * @param projection - {SuperMap.Projection} 空间参考系统的几何坐标。如果没有设置，默认 WGS84。
         * @returns {float} 多边形近似测地面积。
         */

    }, {
        key: 'getGeodesicArea',
        value: function getGeodesicArea(projection) {
            var area = 0.0;
            if (this.components && this.components.length > 0) {
                area += Math.abs(this.components[0].getGeodesicArea(projection));
                for (var i = 1, len = this.components.length; i < len; i++) {
                    area -= Math.abs(this.components[i].getGeodesicArea(projection));
                }
            }
            return area;
        }

        /**
         * @function SuperMap.Geometry.Polygon.prototype.containsPoint
         * @description Test if a point is inside a polygon.  Points on a polygon edge are
         *     considered inside.
         * @param point - {SuperMap.Geometry.Point}
         * @returns {Boolean | number} The point is inside the polygon.  Returns 1 if the
         *     point is on an edge.  Returns boolean otherwise.
         */

    }, {
        key: 'containsPoint',
        value: function containsPoint(point) {
            var numRings = this.components.length;
            var contained = false;
            if (numRings > 0) {
                // check exterior ring - 1 means on edge, boolean otherwise
                contained = this.components[0].containsPoint(point);
                if (contained !== 1) {
                    if (contained && numRings > 1) {
                        // check interior rings
                        var hole;
                        for (var i = 1; i < numRings; ++i) {
                            hole = this.components[i].containsPoint(point);
                            if (hole) {
                                if (hole === 1) {
                                    // on edge
                                    contained = 1;
                                } else {
                                    // in hole
                                    contained = false;
                                }
                                break;
                            }
                        }
                    }
                }
            }
            return contained;
        }

        /**
         * @function SuperMap.Geometry.Polygon.prototype.intersects
         * @description 判断两个几何对象是否相交。
         * @param geometry - {SuperMap.Geometry} 任何类型的几何对象。
         * @returns {Boolean} 两个几何对象是否相交。
         */

    }, {
        key: 'intersects',
        value: function intersects(geometry) {
            var intersect = false;
            var i, len;
            if (geometry.CLASS_NAME === "SuperMap.Geometry.Point") {
                intersect = this.containsPoint(geometry);
            } else if (geometry.CLASS_NAME === "SuperMap.Geometry.LineString" || geometry.CLASS_NAME === "SuperMap.Geometry.LinearRing") {
                // check if rings/linestrings intersect
                for (i = 0, len = this.components.length; i < len; ++i) {
                    intersect = geometry.intersects(this.components[i]);
                    if (intersect) {
                        break;
                    }
                }
                if (!intersect) {
                    // check if this poly contains points of the ring/linestring
                    for (i = 0, len = geometry.components.length; i < len; ++i) {
                        intersect = this.containsPoint(geometry.components[i]);
                        if (intersect) {
                            break;
                        }
                    }
                }
            } else {
                for (i = 0, len = geometry.components.length; i < len; ++i) {
                    intersect = this.intersects(geometry.components[i]);
                    if (intersect) {
                        break;
                    }
                }
            }
            // check case where this poly is wholly contained by another
            if (!intersect && geometry.CLASS_NAME === "SuperMap.Geometry.Polygon") {
                // exterior ring points will be contained in the other geometry
                var ring = this.components[0];
                for (i = 0, len = ring.components.length; i < len; ++i) {
                    intersect = geometry.containsPoint(ring.components[i]);
                    if (intersect) {
                        break;
                    }
                }
            }
            return intersect;
        }

        /**
         * @function SuperMap.Geometry.Polygon.prototype.distanceTo
         * @description 计算两个几何对象间的最小距离（x-y平面坐标系下）。
         * @param geometry - {SuperMap.Geometry} 目标几何对象。
         * @param options - {Object} 距离计算需要设置的可选属性。<br>
         *
         * Valid options:<br>
         * details - {Boolean} 返回距离计算的细节。默认为false。<br>
         * edge - {Boolean} 计算一个几何对象到目标几何对象边缘的最近距离。默认为true。 如果设为true，<br>
         * 一个几何图形完全包含在目标几何对象中时，调用distanceTo返回非零结果，如果false，两个几何对象相交情况下
         * 调用distanceTo结果返回0，而且如果false，将不返距离。
         * @returns {number | Object} 返回一个几何对象到目标几何对象的距离。
         */

    }, {
        key: 'distanceTo',
        value: function distanceTo(geometry, options) {
            var edge = !(options && options.edge === false);
            var result;
            // this is the case where we might not be looking for distance to edge
            if (!edge && this.intersects(geometry)) {
                result = 0;
            } else {
                result = _get(Polygon.prototype.__proto__ || Object.getPrototypeOf(Polygon.prototype), 'distanceTo', this).call(this, geometry, options);
            }
            return result;
        }

        /**
         * @function SuperMap.Geometry.Polygon.createRegularPolygon
         * @description 创建 RegularPolygon 对象。
         * @param origin - {SuperMap.Geometry.Point} 多边形的中心 。
         * @param radius - {float} 半径。
         * @param sides - {integer} 边数，20个近似一个圆。
         * @param rotation - {float} 旋转角度，单位为degrees。
         * @example
         * var sides = 50;
         * var origin = new SuperMap.Geometry.Point(5,0);
         * var polygon = SuperMap.Geometry.Polygon.createRegularPolygon(origin,6,sides,270);
         */

    }], [{
        key: 'createRegularPolygon',
        value: function createRegularPolygon(origin, radius, sides, rotation) {
            var angle = Math.PI * (1 / sides - 1 / 2);
            if (rotation) {
                angle += rotation / 180 * Math.PI;
            }
            var rotatedAngle, x, y;
            var points = [];
            for (var i = 0; i < sides; ++i) {
                rotatedAngle = angle + i * 2 * Math.PI / sides;
                x = origin.x + radius * Math.cos(rotatedAngle);
                y = origin.y + radius * Math.sin(rotatedAngle);
                points.push(new _Point2.default(x, y));
            }
            var ring = new _LinearRing2.default(points);
            return new Polygon([ring]);
        }
    }, {
        key: 'createRegularPolygonCurve',


        /**
         * @function SuperMap.Geometry.Polygon.createRegularPolygonCurve
         * @description 创建扇形对象。
         * @param origin - {SuperMap.Geometry.Point} 多边形的中心 。
         * @param radius - {float} 半径。
         * @param sides - {integer} 边数，50个近似一个扇形。
         * @param r - {integer}
         * @param angel - {float} 旋转角度，单位为degrees。沿着x轴正方向的逆时针方向。
         * @param resolution - {float} 当前地图的分辨率.,固定大小下输入，其他情况不需要此参数
         * 备注：Geometry内部单位均为地理单位，默认用户输入的参数也为地理单位，如果传入resolution，则半径则为
         * 为像素单位，内部会根据像素值和分辨率获取地理大小后在进行构造Geometry，但最终的Geometry均为地理单位。
         * @returns {SuperMap.Geometry.Polygon} 几何面对象。
         * @example
         * var sides = 50;
         * var origin = new SuperMap.Geometry.Point(5,0);
         * var polygon = SuperMap.Geometry.Polygon.createRegularPolygonCurve(origin,6,sides,270);
         */
        value: function createRegularPolygonCurve(origin, radius, sides, r, angel, resolution) {
            if (resolution == undefined) resolution = 1;

            var rR = r * Math.PI / (180 * sides);

            var rotatedAngle, x, y;
            var points = [];
            for (var i = 0; i < sides; ++i) {
                rotatedAngle = rR * i;
                x = origin.x + radius * resolution * Math.cos(rotatedAngle);
                y = origin.y + radius * resolution * Math.sin(rotatedAngle);
                points.push(new _Point2.default(x, y));
            }
            rotatedAngle = r * Math.PI / 180;
            x = origin.x + radius * resolution * Math.cos(rotatedAngle);
            y = origin.y + radius * resolution * Math.sin(rotatedAngle);
            points.push(new _Point2.default(x, y));

            points.push(origin);

            var ring = new _LinearRing2.default(points);
            ring.rotate(parseFloat(angel), origin);
            var geo = new Polygon([ring]);
            geo.origin = origin;
            geo.radius = radius;
            geo.r = r;
            geo.angel = angel;
            geo.sides = sides;
            geo.polygonType = "Curve";
            return geo;
        }
    }, {
        key: 'createRegularPolygonTriangle',


        /**
         * @function SuperMap.Geometry.Polygon.createRegularPolygonTriangle
         * @description 创建4G三角形,电信行业4G专业符号形容类似为：-▷。
         * @param origin - {SuperMap.Geometry.Point} 三角形的原点 。
         * @param height - {Float} 外接矩形的高度。
         * @param width - {Float} 外接矩形的宽度。
         * @param lineLength - {Float} 线长度。
         * @param angel - {Float} 旋转角度，单位为degrees,沿着x轴正方向的逆时针方向.。
         * @param resolution - {Float} 当前地图的分辨率.,固定大小下输入，其他情况不需要此参数
         * 备注：Geometry内部单位均为地理单位，默认用户输入的参数也为地理单位，如果传入resolution，则height、width、lineLength则为
         * 为像素单位，内部会根据像素值和分辨率获取地理大小后在进行构造Geometry，但最终的Geometry均为地理单位。
         * @returns {SuperMap.Geometry.Collection} 几何对象集合，面对象&线对象。
         */
        value: function createRegularPolygonTriangle(origin, height, width, lineLength, angel, resolution) {
            if (resolution == undefined) resolution = 1;

            var lineList = [];
            lineList.push(origin);
            lineList.push(new _Point2.default(origin.x + lineLength * resolution, origin.y));
            var geoline = new _LineString2.default(lineList);
            geoline.rotate(parseFloat(angel), origin);

            var triangleList = [];
            triangleList.push(new _Point2.default(origin.x + height * resolution, origin.y));
            triangleList.push(new _Point2.default(origin.x + lineLength * resolution, origin.y + width * resolution / 2));
            triangleList.push(new _Point2.default(origin.x + lineLength * resolution, origin.y - width * resolution / 2));
            var geoTriangle = new _LinearRing2.default(triangleList);
            geoTriangle.rotate(parseFloat(angel), origin);
            var geo = new _Collection3.default([geoline, geoTriangle]);
            geo.origin = origin;
            geo.height = height;
            geo.width = width;
            geo.lineLength = lineLength;
            geo.angel = angel;
            geo.polygonType = "Triangle";
            return geo;
        }
    }, {
        key: 'createBsplinesurface',


        /**
         * @function SuperMap.Geometry.Polygon.createBsplinesurface
         * @description 创建3G B样条曲面，电信3G专业符号，由B样条曲线模拟生成。
         * @param origin - {SuperMap.Geometry.Point} 曲面的原点 。
         * @param height - {float} 外接矩形的高度。
         * @param width - {float} 外接矩形的宽度。
         * @param angel - {float} 旋转角度，单位为degrees，沿着x轴正方向的逆时针方向。
         * @param resolution - {float} 当前地图的分辨率，固定大小下输入，其他情况不需要此参数。
         * @param k - {number} 递推次数，可以控制曲线的光滑度。
         * 备注：Geometry内部单位均为地理单位，默认用户输入的参数也为地理单位，如果传入resolution，则height、width
         * 为像素单位，内部会根据像素值和分辨率获取地理大小后在进行构造Geometry，但最终的Geometry均为地理单位。
         * @returns {SuperMap.Geometry.Polygon} 几何面对象。
         */
        value: function createBsplinesurface(origin, height, width, angel, resolution, k) {
            if (resolution == undefined) resolution = 1;

            if (k == undefined) k = 10;

            var pointList = [];
            pointList.push(origin);
            pointList.push(origin);

            pointList.push(new _Point2.default(origin.x + height * resolution * 2 / 3, origin.y + width * resolution / 2));
            pointList.push(new _Point2.default(origin.x + height * resolution, origin.y + width * resolution / 2));
            pointList.push(new _Point2.default(origin.x + height * resolution, origin.y - width * resolution / 2));
            pointList.push(new _Point2.default(origin.x + height * resolution * 2 / 3, origin.y - width * resolution / 2));

            pointList.push(origin);
            pointList.push(origin);

            var pointList2 = [];
            var i, j, a0, a1, a2, dt, t1, t2;
            var t_x, t_y;
            var n = pointList.length;
            dt = 1.0 / k;

            pointList2.push(new _Point2.default((pointList[0].x + pointList[1].x) / 2, (pointList[0].y + pointList[1].y) / 2));

            for (i = 1; i < n - 1; i++) {
                for (j = 0; j <= k; j++) {
                    t1 = j * dt;
                    t2 = t1 * t1;

                    a0 = (t2 - 2 * t1 + 1) / 2.0;
                    a1 = (2 * t1 - 2 * t2 + 1) / 2.0;
                    a2 = t2 / 2.0;

                    t_x = a0 * pointList[i - 1].x + a1 * pointList[i].x + a2 * pointList[i + 1].x;
                    t_y = a0 * pointList[i - 1].y + a1 * pointList[i].y + a2 * pointList[i + 1].y;
                    pointList2.push(new _Point2.default(t_x, t_y));
                }
            }

            var ring = new _LinearRing2.default(pointList2);
            ring.rotate(parseFloat(angel), origin);
            var geo = new _Collection3.default([ring]);
            geo.origin = origin;
            geo.height = height;
            geo.width = width;
            geo.angel = angel;
            geo.polygonType = "Bspline";
            return geo;
        }
    }]);

    return Polygon;
}(_Collection3.default);

exports.default = Polygon;


_SuperMap2.default.Geometry.Polygon = Polygon;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.JoinItem
 * @classdesc 连接信息类。
 * 该类用于矢量数据集与外部表的连接。外部表可以为另一个矢量数据集（其中纯属性数据集中没有空间几何信息）所对应的 DBMS 表，也可以是用户自建的业务表。需要注意的是，矢量数据集与外部表必须属于同一数据源。表之间的联系的建立有两种方式，一种是连接（join），一种是关联（link）。连接，实际上是依据相同的字段将一个外部表追加到指定的表；而关联是基于一个相同的字段定义了两个表格之间的联系，但不是实际的追加。用于连接两个表的字段的名称不一定相同，但类型必须一致。当两个表格之间建立了连接，通过对主表进行操作，可以对外部表进行查询，制作专题图以及分析等。当两个表格之间是一对一或多对一的关系时，可以使用 join 连接。当为多对一的关系时，允许指定多个字段之间的关联。(注意：SuperMap.JoinItem 目前支持左连接和内连接，不支持全连接和右连接，UDB 引擎不支持内连接。并且用于建立连接的两个表必须在同一个数据源下。)
 * @param options - {Object} 可選参数。如:</br>
 *        foreignTableName - {string} 外部表的名称。</br>
 *        joinFilter - {string} 矢量数据集与外部表之间的连接表达式，即设定两个表之间关联的字段。</br>
 *        joinType - {JoinType} 两个表之间连接类型。</br>
 * @example 下面以SQL查询说明joinItem的使用方法：
 *(start code)
 *   function queryBySQL() {
     *       // 设置与外部表的连接信息
     *       var joinItem = new SuperMap.JoinItem({
     *           foreignTableName: "foreignTable",
     *           joinFilter: "foreignTable.CONTINENT = Countries.CONTINENT",
     *           joinType: "LEFTJOIN"
     *       })
     *       var queryParam, queryBySQLParams, queryBySQLService;
     *       // 设置查询参数，在查询参数中添加joinItem关联条件信息
     *       queryParam = new SuperMap.FilterParameter({
     *            name: "Countries@World",
     *            joinItems: [joinItem]
     *         }),
     *       queryBySQLParams = new SuperMap.QueryBySQLParameters({
     *             queryParams: [queryParam]
     *         }),
     *       queryBySQLService = new SuperMap.QueryBySQLService(url, {
     *             eventListeners: { "processCompleted": processCompleted, "processFailed": processFailed}
     *         });
     *       queryBySQLService.processAsync(queryBySQLParams);
     *  }
 *  function processCompleted(queryEventArgs) {//todo}
 *  function processFailed(e) {//todo}
 * (end)
 */
var JoinItem = function () {

    /**
     * @member SuperMap.JoinItem.prototype.joinFilter -{string}
     * @description 矢量数据集与外部表之间的连接表达式，即设定两个表之间关联的字段。
     * 例如，将房屋面数据集（Building）的 district 字段与房屋拥有者的纯属性数据集（Owner）的 region 字段相连接，
     * 两个数据集对应的表名称分别为 Table_Building 和 Table_Owner，
     * 则连接表达式为 Table_Building.district = Table_Owner.region。
     * 当有多个字段相连接时，用 AND 将多个表达式相连。
     */
    function JoinItem(options) {
        _classCallCheck(this, JoinItem);

        this.foreignTableName = null;
        this.joinFilter = null;
        this.joinType = null;
        this.CLASS_NAME = "SuperMap.JoinItem";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.JoinItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.JoinItem.prototype.joinType -{JoinType}
     * @description 两个表之间连接类型。
     * 连接类型决定了对两个表进行连接查询后返回的记录的情况。
     */

    /**
     * @member SuperMap.JoinItem.prototype.foreignTableName -{string}
     * @description 外部表的名称。
     * 如果外部表的名称是以“表名@数据源名”命名方式，则该属性只需赋值表名。
     * 例如：外部表 Name@changchun，Name 为表名，changchun 为数据源名称，则该属性的赋值应为：Name。
     */


    _createClass(JoinItem, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.foreignTableName = null;
            me.joinFilter = null;
            me.joinType = null;
        }

        /**
         * @function SuperMap.JoinItem.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: "toServerJSONObject",
        value: function toServerJSONObject() {
            var dataObj = {};
            dataObj = _SuperMap2.default.Util.copyAttributes(dataObj, this);
            //joinFilter基本是个纯属性对象，这里不再做转换
            return dataObj;
        }
    }]);

    return JoinItem;
}();

exports.default = JoinItem;

_SuperMap2.default.JoinItem = JoinItem;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.LabelMatrixCell
 * @classdesc 矩阵标签元素抽象类。
 * @description 该类可以包含 n*n 个矩阵标签元素，矩阵标签元素的类型可以是图片，符号，标签专题图等。
 *              符号类型的矩阵标签元素类、图片类型的矩阵标签元素类和专题图类型的矩阵标签元素类均继承自该类。
 */
var LabelMatrixCell = function LabelMatrixCell() {
  _classCallCheck(this, LabelMatrixCell);

  this.CLASS_NAME = "LabelMatrixCell";
};

exports.default = LabelMatrixCell;


_SuperMap2.default.LabelMatrixCell = LabelMatrixCell;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _PointWithMeasure = __webpack_require__(224);

var _PointWithMeasure2 = _interopRequireDefault(_PointWithMeasure);

var _Collection2 = __webpack_require__(14);

var _Collection3 = _interopRequireDefault(_Collection2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Route
 * @classdesc
 * 路由对象类。路由对象为一系列有序的带有属性值 M 的 x，y 坐标对，其中 M 值为该结点的距离属性（到已知点的距离）。
 * @param points - {{Array<SuperMap.Geometry>}} 形成路由对象的线数组。
 * @param  options - {Object} 可选参数。如:</br>
 *         id - {number}路由对象在数据库中的id。</br>
 *         length - {number}路由对象的长度。</br>
 *         maxM - {number}最大线性度量值，即所有结点到起始点的量算距离中最大值。</br>
 *         minM - {number}最小线性度量值，即所有结点到起始点的量算距离中最小值。</br>
 *         type - {string} 数据类型，如："LINEM"</br>
 * @extends SuperMap.Geometry.Collection
 */
var Route = function (_Collection) {
    _inherits(Route, _Collection);

    /**
     * @member SuperMap.Route.prototype.type -{string}
     * @description 服务端几何对象类型。
     */


    /**
     * @member SuperMap.Route.prototype.parts -{Array<number>}
     * @description 服务端几何对象中各个子对象所包含的节点个数。
     */


    /**
     *  @member SuperMap.Route.prototype.maxM -{number}
     *  @description 最大线性度量值，即所有结点到起始点的量算距离中最大值。
     */


    /**
     * @member SuperMap.Route.prototype.style -{string}
     */


    /**
     * @member SuperMap.Route.prototype.id -{number}
     * @description 路由对象在数据库中的id。
     */
    function Route(points, options) {
        _classCallCheck(this, Route);

        var _this = _possibleConstructorReturn(this, (Route.__proto__ || Object.getPrototypeOf(Route)).call(this, points, options));

        _this.id = null;
        _this.center = null;
        _this.style = null;
        _this.length = null;
        _this.maxM = null;
        _this.minM = null;
        _this.parts = null;
        _this.points = null;
        _this.type = null;
        _this.componentTypes = ["SuperMap.Geometry.LinearRing", "SuperMap.Geometry.LineString"];
        _this.CLASS_NAME = "SuperMap.Route";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     *
     * @function SuperMap.Route.prototype.toJson
     * @description 转换为json对象。
     */


    /**
     * @member SuperMap.Route.prototype.componentTypes -{string}
     */


    /**
     * @member SuperMap.Route.prototype.points -{Array<Object>}
     * @description 路由对象的所有路由点。
     * @example
     * (start code)
     * [
     *  {
     *      "measure": 0,
     *      "y": -4377.027184298267,
     *      "x": 4020.0045221720466
     *  },
     *  {
     *      "measure": 37.33288381391519,
     *      "y": -4381.569363260499,
     *      "x": 4057.0600591960642
     *  }
     * ]
     * (end)
     */


    /**
     * @member SuperMap.Route.prototype.minM -{number}
     * @description 最小线性度量值，即所有结点到起始点的量算距离中最小值。
     */


    /**
     * @member SuperMap.Route.prototype.length -{number}
     * @description 路由对象的长度。
     * 单位与数据集的单位相同。
     */


    /**
     * @member SuperMap.Route.prototype.center -{number}
     */


    _createClass(Route, [{
        key: 'toJson',
        value: function toJson() {
            var result = "{";
            if (this.id != null && this.id != undefined) {
                result += "\"id\":" + this.id + ",";
            }
            if (this.center != null && this.center != undefined) {
                result += "\"center\":" + this.center + ",";
            }
            if (this.style != null && this.style != undefined) {
                result += "\"style\":" + this.style + ",";
            }
            if (this.length != null && this.length != undefined) {
                result += "\"length\":" + this.length + ",";
            }
            if (this.maxM != null && this.maxM != undefined) {
                result += "\"maxM\":" + this.maxM + ",";
            }
            if (this.minM != null && this.minM != undefined) {
                result += "\"minM\":" + this.minM + ",";
            }
            if (this.type != null && this.type != undefined) {
                result += "\"type\":\"" + this.type + "\",";
            }
            if (this.parts != null && this.parts != undefined) {
                result += "\"parts\":[" + this.parts[0];

                for (var i = 1; i < this.parts.length; i++) {
                    result += "," + this.parts[i];
                }
                result += "],";
            }
            if (this.components != null && this.components.length > 0) {
                result += "\"points\":[";
                for (var j = 0, len = this.components.length; j < len; j++) {
                    for (var k = 0, len2 = this.components[j].components.length; k < len2; k++) {
                        result += this.components[j].components[k].toJson() + ",";
                    }
                }
                result = result.replace(/,$/g, '');
                result += "]";
            }
            result = result.replace(/,$/g, '');
            result += "}";
            return result;
        }

        /**
         * @inheritDoc
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.id = null;
            me.center = null;
            me.style = null;
            me.length = null;
            me.maxM = null;
            me.minM = null;
            me.type = null;
            me.parts = null;
            me.components.length = 0;
            me.components = null;
            me.componentTypes = null;
        }

        /**
         * @function SuperMap.Route.fromJson
         * @description  将 JSON 对象转换为 SuperMap.Route 对象。
         * @param jsonObject - {Object} JSON 对象表示的路由对象。
         * @return {SuperMap.Route} 转化后的 Route 对象。
         */

    }], [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }

            var geoParts = jsonObject.parts || [],
                geoPoints = jsonObject.points || [],
                len = geoParts.length,
                lineList = [];
            if (len > 0) {
                for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {
                    for (var j = 0; j < geoParts[i]; j++) {
                        pointList.push(_PointWithMeasure2.default.fromJson(geoPoints[pointIndex + j]));
                    }
                    pointIndex += geoParts[i];
                    //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                    if (pointList[0].equals(pointList[geoParts[i] - 1])) {
                        lineList.push(new _SuperMap2.default.Geometry.LinearRing(pointList));
                    } else {
                        lineList.push(new _SuperMap2.default.Geometry.LineString(pointList));
                    }
                    pointList = [];
                }
            } else {
                return null;
            }

            return new Route(lineList, {
                id: jsonObject.id,
                center: jsonObject.center,
                style: jsonObject.style,
                length: jsonObject.length,
                maxM: jsonObject.maxM,
                minM: jsonObject.minM,
                type: jsonObject.type,
                parts: jsonObject.parts
            });
        }
    }]);

    return Route;
}(_Collection3.default);

exports.default = Route;


_SuperMap2.default.Route = Route;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeFlow
 * @classdesc 标签或符号流动显示和牵引线风格设置类。
 *              通过该类可以设置专题图中符号是否流动显示、是否使用牵引线以及牵引线风格。
 * @param options - {Object} 可选参数。如：<br>
 *        flowEnabled - {boolean} 是否流动显示标签或符号。<br>
 *        leaderLineDisplayed - {boolean} 是否显示标签或符号和它标注的对象之间的牵引线。<br>
 *        leaderLineStyle - {SuperMap.ServerStyle} 标签或符号与其标注对象之间牵引线的风格。
 */
var ThemeFlow = function () {

    /**
     * @member SuperMap.ThemeFlow.prototype.leaderLineDisplayed -{boolean}
     * @description 是否显示标签或符号和它标注的对象之间的牵引线。默认值为 false，即不显示标签或符号和它标注的对象之间的牵引线。<br>
     *              只有当 flowEnabled 为 true 时，牵引线才起作用。在当标签流动显示时，其位置不固定，由于牵引线始终指向要素的内点，<br>
     *              因而通过牵引线显示功能可以找到流动的标签或符号实际对应的要素。或者渲染符号偏移它所指向的对象时，图与对象之间可以采用牵引线进行连接。
     */
    function ThemeFlow(options) {
        _classCallCheck(this, ThemeFlow);

        this.flowEnabled = false;
        this.leaderLineDisplayed = false;
        this.leaderLineStyle = null;
        this.CLASS_NAME = "SuperMap.ThemeFlow";

        var me = this;
        me.leaderLineStyle = new _ServerStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeFlow.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeFlow.prototype.leaderLineStyle -{SuperMap.ServerStyle}
     * @description 标签或符号与其标注对象之间牵引线的风格。
     */


    /**
     * @member SuperMap.ThemeFlow.prototype.flowEnabled -{boolean}
     * @description 是否流动显示标签或符号。<br>
     *              对于标签专题图而言，对于跨越比较大的区域和线条状的几何对象，在一个地图窗口中不能完全显示的情况下，如果其标签位置比较固定，<br>
     *              在当前地图窗口中该对象的标签不可见，则需要通过平移地图来查看对象的标签信息。如果采用了流动显示的效果，在当前地图窗口中，对象即使是部分显示，<br>
     *              其标签也会显示在当前地图窗口中。当平移地图时，对象的标签会随之移动，以保证在当前地图窗口中部分或全部显示的对象其标签都可见，从而可以方便地查看各要素的标签信息。
     */


    _createClass(ThemeFlow, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.flowEnabled = null;
            me.leaderLineDisplayed = null;
            if (me.leaderLineStyle) {
                me.leaderLineStyle.destroy();
                me.leaderLineStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeFlow.fromObj
         * @description 从传入对象获取标签或符号流动显示和牵引线风格设置类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeFlow}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeFlow();
            _SuperMap2.default.Util.copy(res, obj);
            res.leaderLineStyle = _ServerStyle2.default.fromJson(obj.leaderLineStyle);
            return res;
        }
    }]);

    return ThemeFlow;
}();

exports.default = ThemeFlow;


_SuperMap2.default.ThemeFlow = ThemeFlow;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Theme2 = __webpack_require__(13);

var _Theme3 = _interopRequireDefault(_Theme2);

var _ThemeLabelItem = __webpack_require__(253);

var _ThemeLabelItem2 = _interopRequireDefault(_ThemeLabelItem);

var _ThemeLabelUniqueItem = __webpack_require__(255);

var _ThemeLabelUniqueItem2 = _interopRequireDefault(_ThemeLabelUniqueItem);

var _ThemeFlow = __webpack_require__(51);

var _ThemeFlow2 = _interopRequireDefault(_ThemeFlow);

var _ThemeOffset = __webpack_require__(53);

var _ThemeOffset2 = _interopRequireDefault(_ThemeOffset);

var _ThemeLabelText = __webpack_require__(254);

var _ThemeLabelText2 = _interopRequireDefault(_ThemeLabelText);

var _ThemeLabelAlongLine = __webpack_require__(251);

var _ThemeLabelAlongLine2 = _interopRequireDefault(_ThemeLabelAlongLine);

var _ThemeLabelBackground = __webpack_require__(252);

var _ThemeLabelBackground2 = _interopRequireDefault(_ThemeLabelBackground);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeLabel
 * @classdesc 标签专题图类。
 * @extends SuperMap.Theme
 * @param  options - {Object} 可选参数。如：<br>
 *         alongLine - {SuperMap.ThemeLabelAlongLine} 标签沿线标注方向样式类。<br>
 *         background - {SuperMap.ThemeLabelBackground} 标签专题图中标签的背景风格类。<br>
 *         flow - {SuperMap.ThemeFlow} 标签专题图标签流动显示与牵引线设置类。<br>
 *         items - {Array<SuperMap.ThemeUniqueItem>} 分段标签专题图的子项数组。<br>
 *         labelExpression - {string} 标注字段表达式。<br>
 *         labelOverLengthMode - {SuperMap.LabelOverLengthMode} 标签专题图中超长标签的处理模式枚举类。<br>
 *         matrixCells - {Array<SuperMap.LabelMatrixCell>} 矩阵标签元素数组。<br>
 *         maxLabelLength - {number}标签在每一行显示的最大长度。<br>
 *         numericPrecision - {number}通过该字段设置其显示的精度。<br>
 *         offset - {SuperMap.ThemeOffset} 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。<br>
 *         overlapAvoided - {boolean} 是否允许以文本避让方式显示文本。<br>
 *         rangeExpression - {string} 制作分段标签专题的分段字段或字段表达式。<br>
 *         smallGeometryLabeled - {boolean} 是否显示长度大于被标注对象本身长度的标签。<br>
 *         text - {SuperMap.ThemeLabelText} 标签中文本风格。<br>
 *         textSpace - {number} 沿线标注，相邻两个文字之间的间距，单位当前设置的字高。<br>
 *         memoryData - {SuperMap.ThemeMemoryData} 专题图内存数据。
 */
var ThemeLabel = function (_Theme) {
    _inherits(ThemeLabel, _Theme);

    /**
     * @member SuperMap.ThemeLabel.prototype.text -{SuperMap.ThemeLabelText}
     * @description 标签中文本风格。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.uniqueExpression -{string}
     * @description 用于制作单值专题图的字段或字段表达式。
     *              该字段值的数据类型可以为数值型或字符型。如果设置字段表达式，只能是相同数据类型字段间的运算。必设字段,必须与labelExpression一起使用
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.overlapAvoided -{boolean}
     * @description 是否允许以文本避让方式显示文本。默认值为 true， 即自动避免文本叠盖。只针对该标签专题图层中的文本数据。
     *               在标签重叠度很大的情况下，即使使用自动避让功能，可能也无法完全避免标签重叠现象。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.numericPrecision -{number}
     * @description 如果显示的标签内容为数字，通过该字段设置其显示的精度。例如标签对应的数字是8071.64529347，
     *              如果该属性为0时，显示8071；为1时，显示8071.6；为3时，则是8071.645。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.matrixCells -{Array<SuperMap.LabelMatrixCell>}
     * @description 矩阵标签元素数组，用于制作矩阵标签专题图。
     *              数组中可以放置符号类型的矩阵标签元素和图片类型的矩阵标签元素。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.labelExpression -{string}
     * @description 标注字段表达式。系统将 labelExpression 对应的字段或字段表达式的值以标签的形式显示在图层中。必设字段。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.items - {Array<SuperMap.ThemeUniqueItem>}
     * @description 分段标签专题图的子项数组。分段标签专题图使用 rangeExpression <br>
     *              指定数字型的字段作为分段数据，items 中的每个子对象的 [start，end) 分段值必须来源于属性 rangeExpression 的字段值。每个子项拥有自己的风格。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.background -{SuperMap.ThemeLabelBackground}
     * @description 标签专题图中标签的背景风格类。通过该字段可以设置标签的背景形状和风格。
     */
    function ThemeLabel(options) {
        _classCallCheck(this, ThemeLabel);

        var _this = _possibleConstructorReturn(this, (ThemeLabel.__proto__ || Object.getPrototypeOf(ThemeLabel)).call(this, "LABEL", options));

        _this.alongLine = null;
        _this.background = null;
        _this.flow = null;
        _this.items = null;
        _this.uniqueItems = null;
        _this.labelExpression = null;
        _this.labelOverLengthMode = _REST.LabelOverLengthMode.NONE;
        _this.matrixCells = null;
        _this.maxLabelLength = 256;
        _this.numericPrecision = 0;
        _this.offset = null;
        _this.overlapAvoided = true;
        _this.rangeExpression = null;
        _this.uniqueExpression = null;
        _this.smallGeometryLabeled = false;
        _this.text = null;
        _this.textSpace = 0;
        _this.CLASS_NAME = "SuperMap.ThemeLabel";

        var me = _this;
        me.alongLine = new _ThemeLabelAlongLine2.default();
        me.background = new _ThemeLabelBackground2.default();
        me.flow = new _ThemeFlow2.default();
        me.offset = new _ThemeOffset2.default();
        me.text = new _ThemeLabelText2.default();
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.textSpace -{number}
     * @description 沿线标注，相邻两个文字之间的间距，单位当前设置的字高
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.smallGeometryLabeled -{boolean}
     * @description 是否显示长度大于被标注对象本身长度的标签，默认为 false。在标签的长度大于线或者面对象本身的长度时，
     *              如果该值为 true，则标签文字会叠加在一起显示，为了清楚完整的显示该标签，
     *              可以采用换行模式来显示标签，但必须保证每行的长度小于对象本身的长度。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.rangeExpression -{string}
     * @description 制作分段标签专题的分段字段或字段表达式。该表达式对应的字段（或者字段表达式）的值应该为数值型。
     *              该字段与 items 分段子项联合使用，每个子项的起始值 [start，end)来源于 rangeExpression 字段值。
     *              最后 labelExpression 指定的标签字段（标签专题图要显示的具体内容）会根据分段子项的风格进行分段显示。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.offset -{SuperMap.ThemeOffset}
     * @description 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.maxLabelLength -{number}
     * @description 标签在每一行显示的最大长度，一个中文为两个字符。
     *              如果超过最大长度，可以采用两种方式来处理，一种是换行的模式进行显示，另一种是以省略号方式显示。默认最大长度为256个字符。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.labelOverLengthMode -{SuperMap.LabelOverLengthMode} 标签专题图中超长标签的处理模式枚举类。
     * 对于标签的长度超过设置的标签最大长度 maxLabelLength 时称为超长标签。默认为 SuperMap.LabelOverLengthMode.NONE。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.uniqueItems -{Array<SuperMap.ThemeLabelUniqueItem>}
     * @description 单值标签专题图子项数组。单值标签专题图使用 uniqueExpression单值标签专题图子项集合
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.flow -{SuperMap.ThemeFlow}
     * @description 标签专题图标签流动显示与牵引线设置类。通过该字段可以设置标签是否流动显示和牵引线风格。
     */


    /**
     * @member SuperMap.ThemeLabel.prototype.alongLine -{SuperMap.ThemeLabelAlongLine}
     * @description 标签沿线标注方向样式类。<br>
     *              在该类中可以设置标签是否沿线标注以及沿线标注的多种方式。沿线标注属性只适用于线数据集专题图。
     */


    _createClass(ThemeLabel, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeLabel.prototype.__proto__ || Object.getPrototypeOf(ThemeLabel.prototype), 'destroy', this).call(this);
            var me = this;
            me.alongLine = null;
            if (me.background) {
                me.background.destroy();
                me.background = null;
            }
            me.flow = null;
            if (me.items) {
                for (var i = 0, items = me.items, len = items.length; i < len; i++) {
                    items[i].destroy();
                }
                me.items = null;
            }
            if (me.uniqueItems) {
                for (var j = 0, uniqueItems = me.uniqueItems, uniqueLen = uniqueItems.length; j < uniqueLen; j++) {
                    uniqueItems[j].destory();
                }
                me.uniqueItems = null;
            }
            me.labelExpression = null;
            me.labelOverLengthMode = null;
            me.matrixCells = null;
            me.maxLabelLength = null;
            me.numericPrecision = null;
            me.overlapAvoided = null;
            me.rangeExpression = null;
            me.uniqueExpression = null;
            if (me.offset) {
                me.offset.destroy();
                me.offset = null;
            }
            me.overlapAvoided = null;
            me.smallGeometryLabeled = null;
            if (me.text) {
                me.text.destroy();
                me.text = null;
            }
            me.textSpace = null;
        }

        /**
         * @function SuperMap.ThemeLabel.prototype.toJSON
         * @description 将themeLabel对象转化为json字符串。
         * @return {string} 返回转换后的 JSON 字符串。
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            return _SuperMap2.default.Util.toJSON(this.toServerJSONObject());
        }

        /**
         * @function SuperMap.ThemeLabel.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj.type = this.type;
            obj.memoryData = this.memoryData;
            if (this.alongLine) {
                obj.alongLine = this.alongLine.isAlongLine;
                obj.alongLineDirection = this.alongLine.alongLineDirection;
                obj.angleFixed = this.alongLine.angleFixed;
                obj.isLabelRepeated = this.alongLine.isLabelRepeated;
                obj.labelRepeatInterval = this.alongLine.labelRepeatInterval;
                obj.repeatedLabelAvoided = this.alongLine.repeatedLabelAvoided;
                obj.repeatIntervalFixed = this.alongLine.repeatIntervalFixed;
            }
            if (this.offset) {
                obj.offsetFixed = this.offset.offsetFixed;
                obj.offsetX = this.offset.offsetX;
                obj.offsetY = this.offset.offsetY;
            }

            if (this.flow) {
                obj.flowEnabled = this.flow.flowEnabled;
                obj.leaderLineDisplayed = this.flow.leaderLineDisplayed;
                obj.leaderLineStyle = this.flow.leaderLineStyle;
            }
            if (this.text) {
                obj.maxTextHeight = this.text.maxTextHeight;
                obj.maxTextWidth = this.text.maxTextWidth;
                obj.minTextHeight = this.text.minTextHeight;
                obj.minTextWidth = this.text.minTextWidth;
                obj.uniformStyle = this.text.uniformStyle;
                obj.uniformMixedStyle = this.text.uniformMixedStyle;
            }
            if (this.background) {
                obj.labelBackShape = this.background.labelBackShape;
                obj.backStyle = this.background.backStyle;
            }
            obj.labelOverLengthMode = this.labelOverLengthMode;
            obj.maxLabelLength = this.maxLabelLength;
            obj.smallGeometryLabeled = this.smallGeometryLabeled;
            obj.rangeExpression = this.rangeExpression;
            obj.uniqueExpression = this.uniqueExpression;
            obj.numericPrecision = this.numericPrecision;
            obj.items = this.items;
            obj.uniqueItems = this.uniqueItems;
            obj.labelExpression = this.labelExpression;
            obj.overlapAvoided = this.overlapAvoided;
            obj.matrixCells = this.matrixCells;
            obj.textSpace = this.textSpace;
            return obj;
        }

        /**
         * @function SuperMap.ThemeLabel.fromObj
         * @description 从传入对象获取标签专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabel}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var lab = new ThemeLabel();
            var itemsL = obj.items,
                itemsU = obj.uniqueItems,
                cells = obj.matrixCells;
            obj.matrixCells = null;
            _SuperMap2.default.Util.copy(lab, obj);
            lab.alongLine = _ThemeLabelAlongLine2.default.fromObj(obj);
            lab.background = _ThemeLabelBackground2.default.fromObj(obj);
            lab.flow = new _ThemeFlow2.default({ flowEnabled: obj.flowEnabled, leaderLineDisplayed: obj.leaderLineDisplayed, leaderLineStyle: obj.leaderLineStyle });
            if (itemsL) {
                lab.items = [];
                for (var i = 0, len = itemsL.length; i < len; i++) {
                    lab.items.push(_ThemeLabelItem2.default.fromObj(itemsL[i]));
                }
            }
            if (itemsU) {
                lab.uniqueItems = [];
                for (var j = 0, uniqueLen = itemsU.length; j < uniqueLen; j++) {
                    lab.uniqueItems.push(ThemeUniqueItem.fromObj(itemsU[j]));
                }
            }
            if (cells) {
                lab.matrixCells = [];
                for (var i = 0, len = cells.length; i < len; i++) {
                    //TODO
                    //lab.matrixCells.push(SuperMap.LabelMatrixCell.fromObj(cells[i]));
                }
            }
            lab.offset = _ThemeOffset2.default.fromObj(obj);
            lab.text = _ThemeLabelText2.default.fromObj(obj);
            return lab;
        }
    }]);

    return ThemeLabel;
}(_Theme3.default);

exports.default = ThemeLabel;


_SuperMap2.default.ThemeLabel = ThemeLabel;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeOffset
 * @classdesc 专题图中文本或符号相对于要素内点的偏移量设置类。
 *              通过该类可以设置专题图中标记文本或符号的偏移量以及偏移量是否随地图缩放而改变。
 * @param options - {Object} 可选参数。如：<br>
 *        offsetFixed - {boolean} 当前专题图是否固定标记文本或符号的偏移量。<br>
 *        offsetX - {string} 专题图中文本或符号相对于要素内点的水平偏移量。<br>
 *        offsetY - {string} 专题图中文本或符号相对于要素内点的垂直偏移量。
 */
var ThemeOffset = function () {

    /**
     * @member SuperMap.ThemeOffset.prototype.offsetX -{string}
     * @description 专题图中文本或符号相对于要素内点的水平偏移量。偏移量的单位为地图单位。
     *              该偏移量的值为一个常量值或者字段表达式所表示的值，即如果字段表达式为 SmID，其中 SmID = 2，那么水平偏移量为2。
     */
    function ThemeOffset(options) {
        _classCallCheck(this, ThemeOffset);

        this.offsetFixed = false;
        this.offsetX = "0.0";
        this.offsetY = "0.0";
        this.CLASS_NAME = "SuperMap.ThemeOffset";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeOffset.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeOffset.prototype.offsetY -{string}
     * @description 专题图中文本或符号相对于要素内点的垂直偏移量。偏移量的单位为地图单位。
     *              该偏移量的值为一个常量值或者字段表达式所表示的值，即如果字段表达式为 SmID，其中 SmID = 2，那么垂直偏移量为2。
     */


    /**
     * @member SuperMap.ThemeOffset.prototype.offsetFixed -{boolean}
     * @description 当前专题图是否固定标记文本或符号的偏移量。所谓固定偏移量，则文本或符号的偏移量不随地图的缩放而变化。默认为 false，表示偏移量随地图的缩放而变化。
     */


    _createClass(ThemeOffset, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.offsetFixed = null;
            me.offsetX = null;
            me.offsetY = null;
        }

        /**
         * @function SuperMap.ThemeOffset.fromObj
         * @description 从传入对象获取专题图中文本或符号相对于要素内点的偏移量设置类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeOffset}
         */

    }], [{
        key: "fromObj",
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeOffset();
            _SuperMap2.default.Util.copy(res, obj);
            return res;
        }
    }]);

    return ThemeOffset;
}();

exports.default = ThemeOffset;


_SuperMap2.default.ThemeOffset = ThemeOffset;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThiessenAnalystParameters
 * @classdesc 泰森多边形分析参数基类。
 * @param options - {Object} 可选参数。如:</br>
 *        clipRegion - {SuperMap.Geometry} 结果数据裁剪区域，可以为null，表示不对结果进行裁剪。</br>
 *                      面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
 *        createResultDataset - {boolean} 是否返回结果数据集，默认不返回。</br>
 *        resultDatasetName - {boolean} 指定结果数据集名称。</br>
 *        resultDatasourceName - {boolean} 指定结果数据集所在数据源，默认为当前数据源。</br>
 *        returnResultRegion - {boolean} 是否返回分析得到的多边形面数组，默认返回。</br>
 */
var ThiessenAnalystParameters = function () {

    /*
     * @function SuperMap.ThiessenAnalystParameters.prototype.constructor
     * @param options - {Object} 可选参数。如:</br>
     *        clipRegion - {SuperMap.Geometry} 结果数据裁剪区域，可以为null，表示不对结果进行裁剪。</br>
     *        createResultDataset - {boolean} 是否返回结果数据集，默认不返回。</br>
     *        resultDatasetName - {boolean} 指定结果数据集名称。</br>
     *        resultDatasourceName - {boolean} 指定结果数据集所在数据源，默认为当前数据源。</br>
     *        returnResultRegion - {boolean} 是否返回分析得到的多边形面数组，默认返回。</br>
     */


    /**
     * @member SuperMap.ThiessenAnalystParameters.prototype.resultDatasourceName -{string}
     * @description 指定结果数据集所在数据源。
     */


    /**
     *  @member SuperMap.ThiessenAnalystParameters.prototype.createResultDataset -{boolean}
     *  @description 是否返回结果数据集，默认值 false。如果为true，则必须设置属性resultDatasetName和resultDatasourceName。
     */
    function ThiessenAnalystParameters(options) {
        _classCallCheck(this, ThiessenAnalystParameters);

        this.clipRegion = null;
        this.createResultDataset = false;
        this.resultDatasetName = null;
        this.resultDatasourceName = null;
        this.returnResultRegion = true;
        this.CLASS_NAME = "SuperMap.ThiessenAnalystParameters";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.ThiessenAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThiessenAnalystParameters.prototype.returnResultRegion -{boolean}
     * @description 是否返回分析得到的多边形面数组，默认 true，返回。
     */


    /**
     * @member SuperMap.ThiessenAnalystParameters.prototype.resultDatasetName -{string}
     * @description 指定结果数据集名称。
     */

    /**
     * @member SuperMap.ThiessenAnalystParameters.prototype.clipRegion
     * @description 结果数据裁剪区域，可以为null，表示不对结果进行裁剪。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。
     */


    _createClass(ThiessenAnalystParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            if (me.clipRegion) {
                me.clipRegion.destroy();
                me.clipRegion = null;
            }
            me.createResultDataset = null;
            me.resultDatasetName = null;
            me.resultDatasourceName = null;
            me.returnResultRegion = null;
        }
    }]);

    return ThiessenAnalystParameters;
}();

exports.default = ThiessenAnalystParameters;

_SuperMap2.default.ThiessenAnalystParameters = ThiessenAnalystParameters;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var parseCode = __webpack_require__(292);
var extend = __webpack_require__(59);
var projections = __webpack_require__(293);
var deriveConstants = __webpack_require__(288);

function Projection(srsCode,callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error){
    if(error){
      throw error;
    }
  };
  var json = parseCode(srsCode);
  if(typeof json !== 'object'){
    callback(srsCode);
    return;
  }
  var modifiedJSON = deriveConstants(json);
  var ourProj = Projection.projections.get(modifiedJSON.projName);
  if(ourProj){
    extend(this, modifiedJSON);
    extend(this, ourProj);
    this.init();
    callback(null, this);
  }else{
    callback(srsCode);
  }
}
Projection.projections = projections;
Projection.projections.start();
module.exports = Projection;


/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = function(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
};

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = function(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;

  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
};

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = function(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
  }
  else {
    return (2 * sinphi);
  }
};

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = function(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z

/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
exports.forward = function (ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
exports.inverse = function (mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

exports.toPoint = function (mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return deg * (Math.PI / 180.0);
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return 180.0 * (rad / Math.PI);
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    } else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    } else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    } else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = eccSquared / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));

  var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0;

  var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = eccSquared / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if (84 >= lat && lat >= 72) {
    LetterDesignator = 'X';
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = 'W';
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = 'V';
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = 'U';
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = 'T';
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = 'S';
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = 'R';
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = 'Q';
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = 'P';
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = 'N';
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = 'M';
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = 'L';
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = 'K';
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = 'J';
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = 'H';
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = 'G';
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = 'F';
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = 'E';
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = 'D';
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }

  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }

  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }

  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw "MGRSPoint given invalid Northing " + n;
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > V) {
      if (rewindMarker) {
        // making sure that this loop ends
        throw "Bad character: " + n;
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case 'C':
      northing = 1100000.0;
      break;
    case 'D':
      northing = 2000000.0;
      break;
    case 'E':
      northing = 2800000.0;
      break;
    case 'F':
      northing = 3700000.0;
      break;
    case 'G':
      northing = 4600000.0;
      break;
    case 'H':
      northing = 5500000.0;
      break;
    case 'J':
      northing = 6400000.0;
      break;
    case 'K':
      northing = 7300000.0;
      break;
    case 'L':
      northing = 8200000.0;
      break;
    case 'M':
      northing = 9100000.0;
      break;
    case 'N':
      northing = 0.0;
      break;
    case 'P':
      northing = 800000.0;
      break;
    case 'Q':
      northing = 1700000.0;
      break;
    case 'R':
      northing = 2600000.0;
      break;
    case 'S':
      northing = 3500000.0;
      break;
    case 'T':
      northing = 4400000.0;
      break;
    case 'U':
      northing = 5300000.0;
      break;
    case 'V':
      northing = 6200000.0;
      break;
    case 'W':
      northing = 7000000.0;
      break;
    case 'X':
      northing = 7900000.0;
      break;
    default:
      northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Size = __webpack_require__(45);

var _Size2 = _interopRequireDefault(_Size);

var _Pixel = __webpack_require__(37);

var _Pixel2 = _interopRequireDefault(_Pixel);

var _LonLat = __webpack_require__(158);

var _LonLat2 = _interopRequireDefault(_LonLat);

var _Point = __webpack_require__(11);

var _Point2 = _interopRequireDefault(_Point);

var _LinearRing = __webpack_require__(38);

var _LinearRing2 = _interopRequireDefault(_LinearRing);

var _Polygon = __webpack_require__(47);

var _Polygon2 = _interopRequireDefault(_Polygon);

var _Projection = __webpack_require__(22);

var _Projection2 = _interopRequireDefault(_Projection);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class   SuperMap.Bounds
 * @description 表示边界类实例。使用bounds之前需要设置left,bottom, right, top四个属性，这些属性的初始值为null。
 *
 * 例如:
 * (code)
 *     bounds = new SuperMap.Bounds();
 *     bounds.extend(new SuperMap.LonLat(4,5));
 *     bounds.extend(new SuperMap.LonLat(5,6));
 *     bounds.toBBOX(); // returns 4,5,5,6
 * (end)
 */
var Bounds = function () {

    /**
     * Constructor: SuperMap.Bounds
     * 创建新的bounds对象。
     *
     * (code)
     * var bounds = new SuperMap.Bounds(-180,-90,180,90);
     * (end)
     *
     * Parameters (four arguments):
     * left - {Number} 左边界，注意考虑宽度，理论上小于right值。
     * bottom - {Number} 下边界。考虑高度，理论大于top值
     * right - {Number} 右边界
     * top - {Number} 上边界
     *
     * Parameters (single argument):
     * array - {Array(Float)} [left, bottom, right, top]  左下右上组成的数组。
     */


    /**
     * APIProperty: top
     * {Number} 最大的垂直坐标系。
     */


    /**
     * APIProperty: bottom
     * {Number} 最小的垂直坐标系。
     */
    function Bounds(left, bottom, right, top) {
        _classCallCheck(this, Bounds);

        this.left = null;
        this.bottom = null;
        this.right = null;
        this.top = null;
        this.centerLonLat = null;
        this.CLASS_NAME = "SuperMap.Bounds";

        if (_Util.Util.isArray(left)) {
            top = left[3];
            right = left[2];
            bottom = left[1];
            left = left[0];
        }
        this.left = left != null ? _Util.Util.toFloat(left) : this.left;
        this.bottom = bottom != null ? _Util.Util.toFloat(bottom) : this.bottom;
        this.right = right != null ? _Util.Util.toFloat(right) : this.right;
        this.top = top != null ? _Util.Util.toFloat(top) : this.top;
    }

    /**
     * APIMethod: clone
     * 复制当前 bounds 对象。
     *
     * 例如:
     * (start code)
     * var bounds1 = new SuperMap.Bounds(-180,-90,180,90);
     * var bounds2 = bounds1.clone();
     * (end)
     *
     * Returns:
     * {<SuperMap.Bounds>} 返回一个克隆的bounds
     */


    /**
     * Property: centerLonLat
     * {<SuperMap.LonLat>} bounds的地图空间的中心点。用 getCenterLonLat() 获得。
     */


    /**
     * APIProperty: right
     * {Number} 最大的水平坐标系。
     */


    /**
     * APIProperty: left
     * {Number} 最小的水平坐标系。
     */


    _createClass(Bounds, [{
        key: 'clone',
        value: function clone() {
            return new Bounds(this.left, this.bottom, this.right, this.top);
        }

        /**
         * APIMethod: equals
         * 判断两个 bounds 对象是否相等。
         *
         * 例如:
         * (start code)
         * var bounds1 = new SuperMap.Bounds(-180,-90,180,90);
         * var bounds2 = new SuperMap.Bounds(-180,-90,180,90);
         * var isEquals = bounds1.equals(bounds2);
         * (end)
         *
         * Parameters:
         * bounds - {<SuperMap.Bounds>} 需要进行计较的 bounds
         *
         * Returns:
         * {Boolean} 如果 bounds 对象的边和传入的 bounds 一致则返回true,不一
         *      致或传入的 bounds 参数为NULL则返回false。
         */

    }, {
        key: 'equals',
        value: function equals(bounds) {
            var equals = false;
            if (bounds != null) {
                equals = this.left === bounds.left && this.right === bounds.right && this.top === bounds.top && this.bottom === bounds.bottom;
            }
            return equals;
        }

        /**
         * APIMethod: toString
         * 返回此对象的字符串形式
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,180,90);
         * var str = bounds.toString();
         * (end)
         *
         * Returns:
         * {String} 边界对象的字符串表示形式（left,bottom,right,top），例如: "-180,-90,180,90"
         */

    }, {
        key: 'toString',
        value: function toString() {
            return [this.left, this.bottom, this.right, this.top].join(",");
        }

        /**
         * APIMethod: toArray
         * 边界对象的数组表示形式 。
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * //array1 = [-180,-90,100,80];
         * var array1 = bounds.toArray();
         * //array1 = [-90,-180,80,100];
         * var array2 = bounds.toArray(true);
         * (end)
         *
         * Parameters:
         * reverseAxisOrder - {Boolean} 是否反转轴顺序，
         * 如果设为true，则倒转顺序（bottom,left,top,right）,否则按正常轴顺序（left,bottom,right,top）。
         *
         * Returns:
         * {Array} left, bottom, right, top数组
         */

    }, {
        key: 'toArray',
        value: function toArray(reverseAxisOrder) {
            if (reverseAxisOrder === true) {
                return [this.bottom, this.left, this.top, this.right];
            } else {
                return [this.left, this.bottom, this.right, this.top];
            }
        }

        /**
         * APIMethod: toBBOX
         * 取小数点后decimal位数字进行四舍五入再转换为BBOX字符串
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-1.1234567,-1.7654321,1.4444444,1.5555555);
         * //str1 = "-1.123457,-1.765432,1.444444,1.555556";
         * var str1 = bounds.toBBOX();
         * //str2 = "-1.1,-1.8,1.4,1.6";
         * var str2 = bounds.toBBOX(1);
         * //str2 = "-1.8,-1.1,1.6,1.4";
         * var str2 = bounds.toBBOX(1,true);
         * (end)
         *
         * Parameters:
         * decimal - {Integer} 边界方位坐标的有效数字个数，默认为6
         * reverseAxisOrder - {Boolean} 是否是反转轴顺序。
         * 如果设为true，则倒转顺序（bottom,left,top,right）,否则按正常轴顺序（left,bottom,right,top）。
         *
         * Returns:
         * {String} 边界对象的字符串表示形式，如："5,42,10,45"
         */

    }, {
        key: 'toBBOX',
        value: function toBBOX(decimal, reverseAxisOrder) {
            if (decimal == null) {
                decimal = 6;
            }
            var mult = Math.pow(10, decimal);
            var xmin = Math.round(this.left * mult) / mult;
            var ymin = Math.round(this.bottom * mult) / mult;
            var xmax = Math.round(this.right * mult) / mult;
            var ymax = Math.round(this.top * mult) / mult;
            if (reverseAxisOrder === true) {
                return ymin + "," + xmin + "," + ymax + "," + xmax;
            } else {
                return xmin + "," + ymin + "," + xmax + "," + ymax;
            }
        }

        /**
         * APIMethod: toGeometry
         * 基于当前边界范围创建一个新的多边形对象
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * //SuperMap.Geometry.Polygon对象
         * var geo = bounds.toGeometry();
         * (end)
         *
         * Returns:
         * {<SuperMap.Geometry.Polygon>} 基于当前bounds坐标创建的新的多边形.
         */

    }, {
        key: 'toGeometry',
        value: function toGeometry() {
            return new _Polygon2.default([new _LinearRing2.default([new _Point2.default(this.left, this.bottom), new _Point2.default(this.right, this.bottom), new _Point2.default(this.right, this.top), new _Point2.default(this.left, this.top)])]);
        }

        /**
         * APIMethod: getWidth
         * 获取bounds的宽度
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * //width = 280;
         * var width = bounds.getWidth();
         * (end)
         *
         * Returns:
         * {Float} 获取当前bounds的宽度（right减去left）
         */

    }, {
        key: 'getWidth',
        value: function getWidth() {
            return this.right - this.left;
        }

        /**
         * APIMethod: getHeight
         * 获取bounds的高度
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * //height = 170;
         * var height = bounds.getHeight();
         * (end)
         *
         * Returns:
         * {Float} 返回边界高度（top减去bottom）。
         */

    }, {
        key: 'getHeight',
        value: function getHeight() {
            return this.top - this.bottom;
        }

        /**
         * APIMethod: getSize
         * 获取边框
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * var size = bounds.getSize();
         * (end)
         *
         * Returns:
         * {<SuperMap.Size>} 返回边框。
         */

    }, {
        key: 'getSize',
        value: function getSize() {
            return new _Size2.default(this.getWidth(), this.getHeight());
        }

        /**
         * APIMethod: getCenterPixel
         * 获取像素格式的范围中心点
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * var pixel = bounds.getCenterPixel();
         * (end)
         *
         * Returns:
         * {<SuperMap.Pixel>} 返回像素格式的当前范围的中心点。
         */

    }, {
        key: 'getCenterPixel',
        value: function getCenterPixel() {
            return new _Pixel2.default((this.left + this.right) / 2, (this.bottom + this.top) / 2);
        }

        /**
         * APIMethod: getCenterLonLat
         * 获取地理格式的范围中心点
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * var lonlat = bounds.getCenterLonLat();
         * (end)
         *
         * Returns:
         * {<SuperMap.LonLat>} 返回当前地理范围的中心点。
         */

    }, {
        key: 'getCenterLonLat',
        value: function getCenterLonLat() {
            if (!this.centerLonLat) {
                this.centerLonLat = new _LonLat2.default((this.left + this.right) / 2, (this.bottom + this.top) / 2);
            }
            return this.centerLonLat;
        }

        /**
         * APIMethod: scale
         * 按照比例 扩大/缩小 出一个新的bounds。
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-50,-50,40,40);
         * var bounds2 = bounds.scale(2);
         * (end)
         *
         * Parameters:
         * ratio - {Float} 需要扩大的比例，默认为1
         * origin - {<SuperMap.Pixel> or <SuperMap.LonLat>} 扩大时的基准点，默认为当前bounds的中心点。
         *
         * Returns:
         * {<SuperMap.Bounds>} 返回通过ratio、origin计算得到的新的边界范围。
         */

    }, {
        key: 'scale',
        value: function scale(ratio, origin) {
            ratio = ratio ? ratio : 1;
            if (origin == null) {
                origin = this.getCenterLonLat();
            }

            var origx, origy;

            // get origin coordinates
            if (origin.CLASS_NAME === "SuperMap.LonLat") {
                origx = origin.lon;
                origy = origin.lat;
            } else {
                origx = origin.x;
                origy = origin.y;
            }

            var left = (this.left - origx) * ratio + origx;
            var bottom = (this.bottom - origy) * ratio + origy;
            var right = (this.right - origx) * ratio + origx;
            var top = (this.top - origy) * ratio + origy;

            return new Bounds(left, bottom, right, top);
        }

        /**
         * APIMethod: add
         * 在当前的dounds上按照传入的坐标点进行平移，返回新的范围。
         *
         * 例如:
         * (start code)
         * var bounds1 = new SuperMap.Bounds(-50,-50,40,40);
         * //bounds2 是新的 bounds
         * var bounds2 = bounds.add(20,10);
         * (end)
         *
         * Parameters:
         * x - {Float} 传入坐标点的x坐标。
         * y - {Float} 传入坐标点的y坐标。
         *
         * Returns:
         * {<SuperMap.Bounds>} 返回一个新的bounds，此bounds的坐标是由传入
         *      的x，y参数与当前bounds坐标计算所得。
         */

    }, {
        key: 'add',
        value: function add(x, y) {
            if (x == null || y == null) {
                throw new TypeError('Bounds.add cannot receive null values');
            }
            return new Bounds(this.left + x, this.bottom + y, this.right + x, this.top + y);
        }

        /**
         * APIMethod: extend
         * 在当前bounds上扩展bounds，支持point，lanlat和bounds。
         * 扩展后的bounds的范围是两者的结合
         *
         * 例如:
         * (start code)
         * var bounds1 = new SuperMap.Bounds(-50,-50,40,40);
         * //bounds改变
         * bounds.extend(new SuperMap.LonLat(50,60));
         * (end)
         *
         * Parameters:
         * object - {<SuperMap.Geometry.Point> or <SuperMap.LonLat> or <SuperMap.Bounds>} 可以是point，lanlat和bounds。
         */

    }, {
        key: 'extend',
        value: function extend(object) {
            var bounds = null;
            if (object) {
                // clear cached center location
                switch (object.CLASS_NAME) {
                    case "SuperMap.LonLat":
                        bounds = new Bounds(object.lon, object.lat, object.lon, object.lat);
                        break;
                    case "SuperMap.Geometry.Point":
                        bounds = new Bounds(object.x, object.y, object.x, object.y);
                        break;

                    case "SuperMap.Bounds":
                        bounds = object;
                        break;
                }

                if (bounds) {
                    this.centerLonLat = null;
                    if (this.left == null || bounds.left < this.left) {
                        this.left = bounds.left;
                    }
                    if (this.bottom == null || bounds.bottom < this.bottom) {
                        this.bottom = bounds.bottom;
                    }
                    if (this.right == null || bounds.right > this.right) {
                        this.right = bounds.right;
                    }
                    if (this.top == null || bounds.top > this.top) {
                        this.top = bounds.top;
                    }
                }
            }
        }

        /**
         * APIMethod: containsLonLat
         * 判断传入的坐标是否在范围内。
         *
         * 例如:
         * (start code)
         * var bounds1 = new SuperMap.Bounds(-50,-50,40,40);
         * //isContains1 = true
         * //这里的第二个参数可以直接为 Boolean 类型，也就是inclusive
         * var isContains1 = bounds.containsLonLat(new SuperMap.LonLat(40,40),true);
         *
         * //(40,40)在范围内，同样(40+360,40)也在范围内
         * var bounds2 = new SuperMap.Bounds(-50,-50,40,40);
         * //isContains2 = true;
         * var isContains2 = bounds2.containsLonLat(
         *      new SuperMap.LonLat(400,40),
         *      {
         *           inclusive:true,
         *           //全球的范围
         *           worldBounds: new SuperMap.Bounds(-180,-90,180,90)
         *      }
         *      );
         * (end)
         *
         * Parameters:
         * ll - {<SuperMap.LonLat>|Object}  <SuperMap.LonLat> 对象或者是一个
         *     包含 'lon' 与 'lat' 属性的对象。
         * options - {Object} 可选参数
         *
         *
         * Acceptable options:
         * inclusive - {Boolean} 是否包含边界，默认为 true 。
         * worldBounds - {<SuperMap.Bounds>} 如果提供 worldBounds 参数, 如
         *     果 ll 参数提供的坐标超出了世界边界（worldBounds）,  但是通过日界
         *     线的转化可以被包含, 它将被认为是包含在该范围内的。
         *
         * Returns:
         * {Boolean} 传入坐标是否包含在范围内.
         */

    }, {
        key: 'containsLonLat',
        value: function containsLonLat(ll, options) {
            if (typeof options === "boolean") {
                options = { inclusive: options };
            }
            options = options || {};
            var contains = this.contains(ll.lon, ll.lat, options.inclusive),
                worldBounds = options.worldBounds;
            //日界线以外的也有可能算包含，
            if (worldBounds && !contains) {
                var worldWidth = worldBounds.getWidth();
                var worldCenterX = (worldBounds.left + worldBounds.right) / 2;
                //这一步很关键
                var worldsAway = Math.round((ll.lon - worldCenterX) / worldWidth);
                contains = this.containsLonLat({
                    lon: ll.lon - worldsAway * worldWidth,
                    lat: ll.lat
                }, { inclusive: options.inclusive });
            }
            return contains;
        }

        /**
         * APIMethod: containsPixel
         * 判断传入的像素是否在范围内。
         * 直接匹配大小，不涉及像素和地理转换
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-50,-50,40,40);
         * //isContains = true
         * var isContains = bounds.containsPixel(new SuperMap.Pixel(40,40),true);
         * (end)
         *
         * Parameters:
         * px - {<SuperMap.Pixel>} 提供的像素参数。
         * inclusive - {Boolean} 是否包含边界，默认为true。
         *
         * Returns:
         * {Boolean} 传入的pixel在当前边界范围之内。
         */

    }, {
        key: 'containsPixel',
        value: function containsPixel(px, inclusive) {
            return this.contains(px.x, px.y, inclusive);
        }

        /**
         * APIMethod: contains
         * 判断传入的x，y坐标值是否在范围内。
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-50,-50,40,40);
         * //isContains = true
         * var isContains = bounds.contains(40,40,true);
         * (end)
         *
         * Parameters:
         * x - {Float} 传入的x坐标值。
         * y - {Float} 传入的y坐标值。
         * inclusive - {Boolean} 是否包含边界，默认为true。
         *
         * Returns:
         * {Boolean} 传入的x,y坐标在当前范围内。
         */

    }, {
        key: 'contains',
        value: function contains(x, y, inclusive) {
            //set default
            if (inclusive == null) {
                inclusive = true;
            }

            if (x == null || y == null) {
                return false;
            }

            x = _Util.Util.toFloat(x);
            y = _Util.Util.toFloat(y);

            var contains = false;
            if (inclusive) {
                contains = x >= this.left && x <= this.right && y >= this.bottom && y <= this.top;
            } else {
                contains = x > this.left && x < this.right && y > this.bottom && y < this.top;
            }
            return contains;
        }

        /**
         * APIMethod: intersectsBounds
         * 判断目标边界范围是否与当前边界范围相交。如果两个边界范围中的任意
         *     边缘相交或者一个边界包含了另外一个就认为这两个边界相交。
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * var isIntersects = bounds.intersectsBounds(
         *      new SuperMap.Bounds(-170,-90,120,80)
         *  );
         * (end)
         *
         * Parameters:
         * bounds - {<SuperMap.Bounds>} 目标边界。
         * options - {Object} 可选参数。
         *
         * Acceptable options:
         * inclusive - {Boolean} 边缘重合也看成相交，默认为true。
         * 如果是false，两个边界范围没有重叠部分仅仅是在边缘相接（重合），这种情况被认为没有相交。
         * worldBounds - {<SuperMap.Bounds>} 提供了 worldBounds 参数, 如果他们相交时是在全
         * 球范围内, 两个边界将被视为相交。这仅适用于交叉或完全不在世界范围的边界。
         *
         * Returns:
         * {Boolean} 传入的bounds对象与当前bounds相交。
         */

    }, {
        key: 'intersectsBounds',
        value: function intersectsBounds(bounds, options) {
            if (typeof options === "boolean") {
                options = { inclusive: options };
            }
            options = options || {};
            if (options.worldBounds) {
                var self = this.wrapDateLine(options.worldBounds);
                bounds = bounds.wrapDateLine(options.worldBounds);
            } else {
                self = this;
            }
            if (options.inclusive == null) {
                options.inclusive = true;
            }
            var intersects = false;
            var mightTouch = self.left === bounds.right || self.right === bounds.left || self.top === bounds.bottom || self.bottom === bounds.top;

            // if the two bounds only touch at an edge, and inclusive is false,
            // then the bounds don't *really* intersect.
            if (options.inclusive || !mightTouch) {
                // otherwise, if one of the boundaries even partially contains another,
                // inclusive of the edges, then they do intersect.
                var inBottom = bounds.bottom >= self.bottom && bounds.bottom <= self.top || self.bottom >= bounds.bottom && self.bottom <= bounds.top;
                var inTop = bounds.top >= self.bottom && bounds.top <= self.top || self.top > bounds.bottom && self.top < bounds.top;
                var inLeft = bounds.left >= self.left && bounds.left <= self.right || self.left >= bounds.left && self.left <= bounds.right;
                var inRight = bounds.right >= self.left && bounds.right <= self.right || self.right >= bounds.left && self.right <= bounds.right;
                intersects = (inBottom || inTop) && (inLeft || inRight);
            }
            // document me
            if (options.worldBounds && !intersects) {
                var world = options.worldBounds;
                var width = world.getWidth();
                var selfCrosses = !world.containsBounds(self);
                var boundsCrosses = !world.containsBounds(bounds);
                if (selfCrosses && !boundsCrosses) {
                    bounds = bounds.add(-width, 0);
                    intersects = self.intersectsBounds(bounds, { inclusive: options.inclusive });
                } else if (boundsCrosses && !selfCrosses) {
                    self = self.add(-width, 0);
                    intersects = bounds.intersectsBounds(self, { inclusive: options.inclusive });
                }
            }
            return intersects;
        }

        /**
         * APIMethod: containsBounds
         * 判断目标边界是否被当前边界包含在内。
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * var isContains = bounds.containsBounds(
         *      new SuperMap.Bounds(-170,-90,100,80),true,true
         *  );
         * (end)
         *
         * Parameters:
         * bounds - {<SuperMap.Bounds>} 目标边界。
         * partial - {Boolean} 目标边界的任意部分都包含在当前边界中则被认为是包含关系。默认为false，
         * 如果设为false，整个目标边界全部被包含在当前边界范围内。
         * inclusive - {Boolean} 边缘共享被视为包含。默认为true
         *
         * Returns:
         * {Boolean} 传入的边界被当前边界包含。
         */

    }, {
        key: 'containsBounds',
        value: function containsBounds(bounds, partial, inclusive) {
            if (partial == null) {
                partial = false;
            }
            if (inclusive == null) {
                inclusive = true;
            }
            var bottomLeft = this.contains(bounds.left, bounds.bottom, inclusive);
            var bottomRight = this.contains(bounds.right, bounds.bottom, inclusive);
            var topLeft = this.contains(bounds.left, bounds.top, inclusive);
            var topRight = this.contains(bounds.right, bounds.top, inclusive);

            return partial ? bottomLeft || bottomRight || topLeft || topRight : bottomLeft && bottomRight && topLeft && topRight;
        }

        /**
         * APIMethod: determineQuadrant
         * 判断传入坐标在bounds范围内的象限。以bounds中心点为坐标原点。
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * //str = "tr";
         * var str = bounds.determineQuadrant(
         *      new SuperMap.LonLat(20,20)
         *  );
         * (end)
         *
         * Parameters:
         * lonlat - {<SuperMap.LonLat>} 传入的坐标对象。
         *
         * Returns:
         * {String} 传入坐标所在的象限(“br” “tr” “tl” “bl” 分别对应“右下”，“右上”，
         *      “左上”和“左下”)。
         */

    }, {
        key: 'determineQuadrant',
        value: function determineQuadrant(lonlat) {

            var quadrant = "";
            var center = this.getCenterLonLat();

            quadrant += lonlat.lat < center.lat ? "b" : "t";
            quadrant += lonlat.lon < center.lon ? "l" : "r";

            return quadrant;
        }

        /**
         * APIMethod: transform
         * 范围（Bounds）对象的投影转换。
         * （在自身上做投影转换）
         *
         * 例如:
         * (start code)
         * var bounds1 = new SuperMap.Bounds(-180,-90,100,80);
         * //这里bounds1 = bounds2
         * var bounds2 = bounds1.transform(
         *      new SuperMap.Projection("EPSG:4326"),
         *      new SuperMap.Projection("EPSG:3857")
         *  );
         * (end)
         *
         * Parameters:
         * source - {<SuperMap.Projection>} 源投影。
         * dest   - {<SuperMap.Projection>} 目标投影。
         *
         * Returns:
         * {<SuperMap.Bounds>} 返回本身，用于链接操作.
         */

    }, {
        key: 'transform',
        value: function transform(source, dest) {
            // clear cached center location
            this.centerLonLat = null;
            var ll = _Projection2.default.transform({ 'x': this.left, 'y': this.bottom }, source, dest);
            var lr = _Projection2.default.transform({ 'x': this.right, 'y': this.bottom }, source, dest);
            var ul = _Projection2.default.transform({ 'x': this.left, 'y': this.top }, source, dest);
            var ur = _Projection2.default.transform({ 'x': this.right, 'y': this.top }, source, dest);
            this.left = Math.min(ll.x, ul.x);
            this.bottom = Math.min(ll.y, lr.y);
            this.right = Math.max(lr.x, ur.x);
            this.top = Math.max(ul.y, ur.y);
            return this;
        }

        /**
         * APIMethod: wrapDateLine
         * 将当前bounds移动到最大边界范围内部（所谓的内部是相交或者内部）
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(380,-40,400,-20);
         * var maxExtent = new SuperMap.Bounds(-180,-90,100,80);
         * //新的bounds
         * var newBounds = bounds.wrapDateLine(maxExtent);
         * (end)
         *
         * Parameters:
         * maxExtent - {<SuperMap.Bounds>} 最大的边界范围（一般是全球范围）。
         * options - {Object} 可选选项参数。
         *
         * Allowed Options:
         *        leftTolerance - {float} left允许的误差。默认为0
         *        rightTolerance - {float} right允许的误差。默认为0
         *
         * Returns:
         * {<SuperMap.Bounds>} 克隆当前边界。如果当前边界完全在最大范围之外此函数则返回一个不同值的边界，
         * 若落在最大边界的左边，则给当前的bounds值加上最大范围的宽度，即向右移动，
         * 若落在右边，则向左移动，即给当前的bounds值加上负的最大范围的宽度。
         */

    }, {
        key: 'wrapDateLine',
        value: function wrapDateLine(maxExtent, options) {
            options = options || {};

            var leftTolerance = options.leftTolerance || 0;
            var rightTolerance = options.rightTolerance || 0;

            var newBounds = this.clone();

            if (maxExtent) {
                var width = maxExtent.getWidth();
                //如果 newBounds 在 maxExtent 的左边，那么一直向右移动，直到相交或者包含为止，每次移动width
                //shift right?
                while (newBounds.left < maxExtent.left && newBounds.right - rightTolerance <= maxExtent.left) {
                    newBounds = newBounds.add(width, 0);
                }
                //如果 newBounds 在 maxExtent 的右边，那么一直向左移动，直到相交或者包含为止，每次移动width
                //shift left?
                while (newBounds.left + leftTolerance >= maxExtent.right && newBounds.right > maxExtent.right) {
                    newBounds = newBounds.add(-width, 0);
                }
                //如果和右边相交，左边又在内部，那么再次向左边移动一次
                // crosses right only? force left
                var newLeft = newBounds.left + leftTolerance;
                if (newLeft < maxExtent.right && newLeft > maxExtent.left && newBounds.right - rightTolerance > maxExtent.right) {
                    newBounds = newBounds.add(-width, 0);
                }
            }

            return newBounds;
        }

        /**
         * Method: toServerJSONObject
         * 转换成对应的 JSON 格式对象。
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * var obj = bounds.toServerJSONObject();
         * (end)
         *
         * Returns:
         * {Object} 返回json 格式的Object对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var jsonObject = {
                rightTop: { x: this.right, y: this.top },
                leftBottom: { x: this.left, y: this.bottom },
                left: this.left,
                right: this.right,
                top: this.top,
                bottom: this.bottom
            };
            return jsonObject;
        }

        /**
         *
         * APIMethod: destroy
         * 销毁此对象。
         * 销毁后此对象的所有属性为null，而不是初始值。
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds(-180,-90,100,80);
         * bounds.destroy();
         * (end)
         *
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.left = null;
            this.right = null;
            this.top = null;
            this.bottom = null;
            this.centerLonLat = null;
        }

        /**
         * APIFunction: fromString
         * 通过字符串参数创建新的bounds的构造函数
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds.fromString("-180,-90,100,80");
         * (end)
         *
         * Parameters:
         * str - {String} 边界字符串，用逗号隔开 (e.g. <i>"5,42,10,45"</i>)
         * reverseAxisOrder - {Boolean} 是否反转轴顺序.
         * 如果设为true，则倒转顺序（bottom,left,top,right）,否则按正常轴顺序（left,bottom,right,top）。
         *
         * Returns:
         * {<SuperMap.Bounds>} 返回给定的字符串创建的新的边界对象
         */

    }], [{
        key: 'fromString',
        value: function fromString(str, reverseAxisOrder) {
            var bounds = str.split(",");
            return Bounds.fromArray(bounds, reverseAxisOrder);
        }
    }, {
        key: 'fromArray',


        /**
         * APIFunction: fromArray
         * 通过边界框数组创建Bounds
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds.fromArray([-180,-90,100,80]);
         * (end)
         *
         * Parameters:
         * bbox - {Array(Float)} 边界值数组 (e.g. <i>[5,42,10,45]</i>)
         * reverseAxisOrder - {Boolean} 是否是反转轴顺序
         * 如果设为true，则倒转顺序（bottom,left,top,right）,否则按正常轴顺序（left,bottom,right,top）。
         *
         * Returns:
         * {<SuperMap.Bounds>} 返回根据传入的数组创建的新的边界对象。
         */
        value: function fromArray(bbox, reverseAxisOrder) {
            return reverseAxisOrder === true ? new Bounds(bbox[1], bbox[0], bbox[3], bbox[2]) : new Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);
        }
    }, {
        key: 'fromSize',


        /**
         * APIFunction: fromSize
         * 通过传入的边界大小来创建新的边界。
         *
         * 例如:
         * (start code)
         * var bounds = new SuperMap.Bounds.fromSize(new SuperMap.Size(20,10));
         * (end)
         *
         * Parameters:
         * size - {<SuperMap.Size>} 传入的边界大小
         *
         * Returns:
         * {<SuperMap.Bounds>} 返回根据传入的边界大小的创建新的边界。
         */
        value: function fromSize(size) {
            return new Bounds(0, size.h, size.w, 0);
        }
    }, {
        key: 'oppositeQuadrant',


        /**
         * Function: oppositeQuadrant
         * 反转象限
         * "t"和"b" 交换，"r"和"l"交换
         * 如："tl"变为"br"
         *
         * Parameters:
         * quadrant - {String} 代表象限的字符串，如："tl"
         *
         * Returns:
         * {String} The opposing quadrant ("br" "tr" "tl" "bl"). For Example, if
         *          you pass in "bl" it returns "tr", if you pass in "br" it
         *          returns "tl", etc.
         */
        value: function oppositeQuadrant(quadrant) {
            var opp = "";

            opp += quadrant.charAt(0) === 't' ? 'b' : 't';
            opp += quadrant.charAt(1) === 'l' ? 'r' : 'l';

            return opp;
        }
    }]);

    return Bounds;
}();

exports.default = Bounds;

_SuperMap2.default.Bounds = Bounds;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _WKT = __webpack_require__(164);

var _WKT2 = _interopRequireDefault(_WKT);

var _Vector = __webpack_require__(160);

var _Vector2 = _interopRequireDefault(_Vector);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Geometry
 * @description 几何对象类，描述地理对象的几何图形。
 */
var Geometry = function () {

    /**
     * Constructor: SuperMap.Geometry
     * 创建一个几何图形的对象.
     */


    /**
     * Property: bounds
     * {<SuperMap.Bounds>} The bounds of this geometry
     * 几何对象的范围
     */


    /**
     * Property: id
     * {String} A unique identifier for this geometry.
     * 此几何对象的唯一标示符。
     */
    function Geometry() {
        _classCallCheck(this, Geometry);

        this.id = null;
        this.parent = null;
        this.bounds = null;
        this.SRID = null;
        this.CLASS_NAME = "SuperMap.Geometry";

        this.id = _Util.Util.createUniqueID(this.CLASS_NAME + "_");
    }

    /**
     * Method: destroy
     * Destroy this geometry.
     * 解构Geometry类，释放资源。
     */


    /**
     * APIProperty: SRID
     * {Interger}投影坐标参数。通过该参数，服务器判断Geometry对象的坐标参考系是否与数据集相同，如果不同，则在数据入库前进行投影变换。
     *
     * (code)
     *   var geometry= new SuperMap.Geometry();
     *    geometry. SRID=4326;
     *  (end)
     *
     */


    /**
     * Property: parent
     * {<SuperMap.Geometry>}This is set when a Geometry is added as component
     * of another geometry
     */


    _createClass(Geometry, [{
        key: 'destroy',
        value: function destroy() {
            this.id = null;
            this.bounds = null;
            this.SRID = null;
        }

        /**
         * APIMethod: clone
         * 创建克隆的几何图形。克隆的几何图形不设置非标准的属性。
         *
         * Returns:
         * {<SuperMap.Geometry>} 克隆的几何图形。
         */

    }, {
        key: 'clone',
        value: function clone() {
            return new Geometry();
        }

        /**
         * Set the bounds for this Geometry.
         * 设置此几何对象的bounds。
         * Parameters:
         * object - {<SuperMap.Bounds>}
         */

    }, {
        key: 'setBounds',
        value: function setBounds(bounds) {
            if (bounds) {
                this.bounds = bounds.clone();
            }
        }

        /**
         * Method: clearBounds
         * Nullify this components bounds and that of its parent as well.
         * 清除几何对象的bounds。
         * 如果该对象有父类，也会清除父类几何对象的bounds。
         */

    }, {
        key: 'clearBounds',
        value: function clearBounds() {
            this.bounds = null;
            if (this.parent) {
                this.parent.clearBounds();
            }
        }

        /**
         * Method: extendBounds
         * Extend the existing bounds to include the new bounds.
         * If geometry's bounds is not yet set, then set a new Bounds.
         *
         * Parameters:
         * newBounds - {<SuperMap.Bounds>}
         */

    }, {
        key: 'extendBounds',
        value: function extendBounds(newBounds) {
            var bounds = this.getBounds();
            if (!bounds) {
                this.setBounds(newBounds);
            } else {
                this.bounds.extend(newBounds);
            }
        }

        /**
         * APIMethod: getBounds
         * 获得几何图形的边界。如果没有设置边界，可通过计算获得。
         *
         * Returns:
         * {<SuperMap.Bounds>}返回的几何对象的边界。
         */

    }, {
        key: 'getBounds',
        value: function getBounds() {
            if (this.bounds == null) {
                this.calculateBounds();
            }
            return this.bounds;
        }

        /**
         * APIMethod: calculateBounds
         * 重新计算几何图形的边界。（需要在子类中实现此方法）
         */

    }, {
        key: 'calculateBounds',
        value: function calculateBounds() {}
        //
        // This should be overridden by subclasses.
        //


        /**
         * APIMethod: distanceTo
         * 计算两个几个图形间的最小距离（x-y平面坐标系下）。
         * （需要在子类中实现此方法）
         * Parameters:
         * geometry - {<SuperMap.Geometry>} 目标几何图形.
         * options - {Object} 距离计算需要设计的可选属性。有效的选项取决于特定的几何类型。
         *
         * Returns:
         * {Number | Object} 两个几个图形间的距离。
         */

    }, {
        key: 'distanceTo',
        value: function distanceTo(geometry, options) {}

        /**
         * APIMethod: getVertices
         * 返回几何图形的所有顶点的列表。
         * （需要在子类中实现此方法）
         * Parameters:
         * nodes - {Boolean} 如果是true，线则只返回线的末端点，如果false，仅仅返回顶点，如果没有设置，则返回顶点。
         *
         * Returns:
         * {Array} 几何图形的顶点列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {}

        /**
         * Method: atPoint
         * Note - This is only an approximation based on the bounds of the
         * geometry.
         * 确定坐标是否在几何对象的范围内。
         *
         * Parameters:
         * lonlat - {<SuperMap.LonLat>}
         * toleranceLon - {float} Optional tolerance in Geometric Coords
         * 可选参数，经度的偏移 。
         * toleranceLat - {float} Optional tolerance in Geographic Coords
         * 可选参数，纬度的偏移。
         *
         * Returns:
         * {Boolean} Whether or not the geometry is at the specified location
         *    判断传入的坐标是否在指定的范围内 。
         */

    }, {
        key: 'atPoint',
        value: function atPoint(lonlat, toleranceLon, toleranceLat) {
            var atPoint = false;
            var bounds = this.getBounds();
            if (bounds != null && lonlat != null) {

                var dX = toleranceLon != null ? toleranceLon : 0;
                var dY = toleranceLat != null ? toleranceLat : 0;

                var toleranceBounds = new _SuperMap2.default.Bounds(this.bounds.left - dX, this.bounds.bottom - dY, this.bounds.right + dX, this.bounds.top + dY);

                atPoint = toleranceBounds.containsLonLat(lonlat);
            }
            return atPoint;
        }

        /**
         * Method: getLength
         * Calculate the length of this geometry. This method is defined in
         * subclasses.
         * 计算几何对象的长度 ，此方法需要在子类中定义  。
         *
         * Returns:
         * {Float} The length of the collection by summing its parts
         */

    }, {
        key: 'getLength',
        value: function getLength() {
            //to be overridden by geometries that actually have a length
            //
            return 0.0;
        }

        /**
         * Method: getArea
         * Calculate the area of this geometry. This method is defined in subclasses.
         *     计算几何对象的面积 ，此方法需要在子类中定义  。
         *
         * Returns:
         * {Float} The area of the collection by summing its parts
         */

    }, {
        key: 'getArea',
        value: function getArea() {
            //to be overridden by geometries that actually have an area
            //
            return 0.0;
        }

        /**
         * APIMethod: getCentroid
         * 计算几何图形的质心。
         * （需要在子类中实现此方法）
         * Returns:
         * {<SuperMap.Geometry.Point>} 采集的质心。
         */

    }, {
        key: 'getCentroid',
        value: function getCentroid() {
            return null;
        }

        /**
         * Method: toString
         * 返回geometry对象的字符串表述，需要引入SuperMap.Format.WKT.(Returns the Well-Known Text representation of a geometry.If the WKT format is
         *     included in a build, this will be the Well-Known Text
         *     representation.)此方法只能在子类实现，在父类使用会报错。
         *
         * Returns:
         * {String} geometry对象的字符串表述(Well-Known Text)
         */

    }, {
        key: 'toString',
        value: function toString() {
            var string;
            if (_WKT2.default) {
                var wkt = new _WKT2.default();
                string = wkt.write(new _Vector2.default(this));
            } else {
                string = Object.prototype.toString.call(this);
            }
            return string;
        }

        /**
         * Function: SuperMap.Geometry.fromWKT
         * 从一个给定的字符串生成一个geometry对象，需要引入SuperMap.Format.WKT，该方法方可生效。
         * (Generate a geometry given a Well-Known Text string.For this method to
         *     work, you must include the SuperMap.Format.WKT in your build
         *     explicitly.)
         *
         * (code)
         *     var geometry= new SuperMap.Geometry.fromWKT("POINT(0 0)");
         *     geometry.x=0;
         * (end)
         *
         * Parameters:
         * wkt - {String} 描述geometry信息的字符串(A string representing the geometry in Well-Known Text.)
         *
         * Returns:
         * {<SuperMap.Geometry>} 适当类型的geometry对象(A geometry of the appropriate class).
         */

    }], [{
        key: 'fromWKT',
        value: function fromWKT(wkt) {
            var geom;
            if (_WKT2.default) {
                var format = Geometry.fromWKT.format;
                if (!format) {
                    format = new _WKT2.default();
                    Geometry.fromWKT.format = format;
                }
                var result = format.read(wkt);
                if (result instanceof _Vector2.default) {
                    geom = result.geometry;
                } else if (_Util.Util.isArray(result)) {
                    var len = result.length;
                    var components = new Array(len);
                    for (var i = 0; i < len; ++i) {
                        components[i] = result[i].geometry;
                    }
                    geom = new Geometry.Collection(components);
                }
            }
            return geom;
        }

        /**
         * Method: SuperMap.Geometry.segmentsIntersect
         *  线段相交
         * Determine whether two line segments intersect.  Optionally calculates
         *     and returns the intersection point.  This function is optimized for
         *     cases where seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1.  In those
         *     obvious cases where there is no intersection, the function should
         *     not be called.
         *    该方法是判断两条线段是否相交。计算并返回相交的point。如果seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1 ，该方法明显不会被调用。
         *
         * Parameters:
         * seg1 - {Object} Object representing a segment with properties x1, y1, x2,
         *     and y2.  The start point is represented by x1 and y1.  The end point
         *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
         *     该对象包含的属性是 x1, y1, x2,和y2。
         *     起始点是 由x1 and y1构成，终点是有x2 and y2组成，必须满足的是x1 < x2。
         *
         * seg2 - {Object} Object representing a segment with properties x1, y1, x2,
         *     and y2.  The start point is represented by x1 and y1.  The end point
         *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
         *     该对象包含的属性是 x1, y1, x2,和y2。
         *     起始点是 由x1 and y1构成，终点是有x2 and y2组成，必须满足的是x1 < x2。
         * options - {Object} Optional properties for calculating the intersection.
         *  该对象是判断是否计算相交的点。
         *
         * Valid options:
         * point - {Boolean} Return the intersection point.  If false, the actual
         *     intersection point will not be calculated.  If true and the segments
         *     intersect, the intersection point will be returned.  If true and
         *     the segments do not intersect, false will be returned.  If true and
         *     the segments are coincident, true will be returned.
         *     返回相交点。如果设置为false，说明实际的相交点不需要计算出来。如果设置为true,并且这两条线段相交，返回相交的点 。
         *     如果设置为true，但是两条线段不相交，返回false。如果设置为true，但是两条线段平行，则返回true。
         * tolerance - {Number} If a non-null value is provided, if the segments are
         *     within the tolerance distance, this will be considered an intersection.
         *     In addition, if the point option is true and the calculated intersection
         *     is within the tolerance distance of an end point, the endpoint will be
         *     returned instead of the calculated intersection.  Further, if the
         *     intersection is within the tolerance of endpoints on both segments, or
         *     if two segment endpoints are within the tolerance distance of eachother
         *     (but no intersection is otherwise calculated), an endpoint on the
         *     first segment provided will be returned.
         *     如果设置该值不为空，两条线段在容线的范围内，则会被当作相交。此外，如果point这个属性为true，计算相交的容线距离终点,端点将返回而不是计算相交。
         *
         *
         *
         * Returns:
         * {Boolean | <SuperMap.Geometry.Point>}  The two segments intersect.
         *     If the point argument is true, the return will be the intersection
         *     point or false if none exists.  If point is true and the segments
         *     are coincident, return will be true (and the instersection is equal
         *     to the shorter segment).
         *     返回线之间是否相交，如果设置点属性为true的话，会返回相交的点坐标。如果点为true，线重合，将会返回true（相交的等于最短的线）。
         */

    }, {
        key: 'segmentsIntersect',
        value: function segmentsIntersect(seg1, seg2, options) {
            var point = options && options.point;
            var tolerance = options && options.tolerance;
            var intersection = false;
            var x11_21 = seg1.x1 - seg2.x1;
            var y11_21 = seg1.y1 - seg2.y1;
            var x12_11 = seg1.x2 - seg1.x1;
            var y12_11 = seg1.y2 - seg1.y1;
            var y22_21 = seg2.y2 - seg2.y1;
            var x22_21 = seg2.x2 - seg2.x1;
            var d = y22_21 * x12_11 - x22_21 * y12_11;
            var n1 = x22_21 * y11_21 - y22_21 * x11_21;
            var n2 = x12_11 * y11_21 - y12_11 * x11_21;
            if (d == 0) {
                // parallel
                if (n1 == 0 && n2 == 0) {
                    // coincident
                    intersection = true;
                }
            } else {
                var along1 = n1 / d;
                var along2 = n2 / d;
                if (along1 >= 0 && along1 <= 1 && along2 >= 0 && along2 <= 1) {
                    // intersect
                    if (!point) {
                        intersection = true;
                    } else {
                        // calculate the intersection point
                        var x = seg1.x1 + along1 * x12_11;
                        var y = seg1.y1 + along1 * y12_11;
                        intersection = new Geometry.Point(x, y);
                    }
                }
            }
            if (tolerance) {
                var dist;
                if (intersection) {
                    if (point) {
                        var segs = [seg1, seg2];
                        var seg, x, y;
                        // check segment endpoints for proximity to intersection
                        // set intersection to first endpoint within the tolerance
                        outer: for (var i = 0; i < 2; ++i) {
                            seg = segs[i];
                            for (var j = 1; j < 3; ++j) {
                                x = seg["x" + j];
                                y = seg["y" + j];
                                dist = Math.sqrt(Math.pow(x - intersection.x, 2) + Math.pow(y - intersection.y, 2));
                                if (dist < tolerance) {
                                    intersection.x = x;
                                    intersection.y = y;
                                    break outer;
                                }
                            }
                        }
                    }
                } else {
                    // no calculated intersection, but segments could be within
                    // the tolerance of one another
                    var segs = [seg1, seg2];
                    var source, target, x, y, p, result;
                    // check segment endpoints for proximity to intersection
                    // set intersection to first endpoint within the tolerance
                    outer: for (var i = 0; i < 2; ++i) {
                        source = segs[i];
                        target = segs[(i + 1) % 2];
                        for (var j = 1; j < 3; ++j) {
                            p = { x: source["x" + j], y: source["y" + j] };
                            result = Geometry.distanceToSegment(p, target);
                            if (result.distance < tolerance) {
                                if (point) {
                                    intersection = new Geometry.Point(p.x, p.y);
                                } else {
                                    intersection = true;
                                }
                                break outer;
                            }
                        }
                    }
                }
            }
            return intersection;
        }

        /**
         * Function: SuperMap.Geometry.distanceToSegment
         * 计算点到直线的距离
         *
         * Parameters:
         * point - {Object} An object with x and y properties representing the
         *     point coordinates.
         *     一个点包含x和y坐标。
         * segment - {Object} An object with x1, y1, x2, and y2 properties
         *     representing endpoint coordinates.
         *     一个对象包含 x1, y1, x2, and y2坐标。
         *     (code)
         *        var point={
         *         x:0,
         *          y:13
         *          } ,
         *            seg1={
         *             x1:6,
         *             y1:5,
         *            x2:6,
         *            y2:12
         *       } ;
         *       var geo=SuperMap.Geometry.distanceToSegment(point,seg1);
         *     (end)
         *
         * Returns:
         * {Object} An object with distance, x, and y properties.  The distance
         *     will be the shortest distance between the input point and segment.
         *     The x and y properties represent the coordinates along the segment
         *     where the shortest distance meets the segment.
         *     返回的是点到直线的最短距离，以及点与直线最短距离相交的点坐标（x,y）。
         */

    }, {
        key: 'distanceToSegment',
        value: function distanceToSegment(point, segment) {
            var x0 = point.x;
            var y0 = point.y;
            var x1 = segment.x1;
            var y1 = segment.y1;
            var x2 = segment.x2;
            var y2 = segment.y2;
            var dx = x2 - x1;
            var dy = y2 - y1;
            var along = (dx * (x0 - x1) + dy * (y0 - y1)) / (Math.pow(dx, 2) + Math.pow(dy, 2));
            var x, y;
            if (along <= 0.0) {
                x = x1;
                y = y1;
            } else if (along >= 1.0) {
                x = x2;
                y = y2;
            } else {
                x = x1 + along * dx;
                y = y1 + along * dy;
            }
            return {
                distance: Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)),
                x: x, y: y
            };
        }
    }]);

    return Geometry;
}();

exports.default = Geometry;

_SuperMap2.default.Geometry = Geometry;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Collection2 = __webpack_require__(14);

var _Collection3 = _interopRequireDefault(_Collection2);

var _LineString = __webpack_require__(23);

var _LineString2 = _interopRequireDefault(_LineString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.MultiLineString
 * @classdesc 几何对象多线类。
 * @extends {SuperMap.Geometry.Collection}
 * @param components - {Array<SuperMap.Geometry.LineString>} LineString数组。
 * @example 
 * var multi = new SuperMap.Geometry.MultiLineString([
 *      new SuperMap.Geometry.LineString([
 *          new SuperMap.Geometry.Point(1, 0),
 *          new SuperMap.Geometry.Point(0, 1)
 *      ])
 *  ]);
 */
var MultiLineString = function (_Collection) {
    _inherits(MultiLineString, _Collection);

    function MultiLineString(components) {
        _classCallCheck(this, MultiLineString);

        var _this = _possibleConstructorReturn(this, (MultiLineString.__proto__ || Object.getPrototypeOf(MultiLineString)).call(this, components));

        _this.componentTypes = ["SuperMap.Geometry.LineString"];
        _this.CLASS_NAME = "SuperMap.Geometry.MultiLineString";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.MultiLineString.prototype.split
     * @description Use this geometry (the source) to attempt to split a target geometry.
     * @param geometry - {SuperMap.Geometry} The target geometry.
     * @param options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.<br>
     *
     * Valid options:<br>
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.<br>
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.<br>
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * @returns {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     */


    /**
     * @member SuperMap.Geometry.MultiLineString.prototype.componentTypes -{Array<string>}
     * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
     * @readonly
     * @default ["{@link SuperMap.Geometry.LineString}"]
     */


    _createClass(MultiLineString, [{
        key: 'split',
        value: function split(geometry, options) {
            var results = null;
            var mutual = options && options.mutual;
            var splits, sourceLine, sourceLines, sourceSplit, targetSplit;
            var sourceParts = [];
            var targetParts = [geometry];
            for (var i = 0, len = this.components.length; i < len; ++i) {
                sourceLine = this.components[i];
                sourceSplit = false;
                for (var j = 0; j < targetParts.length; ++j) {
                    splits = sourceLine.split(targetParts[j], options);
                    if (splits) {
                        if (mutual) {
                            sourceLines = splits[0];
                            for (var k = 0, klen = sourceLines.length; k < klen; ++k) {
                                if (k === 0 && sourceParts.length) {
                                    sourceParts[sourceParts.length - 1].addComponent(sourceLines[k]);
                                } else {
                                    sourceParts.push(new MultiLineString([sourceLines[k]]));
                                }
                            }
                            sourceSplit = true;
                            splits = splits[1];
                        }
                        if (splits.length) {
                            // splice in new target parts
                            splits.unshift(j, 1);
                            Array.prototype.splice.apply(targetParts, splits);
                            break;
                        }
                    }
                }
                if (!sourceSplit) {
                    // source line was not hit
                    if (sourceParts.length) {
                        // add line to existing multi
                        sourceParts[sourceParts.length - 1].addComponent(sourceLine.clone());
                    } else {
                        // create a fresh multi
                        sourceParts = [new MultiLineString(sourceLine.clone())];
                    }
                }
            }
            if (sourceParts && sourceParts.length > 1) {
                sourceSplit = true;
            } else {
                sourceParts = [];
            }
            if (targetParts && targetParts.length > 1) {
                targetSplit = true;
            } else {
                targetParts = [];
            }
            if (sourceSplit || targetSplit) {
                if (mutual) {
                    results = [sourceParts, targetParts];
                } else {
                    results = targetParts;
                }
            }
            return results;
        }

        /**
         * @function SuperMap.Geometry.MultiLineString.prototype.splitWith
         * @description Split this geometry (the target) with the given geometry (the source).
         * @param geometry - {SuperMap.Geometry} A geometry used to split this geometry (the source).
         * @param options - {Object} Properties of this object will be used to determine
         *     how the split is conducted.<br>
         *
         * Valid options:<br>
         * mutual - {Boolean} Split the source geometry in addition to the target
         *     geometry.  Default is false.<br>
         * edge - {Boolean} Allow splitting when only edges intersect.  Default is
         *     true.  If false, a vertex on the source must be within the tolerance
         *     distance of the intersection to be considered a split.<br>
         * tolerance - {Number} If a non-null value is provided, intersections
         *     within the tolerance distance of an existing vertex on the source
         *     will be assumed to occur at the vertex.
         *
         * @returns {Array} A list of geometries (of this same type as the target) that
         *     result from splitting the target with the source geometry.  The
         *     source and target geometry will remain unmodified.  If no split
         *     results, null will be returned.  If mutual is true and a split
         *     results, return will be an array of two arrays - the first will be
         *     all geometries that result from splitting the source geometry and
         *     the second will be all geometries that result from splitting the
         *     target geometry.
         */

    }, {
        key: 'splitWith',
        value: function splitWith(geometry, options) {
            var results = null;
            var mutual = options && options.mutual;
            var splits, targetLine, sourceLines, sourceSplit, targetSplit, sourceParts, targetParts;
            if (geometry instanceof _LineString2.default) {
                targetParts = [];
                sourceParts = [geometry];
                for (var i = 0, len = this.components.length; i < len; ++i) {
                    targetSplit = false;
                    targetLine = this.components[i];
                    for (var j = 0; j < sourceParts.length; ++j) {
                        splits = sourceParts[j].split(targetLine, options);
                        if (splits) {
                            if (mutual) {
                                sourceLines = splits[0];
                                if (sourceLines.length) {
                                    // splice in new source parts
                                    sourceLines.unshift(j, 1);
                                    Array.prototype.splice.apply(sourceParts, sourceLines);
                                    j += sourceLines.length - 2;
                                }
                                splits = splits[1];
                                if (splits.length === 0) {
                                    splits = [targetLine.clone()];
                                }
                            }
                            for (var k = 0, klen = splits.length; k < klen; ++k) {
                                if (k === 0 && targetParts.length) {
                                    targetParts[targetParts.length - 1].addComponent(splits[k]);
                                } else {
                                    targetParts.push(new MultiLineString([splits[k]]));
                                }
                            }
                            targetSplit = true;
                        }
                    }
                    if (!targetSplit) {
                        // target component was not hit
                        if (targetParts.length) {
                            // add it to any existing multi-line
                            targetParts[targetParts.length - 1].addComponent(targetLine.clone());
                        } else {
                            // or start with a fresh multi-line
                            targetParts = [new MultiLineString([targetLine.clone()])];
                        }
                    }
                }
            } else {
                results = geometry.split(this);
            }
            if (sourceParts && sourceParts.length > 1) {
                sourceSplit = true;
            } else {
                sourceParts = [];
            }
            if (targetParts && targetParts.length > 1) {
                targetSplit = true;
            } else {
                targetParts = [];
            }
            if (sourceSplit || targetSplit) {
                if (mutual) {
                    results = [sourceParts, targetParts];
                } else {
                    results = targetParts;
                }
            }
            return results;
        }
    }]);

    return MultiLineString;
}(_Collection3.default);

exports.default = MultiLineString;

_SuperMap2.default.Geometry.MultiLineString = MultiLineString;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Collection2 = __webpack_require__(14);

var _Collection3 = _interopRequireDefault(_Collection2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.MultiPolygon
 * @classdesc 几何对象多多边形类。
 * @extends {SuperMap.Geometry.Collection}
 * @param  components - {Array<SuperMap.Geometry.Polygon>} 形成 MultiPolygon 的多边形数组。
 * @example
 * var points1 = [new SuperMap.Geometry.Point(10,10),new SuperMap.Geometry.Point(0,0)];
 * var points2 = [new SuperMap.Geometry.Point(10,10),new SuperMap.Geometry.Point(0,0),new SuperMap.Geometry.Point(3,3),new SuperMap.Geometry.Point(10,10)];
 *
 * var linearRing1 = new SuperMap.Geometry.LinearRing(points1);
 * var linearRing2 = new SuperMap.Geometry.LinearRing(points2);
 *
 * var polygon1 = new SuperMap.Geometry.Polygon([linearRing1]);
 * var polygon2 = new SuperMap.Geometry.Polygon([linearRing2]);
 *
 * var multiPolygon1 = new SuperMap.Geometry.MultiPolygon([polygon1,polygon2]);
 */
var MultiPolygon = function (_Collection) {
  _inherits(MultiPolygon, _Collection);

  function MultiPolygon(components) {
    _classCallCheck(this, MultiPolygon);

    var _this = _possibleConstructorReturn(this, (MultiPolygon.__proto__ || Object.getPrototypeOf(MultiPolygon)).call(this, components));

    _this.componentTypes = ["SuperMap.Geometry.Polygon"];
    _this.CLASS_NAME = "SuperMap.Geometry.MultiPolygon";
    return _this;
  }

  /**
   * @member SuperMap.Geometry.MultiPolygon.prototype.componentTypes -{Array<string>}
   * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
   * @readonly
   * @default ["{@link SuperMap.Geometry.Polygon}"]
   */


  return MultiPolygon;
}(_Collection3.default);

exports.default = MultiPolygon;

_SuperMap2.default.Geometry.MultiPolygon = MultiPolygon;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Format
 * @classdesc 读写各种格式的格式类基类。其子类应该包含并实现read和write方法。
 * @param options - {Object} 选项对象，其属性会被直接设置到format实例。如：<br>
 *        keepData - {boolean} 如果设置为true， <data> 属性会指向被解析的对象（例如json或xml数据对象）。
 * @return {SuperMap.Format} 实例。
 */
var Format = function () {

    /**
     * @member SuperMap.Format.prototype.data -{Object}
     * @description 当 <keepData> 属性设置为true，这是传递给<read>操作的要被解析的字符串。
     */


    /**
     * @member SuperMap.Format.prototype.externalProjection -{SuperMap.Projection}
     * @description 当设置了externalProjection和internalProjection参数，
     *              format类会重新对其读到的或写出的几何图形进行投影。externalProjection
     *              是read操作读到或write操作写出的投影内容。为了能够重新投影，针对某
     *              一个投影的transformation方法必须是有效的。同时，我们可以使用proj4js
     *              或自定义的transformation方法来进行支持。查看{SuperMap.Projection.addTransform}
     *              以获取更多的信息。
     */
    function Format(options) {
        _classCallCheck(this, Format);

        this.options = null;
        this.externalProjection = null;
        this.internalProjection = null;
        this.data = null;
        this.keepData = false;
        this.CLASS_NAME = "SuperMap.Format";

        _SuperMap2.default.Util.extend(this, options);
        this.options = options;
    }

    /**
     * @function SuperMap.Format.prototype.destroy
     * @description 销毁该格式类，释放相关资源。
     */


    /**
     * APIProperty: keepData
     * @member SuperMap.Format.prototype.keepData -{Object}
     * @description 保持最近读到的数据的引用（通过 <data> 属性）。默认值是false。
     */


    /**
     * @member SuperMap.Format.prototype.internalProjection -{SuperMap.Projection}
     * @description 当设置了externalProjection和internalProjection参数，
     *              format类会重新对其读到的或写出的几何图形进行投影。internalProjection
     *              是read操作返回或传给write操作的投影内容。为了能够重新投影，针对某
     *              一个投影的transformation方法必须是有效的。同时，我们可以使用proj4js
     *              或自定义的transformation方法来进行支持。查看{SuperMap.Projection.addTransform}
     *              以获取更多的信息。
     */


    /**
     * @member SuperMap.Format.prototype.options -{Object}
     * @description A reference to options passed to the constructor.
     */


    _createClass(Format, [{
        key: "destroy",
        value: function destroy() {}
        //用来销毁该格式类，释放相关资源


        /**
         * @function SuperMap.Format.prototype.read
         * @description Read data from a string, and return an object whose type depends on the subclass.
         * @param data - {string} Data to read/parse.
         */

    }, {
        key: "read",
        value: function read(data) {}
        //用来从字符串中读取数据


        /**
         * @function SuperMap.Format.prototype.write
         * @description Accept an object, and return a string.
         * @param object - {Object} Object to be serialized
         * @return {string} A string representation of the object.
         */

    }, {
        key: "write",
        value: function write(object) {
            //用来写字符串
        }
    }]);

    return Format;
}();

exports.default = Format;

_SuperMap2.default.Format = Format;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _BufferSetting = __webpack_require__(167);

var _BufferSetting2 = _interopRequireDefault(_BufferSetting);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.BufferAnalystParameters
 * @classdesc 缓冲区分析参数基类。
 * @param options - {Object} 参数。如:</br>
 *        bufferSetting - {SuperMap.BufferSetting} 设置缓冲区通用参数。
 */
var BufferAnalystParameters = function () {
    function BufferAnalystParameters(options) {
        _classCallCheck(this, BufferAnalystParameters);

        this.bufferSetting = null;
        this.CLASS_NAME = "SuperMap.BufferAnalystParameters";

        var me = this;
        me.bufferSetting = new _BufferSetting2.default();
        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.BufferAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */

    /**
     * @member SuperMap.BufferAnalystParameters.prototype.bufferSetting -{SuperMap.BufferSetting}
     * @description 设置缓冲区通用参数。为缓冲区分析提供必要的参数信息，包括左缓冲距离、右缓冲距离、端点类型、圆头缓冲圆弧处线段的个数信息。
     */


    _createClass(BufferAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.bufferSetting) {
                me.bufferSetting.destroy();
                me.bufferSetting = null;
            }
        }
    }]);

    return BufferAnalystParameters;
}();

exports.default = BufferAnalystParameters;

_SuperMap2.default.BufferAnalystParameters = BufferAnalystParameters;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.OverlayAnalystParameters
 * @classdesc 叠加分析参数基类，数据集叠加分析参数和几何对象叠加分析参数均继承此基类
 * @param options - {Object} 参数。
 */
var OverlayAnalystParameters = function () {
    function OverlayAnalystParameters(options) {
        _classCallCheck(this, OverlayAnalystParameters);

        this.operation = _REST.OverlayOperationType.UNION;
        this.CLASS_NAME = "SuperMap.OverlayAnalystParameters";

        var me = this;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
    }

    /**
     * @function SuperMap.OverlayAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.OverlayAnalystParameters.prototype.operation -{OverlayOperationType}
     * @description 指定叠加分析操作类型。
     */


    _createClass(OverlayAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.operation = null;
        }
    }]);

    return OverlayAnalystParameters;
}();

exports.default = OverlayAnalystParameters;

_SuperMap2.default.OverlayAnalystParameters = OverlayAnalystParameters;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _DataReturnOption = __webpack_require__(24);

var _DataReturnOption2 = _interopRequireDefault(_DataReturnOption);

var _REST = __webpack_require__(1);

var _SurfaceAnalystParametersSetting = __webpack_require__(240);

var _SurfaceAnalystParametersSetting2 = _interopRequireDefault(_SurfaceAnalystParametersSetting);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SurfaceAnalystParameters
 * @classdesc
 * 表面分析提取操作参数类。
 * 通过该类可以为进行表面分析提供参数信息，包括表面分析的方法提取等值线、提取等值面和中间结果的分辨率，
 * {SuperMap.DatasetSurfaceAnalystParameters} 和 {SuperMap.GeometrySurfaceAnalystParameters} 继承自该类。
 * @param options - {Object} 可选参数。如:</br>
 *        extractParameter - {SuperMap.SurfaceAnalystParametersSetting} 获取或设置表面分析参数。</br>
 *        resolution - {number}指定中间结果（栅格数据集）的分辨率。</br>
 *        resultSetting - {SuperMap.DataReturnOption} 结果返回设置类。</br>
 *        surfaceAnalystMethod - {SuperMap.SurfaceAnalystMethod} 获取或设置表面分析的提取方法，提取等值线和提取等值面。</br>
 */
var SurfaceAnalystParameters = function () {

    /**
     * @member SuperMap.SurfaceAnalystParameters.prototype.resultSetting -{SuperMap.DataReturnOption}
     * @description 结果返回设置类。
     */


    /**
     * @member SuperMap.SurfaceAnalystParameters.prototype.resolution -{number}
     * @description 获取或设置指定中间结果（栅格数据集）的分辨率。
     */
    function SurfaceAnalystParameters(options) {
        _classCallCheck(this, SurfaceAnalystParameters);

        this.resolution = 0;
        this.extractParameter = null;
        this.resultSetting = null;
        this.surfaceAnalystMethod = _REST.SurfaceAnalystMethod.ISOLINE;
        this.CLASS_NAME = "SuperMap.SurfaceAnalystParameters";

        var me = this;
        me.extractParameter = new _SurfaceAnalystParametersSetting2.default();
        me.resultSetting = new _DataReturnOption2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.SurfaceAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.SurfaceAnalystParameters.prototype.surfaceAnalystMethod -{SuperMap.SurfaceAnalystMethod}
     * @description 获取或设置表面分析的提取方法，提取等值线和提取等值面，默认为等值线分析。
     */


    /**
     * @member SuperMap.SurfaceAnalystParameters.prototype.extractParameter -{SuperMap.SurfaceAnalystParametersSetting}
     * @description 获取或设置表面分析参数。
     * 在进行点数据集进行提取等值面分析时，暂时不支持 SurfaceAnalystParametersSetting 类中的 expectedZValues 字段。
     */


    _createClass(SurfaceAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.resolution = null;
            if (me.extractParameter) {
                me.extractParameter.destroy();
                me.extractParameter = null;
            }
            if (me.resultSetting) {
                me.resultSetting.destroy();
                me.resultSetting = null;
            }
            me.surfaceAnalystMethod = null;
        }
    }]);

    return SurfaceAnalystParameters;
}();

exports.default = SurfaceAnalystParameters;

_SuperMap2.default.SurfaceAnalystParameters = SurfaceAnalystParameters;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Theme2 = __webpack_require__(13);

var _Theme3 = _interopRequireDefault(_Theme2);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeDotDensity
 * @classdesc 点密度专题图。<br>
 *              点密度专题图用一定大小、形状相同的点表示现象分布范围、数量特征和分布密度。点的多少和所代表的意义由地图的内容确定。<br>
 *              点密度专题图利用图层的某一数值属性信息（专题值）映射为不同等级，每一级别使用不同数量或表现为密度的点符号来表示。<br>
 *              该专题值在各个分区内的分布情况，体现不同区域的相对数量差异。多用于具有数量特征的地图上，<br>
 *              比如表示不同地区的粮食产量、GDP、人口等的分级，主要针对区域或面状的要素，因而，点密度专题图适用于面数据集。<br>
 *              注意：点密度专题图中点的分布是随机的，并不代表实际的分布位置。即使在相关设置完全相同的情况下，<br>
 *              每次制作出的专题图，点的数量相同，但点的位置都有差异。
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        dotExpression - {string} 创建点密度专题图的字段或字段表达式。<br>
 *        style - {SuperMap.ServerStyle} 点密度专题图中点的风格。<br>
 *        value - {string} 专题图中每一个点所代表的数值。<br>
 *        memoryData - {SuperMap.REST.ThemeMemoryData} 专题图内存数据。
 */
var ThemeDotDensity = function (_Theme) {
    _inherits(ThemeDotDensity, _Theme);

    /**
     * @member SuperMap.ThemeDotDensity.prototype.style -{SuperMap.ServerStyle}
     * @description 点密度专题图中点的风格。
     */
    function ThemeDotDensity(options) {
        _classCallCheck(this, ThemeDotDensity);

        var _this = _possibleConstructorReturn(this, (ThemeDotDensity.__proto__ || Object.getPrototypeOf(ThemeDotDensity)).call(this, "DOTDENSITY", options));

        _this.dotExpression = null;
        _this.style = null;
        _this.value = null;
        _this.CLASS_NAME = "SuperMap.ThemeDotDensity";

        var me = _this;
        me.style = new _ServerStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.ThemeDotDensity.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeDotDensity.prototype.value -{number}
     * @description 专题图中每一个点所代表的数值。<br>
     *              点值的确定与地图比例尺以及点的大小有关。地图比例尺越大，相应的图面范围也越大，<br>
     *              点相应就可以越多，此时点值就可以设置相对小一些。点形状越大，<br>
     *              点值相应就应该设置的小一些。点值过大或过小都是不合适的。
     */


    /**
     * @member SuperMap.ThemeDotDensity.prototype.dotExpression -{string}
     * @description 创建点密度专题图的字段或字段表达式。点的数目或密集程度的来源。
     */


    _createClass(ThemeDotDensity, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.dotExpression = null;
            me.value = null;

            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
        }

        /**
         * @function SuperMap.ThemeDotDensity.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _SuperMap2.default.Util.copyAttributes(obj, this);
            if (obj.style) {
                if (obj.style.toServerJSONObject) {
                    obj.style = obj.style.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeDotDensity.fromObj
         * @description 从传入对象获取点密度专题图中点的风格。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeDotDensity}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeDotDensity();
            _SuperMap2.default.Util.copy(res, obj);
            res.style = _ServerStyle2.default.fromJson(obj.style);
            return res;
        }
    }]);

    return ThemeDotDensity;
}(_Theme3.default);

exports.default = ThemeDotDensity;


_SuperMap2.default.ThemeDotDensity = ThemeDotDensity;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Theme2 = __webpack_require__(13);

var _Theme3 = _interopRequireDefault(_Theme2);

var _ThemeFlow = __webpack_require__(51);

var _ThemeFlow2 = _interopRequireDefault(_ThemeFlow);

var _ThemeOffset = __webpack_require__(53);

var _ThemeOffset2 = _interopRequireDefault(_ThemeOffset);

var _ThemeGraduatedSymbolStyle = __webpack_require__(242);

var _ThemeGraduatedSymbolStyle2 = _interopRequireDefault(_ThemeGraduatedSymbolStyle);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeGraduatedSymbol
 * @classdesc 等级符号专题图。
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        baseValue - {number}等级符号专题图的基准值，单位同专题变量的单位。<br>
 *        expression - {string} 等级符号专题图的字段或字段表达式。<br>
 *        flow - {SuperMap.ThemeFlow} 等级符号专题图符号流动显示与牵引线设置类。<br>
 *        graduatedMode - {SuperMap.GraduatedMode} 等级符号专题图分级模式。<br>
 *        offset - {SuperMap.ThemeOffset} 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。<br>
 *        style - {SuperMap.ThemeGraduatedSymbolStyle} 用于设置等级符号图正负和零值显示风格。<br>
 *        memoryData - {SuperMap.ThemeMemoryData} 专题图内存数据。
 */
var ThemeGraduatedSymbol = function (_Theme) {
    _inherits(ThemeGraduatedSymbol, _Theme);

    /**
     * @member SuperMap.ThemeGraduatedSymbol.prototype.offset -{SuperMap.ThemeOffset}
     * @description 用于设置等级符号图相对于要素内点的偏移量。
     */


    /**
     * @member SuperMap.ThemeGraduatedSymbol.prototype.flow -{SuperMap.ThemeFlow}
     * @description 等级符号专题图符号流动显示与牵引线设置类。<br>
     *              通过该字段可以设置等级符号是否流动显示和牵引线风格。
     */


    /**
     * @member SuperMap.ThemeGraduatedSymbol.prototype.baseValue -{number}
     * @description 等级符号专题图的基准值，单位同专题变量的单位。<br>
     *              依据此值系统会自动根据分级方式计算其余值对应的符号大小，每个符号的显示大小等于<br>
     *              ThemeValueSection.positiveStyle（或 zeroStyle，negativeStyle）.markerSize * value / basevalue，<br>
     *              其中 value 是 expression 所指定字段对应的值经过分级计算之后的值。默认值为0，建议通过多次尝试设置该值才能达到较好的显示效果。
     */
    function ThemeGraduatedSymbol(options) {
        _classCallCheck(this, ThemeGraduatedSymbol);

        var _this = _possibleConstructorReturn(this, (ThemeGraduatedSymbol.__proto__ || Object.getPrototypeOf(ThemeGraduatedSymbol)).call(this, "GRADUATEDSYMBOL", options));

        _this.baseValue = 0;
        _this.expression = null;
        _this.flow = null;
        _this.graduatedMode = _REST.GraduatedMode.CONSTANT;
        _this.offset = null;
        _this.style = null;
        _this.CLASS_NAME = "SuperMap.ThemeGraduatedSymbol";

        var me = _this;
        me.flow = new _ThemeFlow2.default();
        me.offset = new _ThemeOffset2.default();
        me.style = new _ThemeGraduatedSymbolStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.ThemeGraduatedSymbol.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeGraduatedSymbol.prototype.style -{SuperMap.ThemeGraduatedSymbolStyle}
     * @description 用于设置等级符号图正负和零值显示风格。
     */


    /**
     * @member SuperMap.ThemeGraduatedSymbol.prototype.graduatedMode -{SuperMap.GraduatedMode}
     * @description 等级符号专题图分级模式。<br>
     *              分级主要是为了减少制作等级符号专题图中数据大小之间的差异。如果数据之间差距较大，则可以采用对数或者平方根的分级方式来进行，<br>
     *              这样就减少了数据之间的绝对大小的差异，使得等级符号图的视觉效果比较好，同时不同类别之间的比较也是有意义的。<br>
     *              有三种分级模式：常数、对数和平方根，对于有值为负数的字段，在用对数或平方根方式分级时，默认对负数取正。<br>
     *              不同的分级模式用于确定符号大小的数值是不相同的：常数按照字段的原始数据进行；对数则是对每条记录对应的专题变量取自然对数；<br>
     *              平方根则是对其取平方根，然后用最终得到的结果来确定其等级符号的大小。<br>
     *              默认值为 SuperMap.GraduatedMode.CONSTANT。
     */


    /**
     * @member SuperMap.ThemeGraduatedSymbol.prototype.expression -{string}
     * @description 用于创建等级符号专题图的字段或字段表达式，字段或字段表达式应为数值型。必设字段。
     */


    _createClass(ThemeGraduatedSymbol, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeGraduatedSymbol.prototype.__proto__ || Object.getPrototypeOf(ThemeGraduatedSymbol.prototype), 'destroy', this).call(this);
            var me = this;
            me.expression = null;
            if (me.flow) {
                me.flow.destroy();
                me.flow = null;
            }
            me.graduatedMode = _REST.GraduatedMode.CONSTANT;
            if (me.offset) {
                me.offset.destroy();
                me.offset = null;
            }
            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
        }

        /**
         * @function SuperMap.ThemeGraduatedSymbol.prototype.toJSON
         * @description 将themeLabel对象转化为json字符串。
         * @return {string} 返回转换后的 JSON 字符串。
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            return _SuperMap2.default.Util.toJSON(this.toServerJSONObject());
        }

        /**
         * @function SuperMap.ThemeGraduatedSymbol.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj.type = this.type;
            obj.memoryData = this.memoryData;
            obj.baseValue = this.baseValue;
            obj.expression = this.expression;
            obj.graduatedMode = this.graduatedMode;
            if (this.flow) {
                obj.flowEnabled = this.flow.flowEnabled;
                obj.leaderLineDisplayed = this.flow.leaderLineDisplayed;
                obj.leaderLineStyle = this.flow.leaderLineStyle;
            }
            if (this.offset) {
                obj.offsetFixed = this.offset.offsetFixed;
                obj.offsetX = this.offset.offsetX;
                obj.offsetY = this.offset.offsetY;
            }
            if (this.style) {
                obj.negativeStyle = this.style.negativeStyle;
                obj.negativeDisplayed = this.style.negativeDisplayed;
                obj.positiveStyle = this.style.positiveStyle;
                obj.zeroDisplayed = this.style.zeroDisplayed;
                obj.zeroStyle = this.style.zeroStyle;
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeGraduatedSymbol.fromObj
         * @description 从传入对象获取等级符号专题图。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraduatedSymbol}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new _SuperMap2.default.ThemeGraduatedSymbol();
            _SuperMap2.default.Util.copy(res, obj);
            res.flow = _ThemeFlow2.default.fromObj(obj);
            res.offset = _ThemeOffset2.default.fromObj(obj);
            res.style = _ThemeGraduatedSymbolStyle2.default.fromObj(obj);
            return res;
        }
    }]);

    return ThemeGraduatedSymbol;
}(_Theme3.default);

exports.default = ThemeGraduatedSymbol;


_SuperMap2.default.ThemeGraduatedSymbol = ThemeGraduatedSymbol;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Theme2 = __webpack_require__(13);

var _Theme3 = _interopRequireDefault(_Theme2);

var _ThemeFlow = __webpack_require__(51);

var _ThemeFlow2 = _interopRequireDefault(_ThemeFlow);

var _ThemeOffset = __webpack_require__(53);

var _ThemeOffset2 = _interopRequireDefault(_ThemeOffset);

var _ThemeGraphAxes = __webpack_require__(243);

var _ThemeGraphAxes2 = _interopRequireDefault(_ThemeGraphAxes);

var _ThemeGraphSize = __webpack_require__(245);

var _ThemeGraphSize2 = _interopRequireDefault(_ThemeGraphSize);

var _ThemeGraphText = __webpack_require__(246);

var _ThemeGraphText2 = _interopRequireDefault(_ThemeGraphText);

var _ThemeGraphItem = __webpack_require__(244);

var _ThemeGraphItem2 = _interopRequireDefault(_ThemeGraphItem);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeGraph
 * @classdesc 统计专题图类。
 * @extends SuperMap.Theme
 * @param options - {Object} 参数。<br>
 *        barWidth - {number}柱状专题图中每一个柱的宽度。<br>
 *        flow - {SuperMap.ThemeFlow} 统计专题图流动显示与牵引线设置。<br>
 *        graduatedMode - {SuperMap.GraduatedMode} 统计图中地理要素的值与图表尺寸间的映射关系。<br>
 *        graphAxes - {SuperMap.ThemeGraphAxes} 统计图中坐标轴样式相关信息。<br>
 *        graphSize - {SuperMap.ThemeGraphSize} 统计符号的最大最小尺寸。<br>
 *        graphSizeFixed - {boolean} 缩放地图时统计图符号是否固定大小。<br>
 *        graphText - {SuperMap.ThemeGraphText} 统计图上的文字是否可以见以及文字标注风格。<br>
 *        graphType - {SuperMap.ThemeGraphType} 统计专题图类型。<br>
 *        items - {Array<SuperMap.ThemeGraphItem>} 统计专题图子项集合。<br>
 *        memoryKeys - {Array<Integer>} 以内存数组方式制作专题图时的键数组。<br>
 *        negativeDisplayed - {boolean} 专题图中是否显示属性为负值的数据。<br>
 *        offset - {SuperMap.ThemeOffset} 统计图相对于要素内点的偏移量。<br>
 *        overlapAvoided - {boolean} 统计图是否采用避让方式显示。<br>
 *        roseAngle - {number}统计图中玫瑰图或三维玫瑰图用于等分的角度。<br>
 *        startAngle - {number}饼状统计图扇形的起始角度。
 */
var ThemeGraph = function (_Theme) {
    _inherits(ThemeGraph, _Theme);

    /**
     * @member SuperMap.ThemeGraph.prototype.roseAngle -{number}
     * @description 统计图中玫瑰图或三维玫瑰图用于等分的角度，默认为0度，精确到0.1度。在角度为0或者大于360度的情况下均使用360度来等分制作统计图的字段数。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.offset -{SuperMap.ThemeOffset}
     * @description 用于设置统计图相对于要素内点的偏移量。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.memoryKeys -{Array<Integer>}
     * @description 以内存数组方式制作专题图时的键数组。<br>
     *              键数组内的数值代表 SmID 值，它与 SuperMap.ThemeGraphItem 类中的值数组（SuperMap.ThemeGraphItem.memoryDoubleValues）要关联起来应用。<br>
     *              键数组中数值的个数必须要与值数组的数值个数一致。值数组中的值将代替原来的专题值来制作统计专题图。<br>
     *              目前所有的专题图都支持以内存数组的方式制作专题图，但统计专题图与其他专题图指定内存数组的方式不同，<br>
     *              统计专题图使用 memoryKeys 指定内存数组，而其他专题图则使用 memoryData 来指定内存数组。
     * @example
     *  memoryKeys的使用方法如：
     *   function addThemeGraph() {
     *      removeTheme();
     *        //创建统计专题图对象，SuperMap.ThemeGraph 必设 items。
     *       //专题图参数 ThemeParameters 必设 theme（即以设置好的分段专题图对象）、dataSourceName 和 datasetName
     *      var style1 = new SuperMap.ServerStyle({
     *                   fillForeColor: new SuperMap.ServerColor(92,73,234),
     *                   lineWidth: 0.1
     *               }),
     *               style2 = new SuperMap.ServerStyle({
     *                   fillForeColor: new SuperMap.ServerColor(211,111,240),
     *                   lineWidth: 0.1
     *               }),
     *               item1 = new SuperMap.ThemeGraphItem({
     *                   memoryDoubleValues:[1.18,0.95,0.37,1.31,0.8,1.5],
     *                  caption: "1992-1995人口增长率",
     *                  graphExpression: "Pop_Rate95",
     *                   uniformStyle: style1
     *               }),
     *               item2 = new SuperMap.ThemeGraphItem({
     *               //以内存数组方式制作专题图时的值数组
     *                   memoryDoubleValues:[2.71,0,0.74,3.1,2.2,3.5],
     *                   caption: "1995-1999人口增长率",  //专题图子项的名称
     *                   graphExpression: "Pop_Rate99",  //统计专题图的专题变量
     *                   uniformStyle: style2      //统计专题图子项的显示风格
     *               }),
     *               themeGraph  = new SuperMap.ThemeGraph({
     *               //以内存数组方式制作专题图时的键数组，键数组内的数值代表 SmID 值
     *                    memoryKeys:[1,2,4,8,10,12],
     *                   items: new Array(item1,item2),
     *                   barWidth: 0.03,
     *                    //统计图中地理要素的值与图表尺寸间的映射关系为平方根
     *                   graduatedMode: SuperMap.GraduatedMode.SQUAREROOT,
     *                   //graphAxes用于设置统计图中坐标轴样式相关信息
     *                   graphAxes: new SuperMap.ThemeGraphAxes({
     *                       axesDisplayed: true
     *                   }),
     *                   graphSize: new SuperMap.ThemeGraphSize({
     *                       maxGraphSize: 1,
     *                       minGraphSize: 0.35
     *                   }),
     *                   //统计图上的文字是否可以见以及文字标注风格
     *                   graphText: new SuperMap.ThemeGraphText({
     *                       graphTextDisplayed: true,
     *                       graphTextFormat: SuperMap.ThemeGraphTextFormat.VALUE,
     *                       graphTextStyle: new SuperMap.ServerTextStyle({
     *                           sizeFixed: true,
     *                           fontHeight: 9,
     *                           fontWidth: 5
     *                       })
     *                   }),
     *                   //统计专题图类型为三维柱状图
     *                   graphType: SuperMap.ThemeGraphType.BAR3D
     *               }),
     * //专题图参数对象
     *               themeParameters = new SuperMap.ThemeParameters({
     *                   themes: [themeGraph],
     *                   dataSourceNames: ["Jingjin"],
     *                   datasetNames: ["BaseMap_R"]
     *               }),
     *    //与服务端交互
     *               themeService=new SuperMap.ThemeService(url, {
     *                   eventListeners: {
     *                       "processCompleted": ThemeCompleted,
     *                        "processFailed": themeFailed
     *                  }
     *              });
     *       themeService.processAsync(themeParameters);
     *   }
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.graphAxesTextDisplayMode -{SuperMap.GraphAxesTextDisplayMode}
     * @description 统计专题图坐标轴文本显示模式 。默认值 SuperMap.GraphAxesTextDisplayMode.NONE。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.graphText -{SuperMap.ThemeGraphText}
     * @description 统计图上的文字是否可以见以及文字标注风格。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.graphSize -{ThemeGraphSize}
     * @description 用于设置统计符号的最大最小尺寸。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.graduatedMode -{GraduatedMode}
     * @description 统计图中地理要素的值与图表尺寸间的映射关系（常数、对数、平方根），即分级方式。
     *              默认值为 SuperMap.GraduatedMode.CONSTANT。
     *              分级主要是为了减少制作统计专题图中数据大小之间的差异，使得统计图的视觉效果比较好，同时不同类别之间的比较也还是有意义的。
     *              提供三种分级模式：常数、对数和平方根，对于有值为负数的字段，不可以采用对数和平方根的分级方式。不同的等级方式用于确定符号大小的数值是不相同的。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.barWidth -{number}
     * @description 柱状专题图中每一个柱的宽度。使用地图坐标单位，默认值为0。<br>
     *              只有选择的统计图类型为柱状图（柱状图、三维柱状图、堆叠柱状图、三维堆叠柱状图）时，此项才可设置。
     */
    function ThemeGraph(options) {
        _classCallCheck(this, ThemeGraph);

        var _this = _possibleConstructorReturn(this, (ThemeGraph.__proto__ || Object.getPrototypeOf(ThemeGraph)).call(this, "GRAPH", options));

        _this.barWidth = 0;
        _this.flow = null;
        _this.graduatedMode = _REST.GraduatedMode.CONSTANT;
        _this.graphAxes = null;
        _this.graphSize = null;
        _this.graphSizeFixed = false;
        _this.graphText = null;
        _this.graphType = _REST.ThemeGraphType.AREA;
        _this.graphAxesTextDisplayMode = _REST.GraphAxesTextDisplayMode.NONE;
        _this.items = null;
        _this.memoryKeys = null;
        _this.negativeDisplayed = false;
        _this.offset = null;
        _this.overlapAvoided = true;
        _this.roseAngle = 0;
        _this.startAngle = 0;
        _this.CLASS_NAME = "SuperMap.ThemeGraph";

        var me = _this;
        me.flow = new _ThemeFlow2.default();
        me.graphAxes = new _ThemeGraphAxes2.default();
        me.graphSize = new _ThemeGraphSize2.default();
        me.graphText = new _ThemeGraphText2.default();
        me.offset = new _ThemeOffset2.default();
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.startAngle -{number}
     * @description 饼状统计图扇形的起始角度。默认为0度，精确到0.1度，以水平方向为正向。只有选择的统计图类型为饼状图（饼图、三维饼图、玫瑰图、三维玫瑰图）时，此项才可设置。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.overlapAvoided -{boolean}
     * @description 统计图是否采用避让方式显示。<br>
     *              1.对数据集制作统计专题图:当统计图采用避让方式显示时，如果 overlapAvoided 为 true，则在统计图重叠度很大的情况下，
     *              会出现无法完全避免统计图重叠的现象；如果 overlapAvoided 为 false，会过滤掉一些统计图，从而保证所有的统计图均不重叠。<br>
     *              2.对数据集同时制作统计专题图和标签专题图：当统计图不显示子项文本时，标签专题图的标签即使和统计图重叠，两者也都可正常显示；
     *              当统计图显示子项文本时，如果统计图中的子项文本和标签专题图中的标签不重叠，则两者均正常显示；如果重叠，则会过滤掉统计图的子项文本，只显示标签。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.negativeDisplayed -{boolean}
     * @description 专题图中是否显示属性为负值的数据。true 表示显示；默认为 false 即不显示。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.items -{Array<SuperMap.ThemeGraphItem>}
     * @description 统计专题图子项集合。必设字段。
     *              统计专题图可以基于多个变量，反映多种属性，即可以将多个专题变量的值绘制在一个统计图上。每一个专题变量对应的统计图即为一个专题图子项。
     *              对于每个专题图子项可以为其设置标题、风格，甚至可以将该子项再制作成范围分段专题图。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.graphType -{SuperMap.ThemeGraphType}
     * @description 统计专题图类型。SuperMap 提供了多种类型的统计图，<br>
     *              分别为面积图、阶梯图、折线图、点状图、柱状图、三维柱状图、饼图、三维饼图、玫瑰图、三维玫瑰图、堆叠柱状图、三维堆叠柱状图、环状图。默认为面积图。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.graphSizeFixed -{boolean}
     * @description 缩放地图时统计图符号是否固定大小。默认值为 false，即统计图符号将随地图缩放。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.graphAxes -{ThemeGraphAxes}
     * @description 用于设置统计图中坐标轴样式相关信息，如坐标轴颜色、是否显示、坐标文本样式等。
     */


    /**
     * @member SuperMap.ThemeGraph.prototype.flow -{SuperMap.ThemeFlow}
     * @description 统计专题图流动显示与牵引线设置。
     *              通过该字段可以设置统计符号是否流动显示和牵引线风格。
     */


    _createClass(ThemeGraph, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeGraph.prototype.__proto__ || Object.getPrototypeOf(ThemeGraph.prototype), 'destroy', this).call(this);
            var me = this;
            me.barWidth = null;
            if (me.flow) {
                me.flow.destroy();
                me.flow = null;
            }
            me.graduatedMode = null;
            if (me.graphAxes) {
                me.graphAxes.destroy();
                me.graphAxes = null;
            }
            if (me.graphSize) {
                me.graphSize.destroy();
                me.graphSize = null;
            }
            me.graphSizeFixed = null;
            if (me.graphText) {
                me.graphText.destroy();
                me.graphText = null;
            }
            me.graphType = null;
            if (me.items) {
                for (var i = 0, items = me.items, len = items.length; i < len; i++) {
                    items[i].destroy();
                }
                me.items = null;
            }
            me.memoryKeys = null;
            me.negativeDisplayed = null;
            if (me.offset) {
                me.offset.destroy();
                me.offset = null;
            }
            me.overlapAvoided = null;
            me.roseAngle = null;
            me.startAngle = null;
            me.graphAxesTextDisplayMode = null;
        }

        /**
         * @function SuperMap.ThemeGraph.prototype.toJSON
         * @description 将SuperMap.ThemeGraph对象转化为json字符串。
         * @return {string} 返回转换后的 JSON 字符串。
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            return _SuperMap2.default.Util.toJSON(this.toServerJSONObject());
        }

        /**
         * @function SuperMap.ThemeGraph.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj.type = this.type;
            if (this.graphText) {
                obj.graphTextDisplayed = this.graphText.graphTextDisplayed;
                obj.graphTextFormat = this.graphText.graphTextFormat;
                obj.graphTextStyle = this.graphText.graphTextStyle;
            }
            if (this.flow) {
                obj.flowEnabled = this.flow.flowEnabled;
                obj.leaderLineDisplayed = this.flow.leaderLineDisplayed;
                obj.leaderLineStyle = this.flow.leaderLineStyle;
            }
            if (this.graphAxes) {
                obj.axesColor = this.graphAxes.axesColor;
                obj.axesDisplayed = this.graphAxes.axesDisplayed;
                obj.axesGridDisplayed = this.graphAxes.axesGridDisplayed;
                obj.axesTextDisplayed = this.graphAxes.axesTextDisplayed;
                obj.axesTextStyle = this.graphAxes.axesTextStyle;
            }
            if (this.graphSize) {
                obj.maxGraphSize = this.graphSize.maxGraphSize;
                obj.minGraphSize = this.graphSize.minGraphSize;
            }
            if (this.offset) {
                obj.offsetFixed = this.offset.offsetFixed;
                obj.offsetX = this.offset.offsetX;
                obj.offsetY = this.offset.offsetY;
            }
            obj.barWidth = this.barWidth;
            obj.graduatedMode = this.graduatedMode;
            obj.graphSizeFixed = this.graphSizeFixed;
            obj.graphType = this.graphType;
            obj.graphAxesTextDisplayMode = this.graphAxesTextDisplayMode;
            obj.items = this.items;
            obj.memoryKeys = this.memoryKeys;
            obj.negativeDisplayed = this.negativeDisplayed;
            obj.overlapAvoided = this.overlapAvoided;
            obj.roseAngle = this.roseAngle;
            obj.startAngle = this.startAngle;
            return obj;
        }

        /**
         * @function SuperMap.ThemeGraph.fromObj
         * @description 从传入对象获取统计专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraph}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeGraph();
            var itemsG = obj.items;
            var len = itemsG ? itemsG.length : 0;
            _SuperMap2.default.Util.copy(res, obj);
            res.items = [];
            res.flow = _ThemeFlow2.default.fromObj(obj);
            res.graphAxes = _ThemeGraphAxes2.default.fromObj(obj);
            res.graphSize = _ThemeGraphSize2.default.fromObj(obj);
            res.graphText = _ThemeGraphText2.default.fromObj(obj);
            res.offset = _ThemeOffset2.default.fromObj(obj);
            for (var i = 0; i < len; i++) {
                res.items.push(_ThemeGraphItem2.default.fromObj(itemsG[i]));
            }
            return res;
        }
    }]);

    return ThemeGraph;
}(_Theme3.default);

exports.default = ThemeGraph;


_SuperMap2.default.ThemeGraph = ThemeGraph;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Theme2 = __webpack_require__(13);

var _Theme3 = _interopRequireDefault(_Theme2);

var _ThemeRangeItem = __webpack_require__(258);

var _ThemeRangeItem2 = _interopRequireDefault(_ThemeRangeItem);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeRange
 * @classdesc 范围分段专题图。
 *              范围分段专题图是按照指定的分段方法（如：等距离分段法）对字段的属性值进行分段，使用不同的颜色或符号（线型、填充）表示不同范围段落的属性值在整体上的分布情况，体现区域的差异。
 *              在分段专题图中，专题值按照某种分段方式被分成多个范围段，要素根据各自的专题值被分配到其中一个范围段中，在同一个范围段中的要素使用相同的颜色，填充，符号等风格进行显示。
 *              分段专题图所基于的专题变量必须为数值型，分段专题图一般用来反映连续分布现象的数量或程度特征，如降水量的分布，土壤侵蚀强度的分布等。
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        items - {Array<SuperMap.ThemeRangeItem>} 分段专题图子项数组。<br>
 *        rangeExpression - {string} 分段字段表达式。<br>
 *        rangeMode - {SuperMap.RangeMode} 分段专题图的分段模式。<br>
 *        rangeParameter - {number}分段参数。<br>
 *        colorGradientType - {SuperMap.ColorGradientType} 渐变颜色枚举类。<br>
 *        memoryData - {SuperMap.ThemeMemoryData} 专题图内存数据。
 */
var ThemeRange = function (_Theme) {
    _inherits(ThemeRange, _Theme);

    /**
     * @member SuperMap.ThemeRange.prototype.rangeParameter -{number}
     * @description 分段参数。<br>
     *              当分段模式为等距离分段法，平方根分段，对数分段法，计数分段法其中一种模式时，该参数用于设置分段个数，必设；当分段模式为标准差分段法时，
     *              该参数不起作用；当分段模式为自定义距离时，该参数用于设置自定义距离。默认值为 -1。
     */


    /**
     * @member SuperMap.ThemeRange.prototype.rangeExpression -{string}
     * @description 分段字段表达式。<br>
     *              由于范围分段专题图基于各种分段方法根据一定的距离进行分段，因而范围分段专题图所基于的字段值的数据类型必须为数值型。对于字段表达式，只能为数值型的字段间的运算。必设字段。
     */


    /**
     * @member SuperMap.ThemeRange.prototype.precision -{string}
     * @description 精准度
     */
    function ThemeRange(options) {
        _classCallCheck(this, ThemeRange);

        var _this = _possibleConstructorReturn(this, (ThemeRange.__proto__ || Object.getPrototypeOf(ThemeRange)).call(this, "RANGE", options));

        _this.precision = '1.0E-12';
        _this.items = null;
        _this.rangeExpression = null;
        _this.rangeMode = _REST.RangeMode.EQUALINTERVAL;
        _this.rangeParameter = 0;
        _this.colorGradientType = _REST.ColorGradientType.YELLOW_RED;
        _this.CLASS_NAME = "SuperMap.ThemeRange";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.ThemeRange.prototype.colorGradientType -{SuperMap.ColorGradientType}
     * @description 渐变颜色枚举类 <br>
     *              渐变色是由起始色根据一定算法逐渐过渡到终止色的一种混合型颜色。
     *              该类作为单值专题图参数类、分段专题图参数类的属性，负责设置单值专题图、分段专题图的配色方案，在默认情况下专题图所有子项会根据这个配色
     *              方案完成填*充。但如果为某几个子项的风格进行单独设置后（设置了 SuperMap.ThemeUniqueItem 或 SuperMap.ThemeRangeItem 类中Style属性），
     *              该配色方案对于这几个子项将不起作用。
     */


    /**
     * @member SuperMap.ThemeRange.prototype.rangeMode -{SuperMap.RangeMode}
     * @description 分段专题图的分段模式。<br>
     *              默认值为 SuperMap.RangeMode.EQUALINTERVAL（等距离分段）。
     *              在分段专题图中，作为专题变量的字段或表达式的值按照某种分段方式被分成多个范围段。
     *              目前 SuperMap 提供的分段方式包括：等距离分段法、平方根分段法、标准差分段法、对数分段法、等计数分段法和自定义距离法，
     *              显然这些分段方法根据一定的距离进行分段，因而范围分段专题图所基于的专题变量必须为数值型。
     */


    /**
     * @member SuperMap.ThemeRange.prototype.items -{Array<SuperMap.ThemeRangeItem>}
     * @description 分段专题图子项数组。<br>
     *              在分段专题图中，字段值按照某种分段模式被分成多个范围段，每个范围段即为一个子项，同一范围段的要素属于同一个分段专题图子项。<br>
     *              每个子项都有其分段起始值、终止值、名称和风格等。每个分段所表示的范围为[start, end)。<br>
     *              如果设置了范围分段模式和分段数，则会自动计算每段的范围[start, end)，故无需设置[start, end)；当然可以设置，那么结果就会按照您设置的值对分段结果进行调整。
     */


    _createClass(ThemeRange, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeRange.prototype.__proto__ || Object.getPrototypeOf(ThemeRange.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.items) {
                if (me.items.length > 0) {
                    for (var item in me.items) {
                        me.items[item].destroy();
                        me.items[item] = null;
                    }
                }
                me.items = null;
            }
            me.rangeExpression = null;
            me.rangeMode = null;
            me.rangeParameter = null;
            me.colorGradientType = null;
        }

        /**
         * @function SuperMap.ThemeRange.fromObj
         * @description 从传入对象获取范围分段专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeRange}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeRange();
            _SuperMap2.default.Util.copy(res, obj);
            var itemsR = obj.items;
            var len = itemsR ? itemsR.length : 0;
            res.items = [];
            for (var i = 0; i < len; i++) {
                res.items.push(_ThemeRangeItem2.default.fromObj(itemsR[i]));
            }
            return res;
        }
    }]);

    return ThemeRange;
}(_Theme3.default);

exports.default = ThemeRange;


_SuperMap2.default.ThemeRange = ThemeRange;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Theme2 = __webpack_require__(13);

var _Theme3 = _interopRequireDefault(_Theme2);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

var _ThemeUniqueItem = __webpack_require__(259);

var _ThemeUniqueItem2 = _interopRequireDefault(_ThemeUniqueItem);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeUnique
 * @classdesc 单值专题图。<br>
 *              单值专题图是利用不同的颜色或符号（线型、填充）表示图层中某一属性信息的不同属性值，属性值相同的要素具有相同的渲染风格。单值专题图多用于具有分类属性的地图上，
 *              比如土壤类型分布图、土地利用图、行政区划图等。单值专题图着重表示现象质的差别，一般不表示数量的特征。尤其是有交叉或重叠现象时，此类不推荐使用，例如：民族分布区等。
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        items - {Array<SuperMap.ThemeUniqueItem>} 单值专题图子项类数组。<br>
 *        uniqueExpression - {string} 用于制作单值专题图的字段或字段表达式。<br>
 *        defaultStyle - {SuperMap.ServerStyle} 未参与单值专题图制作的对象的显示风格。<br>
 *        colorGradientType - {SuperMap.ColorGradientType} 渐变颜色枚举类。<br>
 *        memoryData - {SuperMap.ThemeMemoryData} 专题图内存数据。
 */
var ThemeUnique = function (_Theme) {
    _inherits(ThemeUnique, _Theme);

    /**
     * @member SuperMap.ThemeUnique.prototype.uniqueExpression -{string}
     * @description 用于制作单值专题图的字段或字段表达式。<br>
     *              该字段值的数据类型可以为数值型或字符型。如果设置字段表达式，只能是相同数据类型字段间的运算。必设字段。
     */


    /**
     * @member SuperMap.ThemeUnique.prototype.defaultStyle -{SuperMap.ServerStyle}
     * @description 未参与单值专题图制作的对象的显示风格。<br>
     *              通过单值专题图子项数组 （items）可以指定某些要素参与单值专题图制作，对于那些没有被包含的要素，即不参加单值专题表达的要素，使用该风格显示。
     */
    function ThemeUnique(options) {
        _classCallCheck(this, ThemeUnique);

        var _this = _possibleConstructorReturn(this, (ThemeUnique.__proto__ || Object.getPrototypeOf(ThemeUnique)).call(this, "UNIQUE", options));

        _this.defaultStyle = null;
        _this.items = null;
        _this.uniqueExpression = null;
        _this.colorGradientType = _REST.ColorGradientType.YELLOW_RED;
        _this.CLASS_NAME = "SuperMap.ThemeUnique";

        var me = _this;
        me.defaultStyle = new _ServerStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.ThemeUnique.prototype.colorGradientType -{SuperMap.ColorGradientType}
     * @description 渐变颜色枚举类。<br>
     *              渐变色是由起始色根据一定算法逐渐过渡到终止色的一种混合型颜色。
     *              该类作为单值专题图参数类、分段专题图参数类的属性，负责设置单值专题图、分段专题图的配色方案，在默认情况下专题图所有子项会根据这个配色方案完成填充。
     *              但如果为某几个子项的风格进行单独设置后（设置了 ThemeUniqueItem 或 ThemeRangeItem 类中Style属性），
     *              该配色方案对于这几个子项将不起作用。
     */


    /**
     * @member SuperMap.ThemeUnique.prototype.items -{Array<SuperMap.ThemeUniqueItem>}
     * @description 单值专题图子项类数组。<br>
     *              单值专题图是将专题值相同的要素归为一类，为每一类设定一种渲染风格，其中每一类就是一个专题图子项。比如，利用单值专题图制作行政区划图，
     *              Name 字段代表省/直辖市名，该字段用来做专题变量，如果该字段的字段值总共有5种不同值，则该行政区划图有5个专题图子项。
     */


    _createClass(ThemeUnique, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeUnique.prototype.__proto__ || Object.getPrototypeOf(ThemeUnique.prototype), 'destroy', this).call(this);
            var me = this;
            me.uniqueExpression = null;
            me.colorGradientType = null;
            if (me.items) {
                if (me.items.length > 0) {
                    for (var item in me.items) {
                        me.items[item].destroy();
                        me.items[item] = null;
                    }
                }
                me.items = null;
            }

            if (me.defaultStyle) {
                me.defaultStyle.destroy();
                me.defaultStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeUnique.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _SuperMap2.default.Util.copyAttributes(obj, this);
            if (obj.defaultStyle) {
                if (obj.defaultStyle.toServerJSONObject) {
                    obj.defaultStyle = obj.defaultStyle.toServerJSONObject();
                }
            }
            if (obj.items) {
                var items = [],
                    len = obj.items.length;
                for (var i = 0; i < len; i++) {
                    items.push(obj.items[i].toServerJSONObject());
                }
                obj.items = items;
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeUniquefromObj
         * @description 从传入对象获取单值专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeUnique}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeUnique();
            var uItems = obj.items;
            var len = uItems ? uItems.length : 0;
            _SuperMap2.default.Util.extend(res, obj);
            res.items = [];
            res.defaultStyle = new _ServerStyle2.default.fromJson(obj.defaultStyle);
            for (var i = 0; i < len; i++) {
                res.items.push(new _ThemeUniqueItem2.default.fromObj(uItems[i]));
            }
            return res;
        }
    }]);

    return ThemeUnique;
}(_Theme3.default);

exports.default = ThemeUnique;


_SuperMap2.default.ThemeUnique = ThemeUnique;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = function(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
};

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = function (array){
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length>2) {
    out.z = array[2];
  }
  if (array.length>3) {
    out.m = array[3];
  }
  return out;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var globals = __webpack_require__(289);
var parseProj = __webpack_require__(77);
var wkt = __webpack_require__(80);

function defs(name) {
  /*global console*/
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = parseProj(arguments[1]);
      }
      else {
        defs[name] = wkt(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  }
  else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        }
        else {
          defs(v);
        }
      });
    }
    else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    }
    else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    }
    else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    }
    else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    }
    else {
      console.log(name);
    }
    return;
  }


}
globals(defs);
module.exports = defs;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var D2R = 0.01745329251994329577;
var PrimeMeridian = __webpack_require__(283);
var units = __webpack_require__(284);

module.exports = function(defData) {
  var self = {};
  var paramObj = {};
  defData.split("+").map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).forEach(function(a) {
    var split = a.split("=");
    split.push(true);
    paramObj[split[0].toLowerCase()] = split[1];
  });
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self.lat0 = v * D2R;
    },
    lat_1: function(v) {
      self.lat1 = v * D2R;
    },
    lat_2: function(v) {
      self.lat2 = v * D2R;
    },
    lat_ts: function(v) {
      self.lat_ts = v * D2R;
    },
    lon_0: function(v) {
      self.long0 = v * D2R;
    },
    lon_1: function(v) {
      self.long1 = v * D2R;
    },
    lon_2: function(v) {
      self.long2 = v * D2R;
    },
    alpha: function(v) {
      self.alpha = parseFloat(v) * D2R;
    },
    lonc: function(v) {
      self.longc = v * D2R;
    },
    x_0: function(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self.k0 = parseFloat(v);
    },
    k: function(v) {
      self.k0 = parseFloat(v);
    },
    a: function(v) {
      self.a = parseFloat(v);
    },
    b: function(v) {
      self.b = parseFloat(v);
    },
    r_a: function() {
      self.R_A = true;
    },
    zone: function(v) {
      self.zone = parseInt(v, 10);
    },
    south: function() {
      self.utmSouth = true;
    },
    towgs84: function(v) {
      self.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self.to_meter = parseFloat(v);
    },
    units: function(v) {
      self.units = v;
      if (units[v]) {
        self.to_meter = units[v].to_meter;
      }
    },
    from_greenwich: function(v) {
      self.from_greenwich = v * D2R;
    },
    pm: function(v) {
      self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;
    },
    nadgrids: function(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      }
      else {
        self.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      }
      else {
        self[paramOutname] = paramVal;
      }
    }
    else {
      self[paramName] = paramVal;
    }
  }
  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
    self.datumCode = self.datumCode.toLowerCase();
  }
  return self;
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var e0fn = __webpack_require__(31);
var e1fn = __webpack_require__(32);
var e2fn = __webpack_require__(33);
var e3fn = __webpack_require__(34);
var mlfn = __webpack_require__(35);
var adjust_lon = __webpack_require__(3);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var sign = __webpack_require__(36);
var asinz = __webpack_require__(18);

exports.init = function() {
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
};

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (this.sphere) {
    var b = cos_phi * Math.sin(delta_lon);
    if ((Math.abs(Math.abs(b) - 1)) < 0.0000000001) {
      return (93);
    }
    else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b));
      con = Math.acos(cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - b * b));
      if (lat < 0) {
        con = -con;
      }
      y = this.a * this.k0 * (con - this.lat0);
    }
  }
  else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var tq = Math.tan(lat);
    var t = Math.pow(tq, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    var n = this.a / Math.sqrt(con);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);

    x = this.k0 * n * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + Math.pow(t, 2) + 72 * c - 58 * this.ep2))) + this.x0;
    y = this.k0 * (ml - this.ml0 + n * tq * (als * (0.5 + als / 24 * (5 - t + 9 * c + 4 * Math.pow(c, 2) + als / 30 * (61 - 58 * t + Math.pow(t, 2) + 600 * c - 330 * this.ep2))))) + this.y0;

  }
  p.x = x;
  p.y = y;
  return p;
};

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
exports.inverse = function(p) {
  var con, phi;
  var delta_phi;
  var i;
  var max_iter = 6;
  var lat, lon;

  if (this.sphere) {
    var f = Math.exp(p.x / (this.a * this.k0));
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + p.y / (this.a * this.k0);
    var h = Math.cos(temp);
    con = Math.sqrt((1 - h * h) / (1 + g * g));
    lat = asinz(con);
    if (temp < 0) {
      lat = -lat;
    }
    if ((g === 0) && (h === 0)) {
      lon = this.long0;
    }
    else {
      lon = adjust_lon(Math.atan2(g, h) + this.long0);
    }
  }
  else { // ellipsoidal form
    var x = p.x - this.x0;
    var y = p.y - this.y0;

    con = (this.ml0 + y / this.k0) / this.a;
    phi = con;
    for (i = 0; true; i++) {
      delta_phi = ((con + this.e1 * Math.sin(2 * phi) - this.e2 * Math.sin(4 * phi) + this.e3 * Math.sin(6 * phi)) / this.e0) - phi;
      phi += delta_phi;
      if (Math.abs(delta_phi) <= EPSLN) {
        break;
      }
      if (i >= max_iter) {
        return (95);
      }
    } // for()
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.tan(phi);
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var n = this.a / Math.sqrt(con);
      var r = n * (1 - this.es) / con;
      var d = x / (n * this.k0);
      var ds = Math.pow(d, 2);
      lat = phi - (n * tan_phi * ds / r) * (0.5 - ds / 24 * (5 + 3 * t + 10 * c - 4 * cs - 9 * this.ep2 - ds / 30 * (61 + 90 * t + 298 * c + 45 * ts - 252 * this.ep2 - 3 * cs)));
      lon = adjust_lon(this.long0 + (d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 - 2 * c + 28 * t - 3 * cs + 8 * this.ep2 + 24 * ts))) / cos_phi));
    }
    else {
      lat = HALF_PI * sign(y);
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var datum_transform = __webpack_require__(287);
var adjust_axis = __webpack_require__(276);
var proj = __webpack_require__(55);
var toPoint = __webpack_require__(75);
module.exports = function transform(source, dest, point) {
  var wgs84;
  if (Array.isArray(point)) {
    point = toPoint(point);
  }
  function checkNotWGS(source, dest) {
    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84");
  }

  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && (checkNotWGS(source, dest) || checkNotWGS(dest, source))) {
    wgs84 = new proj('WGS84');
    transform(source, wgs84, point);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (source.axis !== "enu") {
    adjust_axis(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === "longlat") {
    point.x *= D2R; // convert degrees to radians
    point.y *= D2R;
  }
  else {
    if (source.to_meter) {
      point.x *= source.to_meter;
      point.y *= source.to_meter;
    }
    source.inverse(point); // Convert Cartesian to longlat
  }
  // Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

  // Convert datums if needed, and if possible.
  point = datum_transform(source.datum, dest.datum, point);

  // Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point.x -= dest.from_greenwich;
  }

  if (dest.projName === "longlat") {
    // convert radians to decimal degrees
    point.x *= R2D;
    point.y *= R2D;
  }
  else { // else project
    dest.forward(point);
    if (dest.to_meter) {
      point.x /= dest.to_meter;
      point.y /= dest.to_meter;
    }
  }

  // DGR, 2010/11/12
  if (dest.axis !== "enu") {
    adjust_axis(dest, true, point);
  }

  return point;
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var D2R = 0.01745329251994329577;
var extend = __webpack_require__(59);

function mapit(obj, key, v) {
  obj[key] = v.map(function(aa) {
    var o = {};
    sExpr(aa, o);
    return o;
  }).reduce(function(a, b) {
    return extend(a, b);
  }, {});
}

function sExpr(v, obj) {
  var key;
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  else {
    key = v.shift();
    if (key === 'PARAMETER') {
      key = v.shift();
    }
    if (v.length === 1) {
      if (Array.isArray(v[0])) {
        obj[key] = {};
        sExpr(v[0], obj[key]);
      }
      else {
        obj[key] = v[0];
      }
    }
    else if (!v.length) {
      obj[key] = true;
    }
    else if (key === 'TOWGS84') {
      obj[key] = v;
    }
    else {
      obj[key] = {};
      if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {
        obj[key] = {
          name: v[0].toLowerCase(),
          convert: v[1]
        };
        if (v.length === 3) {
          obj[key].auth = v[2];
        }
      }
      else if (key === 'SPHEROID') {
        obj[key] = {
          name: v[0],
          a: v[1],
          rf: v[2]
        };
        if (v.length === 4) {
          obj[key].auth = v[3];
        }
      }
      else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {
        v[0] = ['name', v[0]];
        mapit(obj, key, v);
      }
      else if (v.every(function(aa) {
        return Array.isArray(aa);
      })) {
        mapit(obj, key, v);
      }
      else {
        sExpr(v, obj[key]);
      }
    }
  }
}

function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && (inName in obj)) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  }
  else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  }
  else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    }
    else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = parseFloat(wkt.UNIT.convert, 10)*wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);
      }
    }
  }

  if (wkt.GEOGCS) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (wkt.GEOGCS.DATUM) {
      wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();
    }
    else {
      wkt.datumCode = wkt.GEOGCS.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === "wgs_1984") {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, - 6);
    }
    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, - 8);
    }
    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = "rnb72";
    }
    if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {
      wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = 'intl';
      }

      wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = "osgb36";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return parseFloat(input, 10) * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ['standard_parallel_1', 'Standard_Parallel_1'],
    ['standard_parallel_2', 'Standard_Parallel_2'],
    ['false_easting', 'False_Easting'],
    ['false_northing', 'False_Northing'],
    ['central_meridian', 'Central_Meridian'],
    ['latitude_of_origin', 'Latitude_Of_Origin'],
    ['latitude_of_origin', 'Central_Parallel'],
    ['scale_factor', 'Scale_Factor'],
    ['k0', 'scale_factor'],
    ['latitude_of_center', 'Latitude_of_center'],
    ['lat0', 'latitude_of_center', d2r],
    ['longitude_of_center', 'Longitude_Of_Center'],
    ['longc', 'longitude_of_center', d2r],
    ['x0', 'false_easting', toMeter],
    ['y0', 'false_northing', toMeter],
    ['long0', 'central_meridian', d2r],
    ['lat0', 'latitude_of_origin', d2r],
    ['lat0', 'standard_parallel_1', d2r],
    ['lat1', 'standard_parallel_1', d2r],
    ['lat2', 'standard_parallel_2', d2r],
    ['alpha', 'azimuth', d2r],
    ['srsCode', 'name']
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === "Lambert_Azimuthal_Equal_Area")) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}
module.exports = function(wkt, self) {
  var lisp = JSON.parse(("," + wkt).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/,''));
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  lisp.unshift('output');
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj.output);
  return extend(self, obj.output);
};


/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = function(){try{return mapv}catch(e){return {}}}();

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _TimeControlBase2 = __webpack_require__(162);

var _TimeControlBase3 = _interopRequireDefault(_TimeControlBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TimeFlowControl
 * @classdesc 时间管理类。<br>
 *              此类只负责时间上的控制，具体执行的操作需要用户在初始化时的回调函数内部进行实现。<br>
 *              如设置起始时间为1000，结束时间是2000，步长设置为1，
 *              那么表示按照每次1年（可以通过setSpeed进行修改）的变化从公元1000年开始到公元2000年为止，默认每1秒会1次(通过setFrequency修改)
 * @extends SuperMap.TimeControlBase
 * @param callback - {Function} 每次刷新回调函数，必设属性。具体的效果需要用户在此回调函数里面实现。
 * @param options - {Object} 该类开放的可选属性。如：<br>
 *        speed - {number}步长(单位ms)。不能小于0，默认为1（表示每次刷新的数据之间的间隔为1ms）。<br>
 *        frequency -  {number} 刷新频率(单位ms)，默认为1000ms。<br>
 *        startTime - {number}起始时间，必须为数字，且小于等于endTime。如果不设置，初始化时为0，建议设置。<br>
 *        endTime - {number}结束时间，必须为数字，且大于等于startTime。如果不设置，初始化时以当前时间进行设置，建议设置。<br>
 *        repeat - {boolean} 是否重复循环。默认为true。<br>
 *        reverse - {boolean} 是否反向。默认为false。
 */
var TimeFlowControl = function (_TimeControlBase) {
    _inherits(TimeFlowControl, _TimeControlBase);

    function TimeFlowControl(callback, options) {
        _classCallCheck(this, TimeFlowControl);

        var _this = _possibleConstructorReturn(this, (TimeFlowControl.__proto__ || Object.getPrototypeOf(TimeFlowControl)).call(this, options));

        _this.callback = null;
        _this.CLASS_NAME = "SuperMap.TimeFlowControl";

        var me = _this;

        //先让IE下支持bind方法
        if (!Function.prototype.bind) {
            Function.prototype.bind = function (oThis) {
                if (typeof this !== "function") {
                    throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
                }
                var aArgs = Array.prototype.slice.call(arguments, 1),
                    fToBind = this,
                    fNOP = function fNOP() {
                    //empty Function
                },
                    fBound = function fBound() {
                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
                };
                fNOP.prototype = this.prototype;
                fBound.prototype = new fNOP();
                return fBound;
            };
        }
        //保证 this.tick 的上下文还是 TimeControl 这个对象
        me.update = me.update.bind(me);

        me.oldTime = me.currentTime;
        //记录回调函数
        me.callback = callback;
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member callback -{Function}
     * @description 每次刷新执行的回调函数
     */


    _createClass(TimeFlowControl, [{
        key: 'updateOptions',
        value: function updateOptions(options) {
            options = options || {};
            _get(TimeFlowControl.prototype.__proto__ || Object.getPrototypeOf(TimeFlowControl.prototype), 'updateOptions', this).call(this, options);
        }

        /**
         * @inheritDoc
         */

    }, {
        key: 'start',
        value: function start() {
            var me = this;
            if (me.running) {
                return;
            }
            me.running = true;
            if (me.reverse) {
                if (me.currentTime === me.startTime) {
                    me.oldTime = me.endTime;
                    me.currentTime = me.oldTime;
                }
            } else {
                if (me.oldTime === me.endTime) {
                    me.currentTime = me.startTime;
                    me.oldTime = me.currentTime;
                }
            }
            me.tick();
        }

        /**
         * @inheritDoc
         */

    }, {
        key: 'stop',
        value: function stop() {
            _get(TimeFlowControl.prototype.__proto__ || Object.getPrototypeOf(TimeFlowControl.prototype), 'stop', this).call(this);
            var me = this;
            me.oldTime = me.currentTime;

            if (me.running) {
                me.running = false;
            }
            //清除定时tick
            me.intervalId && window.clearTimeout(me.intervalId);
        }

        /**
         * @inheritDoc
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            _get(TimeFlowControl.prototype.__proto__ || Object.getPrototypeOf(TimeFlowControl.prototype), 'destroy', this).call(this);
            var me = this;
            me.oldTime = null;
            me.callback = null;
        }

        /**
         * @function SuperMap.TimeFlowControl.prototype.tick
         * @description 定时刷新
         */

    }, {
        key: 'tick',
        value: function tick() {
            var me = this;
            me.intervalId && window.clearInterval(me.intervalId);
            me.intervalId = null;
            me.intervalId = window.setInterval(me.update, me.frequency);
        }

        /**
         * @inheritDoc
         */

    }, {
        key: 'update',
        value: function update() {
            var me = this;

            //判定是否还需要继续
            if (!me.running) {
                return;
            }
            //调用回调函数
            me.callback && me.callback(me.currentTime); //destroy之后callback就为空，所以需要判定一下

            if (!me.reverse) {
                //如果相等，则代表上一帧已经运行到了最后，下一帧运行初始化的状态
                if (me.currentTime === me.endTime) {
                    //不循环时
                    if (!me.repeat) {
                        me.running = false;
                        me.stop();
                        return null;
                    }
                    me.stop();
                    me.currentTime = me.startTime;
                    me.oldTime = me.currentTime;
                    me.start();
                }
                //否则时间递增
                else {
                        me.oldTime = me.currentTime;
                        me.currentTime += me.speed;
                    }

                if (me.currentTime >= me.endTime) {
                    me.currentTime = me.endTime;
                }
            } else {
                //如果相等，则代表上一帧已经运行到了最前，下一帧运行结束的状态
                if (me.currentTime === me.startTime) {
                    //不循环时
                    if (!me.repeat) {
                        me.running = false;
                        return null;
                    }

                    me.oldTime = me.endTime;
                    me.currentTime = me.oldTime;
                }
                //否则时间递减
                else {
                        me.currentTime = me.oldTime;
                        me.oldTime -= me.speed;
                    }

                if (me.oldTime <= me.startTime) {
                    me.oldTime = me.startTime;
                }
            }
        }
    }]);

    return TimeFlowControl;
}(_TimeControlBase3.default);

exports.default = TimeFlowControl;


_SuperMap2.default.TimeFlowControl = TimeFlowControl;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _FetchRequest = __webpack_require__(41);

var _GeoCodingParameter = __webpack_require__(196);

var _GeoCodingParameter2 = _interopRequireDefault(_GeoCodingParameter);

var _GeoDecodingParameter = __webpack_require__(197);

var _GeoDecodingParameter2 = _interopRequireDefault(_GeoDecodingParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.AddressMatchService
 * @classdesc 地址匹配服务，包括正向匹配和反向匹配。
 * @param options - {Object} 参数。
 * @param url {string} 地址匹配服务地址。
 */
var AddressMatchService = function (_CommonServiceBase) {
    _inherits(AddressMatchService, _CommonServiceBase);

    function AddressMatchService(url, options) {
        _classCallCheck(this, AddressMatchService);

        var _this = _possibleConstructorReturn(this, (AddressMatchService.__proto__ || Object.getPrototypeOf(AddressMatchService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.AddressMatchService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(AddressMatchService, [{
        key: 'destroy',
        value: function destroy() {
            _get(AddressMatchService.prototype.__proto__ || Object.getPrototypeOf(AddressMatchService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.code
         * @param url {string} 正向地址匹配服务地址
         * @param params {SuperMap.GeoCodingParameter} 正向地址匹配服务参数
         */

    }, {
        key: 'code',
        value: function code(url, params) {
            this.processAsync(url, params);
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.decode
         * @param url {string} 反向地址匹配服务地址
         * @param params {SuperMap.GeoDecodingParameter} 反向地址匹配服务参数
         */

    }, {
        key: 'decode',
        value: function decode(url, params) {
            this.processAsync(url, params);
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.processAsync
         * @description 负责将客户端的动态分段服务参数传递到服务端。
         * @param url - {string} 服务地址
         * @param params - {Object} 参数
         */

    }, {
        key: 'processAsync',
        value: function processAsync(url, params) {
            var me = this;
            _FetchRequest.FetchRequest.get(url, params).then(function (response) {
                return response.json();
            }).then(function (result) {
                if (result) {
                    me.serviceProcessCompleted(result);
                } else {
                    me.serviceProcessFailed(result);
                }
            }).catch(function (e) {
                me.eventListeners.processFailed({ error: e });
            });
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.serviceProcessCompleted
         * @param result - {Object} 服务器返回的结果对象。
         * @description 服务流程是否完成
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            _get(AddressMatchService.prototype.__proto__ || Object.getPrototypeOf(AddressMatchService.prototype), 'serviceProcessCompleted', this).call(this, result);
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.serviceProcessCompleted
         * @param result - {Object} 服务器返回的结果对象。
         * @description 服务流程是否失败
         */

    }, {
        key: 'serviceProcessFailed',
        value: function serviceProcessFailed(result) {
            _get(AddressMatchService.prototype.__proto__ || Object.getPrototypeOf(AddressMatchService.prototype), 'serviceProcessFailed', this).call(this, result);
        }
    }]);

    return AddressMatchService;
}(_CommonServiceBase3.default);

exports.default = AddressMatchService;

_SuperMap2.default.AddressMatchService = AddressMatchService;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _AreaSolarRadiationParameters = __webpack_require__(165);

var _AreaSolarRadiationParameters2 = _interopRequireDefault(_AreaSolarRadiationParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.AreaSolarRadiationService
 * @classdesc 地区太阳辐射服务类。
 * @param url - {string} 服务的访问地址。如</br> http://localhost:8090/iserver/services/spatialanalyst-sample/restjsr/spatialanalyst 。</br>
 * @param options - {Object} 参数。如:</br>
 * eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myAreaSolarRadiationService = new SuperMap.AreaSolarRadiationService(url);
 * myAreaSolarRadiationService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 *
 */
var AreaSolarRadiationService = function (_SpatialAnalystBase) {
    _inherits(AreaSolarRadiationService, _SpatialAnalystBase);

    function AreaSolarRadiationService(url, options) {
        _classCallCheck(this, AreaSolarRadiationService);

        var _this = _possibleConstructorReturn(this, (AreaSolarRadiationService.__proto__ || Object.getPrototypeOf(AreaSolarRadiationService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.AreaSolarRadiationService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(AreaSolarRadiationService, [{
        key: 'destroy',
        value: function destroy() {
            _get(AreaSolarRadiationService.prototype.__proto__ || Object.getPrototypeOf(AreaSolarRadiationService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.AreaSolarRadiationService.prototype.processAsync
         * @description  负责将客户端的查询参数传递到服务端。
         * @param parameter - {SuperMap.AreaSolarRadiationParameters} 地区太阳辐射参数
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {} else {
                me.url += "/";
            }

            var parameterObject = {};

            if (parameter instanceof _SuperMap2.default.AreaSolarRadiationParameter) {
                me.url += 'datasets/' + parameter.dataset + '/solarradiation';
            }

            _SuperMap2.default.AreaSolarRadiationParameters.toObject(parameter, parameterObject);
            var jsonParameters = _SuperMap2.default.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return AreaSolarRadiationService;
}(_SpatialAnalystBase3.default);

exports.default = AreaSolarRadiationService;

_SuperMap2.default.AreaSolarRadiationService = AreaSolarRadiationService;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _DatasetBufferAnalystParameters = __webpack_require__(173);

var _DatasetBufferAnalystParameters2 = _interopRequireDefault(_DatasetBufferAnalystParameters);

var _GeometryBufferAnalystParameters = __webpack_require__(199);

var _GeometryBufferAnalystParameters2 = _interopRequireDefault(_GeometryBufferAnalystParameters);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.BufferAnalystService
 * @classdesc 缓冲区分析服务类
 * 该类负责将客户设置的缓冲区分析参数传递给服务端，并接收服务端返回的缓冲区分析结果数据。
 * 缓冲区分析结果通过该类支持的事件的监听函数参数获取
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myBufferAnalystService = new SuperMap.BufferAnalystService(url, {
     *     eventListeners: {
     *           "processCompleted": bufferCompleted,
     *           "processFailed": bufferFailed
     *           }
     *    });
 * (end)
 *
 *
 */
var BufferAnalystService = function (_SpatialAnalystBase) {
    _inherits(BufferAnalystService, _SpatialAnalystBase);

    function BufferAnalystService(url, options) {
        _classCallCheck(this, BufferAnalystService);

        var _this = _possibleConstructorReturn(this, (BufferAnalystService.__proto__ || Object.getPrototypeOf(BufferAnalystService)).call(this, url, options));

        _this.mode = null;
        _this.CLASS_NAME = "SuperMap.BufferAnalystService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */

    /**
     * @member SuperMap.BufferAnalystService.prototype.mode -{string}
     * @description 缓冲区分析类型
     */


    _createClass(BufferAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(BufferAnalystService.prototype.__proto__ || Object.getPrototypeOf(BufferAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
        }

        /**
         * @method SuperMap.BufferAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {BufferAnalystParameters} 缓冲区分析参数
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var parameterObject = {};
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {} else {
                me.url += "/";
            }

            if (parameter instanceof _DatasetBufferAnalystParameters2.default) {
                me.mode = "datasets";
                me.url += 'datasets/' + parameter.dataset + '/buffer';
                _DatasetBufferAnalystParameters2.default.toObject(parameter, parameterObject);
            } else if (parameter instanceof _GeometryBufferAnalystParameters2.default) {
                me.mode = "geometry";
                me.url += 'geometry/buffer';
                _GeometryBufferAnalystParameters2.default.toObject(parameter, parameterObject);
            }

            var jsonParameters = _SuperMap2.default.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @method SuperMap.BufferAnalystService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */
        // toGeoJSONResult(result) {
        //     if (!result) {
        //         return result;
        //     }
        //
        //     var analystResult = super.toGeoJSONResult(result);
        //     if (analystResult.resultGeometry) {
        //         var geoJSONFormat = new GeoJSON();
        //         result = JSON.parse(geoJSONFormat.write(analystResult.resultGeometry));
        //     }
        //     return result;
        // }

    }]);

    return BufferAnalystService;
}(_SpatialAnalystBase3.default);

exports.default = BufferAnalystService;

_SuperMap2.default.BufferAnalystService = BufferAnalystService;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _BurstPipelineAnalystParameters = __webpack_require__(168);

var _BurstPipelineAnalystParameters2 = _interopRequireDefault(_BurstPipelineAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.BurstPipelineAnalystService
 * @classdesc 爆管分析服务类;即将给定弧段或节点作为爆管点来进行分析，返回关键结点 ID 数组，普通结点 ID 数组及其上下游弧段 ID 数组。
 * @extends SuperMap.NetworkAnalystServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                       例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var BurstPipelineAnalystService = function (_NetworkAnalystServic) {
    _inherits(BurstPipelineAnalystService, _NetworkAnalystServic);

    function BurstPipelineAnalystService(url, options) {
        _classCallCheck(this, BurstPipelineAnalystService);

        var _this = _possibleConstructorReturn(this, (BurstPipelineAnalystService.__proto__ || Object.getPrototypeOf(BurstPipelineAnalystService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.BurstPipelineAnalystService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(BurstPipelineAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(BurstPipelineAnalystService.prototype.__proto__ || Object.getPrototypeOf(BurstPipelineAnalystService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.BurstPipelineAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @params params - {SuperMap.BurstPipelineAnalystParameters} 爆管分析参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject;
            var end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "burstAnalyse" : "/burstAnalyse") + ".json?";

            jsonObject = {
                sourceNodeIDs: params.sourceNodeIDs,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };

            //必传参数不正确，就终止
            if (params.edgeID !== null && params.nodeID !== null) return;
            if (params.edgeID === null && params.nodeID === null) return;
            if (params.edgeID !== null) jsonObject.edgeID = params.edgeID;else jsonObject.nodeID = params.nodeID;

            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return BurstPipelineAnalystService;
}(_NetworkAnalystServiceBase2.default);

exports.default = BurstPipelineAnalystService;


_SuperMap2.default.BurstPipelineAnalystService = BurstPipelineAnalystService;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ChartFeatureInfoSpecsService
 * @classdesc 海图物标信息服务类，通过该服务类可以查询到服务端支持的所有海图物标信息。<br>
 *              用户可以通过两种方式获取查询结果：<br>
 *              一种是通过监听 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE 事件；<br>
 *              另一种是使用 AsyncResponder 类实现异步处理。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 地图（特指海图）服务地址。<br>
 *        如："http://localhost:8090/iserver/services/map-ChartW/rest/maps/海图"。<br>
 *        发送请求格式类似于："http://localhost:8090/iserver/services/map-ChartW/rest/maps/海图/chartFeatureInfoSpecs.json"
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var ChartFeatureInfoSpecsService = function (_CommonServiceBase) {
    _inherits(ChartFeatureInfoSpecsService, _CommonServiceBase);

    function ChartFeatureInfoSpecsService(url, options) {
        _classCallCheck(this, ChartFeatureInfoSpecsService);

        var _this = _possibleConstructorReturn(this, (ChartFeatureInfoSpecsService.__proto__ || Object.getPrototypeOf(ChartFeatureInfoSpecsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.ChartFeatureInfoSpecsService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(ChartFeatureInfoSpecsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(ChartFeatureInfoSpecsService.prototype.__proto__ || Object.getPrototypeOf(ChartFeatureInfoSpecsService.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.ChartFeatureInfoSpecsService.prototype.processAsync
         * @description 根据地图（特指海图）服务地址与服务端完成异步通讯，获取物标信息。<br>
         *               当查询物标信息成功时，将触发 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE <br>
         *               事件。用可以通过户两种方式获取图层信息: <br>
         *                 1. 通过 AsyncResponder 类获取（推荐使用）；<br>
         *                 2. 通过监听 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE 事件获取。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this,
                method = "GET",
                end = me.url.substr(me.url.length - 1, 1);
            if (!me.isTempLayers) {
                me.url += end === "/" ? '' : '/';
                me.url += "chartFeatureInfoSpecs.json?";
            } else {
                me.url += ".json?";
            }
            me.request({
                method: method,
                params: null,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return ChartFeatureInfoSpecsService;
}(_CommonServiceBase3.default);

exports.default = ChartFeatureInfoSpecsService;


_SuperMap2.default.ChartFeatureInfoSpecsService = ChartFeatureInfoSpecsService;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _QueryParameters = __webpack_require__(15);

var _QueryParameters2 = _interopRequireDefault(_QueryParameters);

var _ChartQueryParameters = __webpack_require__(170);

var _ChartQueryParameters2 = _interopRequireDefault(_ChartQueryParameters);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ChartQueryService
 * @classdesc 海图查询服务类。该类负责将海图查询所需参数（ChartQueryParameters）传递至服务端，并获取服务端的返回结果。<br>
 *      用户可以通过两种方式获取查询结果:<br>
 *      1.通过 AsyncResponder 类获取（推荐使用）；<br>
 *      2.通过监听 QueryEvent.PROCESS_COMPLETE 事件获取。<br>
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 地图查询服务访问地址。如："http://192.168.168.35:8090/iserver/services/map-ChartW/rest/maps/海图"。
 * @param options - {Object} 服务交互时所需的可选参数。<br>
 *        events - {SuperMap.Events} 处理所有事件的对象。<br>
 *        eventListeners - {Object} 听器对象。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        index - {number}服务访问地址在数组中的位置。<br>
 *        length - {number}服务访问地址数组长度。<br>
 *        returnContent -{boolean} 是否立即返回新创建资源的表述还是返回新资源的URI。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
 *                                      参数格式为"ISERVER","GEOJSON",GEOJSON
 * @example
 * 下面示例显示了如何进行海图属性查询：
 * var nameArray = ["GB4X0000_52000"];
 * var chartQueryFilterParameter = new ChartQueryFilterParameter({
 *       isQueryPoint:true,
 *        isQueryLine:true,
 *        isQueryRegion:true,
 *        attributeFilter:"SmID<10",
 *        chartFeatureInfoSpecCode:1
 *    });
 *
 * var chartQueryParameters = new SuperMap.ChartQueryParameters({
 *        queryMode:"ChartAttributeQuery",
 *        chartLayerNames:nameArray,
 *        returnContent:true,
 *        chartQueryFilterParameters:[chartQueryFilterParameter]
 *    });
 *
 * var chartQueryService = new SuperMap.ChartQueryService(url);
 *
 * chartQueryService.events.on({
 *        "processCompleted":processCompleted,
 *        "processFailed":processFailed
 *    });
 * chartQueryService.processAsync(chartQueryParameters);
 */
var ChartQueryService = function (_CommonServiceBase) {
    _inherits(ChartQueryService, _CommonServiceBase);

    /**
     * @member SuperMap.ChartQueryService.prototype.returnContent -{boolean}
     * @description 是否立即返回新创建资源的表述还是返回新资源的URI。
     */
    function ChartQueryService(url, options) {
        _classCallCheck(this, ChartQueryService);

        var _this = _possibleConstructorReturn(this, (ChartQueryService.__proto__ || Object.getPrototypeOf(ChartQueryService)).call(this, url, options));

        _this.returnContent = null;
        _this.format = _REST.DataFormat.GEOJSON;
        _this.CLASS_NAME = "SuperMap.ChartQueryService";

        options = options || {};
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        var me = _this,
            end;
        if (options && options.format) {
            me.format = options.format.toUpperCase();
        }

        if (!me.url) {
            return _possibleConstructorReturn(_this);
        }
        end = me.url.substr(me.url.length - 1, 1);

        // TODO 待iServer featureResul资源GeoJSON表述bug修复当使用以下注释掉的逻辑
        // if (me.format==="geojson") {
        //     me.url += (end == "/") ? "featureResults.geojson?" : "/featureResults.geojson?";
        // } else {
        //     me.url += (end == "/") ? "featureResults.json?" : "/featureResults.json?";
        // }
        me.url += end === "/" ? "queryResults.json?" : "/queryResults.json?";
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.ChartQueryService.prototype.format -{SuperMap.DataFormat}
     * @description 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
     *              参数格式为"ISERVER","GEOJSON",GEOJSON
     */


    _createClass(ChartQueryService, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            _SuperMap2.default.CommonServiceBase.prototype.destroy.apply(this, arguments);
            me.returnContent = null;
            me.format = null;
        }

        /**
         * @function SuperMap.ChartQueryService.prototype.processAsync
         * @description 使用服务地址 URL 实例化 ChartQueryService 对象。
         * @param params - {SuperMap.ChartQueryParameters} 查询参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            //todo重点需要添加代码的地方
            if (!params) {
                return;
            }
            var me = this,
                jsonParameters;
            me.returnContent = params.returnContent;
            jsonParameters = params.getVariablesJson();
            if (me.returnContent) {
                me.url += "returnContent=" + me.returnContent;
            }
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.ChartQueryService.prototype.serviceProcessCompleted
         * @description 查询完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _SuperMap2.default.Util.transformResult(result);
            if (result && result.recordsets && me.format === _REST.DataFormat.GEOJSON) {
                for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
                    if (recordsets[i].features) {
                        var geoJSONFormat = new _GeoJSON2.default();
                        recordsets[i].features = JSON.parse(geoJSONFormat.write(recordsets[i].features));
                    }
                }
            }
            me.events.triggerEvent("processCompleted", { result: result });
        }

        /**
         * @function SuperMap.ChartQueryService.prototype.getQueryParameters
         * @description 将 JSON 对象表示的查询参数转化为 QueryParameters 对象。
         * @param params - {Object} JSON 字符串表示的查询参数。
         * @return {chartQueryFilterParameters} 返回查询结果
         */

    }, {
        key: 'getQueryParameters',
        value: function getQueryParameters(params) {
            return new _QueryParameters2.default({
                queryMode: params.queryMode,
                bounds: params.bounds,
                chartLayerNames: params.chartLayerNames,
                chartQueryFilterParameters: params.chartQueryFilterParameters,
                returnContent: params.returnContent
            });
        }
    }]);

    return ChartQueryService;
}(_CommonServiceBase3.default);

exports.default = ChartQueryService;

_SuperMap2.default.ChartQueryService = ChartQueryService;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ComputeWeightMatrixParameters = __webpack_require__(172);

var _ComputeWeightMatrixParameters2 = _interopRequireDefault(_ComputeWeightMatrixParameters);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ComputeWeightMatrixService
 * @classdesc 耗费矩阵分析服务类。<br>
 *               耗费矩阵是根据交通网络分析参数中的耗费字段来计算一个二维数组，
 *               用来存储指定的任意两点间的资源消耗。
 *               耗费矩阵分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var mycomputeWeightMatrixService = new SuperMap.ComputeWeightMatrixService(url,{
 *     eventListeners: {
 *	       "processCompleted": computeWeightMatrixCompleted,
 *		   "processFailed": computeWeightMatrixnError
 *		   }
 * });
 * @param url - {string} 耗费矩阵分析服务地址。请求服务的URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var ComputeWeightMatrixService = function (_NetworkAnalystServic) {
    _inherits(ComputeWeightMatrixService, _NetworkAnalystServic);

    function ComputeWeightMatrixService(url, options) {
        _classCallCheck(this, ComputeWeightMatrixService);

        var _this = _possibleConstructorReturn(this, (ComputeWeightMatrixService.__proto__ || Object.getPrototypeOf(ComputeWeightMatrixService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.ComputeWeightMatrixService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(ComputeWeightMatrixService, [{
        key: 'destroy',
        value: function destroy() {
            _get(ComputeWeightMatrixService.prototype.__proto__ || Object.getPrototypeOf(ComputeWeightMatrixService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.ComputeWeightMatrixService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {ComputeWeightMatrixParameters} 耗费矩阵分析参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "weightmatrix" : "/weightmatrix") + ".json?";
            jsonObject = {
                parameter: _SuperMap2.default.Util.toJSON(params.parameter),
                nodes: me.getJson(params.isAnalyzeById, params.nodes)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.ComputeWeightMatrixService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过id分析
         * @param params - {Array} 分析参数数组
         * @return- {string} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += params[i];
                }
            }
            jsonString += ']';
            return jsonString;
        }
    }]);

    return ComputeWeightMatrixService;
}(_NetworkAnalystServiceBase2.default);

exports.default = ComputeWeightMatrixService;

_SuperMap2.default.ComputeWeightMatrixService = ComputeWeightMatrixService;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DataFlowService
 * @classdesc 实时数据服务类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 实时数据服务地址
 * @param options - {Object} 加载实时数据可选参数。如：<br>
 *        style - {function} 设置数据加载样式。<br>
 *        onEachFeature - {function} 设置每个数据加载popup等。<br>
 *        geometry - {Array<Object>} 设置增添的几何要素对象数组。
 *        excludeField - -{Object} 排除字段
 */
var DataFlowService = function (_CommonServiceBase) {
    _inherits(DataFlowService, _CommonServiceBase);

    /**
     * @member SuperMap.DataFlowService.prototype.prjCoordSys -{Object}
     * @description 动态投影参数
     */
    function DataFlowService(url, options) {
        _classCallCheck(this, DataFlowService);

        options = options || {};
        options.EVENT_TYPES = ["broadcastSocketConnected", "broadcastSocketError", "broadcastFailed", "broadcastSuccessed", "subscribeSocketConnected", "subscribeSocketError", "messageSuccessed", "setFilterParamSuccessed"];

        var _this = _possibleConstructorReturn(this, (DataFlowService.__proto__ || Object.getPrototypeOf(DataFlowService)).call(this, url, options));

        _this.geometry = null;
        _this.prjCoordSys = null;
        _this.excludeField = null;
        _this.CLASS_NAME = "SuperMap.DataFlowService";


        var me = _this;
        var end = me.url.substr(me.url.length - 1, 1);
        if (end === '/') {} else {
            me.url += "/";
        }
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.DataFlowService.prototype.initBroadcast
     * @description 初始化广播
     * @returns {SuperMap.DataFlowService}
     */


    /**
     * @member SuperMap.DataFlowService.prototype.excludeField -{Object}
     * @description 排除字段
     */


    /*
     * @constant EVENT_TYPES
     * {Array<string>}
     * 此类支持的事件类型
     */
    //EVENT_TYPES = ["broadcastSocketConnected", "broadcastSocketError", "broadcastFailed", "broadcastSuccessed", "subscribeSocketConnected", "subscribeSocketError", "messageSuccessed", "setFilterParamSuccessed"];

    /**
     * @member SuperMap.DataFlowService.prototype.geometry -{Aarry<Object>}
     * @description 设置增添的几何要素对象数组。
     */


    _createClass(DataFlowService, [{
        key: 'initBroadcast',
        value: function initBroadcast() {
            var me = this;
            this.broadcastWebSocket = this._connect(me.url + 'broadcast');
            this.broadcastWebSocket.onopen = function (e) {
                me.broadcastWebSocket.isOpen = true;
                e.eventType = 'broadcastSocketConnected';
                me.events.triggerEvent('broadcastSocketConnected', e);
            };
            this.broadcastWebSocket.onclose = function (e) {
                me.broadcastWebSocket.isOpen = false;
                e.eventType = 'broadcastSocketConnected';
                me.events.triggerEvent('broadcastSocketConnected', e);
            };
            this.broadcastWebSocket.onerror = function (e) {
                e.eventType = 'broadcastSocketError';
                me.events.triggerEvent('broadcastSocketError', e);
            };
            return this;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.broadcast
         * @description 加载广播数据
         * @param geoJSONFeature {JSON} json格式的要素数据
         */

    }, {
        key: 'broadcast',
        value: function broadcast(geoJSONFeature) {
            if (!this.broadcastWebSocket.isOpen) {
                this.events.triggerEvent('broadcastFailed');
                return;
            }
            this.broadcastWebSocket.send(JSON.stringify(geoJSONFeature));
            this.events.triggerEvent('broadcastSuccessed');
        }

        /**
         * @function SuperMap.DataFlowService.prototype.initSubscribe
         * @description 初始化订阅数据
         * @return {SuperMap.DataFlowService}
         */

    }, {
        key: 'initSubscribe',
        value: function initSubscribe() {
            var me = this;
            this.subscribeWebSocket = this._connect(this.url + 'subscribe');
            this.subscribeWebSocket.onopen = function (e) {
                me.subscribeWebSocket.send(me._getFilterParams());
                e.eventType = 'subscribeSocketConnected';
                me.events.triggerEvent('subscribeSocketConnected', e);
            };
            this.subscribeWebSocket.onerror = function (e) {
                e.eventType = 'subscribeSocketError';
                me.events.triggerEvent('subscribeSocketError', e);
            };
            this.subscribeWebSocket.onmessage = function (e) {
                me._onMessage(e);
            };
            return this;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.setPrjCoordSys
         * @description 设置动态投影坐标
         * @param prjCoordSys -{Object} 动态投影参数
         * @return {SuperMap.DataFlowService}
         */

    }, {
        key: 'setPrjCoordSys',
        value: function setPrjCoordSys(prjCoordSys) {
            this.prjCoordSys = prjCoordSys;
            this.subscribeWebSocket.send(this._getFilterParams());
            return this;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.setExcludeField
         * @description 设置排除字段
         * @param excludeField - {Object} 排除字段
         * @return {SuperMap.DataFlowService}
         */

    }, {
        key: 'setExcludeField',
        value: function setExcludeField(excludeField) {
            this.excludeField = excludeField;
            this.subscribeWebSocket.send(this._getFilterParams());
            return this;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.setGeometry
         * @description 设置添加的几何要素数据
         * @param geometry - {Array<Object>} 设置增添的几何要素对象数组。
         * @return {SuperMap.DataFlowService}
         */

    }, {
        key: 'setGeometry',
        value: function setGeometry(geometry) {
            this.geometry = geometry;
            this.subscribeWebSocket.send(this._getFilterParams());
            return this;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.unSubscribe
         * @description 结束订阅数据
         */

    }, {
        key: 'unSubscribe',
        value: function unSubscribe() {
            if (!this.subscribeWebSocket) {
                return;
            }
            this.subscribeWebSocket.close();
            this.subscribeWebSocket = null;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.unBroadcast
         * @description 结束加载广播
         */

    }, {
        key: 'unBroadcast',
        value: function unBroadcast() {
            if (this.broadcastWebSocket) {
                return;
            }
            this.broadcastWebSocket.close();
            this.broadcastWebSocket = null;
        }

        /**
         * @inheritDoc
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            _SuperMap2.default.CommonServiceBase.prototype.destroy.apply(this, arguments);
            var me = this;
            me.geometry = null;
            me.prjCoordSys = null;
            me.excludeField = null;
            this.unBroadcast();
            this.unSubscribe();
        }
    }, {
        key: '_getFilterParams',
        value: function _getFilterParams() {
            var filter = {
                filterParam: {
                    prjCoordSys: this.prjCoordSys,
                    excludeField: this.excludeField,
                    geometry: this.geometry
                }
            };
            return _SuperMap2.default.Util.toJSON(filter);
        }
    }, {
        key: '_onMessage',
        value: function _onMessage(e) {
            if (e.data && e.data.indexOf("filterParam") > 0) {
                var filterParam = JSON.parse(e.data);
                e.filterParam = filterParam;
                e.eventType = 'setFilterParamSuccessed';
                this.events.triggerEvent('setFilterParamSuccessed', e);
                return;
            }
            var feature = JSON.parse(e.data);
            e.featureResult = feature;
            e.eventType = 'messageSuccessed';
            this.events.triggerEvent('messageSuccessed', e);
        }
    }, {
        key: '_connect',
        value: function _connect(url) {
            url = this._appendCredentials(url);
            if ("WebSocket" in window) {
                return new WebSocket(url);
            } else if ("MozWebSocket" in window) {
                return new MozWebSocket(url);
            } else {
                console.log("no WebSocket");
                return null;
            }
        }
    }, {
        key: '_appendCredentials',
        value: function _appendCredentials(url) {
            var token = _SuperMap2.default.SecurityManager.getToken(url);
            if (token) {
                url += "?token=" + token;
            }
            return url;
        }
    }]);

    return DataFlowService;
}(_CommonServiceBase3.default);

exports.default = DataFlowService;


_SuperMap2.default.DataFlowService = DataFlowService;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _DensityKernelAnalystParameters = __webpack_require__(179);

var _DensityKernelAnalystParameters2 = _interopRequireDefault(_DensityKernelAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DensityAnalystService
 * @classdesc
 *  密度分析服务类，密度分析可计算每个输出栅格像元周围圆形邻域内输入的点或线对象的密度。
 *  密度分析，在某种意义上来说，相当于在表面上将输入的点线对象的测量值散开来，将每个点或线对象的测量量分布在整个研究区域，并计算输出栅格中每个像元的密度值。目前提供1种密度分析：核密度分析（Kernel）。
 * @param  url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example  例如：
 * (start code)
 * var myDensityAnalystService = new SuperMap.DensityAnalystService(url);
 * myDensityAnalystService.on({
 *     "processCompleted": processCompleted,
 *     "processFailed": processFailed
 *     }
 * );
 * (end)
 *
 */
var DensityAnalystService = function (_SpatialAnalystBase) {
    _inherits(DensityAnalystService, _SpatialAnalystBase);

    function DensityAnalystService(url, options) {
        _classCallCheck(this, DensityAnalystService);

        var _this = _possibleConstructorReturn(this, (DensityAnalystService.__proto__ || Object.getPrototypeOf(DensityAnalystService)).call(this, url, options));

        _this.mode = null;
        _this.CLASS_NAME = "SuperMap.DensityAnalystService";

        var me = _this;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.DensityAnalystService.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */


    /**
     * @member SuperMap.DensityAnalystService.prototype.mode -{string}
     * @description 密度分析类型。
     */


    _createClass(DensityAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(DensityAnalystService.prototype.__proto__ || Object.getPrototypeOf(DensityAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
        }

        /**
         * @function SuperMap.DensityAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {DensityKernelAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {} else {
                me.url += "/";
            }

            var parameterObject = new Object();

            if (parameter instanceof _SuperMap2.default.DensityKernelAnalystParameters) {
                me.url += 'datasets/' + parameter.dataset + '/densityanalyst/kernel';
                me.mode = "kernel";
            }

            _DensityKernelAnalystParameters2.default.toObject(parameter, parameterObject);
            var jsonParameters = _SuperMap2.default.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return DensityAnalystService;
}(_SpatialAnalystBase3.default);

exports.default = DensityAnalystService;

_SuperMap2.default.DensityAnalystService = DensityAnalystService;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _EditFeaturesParameters = __webpack_require__(180);

var _EditFeaturesParameters2 = _interopRequireDefault(_EditFeaturesParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.EditFeaturesService
 * @classdesc 数据服务中数据集添加、更新、删除服务类。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 服务端的数据服务资源地址。请求数据服务中数据集编辑服务，URL 应为：</br>
 * http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/datasources/name/{数据源名}/datasets/name/{数据集名} 。</br>
 * 例如：http://localhost:8090/iserver/services/data-jingjin/rest/data/datasources/name/Jingjin/datasets/name/Landuse_R
 * @param options - {Object} 参数。如:</br>
 * eventListeners - {Object} 需要被注册的监听器对象。
 * @example 例如：
 * (start code)
 * var myService = new SuperMap.EditFeaturesService(url, {eventListeners: {
     *     "processCompleted": editFeatureCompleted,
     *     "processFailed": editFeatureError
     *       }
     * };
 * (end)
 *
 */
var EditFeaturesService = function (_CommonServiceBase) {
    _inherits(EditFeaturesService, _CommonServiceBase);

    /**
     * @member SuperMap.EditFeaturesService.prototype.returnContent -{boolean}
     * @description要素添加时，isUseBatch 不传或传为 false 的情况下有效。true 表示直接返回新创建的要素的 ID 数组;false 表示返回创建的 featureResult 资源的 URI。默认不传时为 false。
     */
    function EditFeaturesService(url, options) {
        _classCallCheck(this, EditFeaturesService);

        var _this = _possibleConstructorReturn(this, (EditFeaturesService.__proto__ || Object.getPrototypeOf(EditFeaturesService)).call(this, url, options));

        _this.returnContent = false;
        _this.isUseBatch = false;
        _this.CLASS_NAME = "SuperMap.EditFeaturesService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        var me = _this,
            end;
        end = me.url.substr(me.url.length - 1, 1);
        me.url += end == "/" ? "features.json?" : "/features.json?";
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.EditFeaturesService.prototype.isUseBatch -{boolean}
     * @description 是否使用批量添加要素功能，要素添加时有效。
     *           批量添加能够提高要素编辑效率。
     *           true 表示批量添加；false 表示不使用批量添加。默认不传时为 false。
     */


    _createClass(EditFeaturesService, [{
        key: 'destroy',
        value: function destroy() {
            _get(EditFeaturesService.prototype.__proto__ || Object.getPrototypeOf(EditFeaturesService.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
            me.isUseBatch = null;
            me.fromIndex = null;
            me.toIndex = null;
        }

        /**
         * @function SuperMap.EditFeaturesService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {SuperMap.EditFeaturesParameters} 编辑要素参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                method = "POST",
                ids = "",
                editType = params.editType,
                jsonParameters = null;

            me.returnContent = params.returnContent;
            me.isUseBatch = params.isUseBatch;
            jsonParameters = _EditFeaturesParameters2.default.toJsonParameters(params);
            if (editType === _REST.EditType.DELETE) {
                ids = _SuperMap2.default.Util.toJSON(params.IDs);
                me.url += "ids=" + ids;
                method = "DELETE";
                jsonParameters = ids;
            } else if (editType === _REST.EditType.UPDATE) {
                method = "PUT";
            } else {
                if (me.isUseBatch) {
                    me.url += "isUseBatch=" + me.isUseBatch;
                    me.returnContent = false;
                }
                if (me.returnContent) {
                    me.url += "returnContent=" + me.returnContent;
                    method = "POST";
                }
            }

            me.request({
                method: method,
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return EditFeaturesService;
}(_CommonServiceBase3.default);

exports.default = EditFeaturesService;

_SuperMap2.default.EditFeaturesService = EditFeaturesService;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _FacilityAnalystSinks3DParameters = __webpack_require__(181);

var _FacilityAnalystSinks3DParameters2 = _interopRequireDefault(_FacilityAnalystSinks3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystSinks3DService
 * @classdesc  最近设施分析服务类(汇查找资源)<br>
 *                最近设施分析是指在网络上给定一个事件点和一组设施点，
 *                查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *                该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
 *                最近设施分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.CommonServiceBase
 * @example
 * var myFacilityAnalystSinks3DService = new SuperMap.FacilityAnalystSinks3DService(url, {
 *     eventListeners: {
 *	       "processCompleted": facilityAnalystSinks3DCompleted,
 *		   "processFailed": facilityAnalystSinks3DError
 *		   }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *               http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *              例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。<br>
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystSinks3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystSinks3DService, _CommonServiceBase);

    function FacilityAnalystSinks3DService(url, options) {
        _classCallCheck(this, FacilityAnalystSinks3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystSinks3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystSinks3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystSinks3DService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystSinks3DService, [{
        key: 'destroy',
        value: function destroy() {
            _SuperMap2.default.CommonServiceBase.prototype.destroy.apply(this, arguments);
        }

        /**
         * @function SuperMap.FacilityAnalystSinks3DService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystSinks3DParameters} 最近设施分析参数类(汇查找资源)
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "sinks" : "/sinks") + ".json?";
            jsonObject = {
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                weightName: params.weightName,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystSinks3DService;
}(_CommonServiceBase3.default);

exports.default = FacilityAnalystSinks3DService;


_SuperMap2.default.FacilityAnalystSinks3DService = FacilityAnalystSinks3DService;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _FacilityAnalystSources3DParameters = __webpack_require__(182);

var _FacilityAnalystSources3DParameters2 = _interopRequireDefault(_FacilityAnalystSources3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystSources3DService
 * @classdesc 最近设施分析服务类(源查找资源) <br>
 *               最近设施分析是指在网络上给定一个事件点和一组设施点，
 *               查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *               该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
 *               最近设施分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.CommonServiceBase
 * @param  url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystSources3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystSources3DService, _CommonServiceBase);

    function FacilityAnalystSources3DService(url, options) {
        _classCallCheck(this, FacilityAnalystSources3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystSources3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystSources3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystSources3DService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystSources3DService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystSources3DService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystSources3DService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystSources3DService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystSources3DParameters} 最近设施分析参数类(源查找资源)
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "sources" : "/sources") + ".json?";
            jsonObject = {
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                weightName: params.weightName,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystSources3DService;
}(_CommonServiceBase3.default);

exports.default = FacilityAnalystSources3DService;


_SuperMap2.default.FacilityAnalystSources3DService = FacilityAnalystSources3DService;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _FacilityAnalystStreamParameters = __webpack_require__(183);

var _FacilityAnalystStreamParameters2 = _interopRequireDefault(_FacilityAnalystStreamParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystStreamService
 * @description 上游/下游 关键设施查找资源服务类;即查找给定弧段或节点的上游/下游中的关键设施结点，返回关键结点 ID 数组及其下游弧段 ID 数组。
 * @extends SuperMap.NetworkAnalystServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystStreamService = function (_NetworkAnalystServic) {
    _inherits(FacilityAnalystStreamService, _NetworkAnalystServic);

    function FacilityAnalystStreamService(url, options) {
        _classCallCheck(this, FacilityAnalystStreamService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystStreamService.__proto__ || Object.getPrototypeOf(FacilityAnalystStreamService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystStreamService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystStreamService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystStreamService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystStreamService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystStreamService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystStreamParameters} 上游/下游关键设施查找资源参数类。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject;
            var end = me.url.substr(me.url.length - 1, 1);

            //URL 通过参数类型来判断是 上游 还是下游 查询
            if (params.queryType === 0) {
                me.url = me.url + (end === "/" ? "upstreamcirticalfaclilities" : "/upstreamcirticalfaclilities") + ".json?";
            } else if (params.queryType === 1) {
                me.url = me.url + (end === "/" ? "downstreamcirticalfaclilities" : "/downstreamcirticalfaclilities") + ".json?";
            } else return;

            jsonObject = {
                sourceNodeIDs: params.sourceNodeIDs,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };

            if (params.edgeID !== null && params.nodeID !== null) return;
            if (params.edgeID === null && params.nodeID === null) return;
            if (params.edgeID !== null) jsonObject.edgeID = params.edgeID;else jsonObject.nodeID = params.nodeID;

            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystStreamService;
}(_NetworkAnalystServiceBase2.default);

exports.default = FacilityAnalystStreamService;


_SuperMap2.default.FacilityAnalystStreamService = FacilityAnalystStreamService;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _FacilityAnalystTracedown3DParameters = __webpack_require__(184);

var _FacilityAnalystTracedown3DParameters2 = _interopRequireDefault(_FacilityAnalystTracedown3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystTracedown3DService
 * @classdesc 下游追踪资源服务类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystTracedown3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystTracedown3DService, _CommonServiceBase);

    function FacilityAnalystTracedown3DService(url, options) {
        _classCallCheck(this, FacilityAnalystTracedown3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystTracedown3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystTracedown3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystTracedown3DService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystTracedown3DService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystTracedown3DService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystTracedown3DService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystTracedown3DService.prototype.processAsync
         * @description负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystTracedown3DParameters} 下游追踪资源参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "tracedownresult" : "/tracedownresult") + ".json?";
            jsonObject = {
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                weightName: params.weightName,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystTracedown3DService;
}(_CommonServiceBase3.default);

exports.default = FacilityAnalystTracedown3DService;


_SuperMap2.default.FacilityAnalystTracedown3DService = FacilityAnalystTracedown3DService;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _FacilityAnalystTraceup3DParameters = __webpack_require__(185);

var _FacilityAnalystTraceup3DParameters2 = _interopRequireDefault(_FacilityAnalystTraceup3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystTraceup3DService
 * @classdesc 上游追踪资源服务类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystTraceup3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystTraceup3DService, _CommonServiceBase);

    /*
     * @function SuperMap.FacilityAnalystTraceup3DService.constructor
     * @description 上游追踪资源服务类构造函数。
     * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
     *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
     *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
     * @param options - {Object} 互服务时所需可选参数。如：<br>
     *         eventListeners - {Object} 需要被注册的监听器对象。
     */
    function FacilityAnalystTraceup3DService(url, options) {
        _classCallCheck(this, FacilityAnalystTraceup3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystTraceup3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystTraceup3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystTraceup3DService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystTraceup3DService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystTraceup3DService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystTraceup3DService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystTraceup3DService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystTraceup3DParameters} 上游追踪资源参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "traceupresult" : "/traceupresult") + ".json?";
            jsonObject = {
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                weightName: params.weightName,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystTraceup3DService;
}(_CommonServiceBase3.default);

exports.default = FacilityAnalystTraceup3DService;


_SuperMap2.default.FacilityAnalystTraceup3DService = FacilityAnalystTraceup3DService;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _FacilityAnalystUpstream3DParameters = __webpack_require__(186);

var _FacilityAnalystUpstream3DParameters2 = _interopRequireDefault(_FacilityAnalystUpstream3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystUpstream3DService
 * @classdesc 上游关键设施查找资源服务类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystUpstream3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystUpstream3DService, _CommonServiceBase);

    function FacilityAnalystUpstream3DService(url, options) {
        _classCallCheck(this, FacilityAnalystUpstream3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystUpstream3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystUpstream3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystUpstream3DService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystUpstream3DService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystUpstream3DService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystUpstream3DService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystUpstream3DService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystUpstream3DParameters} 上游关键设施查找资源参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "upstreamcirticalfaclilities" : "/upstreamcirticalfaclilities") + ".json?";
            jsonObject = {
                sourceNodeIDs: params.sourceNodeIDs,
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystUpstream3DService;
}(_CommonServiceBase3.default);

exports.default = FacilityAnalystUpstream3DService;


_SuperMap2.default.FacilityAnalystUpstream3DService = FacilityAnalystUpstream3DService;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _FieldStatisticsParameters = __webpack_require__(188);

var _FieldStatisticsParameters2 = _interopRequireDefault(_FieldStatisticsParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FieldStatisticService
 * @classdesc 字段查询统计服务类。用来完成对指定数据集指定字段的查询统计分析，即求平均值，最大值等。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为:http://localhost:8090/iserver/services/data-world/rest/data 即可。
 * @param options - {Object} 参数。
 *        eventListeners - {Object} 需要被注册的监听器对象。</br>
 *        datasource - {string} 数据集所在的数据源名称。</br>
 *        dataset - {string} 数据集名称。</br>
 *        field - {string} 查询统计的目标字段名称。</br>
 *        statisticMode - {StatisticMode} 字段查询统计的方法类型。</br>
 * @example
 * (start code)
 * var myService = new SuperMap.FieldStatisticService(url, {eventListeners: {
     *     "processCompleted": fieldStatisticCompleted,
     *     "processFailed": fieldStatisticError
     *     }，
     *     datasource: "World",
     *     dataset: "Countries",
     *     field: "SmID",
     *     statisticMode: StatisticMode.AVERAGE
     * };
 * (end)
 */

var FieldStatisticService = function (_CommonServiceBase) {
    _inherits(FieldStatisticService, _CommonServiceBase);

    /**
     * @member SuperMap.FieldStatisticService.prototype.field -{string}
     * @description 查询统计的目标字段名称。
     */


    /**
     * @member SuperMap.FieldStatisticService.prototype.datasource -{string}
     * @description 数据集所在的数据源名称。
     */
    function FieldStatisticService(url, options) {
        _classCallCheck(this, FieldStatisticService);

        var _this = _possibleConstructorReturn(this, (FieldStatisticService.__proto__ || Object.getPrototypeOf(FieldStatisticService)).call(this, url, options));

        _this.datasource = null;
        _this.dataset = null;
        _this.field = null;
        _this.statisticMode = null;
        _this.CLASS_NAME = "SuperMap.FieldStatisticService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.FieldStatisticService.prototype.statisticMode -{string}
     * @description 字段查询统计的方法类型。
     */


    /**
     * @member SuperMap.FieldStatisticService.prototype.dataset -{string}
     * @description 数据集名称。
     */


    _createClass(FieldStatisticService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FieldStatisticService.prototype.__proto__ || Object.getPrototypeOf(FieldStatisticService.prototype), 'destroy', this).call(this);
            var me = this;
            me.datasource = null;
            me.dataset = null;
            me.field = null;
            me.statisticMode = null;
        }

        /**
         * @function SuperMap.FieldStatisticService.prototype.processAsync
         * @description 执行服务，进行指定字段的查询统计。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this,
                end = me.url.substr(me.url.length - 1, 1),
                fieldStatisticURL = "datasources/" + me.datasource + "/datasets/" + me.dataset + "/fields/" + me.field + "/" + me.statisticMode;
            me.url += end == "/" ? fieldStatisticURL + ".json?" : "/" + fieldStatisticURL + ".json?";

            me.request({
                method: "GET",
                data: null,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FieldStatisticService;
}(_CommonServiceBase3.default);

exports.default = FieldStatisticService;


_SuperMap2.default.FieldStatisticService = FieldStatisticService;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _FindClosestFacilitiesParameters = __webpack_require__(189);

var _FindClosestFacilitiesParameters2 = _interopRequireDefault(_FindClosestFacilitiesParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindClosestFacilitiesService
 * @classdesc 最近设施分析服务类。<br>
 *               最近设施分析是指在网络上给定一个事件点和一组设施点，
 *               查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *               该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
 *              最近设施分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var myfindClosestFacilitiesService = new SuperMap.FindClosestFacilitiesService(url, {
 *     eventListeners: {
 *	       "processCompleted": findClosestFacilitiesCompleted,
 *		   "processFailed": findClosestFacilitiesError
 *		   }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindClosestFacilitiesService = function (_NetworkAnalystServic) {
    _inherits(FindClosestFacilitiesService, _NetworkAnalystServic);

    /*
     * @function SuperMap.FindClosestFacilitiesService.prototype.constructor
     * @description 最近设施分析服务类构造函数。
     * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
     *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
     *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
     * @param options - {Object} 互服务时所需可选参数。如：<br>
     *         eventListeners - {Object} 需要被注册的监听器对象。
     */
    function FindClosestFacilitiesService(url, options) {
        _classCallCheck(this, FindClosestFacilitiesService);

        var _this = _possibleConstructorReturn(this, (FindClosestFacilitiesService.__proto__ || Object.getPrototypeOf(FindClosestFacilitiesService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindClosestFacilitiesService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FindClosestFacilitiesService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindClosestFacilitiesService.prototype.__proto__ || Object.getPrototypeOf(FindClosestFacilitiesService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindClosestFacilitiesService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindClosestFacilitiesParameters} 最近设施分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "closestfacility" : "/closestfacility") + ".json?";
            jsonObject = {
                expectFacilityCount: params.expectFacilityCount,
                fromEvent: params.fromEvent,
                maxWeight: params.maxWeight,
                parameter: _SuperMap2.default.Util.toJSON(params.parameter),
                event: _SuperMap2.default.Util.toJSON(params.event),
                facilities: me.getJson(params.isAnalyzeById, params.facilities)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindClosestFacilitiesService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过ID来分析
         * @param params - {Array} 分析参数数组
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += params[i];
                }
            }
            jsonString += ']';
            return jsonString;
        }

        /**
         * @function SuperMap.FindClosestFacilitiesService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.facilityPathList) {
                return result;
            }

            var geoJSONFormat = new _GeoJSON2.default();
            result.facilityPathList.map(function (path) {
                if (path.route) {
                    path.route = JSON.parse(geoJSONFormat.write(path.route));
                }
                if (path.pathGuideItems) {
                    path.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));
                }
                if (path.edgeFeatures) {
                    path.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
                }
                if (path.nodeFeatures) {
                    path.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
                }
            });
            return result;
        }
    }]);

    return FindClosestFacilitiesService;
}(_NetworkAnalystServiceBase2.default);

exports.default = FindClosestFacilitiesService;


_SuperMap2.default.FindClosestFacilitiesService = FindClosestFacilitiesService;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _FindLocationParameters = __webpack_require__(190);

var _FindLocationParameters2 = _interopRequireDefault(_FindLocationParameters);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindLocationService
 * @classdesc 选址分区分析服务类。
 *               选址分区分析是为了确定一个或多个待建设施的最佳或最优位置，使得设施可以用一种最经济有效的方式为需求方提供服务或者商品。
 *               选址分区不仅仅是一个选址过程，还要将需求点的需求分配到相应的新建设施的服务区中，因此称之为选址与分区。
 *               选址分区分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * (start code)
 * var findLocationService = new SuperMap.FindLocationService(url, {
 *     eventListeners: {
 *         "processCompleted": findLocationCompleted,
 *		   "processFailed": findLocationError
 *		   }
 * });
 * (end)
 * @param url - {string} 服务的访问地址。<br>
 *                        如 http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindLocationService = function (_NetworkAnalystServic) {
    _inherits(FindLocationService, _NetworkAnalystServic);

    function FindLocationService(url, options) {
        _classCallCheck(this, FindLocationService);

        var _this = _possibleConstructorReturn(this, (FindLocationService.__proto__ || Object.getPrototypeOf(FindLocationService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindLocationService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FindLocationService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindLocationService.prototype.__proto__ || Object.getPrototypeOf(FindLocationService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindLocationService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindLocationParameters} 选址分区分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "location" : "/location") + ".json?";
            jsonObject = {
                isFromCenter: params.isFromCenter,
                expectedSupplyCenterCount: params.expectedSupplyCenterCount,
                weightName: params.weightName,
                turnWeightField: params.turnWeightField,
                returnEdgeFeature: true,
                returnEdgeGeometry: true,
                returnNodeFeature: true,
                mapParameter: _SuperMap2.default.Util.toJSON(params.mapParameter),
                supplyCenters: me.getCentersJson(params.supplyCenters)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindLocationService.prototype.getCentersJson
         * @description 将数组对象转化为JSON字符串。
         * @param params - {Array} 需要转换的参数
         * @return {string} 转化后的JSON字符串。
         */

    }, {
        key: 'getCentersJson',
        value: function getCentersJson(params) {
            var json = "[",
                len = params ? params.length : 0;
            for (var i = 0; i < len; i++) {
                if (i > 0) json += ",";
                json += _SuperMap2.default.Util.toJSON(params[i]);
            }
            json += "]";
            return json;
        }

        /**
         * @function SuperMap.FindLocationService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON2.default();
            if (result.demandResults) {
                result.demandResults = JSON.parse(geoJSONFormat.write(result.demandResults));
            }
            if (result.supplyResults) {
                result.supplyResults = JSON.parse(geoJSONFormat.write(result.supplyResults));
            }

            return result;
        }
    }]);

    return FindLocationService;
}(_NetworkAnalystServiceBase2.default);

exports.default = FindLocationService;


_SuperMap2.default.FindLocationService = FindLocationService;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _FindMTSPPathsParameters = __webpack_require__(191);

var _FindMTSPPathsParameters2 = _interopRequireDefault(_FindMTSPPathsParameters);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindMTSPPathsService
 * @classdesc 多旅行商分析服务类<br>
 *               多旅行商分析也称为物流配送，是指在网络数据集中，给定 M 个配送中心点和 N 个配送目的地（M，N 为大于零的整数）。<br>
 *               查找经济有效的配送路径，并给出相应的行走路线。<br>
 *               物流配送功能就是解决如何合理分配配送次序和送货路线，使配送总花费达到最小或每个配送中心的花费达到最小。<br>
 *               该类负责将客户端指定的多旅行商分析参数传递给服务端，并接收服务端返回的结果数据。<br>
 *               多旅行商分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var myFindMTSPPathsService = new SuperMap.FindMTSPPathsService(url, {
 *     eventListeners: {
 *         "processCompleted": findMTSPPathsCompleted,
 *		   "processFailed": findMTSPPathsError
 *		   }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                       http://{服务器地址}:{服务端口号}/iserver/services/网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindMTSPPathsService = function (_NetworkAnalystServic) {
    _inherits(FindMTSPPathsService, _NetworkAnalystServic);

    function FindMTSPPathsService(url, options) {
        _classCallCheck(this, FindMTSPPathsService);

        var _this = _possibleConstructorReturn(this, (FindMTSPPathsService.__proto__ || Object.getPrototypeOf(FindMTSPPathsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindMTSPPathsService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FindMTSPPathsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindMTSPPathsService.prototype.__proto__ || Object.getPrototypeOf(FindMTSPPathsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindMTSPPathsService..prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindMTSPPathsParameters} 多旅行商分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1),
                centers = me.getJson(params.isAnalyzeById, params.centers),
                nodes = me.getJson(params.isAnalyzeById, params.nodes);
            me.url = me.url + "/mtsppath" + ".json?";
            jsonObject = {
                centers: centers,
                nodes: nodes,
                parameter: _SuperMap2.default.Util.toJSON(params.parameter),
                hasLeastTotalCost: params.hasLeastTotalCost
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindMTSPPathsService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过id分析
         * @param params - {Array} 需要转换的数字
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += params[i];
                }
            }
            jsonString += ']';
            return jsonString;
        }

        /**
         * @function SuperMap.FindMTSPPathsService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.pathList) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON2.default();
            result.pathList.map(function (path) {
                if (path.route) {
                    path.route = JSON.parse(geoJSONFormat.write(path.route));
                }
                if (path.pathGuideItems) {
                    path.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));
                }
                if (path.edgeFeatures) {
                    path.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
                }
                if (path.nodeFeatures) {
                    path.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
                }
            });
            return result;
        }
    }]);

    return FindMTSPPathsService;
}(_NetworkAnalystServiceBase2.default);

exports.default = FindMTSPPathsService;


_SuperMap2.default.FindMTSPPathsService = FindMTSPPathsService;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _FindPathParameters = __webpack_require__(192);

var _FindPathParameters2 = _interopRequireDefault(_FindPathParameters);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindPathService
 * @classdesc 最佳路径分析服务类。<br>
 *               最佳路径是在网络数据集中指定一些节点，按照节点的选择顺序，<br>
 *               顺序访问这些节点从而求解起止点之间阻抗最小的路经。<br>
 *               该类负责将客户端指定的最佳路径分析参数传递给服务端，并接收服务端返回的结果数据。<br>
 *               最佳路径分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var myFindPathService = new SuperMap.FindPathService(url, {
 *     eventListeners: {
 *	       "processCompleted": findPathCompleted,
 *		   "processFailed": findPathError
 *		   }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *               http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *               例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindPathService = function (_NetworkAnalystServic) {
    _inherits(FindPathService, _NetworkAnalystServic);

    function FindPathService(url, options) {
        _classCallCheck(this, FindPathService);

        var _this = _possibleConstructorReturn(this, (FindPathService.__proto__ || Object.getPrototypeOf(FindPathService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindPathService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FindPathService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindPathService.prototype.__proto__ || Object.getPrototypeOf(FindPathService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindPathService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindPathParameters} 最佳路径分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "path" : "/path") + ".json?";
            jsonObject = {
                hasLeastEdgeCount: params.hasLeastEdgeCount,
                parameter: _SuperMap2.default.Util.toJSON(params.parameter),
                nodes: me.getJson(params.isAnalyzeById, params.nodes)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindPathService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过id分析
         * @param params - {Array} 需要转换的数字
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += params[i];
                }
            }
            jsonString += ']';
            return jsonString;
        }

        /**
         * @function SuperMap.FindMTSPPathsService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.pathList || result.pathList.length < 1) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON2.default();
            result.pathList.forEach(function (path) {
                if (path.route) {
                    path.route = JSON.parse(geoJSONFormat.write(path.route));
                }
                if (path.pathGuideItems) {
                    path.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));
                }
                if (path.edgeFeatures) {
                    path.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
                }
                if (path.nodeFeatures) {
                    path.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
                }
            });
            return result;
        }
    }]);

    return FindPathService;
}(_NetworkAnalystServiceBase2.default);

exports.default = FindPathService;


_SuperMap2.default.FindPathService = FindPathService;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _FindServiceAreasParameters = __webpack_require__(193);

var _FindServiceAreasParameters2 = _interopRequireDefault(_FindServiceAreasParameters);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindServiceAreasService
 * @classdesc 服务区分析服务类。<br>
 *               服务区分析是以指定服务站点为中心，<br>
 *               在一定服务范围内查找网络上服务站点能够提供服务的区域范围。<br>
 *               该类负责将客户端指定的服务区分析参数传递给服务端，并接收服务端返回的结果数据。<br>
 *               服务区分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var myFindServiceAreasService = new SuperMap.FindServiceAreasService(url, {
 *          eventListeners: {
 *              "processCompleted": findServiceAreasCompleted,
 *              "processFailed": findServiceAreasError
 *          }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象
 */
var FindServiceAreasService = function (_NetworkAnalystServic) {
    _inherits(FindServiceAreasService, _NetworkAnalystServic);

    function FindServiceAreasService(url, options) {
        _classCallCheck(this, FindServiceAreasService);

        var _this = _possibleConstructorReturn(this, (FindServiceAreasService.__proto__ || Object.getPrototypeOf(FindServiceAreasService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindServiceAreasService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FindServiceAreasService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindServiceAreasService.prototype.__proto__ || Object.getPrototypeOf(FindServiceAreasService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindServiceAreasService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindServiceAreasParameters} 服务区分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "servicearea" : "/servicearea") + ".json?";
            jsonObject = {
                isFromCenter: params.isFromCenter,
                isCenterMutuallyExclusive: params.isCenterMutuallyExclusive,
                parameter: _SuperMap2.default.Util.toJSON(params.parameter),
                centers: me.getJson(params.isAnalyzeById, params.centers),
                weights: me.getJson(true, params.weights)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindServiceAreasService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过id分析
         * @param params - {Array} 需要转换的数字
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) jsonString += ",";
                    jsonString += params[i];
                }
            }
            jsonString += ']';
            return jsonString;
        }

        /**
         * @function SuperMap.FindServiceAreasService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.serviceAreaList) {
                return result;
            }
            var geoJSONFormat = new _GeoJSON2.default();
            result.serviceAreaList.map(function (serviceArea) {
                if (serviceArea.serviceRegion) {
                    serviceArea.serviceRegion = JSON.parse(geoJSONFormat.write(serviceArea.serviceRegion));
                }
                if (serviceArea.edgeFeatures) {
                    serviceArea.edgeFeatures = JSON.parse(geoJSONFormat.write(serviceArea.edgeFeatures));
                }
                if (serviceArea.nodeFeatures) {
                    serviceArea.nodeFeatures = JSON.parse(geoJSONFormat.write(serviceArea.nodeFeatures));
                }
                if (serviceArea.routes) {
                    serviceArea.routes = JSON.parse(geoJSONFormat.write(serviceArea.routes));
                }
            });

            return result;
        }
    }]);

    return FindServiceAreasService;
}(_NetworkAnalystServiceBase2.default);

exports.default = FindServiceAreasService;


_SuperMap2.default.FindServiceAreasService = FindServiceAreasService;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _FindTSPPathsParameters = __webpack_require__(194);

var _FindTSPPathsParameters2 = _interopRequireDefault(_FindTSPPathsParameters);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindTSPPathsService
 * @classdesc 旅行商分析服务类<br>
 *               旅行商分析是路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
 *               旅行商分析也可以指定到达的终点，这时查找从起点能够遍历所有途经点最后到达终点，且花费最小的路径。
 *               该类负责将客户端指定的旅行商分析参数传递给服务端，并接收服务端返回的结果数据。
 *               旅行商分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * (start code)
 * var myFindTSPPathsService = new SuperMap.FindTSPPathsService(url, {
 *     eventListeners: {
 *	      "processCompleted": findTSPPathsCompleted,
 *		  "processFailed": findTSPPathsError
 *		  }
 *  });
 * (end)
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindTSPPathsService = function (_NetworkAnalystServic) {
    _inherits(FindTSPPathsService, _NetworkAnalystServic);

    function FindTSPPathsService(url, options) {
        _classCallCheck(this, FindTSPPathsService);

        var _this = _possibleConstructorReturn(this, (FindTSPPathsService.__proto__ || Object.getPrototypeOf(FindTSPPathsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindTSPPathsService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FindTSPPathsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindTSPPathsService.prototype.__proto__ || Object.getPrototypeOf(FindTSPPathsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindTSPPathsService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindTSPPathsParameters} 旅行商分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "tsppath" : "/tsppath") + ".json?";
            jsonObject = {
                parameter: _SuperMap2.default.Util.toJSON(params.parameter),
                endNodeAssigned: params.endNodeAssigned,
                nodes: me.getNodesJson(params)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindTSPPathsService.prototype.getNodesJson
         * @description 将节点对象转化为JSON字符串。
         * @param params - {SuperMap.FindTSPPathsParameters}
         * @return {string} 转化后的JSON字符串。
         */

    }, {
        key: 'getNodesJson',
        value: function getNodesJson(params) {
            var jsonParameters = "",
                nodesString,
                i,
                len,
                nodes;
            if (params.isAnalyzeById === false) {
                for (nodesString = "[", i = 0, nodes = params.nodes, len = nodes.length; i < len; i++) {
                    if (i > 0) nodesString += ",";
                    nodesString += '{"x":' + nodes[i].x + ',"y":' + nodes[i].y + '}';
                }
                nodesString += ']';
                jsonParameters += nodesString;
            } else if (params.isAnalyzeById == true) {
                for (var nodeIDsString = "[", i = 0, nodes = params.nodes, len = nodes.length; i < len; i++) {
                    if (i > 0) nodeIDsString += ",";
                    nodeIDsString += nodes[i];
                }
                nodeIDsString += ']';
                jsonParameters += nodeIDsString;
            }
            return jsonParameters;
        }

        /**
         * @function SuperMap.FindTSPPathsService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.tspPathList) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON2.default();
            result.tspPathList.forEach(function (path) {
                if (path.route) {
                    path.route = JSON.parse(geoJSONFormat.write(path.route));
                }
                if (path.pathGuideItems) {
                    path.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));
                }
                if (path.edgeFeatures) {
                    path.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
                }
                if (path.nodeFeatures) {
                    path.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
                }
            });
            return result;
        }
    }]);

    return FindTSPPathsService;
}(_NetworkAnalystServiceBase2.default);

exports.default = FindTSPPathsService;


_SuperMap2.default.FindTSPPathsService = FindTSPPathsService;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _GenerateSpatialDataParameters = __webpack_require__(195);

var _GenerateSpatialDataParameters2 = _interopRequireDefault(_GenerateSpatialDataParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GenerateSpatialDataService
 * @classdesc
 * 动态分段分析服务类。
 * 该类负责将客户设置的动态分段分析服务参数传递给服务端，并接收服务端返回的动态分段分析结果数据。
 * 获取的结果数据包括 originResult 、result 两种，其中，originResult 为服务端返回的用 JSON 对象表示的动态分段分析结果数据，result 为服务端返回的动态分段分析结果数据。
 *  @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 *  @param options - {Object} 可选参数。如:</br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example 实例化该类如下例所示：
 * (start code)
 *  function GenerateSpatialData(){
     *
     *  //配置数据返回选项(option)
     *  var option = new SuperMap.DataReturnOption({
     *      expectCount: 1000,
     *      dataset: "generateSpatialData",
     *      deleteExistResultDataset: true,
     *      dataReturnMode: SuperMap.DataReturnMode.DATASET_ONLY
     *  }),
     *  //配置动态分段参数(Parameters)
     *  parameters = new SuperMap.GenerateSpatialDataParameters({
     *      routeTable: "RouteDT_road@Changchun",
     *      routeIDField: "RouteID",
     *      eventTable: "LinearEventTabDT@Changchun",
     *      eventRouteIDField: "RouteID",
     *      measureField: "",
     *      measureStartField: "LineMeasureFrom",
     *      measureEndField: "LineMeasureTo",
     *      measureOffsetField: "",
     *      errorInfoField: "",
     *      retainedFields:[],
     *      dataReturnOption: option
     *  }),
     *  //配置动态分段iService
     *  iService = new SuperMap.GenerateSpatialDataService(Changchun_spatialanalyst, {
     *      eventListeners: {
     *          processCompleted: generateCompleted,
     *          processFailed: generateFailded
     *      }
     *  });
     *  //执行
     *  iService.processAsync(parameters);
     *  function Completed(generateSpatialDataEventArgs){//todo};
     *  function Error(generateSpatialDataEventArgs){//todo};
     * (end)
     */
var GenerateSpatialDataService = function (_SpatialAnalystBase) {
    _inherits(GenerateSpatialDataService, _SpatialAnalystBase);

    function GenerateSpatialDataService(url, options) {
        _classCallCheck(this, GenerateSpatialDataService);

        var _this = _possibleConstructorReturn(this, (GenerateSpatialDataService.__proto__ || Object.getPrototypeOf(GenerateSpatialDataService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GenerateSpatialDataService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(GenerateSpatialDataService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GenerateSpatialDataService.prototype.__proto__ || Object.getPrototypeOf(GenerateSpatialDataService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GenerateSpatialDataService.prototype.processAsync
         * @description 负责将客户端的动态分段服务参数传递到服务端。
         * @param params - {SuperMap.GenerateSpatialDataParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonParameters;

            jsonParameters = me.getJsonParameters(params);

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.GenerateSpatialDataService.prototype.getJsonParameters
         * @description 将参数转化为 JSON 字符串。
         * @param params -  {SuperMap.GenerateSpatialDataParameters}
         * @return {string}转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var jsonParameters = "",
                jsonStr = "datasets/" + params.routeTable + "/linearreferencing/generatespatialdata",
                me = this,
                end;

            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? jsonStr + ".json" : "/" + jsonStr + ".json";

            me.url += "?returnContent=true";
            jsonParameters = _SuperMap2.default.Util.toJSON(params);
            return jsonParameters;
        }
    }]);

    return GenerateSpatialDataService;
}(_SpatialAnalystBase3.default);

exports.default = GenerateSpatialDataService;


_SuperMap2.default.GenerateSpatialDataService = GenerateSpatialDataService;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _GeoRelationAnalystParameters = __webpack_require__(198);

var _GeoRelationAnalystParameters2 = _interopRequireDefault(_GeoRelationAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeoRelationAnalystService
 * @classdesc
 * 空间关系分析服务类。
 * 该类负责将客户设置的空间关系分析服务参数传递给服务端，并接收服务端返回的空间关系分析结果数据。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example 实例化该类如下例所示：
 * (start code)
 *  function datasetGeoRelationAnalystProcess() {
     *      var referenceFilter = new SuperMap.FilterParameter({
     *                              name:"Frame_R@Changchun",
     *                              attributeFilter:"SmID>0"});
     *      var sourceFilter = new SuperMap.FilterParameter({
     *                          attributeFilter:"SmID>0"});
     *      //初始化服务类
     *      var datasetGeoRelationService = new SuperMap.GeoRelationAnalystService(
     *          "http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst/"),
     *      //构建参数类
     *      datasetGeoRelationParameters = new SuperMap.GeoRelationAnalystParameters({
     *          dataset: "Park@Changchun",
     *          startRecord: 0,
     *          expectCount: 20,
     *          sourceFilter: sourceFilter,
     *          referenceFilter: referenceFilter,
     *          spatialRelationType: SuperMap.SpatialRelationType.INTERSECT,
     *          isBorderInside: true,
     *          returnFeature: true,
     *          returnGeoRelatedOnly: true
     *      });
     *      datasetGeoRelationService.events.on({
     *          "processCompleted": datasetGeoRelationAnalystCompleted,
     *          "processFailed": datasetGeoRelationAnalystFailed});
     *      //执行
     *      datasetGeoRelationService.processAsync(datasetGeoRelationParameters);
     *  }
 *  function Completed(datasetGeoRelationAnalystCompleted){//todo};
 *  function Error(datasetGeoRelationAnalystFailed){//todo};
 * (end)
 *
 */
var GeoRelationAnalystService = function (_SpatialAnalystBase) {
    _inherits(GeoRelationAnalystService, _SpatialAnalystBase);

    function GeoRelationAnalystService(url, options) {
        _classCallCheck(this, GeoRelationAnalystService);

        var _this = _possibleConstructorReturn(this, (GeoRelationAnalystService.__proto__ || Object.getPrototypeOf(GeoRelationAnalystService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GeoRelationAnalystService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(GeoRelationAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeoRelationAnalystService.prototype.__proto__ || Object.getPrototypeOf(GeoRelationAnalystService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GeoRelationAnalystService.prototype.processAsync
         * @description 负责将客户端的空间关系分析参数传递到服务端
         * @param parameter - {GeoRelationAnalystParameters} 空间关系分析所需的参数信息。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var me = this;
            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {
                me.url += 'datasets/' + parameter.dataset + '/georelation';
            } else {
                me.url += '/datasets/' + parameter.dataset + '/georelation';
            }

            var jsonParameters = _SuperMap2.default.Util.toJSON(parameter);

            me.url += '.json?returnContent=true';

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return GeoRelationAnalystService;
}(_SpatialAnalystBase3.default);

exports.default = GeoRelationAnalystService;


_SuperMap2.default.GeoRelationAnalystService = GeoRelationAnalystService;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _GetFeaturesServiceBase = __webpack_require__(27);

var _GetFeaturesServiceBase2 = _interopRequireDefault(_GetFeaturesServiceBase);

var _GetFeaturesByBoundsParameters = __webpack_require__(203);

var _GetFeaturesByBoundsParameters2 = _interopRequireDefault(_GetFeaturesByBoundsParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByBoundsService
 * @classdesc 数据集范围查询服务类,查询与指定范围对象符合一定空间关系的矢量要素。
 * @description 数据集范围查询服务类构造函数。
 * @extends SuperMap.GetFeaturesServiceBase
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务，URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；</br>
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param options - {Object} 可选参数。如：<br>
 *       eventListeners - {Object} 需要被注册的监听器对象。</br>
 * @example
 * (start code)
 * var myGetFeaturesByBoundsService = new SuperMa.GetFeaturesByBoundsService(url, {
     *     eventListeners: {
     *           "processCompleted": getFeatureCompleted,
     *           "processFailed": getFeatureError
     *           }
     * });
 * function getFeatureCompleted(object){//todo};
 * function getFeatureError(object){//todo}
 * (end)
 */

var GetFeaturesByBoundsService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesByBoundsService, _GetFeaturesServiceBa);

    function GetFeaturesByBoundsService(url, options) {
        _classCallCheck(this, GetFeaturesByBoundsService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByBoundsService.__proto__ || Object.getPrototypeOf(GetFeaturesByBoundsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesByBoundsService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(GetFeaturesByBoundsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByBoundsService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByBoundsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GetFeaturesByBoundsService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry,Bounds等）。
         * @param params  {SuperMap.GetFeaturesByBoundsParameters}
         * @return {string} 转化后的 JSON 字符串。
         *
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            return _GetFeaturesByBoundsParameters2.default.toJsonParameters(params);
        }
    }]);

    return GetFeaturesByBoundsService;
}(_GetFeaturesServiceBase2.default);

exports.default = GetFeaturesByBoundsService;


_SuperMap2.default.GetFeaturesByBoundsService = GetFeaturesByBoundsService;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _GetFeaturesServiceBase = __webpack_require__(27);

var _GetFeaturesServiceBase2 = _interopRequireDefault(_GetFeaturesServiceBase);

var _GetFeaturesByBufferParameters = __webpack_require__(204);

var _GetFeaturesByBufferParameters2 = _interopRequireDefault(_GetFeaturesByBufferParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByBufferService
 * @classdesc 数据服务中数据集缓冲区查询服务类。
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务，
 * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；</br>
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param options - {Object} 可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.GetFeaturesServiceBase
 * @example 例如：
 * var myGetFeaturesByBufferService = new   SuperMap.GetFeaturesByBufferService(url, {
 *     eventListeners: {
 *           "processCompleted": GetFeaturesCompleted,
 *           "processFailed": GetFeaturesError
 *           }
 * });
 * function GetFeaturesCompleted(object){//todo};
 * function GetFeaturesError(object){//todo};
 */

var GetFeaturesByBufferService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesByBufferService, _GetFeaturesServiceBa);

    function GetFeaturesByBufferService(url, options) {
        _classCallCheck(this, GetFeaturesByBufferService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByBufferService.__proto__ || Object.getPrototypeOf(GetFeaturesByBufferService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesByBufferService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(GetFeaturesByBufferService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByBufferService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByBufferService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GetFeaturesByBufferService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         * 在本类中重写此方法，可以实现不同种类的查询（IDs, SQL, Buffer, Geometry等）。
         * @param params {SuperMap.GetFeaturesByBufferParameters}
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            return _SuperMap2.default.GetFeaturesByBufferParameters.toJsonParameters(params);
        }
    }]);

    return GetFeaturesByBufferService;
}(_GetFeaturesServiceBase2.default);

exports.default = GetFeaturesByBufferService;


_SuperMap2.default.GetFeaturesByBufferService = GetFeaturesByBufferService;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _GetFeaturesServiceBase = __webpack_require__(27);

var _GetFeaturesServiceBase2 = _interopRequireDefault(_GetFeaturesServiceBase);

var _GetFeaturesByGeometryParameters = __webpack_require__(205);

var _GetFeaturesByGeometryParameters2 = _interopRequireDefault(_GetFeaturesByGeometryParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByGeometryService
 * @classdesc 数据集几何查询服务类,查询与指定几何对象符合一定空间关系的矢量要素。
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务，:</br>
 * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data；:</br>
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data"
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。</br>
 * @extends SuperMap.GetFeaturesServiceBase
 * @example 例如：
 * (start code)
 * var myService = new SuperMap.GetFeaturesByGeometryService(url, {
     *     eventListeners: {
     *           "processCompleted": getFeatureCompleted,
     *           "processFailed": getFeatureError
     *           }
     * });
 * function getFeatureCompleted(object){//todo};
 * function getFeatureError(object){//todo}
 * (end)
 *
 */
var GetFeaturesByGeometryService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesByGeometryService, _GetFeaturesServiceBa);

    function GetFeaturesByGeometryService(url, options) {
        _classCallCheck(this, GetFeaturesByGeometryService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByGeometryService.__proto__ || Object.getPrototypeOf(GetFeaturesByGeometryService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesByGeometryService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(GetFeaturesByGeometryService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByGeometryService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByGeometryService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GetFeaturesByGeometryService.prototype.getJsonParameters
         * @param params - {SuperMap.GetFeaturesByGeometryParameters}
         * @description 将查询参数转化为 JSON 字符串。
         * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry等）。
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            return _GetFeaturesByGeometryParameters2.default.toJsonParameters(params);
        }
    }]);

    return GetFeaturesByGeometryService;
}(_GetFeaturesServiceBase2.default);

exports.default = GetFeaturesByGeometryService;


_SuperMap2.default.GetFeaturesByGeometryService = GetFeaturesByGeometryService;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _GetFeaturesServiceBase = __webpack_require__(27);

var _GetFeaturesServiceBase2 = _interopRequireDefault(_GetFeaturesServiceBase);

var _GetFeaturesByIDsParameters = __webpack_require__(206);

var _GetFeaturesByIDsParameters2 = _interopRequireDefault(_GetFeaturesByIDsParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByIDsService
 * @classdesc 数据集ID查询服务类。在数据集集合中查找指定 ID 号对应的空间地物要素。
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务。
 *              URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；</br>
 *              例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。</br>
 * @extends SuperMap.GetFeaturesServiceBase
 * @example 例如：
 * (start code)
 * var myGetFeaturesByIDsService = new SuperMap.GetFeaturesByIDsService(url, {
 *     eventListeners: {
 *         "processCompleted": getFeatureCompleted,
 *         "processFailed": getFeatureError
 *            }
 *     });
 * function getFeatureCompleted(object){//todo};
 * function getFeatureError(object){//todo}
 * (end)
 */
var GetFeaturesByIDsService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesByIDsService, _GetFeaturesServiceBa);

    function GetFeaturesByIDsService(url, options) {
        _classCallCheck(this, GetFeaturesByIDsService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByIDsService.__proto__ || Object.getPrototypeOf(GetFeaturesByIDsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesByIDsService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(GetFeaturesByIDsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByIDsService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByIDsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GetFeaturesByIDsService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry等）。
         * @param  params - {SuperMap.GetFeaturesByIDsParameters}
         * @return {string} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            return _GetFeaturesByIDsParameters2.default.toJsonParameters(params);
        }
    }]);

    return GetFeaturesByIDsService;
}(_GetFeaturesServiceBase2.default);

exports.default = GetFeaturesByIDsService;


_SuperMap2.default.GetFeaturesByIDsService = GetFeaturesByIDsService;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _GetFeaturesServiceBase = __webpack_require__(27);

var _GetFeaturesServiceBase2 = _interopRequireDefault(_GetFeaturesServiceBase);

var _GetFeaturesBySQLParameters = __webpack_require__(207);

var _GetFeaturesBySQLParameters2 = _interopRequireDefault(_GetFeaturesBySQLParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesBySQLService
 * @constructs SuperMap.GetFeaturesBySQLService
 * @classdesc
 * 数据服务中数据集 SQL 查询服务类。
 * 在一个或多个指定的图层上查询符合 SQL 条件的空间地物信息。
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务，
 * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；</br>
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param  options - {Object} 可選参数。如</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.GetFeaturesServiceBase
 * @example 例如：
 * (start code)
 * var myGetFeaturesBySQLService = new SuperMap.GetFeaturesBySQLService(url, {
     *     eventListeners: {
     *         "processCompleted": GetFeaturesCompleted,
     *         "processFailed": GetFeaturesError
     *         }
     * });
 * function getFeaturesCompleted(object){//todo};
 * function getFeaturesError(object){//todo};
 * (end)
 *
 */
var GetFeaturesBySQLService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesBySQLService, _GetFeaturesServiceBa);

    function GetFeaturesBySQLService(url, options) {
        _classCallCheck(this, GetFeaturesBySQLService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesBySQLService.__proto__ || Object.getPrototypeOf(GetFeaturesBySQLService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesBySQLService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(GetFeaturesBySQLService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesBySQLService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesBySQLService.prototype), 'destroy', this).call(this);
        }

        /*
         * @function SuperMap.GetFeaturesBySQLService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry等）。
         * @param params - {SuperMap.GetFeaturesBySQLParameters}
         * @return {string} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            return _GetFeaturesBySQLParameters2.default.toJsonParameters(params);
        }
    }]);

    return GetFeaturesBySQLService;
}(_GetFeaturesServiceBase2.default);

exports.default = GetFeaturesBySQLService;


_SuperMap2.default.GetFeaturesBySQLService = GetFeaturesBySQLService;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFieldsService
 * @classdesc 字段查询服务，支持查询指定数据集的中所有属性字段（field）的集合。
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/data-world/rest/data 即可。
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。</br>
 *        datasource - {string}</br>
 *        dataset - {string}</br>
 * @extends SuperMap.CommonServiceBase
 * @example 例如：
 * (start code)
 * var myService = new SuperMap.GetFieldsService(url, {eventListeners: {
     *     "processCompleted": getFieldsCompleted,
     *     "processFailed": getFieldsError
     *     },
     *     datasource: "World",
     *     dataset: "Countries"
     * };
 * (end)
 *
 */
var GetFieldsService = function (_CommonServiceBase) {
    _inherits(GetFieldsService, _CommonServiceBase);

    /**
     * @member SuperMap.GetFieldsService.prototype.datasource -{string}
     * @description 要查询的数据集所在的数据源名称。
     */
    function GetFieldsService(url, options) {
        _classCallCheck(this, GetFieldsService);

        var _this = _possibleConstructorReturn(this, (GetFieldsService.__proto__ || Object.getPrototypeOf(GetFieldsService)).call(this, url, options));

        _this.datasource = null;
        _this.dataset = null;
        _this.CLASS_NAME = "SuperMap.GetFieldsService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     *  @member SuperMap.GetFieldsService.prototype.dataset -{string}
     *  @description 要查询的数据集名称。
     */


    _createClass(GetFieldsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFieldsService.prototype.__proto__ || Object.getPrototypeOf(GetFieldsService.prototype), 'destroy', this).call(this);
            var me = this;
            me.datasource = null;
            me.dataset = null;
        }

        /**
         * @function SuperMap.GetFieldsService.prototype.processAsync
         * @description 执行服务，查询指定数据集的字段信息。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this,
                end = me.url.substr(me.url.length - 1, 1),
                datasetURL = "datasources/" + me.datasource + "/datasets/" + me.dataset;
            me.url += end == "/" ? datasetURL + "/fields.json?" : "/" + datasetURL + "/fields.json?";

            me.request({
                method: "GET",
                data: null,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return GetFieldsService;
}(_CommonServiceBase3.default);

exports.default = GetFieldsService;


_SuperMap2.default.GetFieldsService = GetFieldsService;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _GetGridCellInfosParameters = __webpack_require__(208);

var _GetGridCellInfosParameters2 = _interopRequireDefault(_GetGridCellInfosParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetGridCellInfosService
 * @classdesc 数据栅格查询服务，支持查询指定地理位置的栅格信息
 * @param url - {string} 查询服务地址。例如: http://localhost:8090/iserver/services/data-jingjin/rest/data
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.CommonServiceBase
 * @example  例如：
 * (start code)
 * var myService = new SuperMap.GetGridCellInfosService(url, {eventListeners: {
     *     "processCompleted": queryCompleted,
     *     "processFailed": queryError
     *     }
     * });
 * (end)
 *
 */
var GetGridCellInfosService = function (_CommonServiceBase) {
    _inherits(GetGridCellInfosService, _CommonServiceBase);

    /**
     * @member SuperMap.GetGridCellInfosService.prototype.X -{number}
     * @description 要查询的地理位置X轴
     */


    /**
     * @member SuperMap.GetGridCellInfosService.prototype.dataSourceName -{string}
     * @description 数据源名称。
     */
    function GetGridCellInfosService(url, options) {
        _classCallCheck(this, GetGridCellInfosService);

        var _this = _possibleConstructorReturn(this, (GetGridCellInfosService.__proto__ || Object.getPrototypeOf(GetGridCellInfosService)).call(this, url, options));

        _this.datasetName = null;
        _this.dataSourceName = null;
        _this.datasetType = null;
        _this.X = null;
        _this.Y = null;
        _this.CLASS_NAME = "SuperMap.GetGridCellInfosService";

        if (!!options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.GetGridCellInfosService.prototype.Y-{number}
     * @description 要查询的地理位置Y轴
     */


    /**
     * @member SuperMap.GetGridCellInfosService.prototype.datasetType -{string}
     * @description 数据集类型。
     */


    /**
     * @member SuperMap.GetGridCellInfosService.prototype.datasetName -{string}
     * @description 数据集名称。
     */


    _createClass(GetGridCellInfosService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetGridCellInfosService.prototype.__proto__ || Object.getPrototypeOf(GetGridCellInfosService.prototype), 'destroy', this).call(this);
            var me = this;
            me.X = null;
            me.Y = null;
            me.datasetName = null;
            me.dataSourceName = null;
            me.datasetType = null;
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.processAsync
         * @description 执行服务，查询数据集信息。
         * params - {SuperMap.GetGridCellInfosParameters} 查询参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (params) {
                _SuperMap2.default.Util.extend(this, params);
            }
            var me = this;
            var end = me.url.substr(me.url.length - 1, 1);
            me.url += end == "/" ? "datasources/" + me.dataSourceName + "/datasets/" + me.datasetName + ".json" : "/datasources/" + me.dataSourceName + "/datasets/" + me.datasetName + ".json";

            me.queryRequest(me.getDatasetInfoCompleted, me.getDatasetInfoFailed);
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.queryRequest
         * @description 执行服务，查询。
         * @param successFun -{function} 成功后执行的函数
         * @param failedFunc -{function} 失败后执行的函数
         */

    }, {
        key: 'queryRequest',
        value: function queryRequest(successFun, failedFunc) {
            var me = this;
            me.request({
                method: "GET",
                data: null,
                scope: me,
                success: successFun,
                failure: failedFunc
            });
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.getDatasetInfoCompleted
         * @description  数据集查询完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'getDatasetInfoCompleted',
        value: function getDatasetInfoCompleted(result) {
            var me = this;
            result = _SuperMap2.default.Util.transformResult(result);
            me.datasetType = result.datasetInfo.type;
            me.queryGridInfos();
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.queryGridInfos
         * @description 执行服务，查询数据集栅格信息信息。
         */

    }, {
        key: 'queryGridInfos',
        value: function queryGridInfos() {
            var me = this,
                re = /\.json/,
                index = re.exec(me.url).index,
                urlBack = me.url.substring(index),
                urlFront = me.url.substring(0, me.url.length - urlBack.length);
            if (me.datasetType == "GRID") {
                me.url = urlFront + "/gridValue" + urlBack;
            } else {
                me.url = urlFront + "/imageValue" + urlBack;
            }

            if (me.X != null && me.Y != null) {
                me.url += '?x=' + me.X + '&y=' + me.Y;
            }
            me.queryRequest(me.serviceProcessCompleted, me.serviceProcessFailed);
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.getDatasetInfoFailed
         * @description 数据集查询失败，执行此方法。
         * @param result -  {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'getDatasetInfoFailed',
        value: function getDatasetInfoFailed(result) {
            var me = this;
            me.serviceProcessFailed(result);
        }
    }]);

    return GetGridCellInfosService;
}(_CommonServiceBase3.default);

exports.default = GetGridCellInfosService;


_SuperMap2.default.GetGridCellInfosService = GetGridCellInfosService;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _ServerTheme = __webpack_require__(231);

var _ServerTheme2 = _interopRequireDefault(_ServerTheme);

var _Grid = __webpack_require__(209);

var _Grid2 = _interopRequireDefault(_Grid);

var _Image = __webpack_require__(210);

var _Image2 = _interopRequireDefault(_Image);

var _Vector = __webpack_require__(268);

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetLayersInfoService
 * @classdesc 获取图层信息服务类构造函数。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 与客户端交互的地图服务地址。请求地图服务,URL 应为：<br>
 *         http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；<br>
 *         如 http://localhost:8090/iserver/services/map-world/rest/maps/World 。<br>
 *         如果查询临时图层的信息，请指定完成的url，包含临时图层ID信息，如：<br>
 *         http://localhost:8090/iserver/services/map-world/rest/maps/World/tempLayersSet/resourceID
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 *         isTempLayers - {boolean} 当前url对应的图层是否是临时图层。
 */
var GetLayersInfoService = function (_CommonServiceBase) {
    _inherits(GetLayersInfoService, _CommonServiceBase);

    function GetLayersInfoService(url, options) {
        _classCallCheck(this, GetLayersInfoService);

        var _this = _possibleConstructorReturn(this, (GetLayersInfoService.__proto__ || Object.getPrototypeOf(GetLayersInfoService)).call(this, url, options));

        _this.isTempLayers = false;
        _this.CLASS_NAME = "SuperMap.GetLayersInfoService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */

    /**
     * @member SuperMap.GetLayersInfoService.prototype.isTempLayers -{Boolean}
     * @description 当前url对应的图层是否是临时图层。
     */


    _createClass(GetLayersInfoService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetLayersInfoService.prototype.__proto__ || Object.getPrototypeOf(GetLayersInfoService.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.GetLayersInfoService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this,
                method = "GET",
                end = me.url.substr(me.url.length - 1, 1);
            if (!me.isTempLayers) {
                me.url += end === "/" ? '' : '/';
                me.url += "layers.json?";
            } else {
                me.url += ".json?";
            }
            me.request({
                method: method,
                params: null,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.GetLayersInfoService.prototype.serviceProcessCompleted
         * @description 编辑完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this,
                existRes,
                layers,
                len;
            result = _SuperMap2.default.Util.transformResult(result);

            existRes = !!result && result.length > 0;
            layers = existRes ? result[0].subLayers.layers : null;
            len = layers ? layers.length : 0;
            me.handleLayers(len, layers);
            me.events.triggerEvent("processCompleted", { result: result[0] });
        }

        /**
         * TODO 专题图时候可能会用到
         * @function SuperMap.GetLayersInfoService.prototype.handleLayers
         * @description 处理iserver 新增图层组数据 (subLayers.layers 中可能还会含有 subLayers.layers)
         * @param len - {number} subLayers.layers的长度
         * @param layers - {Array} subLayers.layers
         */

    }, {
        key: 'handleLayers',
        value: function handleLayers(len, layers) {
            var me = this,
                tempLayer;
            if (len) {
                for (var i = 0; i < len; i++) {
                    if (layers[i].subLayers && layers[i].subLayers.layers && layers[i].subLayers.layers.length > 0) {
                        me.handleLayers(layers[i].subLayers.layers.length, layers[i].subLayers.layers);
                    } else {
                        var type = layers[i].ugcLayerType;
                        switch (type) {
                            case 'THEME':
                                tempLayer = new _ServerTheme2.default();
                                tempLayer.fromJson(layers[i]);
                                layers[i] = tempLayer;
                                break;
                            case 'GRID':
                                tempLayer = new _Grid2.default();
                                tempLayer.fromJson(layers[i]);
                                layers[i] = tempLayer;
                                break;
                            case 'IMAGE':
                                tempLayer = new _Image2.default();
                                tempLayer.fromJson(layers[i]);
                                layers[i] = tempLayer;
                                break;
                            case 'VECTOR':
                                tempLayer = new _Vector2.default();
                                tempLayer.fromJson(layers[i]);
                                layers[i] = tempLayer;
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
        }
    }]);

    return GetLayersInfoService;
}(_CommonServiceBase3.default);

exports.default = GetLayersInfoService;


_SuperMap2.default.GetLayersInfoService = GetLayersInfoService;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _InterpolationRBFAnalystParameters = __webpack_require__(214);

var _InterpolationRBFAnalystParameters2 = _interopRequireDefault(_InterpolationRBFAnalystParameters);

var _InterpolationDensityAnalystParameters = __webpack_require__(211);

var _InterpolationDensityAnalystParameters2 = _interopRequireDefault(_InterpolationDensityAnalystParameters);

var _InterpolationIDWAnalystParameters = __webpack_require__(212);

var _InterpolationIDWAnalystParameters2 = _interopRequireDefault(_InterpolationIDWAnalystParameters);

var _InterpolationKrigingAnalystParameters = __webpack_require__(213);

var _InterpolationKrigingAnalystParameters2 = _interopRequireDefault(_InterpolationKrigingAnalystParameters);

var _InterpolationAnalystParameters = __webpack_require__(28);

var _InterpolationAnalystParameters2 = _interopRequireDefault(_InterpolationAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationAnalystService
 * @classdesc
 * 插值分析服务类
 * 插值分析可以将有限的采样点数据，通过插值算法对采样点周围的数值情况进行预测，可以掌握研究区域内数据的总体分布状况，从而使采样的离散点不仅仅反映其所在位置的数值情况，还可以反映区域的数值分布。目前SuperMap iServer的插值功能提供从点数据集插值得到栅格数据集的功能，支持以下常用的内插方法，包括：反距离加权插值、克吕金（Kriging）插值法、样条（径向基函数，Radial Basis Function）插值、点密度插值。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。如</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 *
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myTInterpolationAnalystService = new SuperMap.InterpolationAnalystService(url);
 * myTInterpolationAnalystService.events.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 *
 */
var InterpolationAnalystService = function (_SpatialAnalystBase) {
    _inherits(InterpolationAnalystService, _SpatialAnalystBase);

    function InterpolationAnalystService(url, options) {
        _classCallCheck(this, InterpolationAnalystService);

        var _this = _possibleConstructorReturn(this, (InterpolationAnalystService.__proto__ || Object.getPrototypeOf(InterpolationAnalystService)).call(this, url, options));

        _this.mode = null;
        _this.CLASS_NAME = "SuperMap.InterpolationAnalystService";

        var me = _this;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.InterpolationAnalystService.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */

    /**
     * @member SuperMap.InterpolationAnalystService.prototype.mode -{string}
     * @description 插值分析类型。
     */

    _createClass(InterpolationAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(InterpolationAnalystService.prototype.__proto__ || Object.getPrototypeOf(InterpolationAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
        }

        /**
         * @function SuperMap.InterpolationAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param  parameter - {SuperMap.InterpolationAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var parameterObject = {};
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {} else {
                me.url += "/";
            }

            if (parameter instanceof _InterpolationDensityAnalystParameters2.default) {
                me.mode = "Density";
                if (parameter.InterpolationAnalystType === "geometry") {
                    me.url += 'geometry/interpolation/density';
                } else {
                    me.url += 'datasets/' + parameter.dataset + '/interpolation/density';
                }
            } else if (parameter instanceof _InterpolationIDWAnalystParameters2.default) {
                me.mode = "IDW";
                if (parameter.InterpolationAnalystType === "geometry") {
                    me.url += 'geometry/interpolation/idw';
                } else {
                    me.url += 'datasets/' + parameter.dataset + '/interpolation/idw';
                }
            } else if (parameter instanceof _InterpolationRBFAnalystParameters2.default) {
                me.mode = "RBF";
                if (parameter.InterpolationAnalystType === "geometry") {
                    me.url += 'geometry/interpolation/rbf';
                } else {
                    me.url += 'datasets/' + parameter.dataset + '/interpolation/rbf';
                }
            } else if (parameter instanceof _InterpolationKrigingAnalystParameters2.default) {
                me.mode = "Kriging";
                if (parameter.InterpolationAnalystType === "geometry") {
                    me.url += 'geometry/interpolation/kriging';
                } else {
                    me.url += 'datasets/' + parameter.dataset + '/interpolation/kriging';
                }
            }
            _InterpolationAnalystParameters2.default.toObject(parameter, parameterObject);
            var jsonParameters = _SuperMap2.default.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return InterpolationAnalystService;
}(_SpatialAnalystBase3.default);

exports.default = InterpolationAnalystService;


_SuperMap2.default.InterpolationAnalystService = InterpolationAnalystService;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ProcessingServiceBase = __webpack_require__(29);

var _ProcessingServiceBase2 = _interopRequireDefault(_ProcessingServiceBase);

var _KernelDensityJobParameter = __webpack_require__(215);

var _KernelDensityJobParameter2 = _interopRequireDefault(_KernelDensityJobParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.KernelDensityJobsService
 * @classdesc 核密度分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 核密度分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。
 */
var KernelDensityJobsService = function (_ProcessingServiceBas) {
    _inherits(KernelDensityJobsService, _ProcessingServiceBas);

    function KernelDensityJobsService(url, options) {
        _classCallCheck(this, KernelDensityJobsService);

        var _this = _possibleConstructorReturn(this, (KernelDensityJobsService.__proto__ || Object.getPrototypeOf(KernelDensityJobsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.KernelDensityJobsService";

        _this.url += "/spatialanalyst/density";
        return _this;
    }

    /**
     *@inheritDoc
     */


    _createClass(KernelDensityJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(KernelDensityJobsService.prototype.__proto__ || Object.getPrototypeOf(KernelDensityJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.prototype.getKernelDensityJobs
         * @description 获取核密度分析任务
         */

    }, {
        key: 'getKernelDensityJobs',
        value: function getKernelDensityJobs() {
            _get(KernelDensityJobsService.prototype.__proto__ || Object.getPrototypeOf(KernelDensityJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.prototype.getKernelDensityJobs
         * @description 获取指定id的核密度分析服务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getKernelDensityJob',
        value: function getKernelDensityJob(id) {
            _get(KernelDensityJobsService.prototype.__proto__ || Object.getPrototypeOf(KernelDensityJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.prototype.addKernelDensityJob
         * @description 新建核密度分析服务
         * @param params - {SuperMap.KernelDensityJobParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addKernelDensityJob',
        value: function addKernelDensityJob(params, seconds) {
            _get(KernelDensityJobsService.prototype.__proto__ || Object.getPrototypeOf(KernelDensityJobsService.prototype), 'addJob', this).call(this, this.url, params, _KernelDensityJobParameter2.default, seconds);
        }
    }]);

    return KernelDensityJobsService;
}(_ProcessingServiceBase2.default);

exports.default = KernelDensityJobsService;


_SuperMap2.default.KernelDensityJobsService = KernelDensityJobsService;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.MapService
 * @classdesc 地图信息服务类。
 * @extends SuperMap.CommonServiceBase
 * @example
 * (start code)
 * var myMapService = new SuperMap.MapService(url, {
     * eventListeners:{
     *     "processCompleted": MapServiceCompleted,
     *       "processFailed": MapServiceFailed
     *       }
     * });
 * (end)
 *
 * @param url - {string} 服务的访问地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param options - {Object} 参数 。
 * eventListeners - {Object} 需要被注册的监听器对象。
 */
var MapService = function (_CommonServiceBase) {
    _inherits(MapService, _CommonServiceBase);

    function MapService(url, options) {
        _classCallCheck(this, MapService);

        var _this = _possibleConstructorReturn(this, (MapService.__proto__ || Object.getPrototypeOf(MapService)).call(this, url, options));

        _this.projection = null;
        _this.CLASS_NAME = "SuperMap.MapService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        var me = _this;

        me.url += ".json";

        if (me.projection) {
            if (typeof me.projection === "string") {
                me.projection = new _SuperMap2.default.Projection(me.projection);
            }

            var arr = me.projection.getCode().split(":");
            if (arr instanceof Array && arr.length === 2) {
                me.url += "?prjCoordSys={\"epsgCode\":" + arr[1] + "}";
            }
        }
        return _this;
    }

    /**
     * @function  destroy
     * @description 释放资源，将引用的资源属性置空。
     */


    /**
     * @member  SuperMap.MapService.prototype.projection -{SuperMap.Projection} or {string}
     * @description 根据投影参数获取地图状态信息。
     */


    _createClass(MapService, [{
        key: 'destroy',
        value: function destroy() {
            _get(MapService.prototype.__proto__ || Object.getPrototypeOf(MapService.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.events) {
                me.events.un(me.eventListeners);
                me.events.listeners = null;
                me.events.destroy();
                me.events = null;
                me.eventListeners = null;
            }
        }

        /**
         * @function  SuperMap.MapService.prototype.processAsync
         * @description 负责将客户端的设置的参数传递到服务端，与服务端完成异步通讯。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this;
            me.request({
                method: "GET",
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /*
         * Method: getMapStatusCompleted
         * 获取地图状态完成，执行此方法。
         *
         * Parameters:
         * result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _SuperMap2.default.Util.transformResult(result);
            var codeStatus = result.code >= 200 && result.code < 300 || result.code == 0 || result.code === 304;
            var isCodeValid = result.code && codeStatus;
            if (!result.code || isCodeValid) {
                me.events && me.events.triggerEvent("processCompleted", { result: result });
            }
            //在没有token是返回的是200，但是其实是没有权限，所以这里也应该是触发失败事件
            else {
                    me.events.triggerEvent("processFailed", { error: result });
                }
        }
    }]);

    return MapService;
}(_CommonServiceBase3.default);

exports.default = MapService;


_SuperMap2.default.MapService = MapService;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _MathExpressionAnalysisParameters = __webpack_require__(222);

var _MathExpressionAnalysisParameters2 = _interopRequireDefault(_MathExpressionAnalysisParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.MathExpressionAnalysisService
 * @classdesc 栅格代数运算服务类。
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myMathExpressionAnalysisService = new SuperMap.MathExpressionAnalysisService(url);
 * myMathExpressionAnalysisService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 *
 */
var MathExpressionAnalysisService = function (_SpatialAnalystBase) {
    _inherits(MathExpressionAnalysisService, _SpatialAnalystBase);

    function MathExpressionAnalysisService(url, options) {
        _classCallCheck(this, MathExpressionAnalysisService);

        var _this = _possibleConstructorReturn(this, (MathExpressionAnalysisService.__proto__ || Object.getPrototypeOf(MathExpressionAnalysisService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.MathExpressionAnalysisService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(MathExpressionAnalysisService, [{
        key: 'destroy',
        value: function destroy() {
            _get(MathExpressionAnalysisService.prototype.__proto__ || Object.getPrototypeOf(MathExpressionAnalysisService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.MathExpressionAnalysisService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param  parameter - {SuperMap.MathExpressionAnalysisParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {} else {
                me.url += "/";
            }

            var parameterObject = {};

            if (parameter instanceof _MathExpressionAnalysisParameters2.default) {
                me.url += 'datasets/' + parameter.dataset + '/mathanalyst';
            }

            _MathExpressionAnalysisParameters2.default.toObject(parameter, parameterObject);
            var jsonParameters = _SuperMap2.default.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return MathExpressionAnalysisService;
}(_SpatialAnalystBase3.default);

exports.default = MathExpressionAnalysisService;


_SuperMap2.default.MathExpressionAnalysisService = MathExpressionAnalysisService;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _MeasureParameters = __webpack_require__(223);

var _MeasureParameters2 = _interopRequireDefault(_MeasureParameters);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.MeasureService
 * @classdesc 量算服务类。
 *              该类负责将量算参数传递到服务端，并获取服务端返回的量算结果。
 * @extends SuperMap.CommonServiceBase
 * @example
 * var myMeasuerService = new SuperMap.MeasureService(url, {
 *      measureMode: SuperMap.MeasureMode.DISTANCE,
 *      eventListeners:{
 *          "processCompleted": measureCompleted
 *      }
 * });
 * @param url - {string} 服务访问的地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 *         measureMode - {MeasureMode} 量算模式，包括距离量算模式和面积量算模式。
 */
var MeasureService = function (_CommonServiceBase) {
    _inherits(MeasureService, _CommonServiceBase);

    function MeasureService(url, options) {
        _classCallCheck(this, MeasureService);

        var _this = _possibleConstructorReturn(this, (MeasureService.__proto__ || Object.getPrototypeOf(MeasureService)).call(this, url, options));

        _this.measureMode = _REST.MeasureMode.DISTANCE;
        _this.CLASS_NAME = "SuperMap.MeasureService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.MeasureService.prototype.measureMode -{SuperMap.MeasureMode}
     * @description 量算模式，包括距离量算模式和面积量算模式。默认值为：MeasureMode.DISTANCE 。
     */


    _createClass(MeasureService, [{
        key: 'destroy',
        value: function destroy() {
            _get(MeasureService.prototype.__proto__ || Object.getPrototypeOf(MeasureService.prototype), 'destroy', this).call(this);
            var me = this;
            me.measureMode = null;
        }

        /**
         * @function SuperMap.MeasureService.prototype.processAsync
         * @description 负责将客户端的量算参数传递到服务端。
         * @param params - {SuperMap.MeasureParameters} 量算参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                geometry = params.geometry,
                pointsCount = 0,
                point2ds = null,
                urlParameters = null,
                end = null;
            if (!geometry) {
                return;
            }
            end = me.url.substr(me.url.length - 1, 1);
            if (me.measureMode === _REST.MeasureMode.AREA) {
                me.url += end === "/" ? "area.json?" : "/area.json?";
            } else {
                me.url += end === "/" ? "distance.json?" : "/distance.json?";
            }
            var serverGeometry = _ServerGeometry2.default.fromGeometry(geometry);
            if (!serverGeometry) {
                return;
            }
            pointsCount = serverGeometry.parts[0];
            point2ds = serverGeometry.points.splice(0, pointsCount);

            var prjCoordSysTemp, prjCodeTemp, paramsTemp;
            if (params.prjCoordSys) {
                if (_typeof(params.prjCoordSys) === "object") {
                    prjCodeTemp = params.prjCoordSys.projCode;
                    prjCoordSysTemp = '{"epsgCode"' + prjCodeTemp.substring(prjCodeTemp.indexOf(":"), prjCodeTemp.length) + "}";
                } else if (typeof params.prjCoordSys === "string") {
                    prjCoordSysTemp = '{"epsgCode"' + params.prjCoordSys.substring(params.prjCoordSys.indexOf(":"), params.prjCoordSys.length) + "}";
                }
                paramsTemp = {
                    "point2Ds": _SuperMap2.default.Util.toJSON(point2ds),
                    "unit": params.unit,
                    "prjCoordSys": prjCoordSysTemp
                };
            } else {
                paramsTemp = { "point2Ds": _SuperMap2.default.Util.toJSON(point2ds), "unit": params.unit };
            }

            me.request({
                method: "GET",
                params: paramsTemp,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return MeasureService;
}(_CommonServiceBase3.default);

exports.default = MeasureService;


_SuperMap2.default.MeasureService = MeasureService;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _DatasetOverlayAnalystParameters = __webpack_require__(175);

var _DatasetOverlayAnalystParameters2 = _interopRequireDefault(_DatasetOverlayAnalystParameters);

var _GeometryOverlayAnalystParameters = __webpack_require__(200);

var _GeometryOverlayAnalystParameters2 = _interopRequireDefault(_GeometryOverlayAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.OverlayAnalystService
 * @classdesc
 * 叠加分析服务类
 * 该类负责将客户设置的叠加分析参数传递给服务端，并接收服务端返回的叠加分析结果数据。
 * 叠加分析结果通过该类支持的事件的监听函数参数获取
 * @param url - {string} 服务的访问地址。如http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.CommonServiceBase
 * @example 例如：
 * (start code)
 * var myOverlayAnalystService = new SuperMap.OverlayAnalystService(url, {
     *     eventListeners: {
     *	       "processCompleted": OverlayCompleted,
     *		   "processFailed": OverlayFailed
     *		   }
     * });
 * (end)
 */

var OverlayAnalystService = function (_SpatialAnalystBase) {
    _inherits(OverlayAnalystService, _SpatialAnalystBase);

    function OverlayAnalystService(url, options) {
        _classCallCheck(this, OverlayAnalystService);

        var _this = _possibleConstructorReturn(this, (OverlayAnalystService.__proto__ || Object.getPrototypeOf(OverlayAnalystService)).call(this, url, options));

        _this.mode = null;
        _this.CLASS_NAME = "SuperMap.OverlayAnalystService";

        var me = _this;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.OverlayAnalystService.prototype.mode -{string}
     * @description 叠加分析类型
     */


    _createClass(OverlayAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(OverlayAnalystService.prototype.__proto__ || Object.getPrototypeOf(OverlayAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
        }

        /**
         * @function SuperMap.OverlayAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {SuperMap.OverlayAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var parameterObject = {};
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {} else {
                me.url += "/";
            }

            if (parameter instanceof _DatasetOverlayAnalystParameters2.default) {
                me.mode = "datasets";
                me.url += 'datasets/' + parameter.sourceDataset + '/overlay';
                _DatasetOverlayAnalystParameters2.default.toObject(parameter, parameterObject);
            } else if (parameter instanceof _GeometryOverlayAnalystParameters2.default) {
                me.mode = "geometry";
                me.url += 'geometry/overlay';
                _GeometryOverlayAnalystParameters2.default.toObject(parameter, parameterObject);
            }

            var jsonParameters = _SuperMap2.default.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return OverlayAnalystService;
}(_SpatialAnalystBase3.default);

exports.default = OverlayAnalystService;


_SuperMap2.default.OverlayAnalystService = OverlayAnalystService;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _QueryService2 = __webpack_require__(39);

var _QueryService3 = _interopRequireDefault(_QueryService2);

var _QueryByBoundsParameters = __webpack_require__(225);

var _QueryByBoundsParameters2 = _interopRequireDefault(_QueryByBoundsParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByBoundsService
 * @classdesc Bounds 查询服务类。
 * @augments SuperMap.QueryService
 * @example
 * (start end)
 * var myQueryByBoundsService = new SuperMap.QueryByBoundsService(url, {
 *     eventListeners: {
 *         "processCompleted": queryCompleted,
 *		   "processFailed": queryError
 *		   }
 * });
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * (end)
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var QueryByBoundsService = function (_QueryService) {
    _inherits(QueryByBoundsService, _QueryService);

    function QueryByBoundsService(url, options) {
        _classCallCheck(this, QueryByBoundsService);

        var _this = _possibleConstructorReturn(this, (QueryByBoundsService.__proto__ || Object.getPrototypeOf(QueryByBoundsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.QueryByBoundsService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(QueryByBoundsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryByBoundsService.prototype.__proto__ || Object.getPrototypeOf(QueryByBoundsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.QueryByBoundsService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         *              在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds 等）。
         * @param params - {SuperMap.QueryByBoundsParameters} Bounds 查询参数。
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var me = this,
                jsonParameters = "",
                qp = null,
                bounds = params.bounds;
            qp = me.getQueryParameters(params);
            jsonParameters += "'queryMode':'BoundsQuery','queryParameters':";
            jsonParameters += _SuperMap2.default.Util.toJSON(qp);
            jsonParameters += ",'bounds': {'rightTop':{'y':" + bounds.top + ",'x':" + bounds.right + "},'leftBottom':{'y':" + bounds.bottom + ",'x':" + bounds.left + "}}";
            jsonParameters = "{" + jsonParameters + "}";
            return jsonParameters;
        }
    }]);

    return QueryByBoundsService;
}(_QueryService3.default);

exports.default = QueryByBoundsService;


_SuperMap2.default.QueryByBoundsService = QueryByBoundsService;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _QueryService2 = __webpack_require__(39);

var _QueryService3 = _interopRequireDefault(_QueryService2);

var _QueryByDistanceParameters = __webpack_require__(226);

var _QueryByDistanceParameters2 = _interopRequireDefault(_QueryByDistanceParameters);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByDistanceService
 * @description Distance查询服务类。
 * @extends SuperMap.QueryService
 * @example
 *(start code)
 * var myQueryByDistService = new SuperMap.QueryByDistanceService(url, {
 *     eventListeners: {
 *         "processCompleted": queryCompleted,
 *		   "processFailed": queryError
 *		   }
 * });
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 *(end)
 *
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var QueryByDistanceService = function (_QueryService) {
    _inherits(QueryByDistanceService, _QueryService);

    function QueryByDistanceService(url, options) {
        _classCallCheck(this, QueryByDistanceService);

        var _this = _possibleConstructorReturn(this, (QueryByDistanceService.__proto__ || Object.getPrototypeOf(QueryByDistanceService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.QueryByDistanceService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(QueryByDistanceService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryByDistanceService.prototype.__proto__ || Object.getPrototypeOf(QueryByDistanceService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.QueryByDistanceService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         *              在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds等）。
         * @param params - {SuperMap.QueryByDistanceParameters}
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var me = this,
                jsonParameters = "",
                qp = me.getQueryParameters(params);
            var sg = _ServerGeometry2.default.fromGeometry(params.geometry);

            jsonParameters += params.isNearest ? "'queryMode':'FindNearest','queryParameters':" : "'queryMode':'DistanceQuery','queryParameters':";
            jsonParameters += _SuperMap2.default.Util.toJSON(qp);
            jsonParameters += ",'geometry':" + _SuperMap2.default.Util.toJSON(sg) + ",'distance':" + params.distance;
            jsonParameters = "{" + jsonParameters + "}";
            return jsonParameters;
        }
    }]);

    return QueryByDistanceService;
}(_QueryService3.default);

exports.default = QueryByDistanceService;


_SuperMap2.default.QueryByDistanceService = QueryByDistanceService;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _QueryService2 = __webpack_require__(39);

var _QueryService3 = _interopRequireDefault(_QueryService2);

var _QueryByGeometryParameters = __webpack_require__(227);

var _QueryByGeometryParameters2 = _interopRequireDefault(_QueryByGeometryParameters);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByGeometryService
 * @classdesc Geometry查询服务类。
 * @extends SuperMap.QueryService
 * @example
 * var myQueryByGeometryService = new SuperMap.QueryByGeometryService(url, {
 *     eventListeners: {
 *	      "processCompleted": queryCompleted,
 *		  "processFailed": queryError
 *		  }
 * });
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var QueryByGeometryService = function (_QueryService) {
    _inherits(QueryByGeometryService, _QueryService);

    /*
     * @function SuperMap.QueryByGeometryService.prototype.constructor
     * @description Geometry 查询服务类构造函数。
     * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
     * @param options - {Object} 互服务时所需可选参数。如：<br>
     *         eventListeners - {Object} 需要被注册的监听器对象。
     */
    function QueryByGeometryService(url, options) {
        _classCallCheck(this, QueryByGeometryService);

        var _this = _possibleConstructorReturn(this, (QueryByGeometryService.__proto__ || Object.getPrototypeOf(QueryByGeometryService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.QueryByGeometryService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(QueryByGeometryService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryByGeometryService.prototype.__proto__ || Object.getPrototypeOf(QueryByGeometryService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.QueryByGeometryService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         *              在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds等）。
         * @param params - {SuperMap.QueryByGeometryParameters}
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var me = this,
                jsonParameters = "",
                qp = null,
                geometry = params.geometry,
                sg = _ServerGeometry2.default.fromGeometry(geometry);
            qp = me.getQueryParameters(params);
            jsonParameters += "'queryMode':'SpatialQuery','queryParameters':";
            jsonParameters += _SuperMap2.default.Util.toJSON(qp) + ",'geometry':" + _SuperMap2.default.Util.toJSON(sg) + ",'spatialQueryMode':" + _SuperMap2.default.Util.toJSON(params.spatialQueryMode);
            jsonParameters = "{" + jsonParameters + "}";
            return jsonParameters;
        }
    }]);

    return QueryByGeometryService;
}(_QueryService3.default);

exports.default = QueryByGeometryService;


_SuperMap2.default.QueryByGeometryService = QueryByGeometryService;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _QueryService2 = __webpack_require__(39);

var _QueryService3 = _interopRequireDefault(_QueryService2);

var _QueryBySQLParameters = __webpack_require__(228);

var _QueryBySQLParameters2 = _interopRequireDefault(_QueryBySQLParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryBySQLService
 * @classdesc SQL 查询服务类。在一个或多个指定的图层上查询符合 SQL 条件的空间地物信息。
 * @extends SuperMap.QueryService
 * @example
 * var queryParam = new SuperMap.FilterParameter({
 *     name: "Countries@World.1",
 *     attributeFilter: "Pop_1994>1000000000 and SmArea>900"
 * });
 * var queryBySQLParams = new SuperMap.QueryBySQLParameters({
 *     queryParams: [queryParam]
 * });
 * var myQueryBySQLService = new SuperMap.QueryBySQLService(url, {eventListeners: {
 *     "processCompleted": queryCompleted,
 *     "processFailed": queryError
 *	   }
 * });
 * queryBySQLService.processAsync(queryBySQLParams);
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var QueryBySQLService = function (_QueryService) {
    _inherits(QueryBySQLService, _QueryService);

    /*
     * @function SuperMap.QueryBySQLService.prototype.constructor
     * @descriptionSQL 查询服务类构造函数。
     * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
     * @param options - {Object} 互服务时所需可选参数。如：<br>
     *         eventListeners - {Object} 需要被注册的监听器对象。
     */
    function QueryBySQLService(url, options) {
        _classCallCheck(this, QueryBySQLService);

        var _this = _possibleConstructorReturn(this, (QueryBySQLService.__proto__ || Object.getPrototypeOf(QueryBySQLService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.QueryBySQLService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(QueryBySQLService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryBySQLService.prototype.__proto__ || Object.getPrototypeOf(QueryBySQLService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.QueryBySQLService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         *              在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds等）。
         * @param params - {SuperMap.QueryBySQLParameters}
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var me = this,
                jsonParameters = "",
                qp = null;
            qp = me.getQueryParameters(params);
            jsonParameters += "'queryMode':'SqlQuery','queryParameters':";
            jsonParameters += _SuperMap2.default.Util.toJSON(qp);
            jsonParameters = "{" + jsonParameters + "}";
            return jsonParameters;
        }
    }]);

    return QueryBySQLService;
}(_QueryService3.default);

exports.default = QueryBySQLService;


_SuperMap2.default.QueryBySQLService = QueryBySQLService;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _RouteCalculateMeasureParameters = __webpack_require__(229);

var _RouteCalculateMeasureParameters2 = _interopRequireDefault(_RouteCalculateMeasureParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.RouteCalculateMeasureService
 * @classdesc
 * 该类负责将客户设置的计算指定点的M值参数传递给服务端，并接收服务端返回的
 *      指定点的M值。通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.SpatialAnalystBase
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。</br>
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst
 * @example 实例化该类如下例所示：
 * (start code)
 * var parameters = new SuperMap.RouteCalculateMeasureParameters({
     *     "sourceRoute":{
     *         "type":"LINEM",
     *        "parts":[4],
     *         "points":[
     *             {
     *                 "measure":0,
     *                 "y":-6674.466867067764,
     *                 "x":3817.3527876130133
     *             },
     *             {
     *                 "measure":199.57954019411724,
     *                 "y":-6670.830929417594,
     *                 "x":3617.806369901496
     *             },
     *             {
     *                 "measure":609.3656478634477,
     *                "y":-6877.837541432356,
     *                 "x":3264.1498746678444
     *             },
     *             {
     *                 "measure":936.0174126282958,
     *                 "y":-7038.687780615184,
     *                 "x":2979.846206068903
     *             }
     *         ]
     *     },
     *     "tolerance":1,
     *     "point":{
     *         "x":3330.7754269417,
     *         "y":-6838.8394457216
     *     },
     *     "isIgnoreGap":false
     * });
 *
 * var routeCalculateMeasureService = new SuperMap.RouteCalculateMeasureService(spatialAnalystURL, {
     *     eventListeners:{
     *         processCompleted:calculateCompleted,
     *         processFailed:calculateFailded
     *     }
     * );
     * routeCalculateMeasureService.processAsync(parameters);
     *
     *  //执行
     * function calculateCompleted(){todo}
     * function calculateFailded(){todo}
     * (end)
     *
     */
var RouteCalculateMeasureService = function (_SpatialAnalystBase) {
    _inherits(RouteCalculateMeasureService, _SpatialAnalystBase);

    function RouteCalculateMeasureService(url, options) {
        _classCallCheck(this, RouteCalculateMeasureService);

        var _this = _possibleConstructorReturn(this, (RouteCalculateMeasureService.__proto__ || Object.getPrototypeOf(RouteCalculateMeasureService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.RouteCalculateMeasureService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(RouteCalculateMeasureService, [{
        key: 'destroy',
        value: function destroy() {
            _get(RouteCalculateMeasureService.prototype.__proto__ || Object.getPrototypeOf(RouteCalculateMeasureService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.RouteCalculateMeasureService.prototype.processAsync
         * @description 负责将客户端的基于路由对象计算指定点M值操作的参数传递到服务端。
         * @param params - {SuperMap.RouteCalculateMeasureParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonParameters;

            jsonParameters = me.getJsonParameters(params);

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.RouteCalculateMeasureService.prototype.getJsonParameters
         * @description 将参数转化为 JSON 字符串。
         * @param params - {SuperMap.RouteCalculateMeasureParameters}
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var jsonParameters,
                jsonStr = "geometry/calculatemeasure",
                me = this,
                end;
            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? jsonStr + ".json" : "/" + jsonStr + ".json";
            me.url += "?returnContent=true";
            jsonParameters = _SuperMap2.default.Util.toJSON(params);
            return jsonParameters;
        }
    }]);

    return RouteCalculateMeasureService;
}(_SpatialAnalystBase3.default);

exports.default = RouteCalculateMeasureService;


_SuperMap2.default.RouteCalculateMeasureService = RouteCalculateMeasureService;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _RouteLocatorParameters = __webpack_require__(230);

var _RouteLocatorParameters2 = _interopRequireDefault(_RouteLocatorParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.RouteLocatorService
 * @classdesc 路由对象定位空间对象的服务类。
 * @extends SuperMap.SpatialAnalystBase
 * @param options - {Object} 可选参数。如</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url -{string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @example 实例化该类如下例所示：
 * (start code)
 * var routeLocatorParameters_point = new SuperMap.RouteLocatorParameters({
     *   "sourceRoute":{
     *       "type":"LINEM",
     *       "parts":[4],
     *       "points":[
     *           {
     *               "measure":0,
     *               "y":-6674.466867067764,
     *               "x":3817.3527876130133
     *           },
     *           {
     *               "measure":199.57954019411724,
     *               "y":-6670.830929417594,
     *               "x":3617.806369901496
     *          },
     *           {
     *               "measure":609.3656478634477,
     *               "y":-6877.837541432356,
     *               "x":3264.1498746678444
     *           },
     *           {
     *               "measure":936.0174126282958,
     *               "y":-7038.687780615184,
     *               "x":2979.846206068903
     *           }
     *       ]
     *   },
     *   "type":"POINT",
     *   "measure":10,
     *   "offset":3,
     *   "isIgnoreGap":true
     * });
 * var routeLocatorService = new SuperMap.RouteLocatorService(spatialAnalystURL, {
     *     eventListeners:{
     *         processCompleted:routeLocatorCompleted,
     *         processFailed:routeLocatorFailded
     *     }
     * );
     * routeLocatorService.processAsync(routeLocatorParameters_point);
     *
     *  //执行
     * function routeLocatorCompleted(){todo}
     * function routeLocatorFailded(){todo}
     * (end)
     *
     */
var RouteLocatorService = function (_SpatialAnalystBase) {
    _inherits(RouteLocatorService, _SpatialAnalystBase);

    function RouteLocatorService(url, options) {
        _classCallCheck(this, RouteLocatorService);

        var _this = _possibleConstructorReturn(this, (RouteLocatorService.__proto__ || Object.getPrototypeOf(RouteLocatorService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.RouteLocatorService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(RouteLocatorService, [{
        key: 'destroy',
        value: function destroy() {
            _get(RouteLocatorService.prototype.__proto__ || Object.getPrototypeOf(RouteLocatorService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.RouteLocatorService.prototype.processAsync
         * @description 负责将客户端的基于路由对象计算指定点M值操作的参数传递到服务端。
         * @param params - {SuperMap.RouteLocatorParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonParameters;

            jsonParameters = me.getJsonParameters(params);

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.RouteLocatorService.prototype.processAsync
         * @description 将参数转化为 JSON 字符串。
         * @param params - {SuperMap.RouteLocatorParameters}
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var jsonParameters,
                jsonStr = "geometry/routelocator",
                me = this,
                end;
            end = me.url.substr(me.url.length - 1, 1);

            if (params.dataset) {
                jsonStr = "datasets/" + params.dataset + "/linearreferencing/routelocator";
                params.sourceRoute = null;
            }
            me.url += end === "/" ? jsonStr + ".json" : "/" + jsonStr + ".json";
            me.url += "?returnContent=true";
            jsonParameters = _SuperMap2.default.Util.toJSON(params);
            return jsonParameters;
        }
    }]);

    return RouteLocatorService;
}(_SpatialAnalystBase3.default);

exports.default = RouteLocatorService;


_SuperMap2.default.RouteLocatorService = RouteLocatorService;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _SetLayerInfoParameters = __webpack_require__(232);

var _SetLayerInfoParameters2 = _interopRequireDefault(_SetLayerInfoParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SetLayerInfoService
 * @classdesc 设置图层信息服务类。可以实现临时图层中子图层的修改
 *              该类负责将图层设置参数传递到服务端，并获取服务端返回的结果信息。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 与客户端交互的地图服务地址。请求地图服务,URL 应为：<br>
 *               http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}/tempLayersSet/{tempLayerID}/Rivers@World@@World"；
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var SetLayerInfoService = function (_CommonServiceBase) {
    _inherits(SetLayerInfoService, _CommonServiceBase);

    function SetLayerInfoService(url, options) {
        _classCallCheck(this, SetLayerInfoService);

        var _this = _possibleConstructorReturn(this, (SetLayerInfoService.__proto__ || Object.getPrototypeOf(SetLayerInfoService)).call(this, url, options));

        _this.resourceID = null;
        _this.CLASS_NAME = "SuperMap.SetLayerInfoService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        _this.resourceID = options.resourceID;
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.SetLayerInfoService.prototype.resourceID - {string}
     * @description 图层资源ID，临时图层的资源ID标记。
     */


    _createClass(SetLayerInfoService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SetLayerInfoService.prototype.__proto__ || Object.getPrototypeOf(SetLayerInfoService.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.SetLayerInfoService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {Object} 修改后的图层资源信息。<br>
         *        该参数可以使用获取图层信息服务 <SuperMap.GetLayerInfoService>.result.subLayers.layers[i]返回图层信息，然后对其属性进行修改来获取。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            var me = this;

            if (!params) {
                return;
            }
            me.url += ".json";
            var jsonParamsStr = _SuperMap2.default.Util.toJSON(params);
            me.request({
                method: "PUT",
                data: jsonParamsStr,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return SetLayerInfoService;
}(_CommonServiceBase3.default);

exports.default = SetLayerInfoService;


_SuperMap2.default.SetLayerInfoService = SetLayerInfoService;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _SetLayerStatusParameters = __webpack_require__(233);

var _SetLayerStatusParameters2 = _interopRequireDefault(_SetLayerStatusParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SetLayerStatusService
 * @classdesc  子图层显示控制服务类。该类负责将子图层显示控制参数传递到服务端，并获取服务端返回的图层显示状态。<br>
 *                用户获取服务端返回的各子图层显示状态有两种方式：<br>
 *                一种是通过监听 SetLayerEvent.PROCESS_COMPLETE 事件；<br>
 *                一种是使用 AsyncResponder 类实现异步处理。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 地图服务访问地址。请求地图服务,URL 应为：<br>
 *               http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var SetLayerStatusService = function (_CommonServiceBase) {
    _inherits(SetLayerStatusService, _CommonServiceBase);

    function SetLayerStatusService(url, options) {
        _classCallCheck(this, SetLayerStatusService);

        var _this = _possibleConstructorReturn(this, (SetLayerStatusService.__proto__ || Object.getPrototypeOf(SetLayerStatusService)).call(this, url, options));

        _this.lastparams = null;
        _this.mapUrl = null;
        _this.CLASS_NAME = "SuperMap.SetLayerStatusService";

        var me = _this;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
        me.mapUrl = url;
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(SetLayerStatusService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SetLayerStatusService.prototype.__proto__ || Object.getPrototypeOf(SetLayerStatusService.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.SetLayerStatusService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {Object} 修改后的图层资源信息。该参数可以使用获取图层信息服务 <SuperMap.SetLayerStatusParameters>
         *         返回图层信息，然后对其属性进行修改来获取。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            var subLayers = [],
                me = this,
                method = "POST";
            if (!params) {
                return;
            }

            me.url = me.mapUrl;
            var end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';

            if (params.resourceID == null) {
                me.url += "tempLayersSet";
                me.url += ".json?";

                me.lastparams = params;

                me.request({
                    method: method,
                    scope: me,
                    success: me.createTempLayerComplete,
                    failure: me.serviceProcessFailed
                });
            } else {
                me.url += "tempLayersSet/" + params.resourceID;
                me.url += ".json?";

                me.url += "elementRemain=true&reference=" + params.resourceID + "&holdTime=" + params.holdTime.toString();

                var jsonParameters = '[{';

                jsonParameters += '"type":"UGC",';
                if (params.layerStatusList != null && params.layerStatusList.length > 0) {
                    jsonParameters += '"subLayers":' + params.toJSON();
                }
                jsonParameters += ',"visible":' + true + ',';
                jsonParameters += '"name":"' + this.getMapName(this.mapUrl) + '"';

                jsonParameters += '}]';

                me.request({
                    method: "PUT",
                    data: jsonParameters,
                    scope: me,
                    success: me.serviceProcessCompleted,
                    failure: me.serviceProcessFailed
                });
            }
        }

        /*
         * Method: createTempLayerComplete
         * 设置完成，执行此方法。
         *
         * Parameters:
         * result - {Object} 服务器返回的结果对象，记录设置操作是否成功。
         */

    }, {
        key: 'createTempLayerComplete',
        value: function createTempLayerComplete(result) {
            var me = this;
            result = _SuperMap2.default.Util.transformResult(result);
            if (result.succeed) {
                me.lastparams.resourceID = result.newResourceID;
            }

            me.processAsync(me.lastparams);
        }
    }, {
        key: 'getMapName',
        value: function getMapName(url) {
            var mapUrl = url;
            if (mapUrl.charAt(mapUrl.length - 1) === "/") {
                mapUrl = mapUrl.substr(0, mapUrl.length - 1);
            }
            var index = mapUrl.lastIndexOf("/");
            var mapName = mapUrl.substring(index + 1, mapUrl.length);
            return mapName;
        }

        /*
         * Method: setLayerCompleted
         * 设置完成，执行此方法。
         *
         * Parameters:
         * result - {Object} 服务器返回的结果对象，记录设置操作是否成功。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _SuperMap2.default.Util.transformResult(result);
            if (result != null && me.lastparams != null) {
                result.newResourceID = me.lastparams.resourceID;
            }
            me.events.triggerEvent("processCompleted", { result: result });
        }
    }]);

    return SetLayerStatusService;
}(_CommonServiceBase3.default);

exports.default = SetLayerStatusService;


_SuperMap2.default.SetLayerStatusService = SetLayerStatusService;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _SetLayersInfoParameters = __webpack_require__(234);

var _SetLayersInfoParameters2 = _interopRequireDefault(_SetLayersInfoParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SetLayersInfoService
 * @classdesc  设置图层信息服务类。可以实现创建新的临时图层和对现有临时图层的修改，<br>
 *                当 isTempLayers 为 false的时候执行创建临时图层。当 isTempLayers 为 ture 并且临时图层资源 resourceID 被设置有效时执行对临时图层的编辑。<br>
 *                该类负责将图层设置参数传递到服务端，并获取服务端返回的结果信息。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 与客户端交互的地图服务地址。请求地图服务,URL 应为：<br>
 *              http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         resourceID - {string} 图层资源ID，临时图层的资源ID标记。<br>
 *         isTempLayers - {boolean} 当前url对应的图层是否是临时图层。<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var SetLayersInfoService = function (_CommonServiceBase) {
    _inherits(SetLayersInfoService, _CommonServiceBase);

    /**
     * @member SuperMap.SetLayersInfoService.prototype.resourceID - {string}
     * @description 图层资源ID，临时图层的资源ID标记。
     */
    function SetLayersInfoService(url, options) {
        _classCallCheck(this, SetLayersInfoService);

        var _this = _possibleConstructorReturn(this, (SetLayersInfoService.__proto__ || Object.getPrototypeOf(SetLayersInfoService)).call(this, url, options));

        _this.resourceID = null;
        _this.isTempLayers = false;
        _this.CLASS_NAME = "SuperMap.SetLayersInfoService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        _this.resourceID = options.resourceID;
        _this.isTempLayers = options.isTempLayers;
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @function SuperMap.SetLayersInfoService.prototype.isTempLayers -{boolean}
     * @description 当前url对应的图层是否是临时图层。
     */


    _createClass(SetLayersInfoService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SetLayersInfoService.prototype.__proto__ || Object.getPrototypeOf(SetLayersInfoService.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.SetLayersInfoService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param  params - {Object} 修改后的图层资源信息。该参数可以使用获取图层信息服务<SuperMap.GetLayerInfoService>.result.subLayers.layers
         *            返回图层信息，然后对其属性进行修改来获取。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            var jsonParams,
                subLayers = [],
                me = this,
                method = "",
                end;
            if (!params) {
                return;
            }
            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';
            //创建临时图层和设置修改临时图层信息对应不同的资源URL
            if (me.isTempLayers) {
                me.url += "tempLayersSet/" + me.resourceID;
                method = "PUT";
            } else {
                me.url += "tempLayersSet";
                method = "POST";
            }
            me.url += ".json?";
            var layers = params.subLayers.layers,
                len = layers.length;
            for (var i in layers) {
                if (layers[i].ugcLayerType === "GRID") {
                    var colorDictionary = {};
                    var colorDics = layers[i].colorDictionarys;
                    for (var j in colorDics) {
                        var key = colorDics[j].elevation;
                        colorDictionary[key] = colorDics[j].color;
                    }
                }
                layers[i].colorDictionary = colorDictionary;
                delete layers[i].colorDictionarys;
            }

            for (var i = 0; i < len; i++) {
                if (layers[i].toJsonObject) {
                    //将图层信息转换成服务端能识别的简单json对象
                    subLayers.push(layers[i].toJsonObject());
                } else {
                    subLayers.push(layers[i]);
                }
            }
            jsonParams = _SuperMap2.default.Util.extend(jsonParams, params);
            jsonParams.subLayers = { "layers": subLayers };
            jsonParams.object = null;
            var jsonParamsStr = _SuperMap2.default.Util.toJSON([jsonParams]);
            me.request({
                method: method,
                data: jsonParamsStr,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return SetLayersInfoService;
}(_CommonServiceBase3.default);

exports.default = SetLayersInfoService;


_SuperMap2.default.SetLayersInfoService = SetLayersInfoService;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ProcessingServiceBase = __webpack_require__(29);

var _ProcessingServiceBase2 = _interopRequireDefault(_ProcessingServiceBase);

var _SingleObjectQueryJobsParameter = __webpack_require__(235);

var _SingleObjectQueryJobsParameter2 = _interopRequireDefault(_SingleObjectQueryJobsParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SingleObjectQueryJobsService
 * @classdesc 单对象查询分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 单对象空间查询分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。
 */
var SingleObjectQueryJobsService = function (_ProcessingServiceBas) {
    _inherits(SingleObjectQueryJobsService, _ProcessingServiceBas);

    function SingleObjectQueryJobsService(url, options) {
        _classCallCheck(this, SingleObjectQueryJobsService);

        var _this = _possibleConstructorReturn(this, (SingleObjectQueryJobsService.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.SingleObjectQueryJobsService";

        _this.url += "/spatialanalyst/query";
        return _this;
    }

    /**
     *@inheritDoc
     */


    _createClass(SingleObjectQueryJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SingleObjectQueryJobsService.prototype.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.SingleObjectQueryJobsService.protitype.getQueryJobs
         * @description 获取单对象空间查询分析所有任务
         */

    }, {
        key: 'getQueryJobs',
        value: function getQueryJobs() {
            _get(SingleObjectQueryJobsService.prototype.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.protitype.getQueryJob
         * @description 获取指定id的单对象空间查询分析服务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getQueryJob',
        value: function getQueryJob(id) {
            _get(SingleObjectQueryJobsService.prototype.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.SingleObjectQueryJobsService.protitype.addQueryJob
         * @description 新建单对象空间查询分析服务
         * @param params - {SuperMap.SingleObjectQueryJobsParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addQueryJob',
        value: function addQueryJob(params, seconds) {
            _get(SingleObjectQueryJobsService.prototype.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService.prototype), 'addJob', this).call(this, this.url, params, _SingleObjectQueryJobsParameter2.default, seconds);
        }
    }]);

    return SingleObjectQueryJobsService;
}(_ProcessingServiceBase2.default);

exports.default = SingleObjectQueryJobsService;


_SuperMap2.default.SingleObjectQueryJobsService = SingleObjectQueryJobsService;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _StopQueryParameters = __webpack_require__(236);

var _StopQueryParameters2 = _interopRequireDefault(_StopQueryParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.StopQueryService
 * @classdesc
 * 站点查询服务类。
 * 返回结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 与客户端交互的站点查询服务地址。
 * 例如:</br>"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 *
 * @example 例如：
 * (start code)
 * var myService = new SuperMap.StopQueryService(url, {eventListeners: {
     *     "processCompleted": StopQueryCompleted,
     *     "processFailed": StopQueryError
     *     }
     * };
 * (end)
 *
 *
 */

var StopQueryService = function (_CommonServiceBase) {
    _inherits(StopQueryService, _CommonServiceBase);

    function StopQueryService(url, options) {
        _classCallCheck(this, StopQueryService);

        var _this = _possibleConstructorReturn(this, (StopQueryService.__proto__ || Object.getPrototypeOf(StopQueryService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.StopQueryService";

        options = options || {};
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     *@inheritDoc
     */


    _createClass(StopQueryService, [{
        key: 'destroy',
        value: function destroy() {
            _get(StopQueryService.prototype.__proto__ || Object.getPrototypeOf(StopQueryService.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.StopQueryService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {SuperMap.StopQueryParameters} 交通换乘参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                end;

            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';
            me.url += "stops/keyword/" + params.keyWord;
            me.url += ".json?";

            me.request({
                method: "GET",
                params: { returnPosition: params.returnPosition },
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return StopQueryService;
}(_CommonServiceBase3.default);

exports.default = StopQueryService;


_SuperMap2.default.StopQueryService = StopQueryService;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ProcessingServiceBase = __webpack_require__(29);

var _ProcessingServiceBase2 = _interopRequireDefault(_ProcessingServiceBase);

var _SummaryMeshJobParameter = __webpack_require__(237);

var _SummaryMeshJobParameter2 = _interopRequireDefault(_SummaryMeshJobParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SummaryMeshJobsService
 * @classdesc 点聚合分析任务类。
 * @param url -{string} 点聚合分析任务地址。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        events - {SuperMap.Events} 处理所有事件的对象。<br>
 *        eventListeners - {Object} 听器对象。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        index - {number}服务访问地址在数组中的位置。<br>
 *        length - {number}服务访问地址数组长度。
 */
var SummaryMeshJobsService = function (_ProcessingServiceBas) {
    _inherits(SummaryMeshJobsService, _ProcessingServiceBas);

    function SummaryMeshJobsService(url, options) {
        _classCallCheck(this, SummaryMeshJobsService);

        var _this = _possibleConstructorReturn(this, (SummaryMeshJobsService.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.SummaryMeshJobsService";

        _this.url += "/spatialanalyst/aggregatepoints";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(SummaryMeshJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SummaryMeshJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.SummaryMeshJobsService.prototype.getSummaryMeshJobs
         * @description 获取点聚合分析任务
         */

    }, {
        key: 'getSummaryMeshJobs',
        value: function getSummaryMeshJobs() {
            _get(SummaryMeshJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.SummaryMeshJobsService.prototype.getSummaryMeshJob
         * @description 获取指定ip的点聚合分析任务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getSummaryMeshJob',
        value: function getSummaryMeshJob(id) {
            _get(SummaryMeshJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.SummaryMeshJobsService.prototype.addSummaryMeshJob
         * @description 新建点聚合分析服务
         * @param params - {SuperMap.SummaryMeshJobParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addSummaryMeshJob',
        value: function addSummaryMeshJob(params, seconds) {
            _get(SummaryMeshJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService.prototype), 'addJob', this).call(this, this.url, params, _SummaryMeshJobParameter2.default, seconds);
        }
    }]);

    return SummaryMeshJobsService;
}(_ProcessingServiceBase2.default);

exports.default = SummaryMeshJobsService;


_SuperMap2.default.SummaryMeshJobsService = SummaryMeshJobsService;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ProcessingServiceBase = __webpack_require__(29);

var _ProcessingServiceBase2 = _interopRequireDefault(_ProcessingServiceBase);

var _SummaryRegionJobParameter = __webpack_require__(238);

var _SummaryRegionJobParameter2 = _interopRequireDefault(_SummaryRegionJobParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SummaryRegionJobsService
 * @classdesc 区域汇总分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 区域汇总分析服务地址。
 * @param options - {Object} 区域汇总分析服务可选参数。
 */
var SummaryRegionJobsService = function (_ProcessingServiceBas) {
    _inherits(SummaryRegionJobsService, _ProcessingServiceBas);

    function SummaryRegionJobsService(url, options) {
        _classCallCheck(this, SummaryRegionJobsService);

        var _this = _possibleConstructorReturn(this, (SummaryRegionJobsService.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.SummaryRegionJobsService";

        _this.url += "/spatialanalyst/summaryregion";
        return _this;
    }

    /**
     *@inheritDoc
     */


    _createClass(SummaryRegionJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SummaryRegionJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.SummaryRegionJobsService.prototype.getSummaryRegionJobs
         * @description 获取区域汇总分析任务集合。
         */

    }, {
        key: 'getSummaryRegionJobs',
        value: function getSummaryRegionJobs() {
            _get(SummaryRegionJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.SummaryRegionJobsService.prototype.getSummaryRegionJob
         * @description 获取指定id的区域汇总分析任务。
         * @param id -{string} 要获取区域汇总分析任务的id
         */

    }, {
        key: 'getSummaryRegionJob',
        value: function getSummaryRegionJob(id) {
            _get(SummaryRegionJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.SummaryRegionJobsService.prototype.addSummaryRegionJob
         * @description 新建区域汇总任务。
         * @param params - {SuperMap.SummaryRegionJobParameter} 创建一个区域汇总任务的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addSummaryRegionJob',
        value: function addSummaryRegionJob(params, seconds) {
            _get(SummaryRegionJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService.prototype), 'addJob', this).call(this, this.url, params, _SummaryRegionJobParameter2.default, seconds);
        }
    }]);

    return SummaryRegionJobsService;
}(_ProcessingServiceBase2.default);

exports.default = SummaryRegionJobsService;


_SuperMap2.default.SummaryRegionJobsService = SummaryRegionJobsService;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _DatasetSurfaceAnalystParameters = __webpack_require__(176);

var _DatasetSurfaceAnalystParameters2 = _interopRequireDefault(_DatasetSurfaceAnalystParameters);

var _GeometrySurfaceAnalystParameters = __webpack_require__(201);

var _GeometrySurfaceAnalystParameters2 = _interopRequireDefault(_GeometrySurfaceAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SurfaceAnalystService
 * @classdesc
 * 表面分析服务类。
 * 该类负责将客户设置的表面分析服务参数传递给服务端，并接收服务端返回的表面分析服务分析结果数据。
 * 表面分析结果通过该类支持的事件的监听函数参数获取
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。s
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var mySurfaceAnalystService = new SuperMap.SurfaceAnalystService(url, {
     *      eventListeners: {
     *	       "processCompleted": surfaceAnalysCompleted,
     *		   "processFailed": surfaceAnalysFailed
     *		   }
     * });
 * (end)
 *
 */
var SurfaceAnalystService = function (_SpatialAnalystBase) {
    _inherits(SurfaceAnalystService, _SpatialAnalystBase);

    function SurfaceAnalystService(url, options) {
        _classCallCheck(this, SurfaceAnalystService);

        var _this = _possibleConstructorReturn(this, (SurfaceAnalystService.__proto__ || Object.getPrototypeOf(SurfaceAnalystService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.SurfaceAnalystService";
        return _this;
    }

    /**
     * @function SuperMap.SurfaceAnalystService.prototype.destroy
     * @description 释放资源,将引用的资源属性置空。
     */


    _createClass(SurfaceAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SurfaceAnalystService.prototype.__proto__ || Object.getPrototypeOf(SurfaceAnalystService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.SurfaceAnalystService.prototype.processAsync
         * @description 负责将客户端的表面分析服务参数传递到服务端。
         * @param params - {SuperMap.SurfaceAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonParameters;
            jsonParameters = me.getJsonParameters(params);
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.SurfaceAnalystService.prototype.getJsonParameters
         * @description 将参数转化为 JSON 字符串。
         * @param params - {SuperMap.SurfaceAnalystParameters}
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var jsonParameters = "";
            var parameterObject = {};
            var me = this,
                end;
            if (params instanceof _DatasetSurfaceAnalystParameters2.default) {
                var end = me.url.substr(me.url.length - 1, 1);
                me.url += end === "/" ? "datasets/" + params.dataset + "/" + params.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true" : "/datasets/" + params.dataset + "/" + params.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true";
                _DatasetSurfaceAnalystParameters2.default.toObject(params, parameterObject);
                jsonParameters = _SuperMap2.default.Util.toJSON(parameterObject);
            } else if (params instanceof _GeometrySurfaceAnalystParameters2.default) {
                end = me.url.substr(me.url.length - 1, 1);
                me.url += end === "/" ? "geometry/" + params.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true" : "/geometry/" + params.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true";
                jsonParameters = _SuperMap2.default.Util.toJSON(params);
            } else {
                return;
            }

            return jsonParameters;
        }
    }]);

    return SurfaceAnalystService;
}(_SpatialAnalystBase3.default);

exports.default = SurfaceAnalystService;


_SuperMap2.default.SurfaceAnalystService = SurfaceAnalystService;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _TerrainCurvatureCalculationParameters = __webpack_require__(241);

var _TerrainCurvatureCalculationParameters2 = _interopRequireDefault(_TerrainCurvatureCalculationParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TerrainCurvatureCalculationService
 * @classdesc 地形曲率计算服务类。
 * @extends SuperMap.SpatialAnalystBase
 * @param options - {Object} 可选参数。如</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @example 例如：
 * (start code)
 * var myTerrainCurvatureCalculationService = new SuperMap.TerrainCurvatureCalculationService(url);
 * myTerrainCurvatureCalculationService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 *
 */
var TerrainCurvatureCalculationService = function (_SpatialAnalystBase) {
    _inherits(TerrainCurvatureCalculationService, _SpatialAnalystBase);

    function TerrainCurvatureCalculationService(url, options) {
        _classCallCheck(this, TerrainCurvatureCalculationService);

        var _this = _possibleConstructorReturn(this, (TerrainCurvatureCalculationService.__proto__ || Object.getPrototypeOf(TerrainCurvatureCalculationService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.TerrainCurvatureCalculationService";
        return _this;
    }

    /**
     *@inheritDoc
     */


    _createClass(TerrainCurvatureCalculationService, [{
        key: 'destroy',
        value: function destroy() {
            _get(TerrainCurvatureCalculationService.prototype.__proto__ || Object.getPrototypeOf(TerrainCurvatureCalculationService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.TerrainCurvatureCalculationService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {SuperMap.TerrainCurvatureCalculationParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {} else {
                me.url += "/";
            }

            var parameterObject = {};

            if (parameter instanceof _TerrainCurvatureCalculationParameters2.default) {
                me.url += 'datasets/' + parameter.dataset + '/terraincalculation/curvature';
            }

            _TerrainCurvatureCalculationParameters2.default.toObject(parameter, parameterObject);
            var jsonParameters = _SuperMap2.default.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return TerrainCurvatureCalculationService;
}(_SpatialAnalystBase3.default);

exports.default = TerrainCurvatureCalculationService;


_SuperMap2.default.TerrainCurvatureCalculationService = TerrainCurvatureCalculationService;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _ThemeParameters = __webpack_require__(257);

var _ThemeParameters2 = _interopRequireDefault(_ThemeParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeService
 * @classdesc 专题图服务类。
 * @extends SuperMap.CommonServiceBase
 * @example
 * var myThemeService = new SuperMap.ThemeService(url, {
 *     eventListeners: {
 *           "processCompleted": themeCompleted,
 *           "processFailed": themeFailed
 *           }
 * });
 * @param url - {string} 服务的访问地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var ThemeService = function (_CommonServiceBase) {
    _inherits(ThemeService, _CommonServiceBase);

    function ThemeService(url, options) {
        _classCallCheck(this, ThemeService);

        var _this = _possibleConstructorReturn(this, (ThemeService.__proto__ || Object.getPrototypeOf(ThemeService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.ThemeService";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        var end,
            me = _this;
        end = me.url.substr(me.url.length - 1, 1);
        me.url += end === "/" ? "tempLayersSet.json?" : "/tempLayersSet.json?";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(ThemeService, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeService.prototype.__proto__ || Object.getPrototypeOf(ThemeService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.ThemeService.prototype.processAsync
         * @description 负责将客户端的专题图参数传递到服务端。
         * @param params - {SuperMap.ThemeParameters} 专题图参数类。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonParameters = null;
            jsonParameters = me.getJsonParameters(params);
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.ThemeService.prototype.getJsonParameters
         * @description 将专题图参数参数转化为 JSON 字符串。
         * @param params - {SuperMap.ThemeParameters} 专题图参数类。
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(parameter) {
            var jsonParameters = "",
                themeType = "",
                themeObj = null,
                filters = null,
                orderBys = null,
                fieldValuesDisplayFilter;
            jsonParameters += "[{'type': 'UGC','subLayers': {'layers': [";
            for (var themeID in parameter.themes) {
                themeObj = parameter.themes[themeID];
                var jsonTheme = _SuperMap2.default.Util.toJSON(themeObj);
                jsonTheme = jsonTheme.slice(0, -1);

                jsonParameters += "{'theme': " + jsonTheme + "},'type': 'UGC','ugcLayerType': 'THEME',";
                filters = parameter.displayFilters;
                if (filters && filters.length > 0) {
                    if (filters.length === 1) {
                        jsonParameters += "'displayFilter':\"" + filters[0] + "\",";
                    } else {
                        jsonParameters += "'displayFilter':\"" + filters[themeID] + "\",";
                    }
                }
                orderBys = parameter.displayOrderBy;
                if (orderBys && orderBys.length > 0) {
                    if (orderBys.length === 1) {
                        jsonParameters += "'displayOrderBy':'" + orderBys[0] + "',";
                    } else {
                        jsonParameters += "'displayOrderBy':'" + orderBys[themeID] + "',";
                    }
                }

                fieldValuesDisplayFilter = parameter.fieldValuesDisplayFilter;
                if (fieldValuesDisplayFilter) {
                    jsonParameters += "'fieldValuesDisplayFilter':" + _SuperMap2.default.Util.toJSON(fieldValuesDisplayFilter) + ",";
                }

                if (parameter.joinItems && parameter.joinItems.length > 0 && parameter.joinItems[themeID]) {
                    jsonParameters += "'joinItems':[" + _SuperMap2.default.Util.toJSON(parameter.joinItems[themeID]) + "],";
                }
                if (parameter.datasetNames && parameter.dataSourceNames) {
                    var datasetID = parameter.datasetNames[themeID] ? themeID : parameter.datasetNames.length - 1;
                    var dataSourceID = parameter.dataSourceNames[themeID] ? themeID : parameter.dataSourceNames.length - 1;
                    jsonParameters += "'datasetInfo': {'name': '" + parameter.datasetNames[datasetID] + "','dataSourceName': '" + parameter.dataSourceNames[dataSourceID] + "'}},";
                } else {
                    jsonParameters += "},";
                }
            }
            //去除多余的逗号
            if (parameter.themes && parameter.themes.length > 0) {
                jsonParameters = jsonParameters.substring(0, jsonParameters.length - 1);
            }
            jsonParameters += "]},";
            var urlArray = this.url.split("/");
            var jsonMapName = urlArray[urlArray.length - 2];

            jsonParameters += "'name': '" + jsonMapName + "'}]";
            return jsonParameters;
        }
    }]);

    return ThemeService;
}(_CommonServiceBase3.default);

exports.default = ThemeService;


_SuperMap2.default.ThemeService = ThemeService;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SpatialAnalystBase2 = __webpack_require__(5);

var _SpatialAnalystBase3 = _interopRequireDefault(_SpatialAnalystBase2);

var _DatasetThiessenAnalystParameters = __webpack_require__(177);

var _DatasetThiessenAnalystParameters2 = _interopRequireDefault(_DatasetThiessenAnalystParameters);

var _GeometryThiessenAnalystParameters = __webpack_require__(202);

var _GeometryThiessenAnalystParameters2 = _interopRequireDefault(_GeometryThiessenAnalystParameters);

var _GeoJSON = __webpack_require__(6);

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThiessenAnalystService
 * @classdesc
 * 泰森多边形分析服务类
 * 该类负责将客户设置的泰森多边形分析参数传递给服务端，并接收服务端返回的分析结果数据。
 * 泰森多边形分析结果通过该类支持的事件的监听函数参数获取
 * 泰森多边形分析的参数支持两种，当参数为 {SuperMap.DatasetThiessenAnalystParameters} 类型
 * 时，执行数据集泰森多边形分析，当参数为 {SuperMap.GeometryThiessenAnalystParameters} 类型时，
 * 执行几何对象泰森多边形分析。
 * @param options - {Object} 参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url - {string} 服务的访问地址。
 * 如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 *
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myThiessenAnalystService = new SuperMap.ThiessenAnalystService(url, {
     *     eventListeners: {
     *           "processCompleted": bufferCompleted,
     *           "processFailed": bufferFailed
     *           }
     *    });
 * (end)
 *
 */
var ThiessenAnalystService = function (_SpatialAnalystBase) {
    _inherits(ThiessenAnalystService, _SpatialAnalystBase);

    function ThiessenAnalystService(url, options) {
        _classCallCheck(this, ThiessenAnalystService);

        var _this = _possibleConstructorReturn(this, (ThiessenAnalystService.__proto__ || Object.getPrototypeOf(ThiessenAnalystService)).call(this, url, options));

        _this.mode = null;
        _this.CLASS_NAME = "SuperMap.ThiessenAnalystService";

        var me = _this;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */

    /**
     * @member SuperMap.ThiessenAnalystService.prototype.mode -{string}
     * @description 缓冲区分析类型
     */


    _createClass(ThiessenAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThiessenAnalystService.prototype.__proto__ || Object.getPrototypeOf(ThiessenAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
        }

        /**
         * @function SuperMap.ThiessenAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {SuperMap.DatasetThiessenAnalystParameters}|{GeometryThiessenAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var parameterObject = {};
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {} else {
                me.url += "/";
            }

            if (parameter instanceof _DatasetThiessenAnalystParameters2.default) {
                me.mode = "datasets";
                me.url += 'datasets/' + parameter.dataset + '/thiessenpolygon';
                _DatasetThiessenAnalystParameters2.default.toObject(parameter, parameterObject);
            } else if (parameter instanceof _GeometryThiessenAnalystParameters2.default) {
                me.mode = "geometry";
                me.url += 'geometry/thiessenpolygon';
                _GeometryThiessenAnalystParameters2.default.toObject(parameter, parameterObject);
            }

            var jsonParameters = _SuperMap2.default.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.ThiessenAnalystService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result) {
                return result;
            }

            result = _get(ThiessenAnalystService.prototype.__proto__ || Object.getPrototypeOf(ThiessenAnalystService.prototype), 'toGeoJSONResult', this).call(this, result);
            if (result.regions) {
                var geoJSONFormat = new _GeoJSON2.default();
                result.regions = JSON.parse(geoJSONFormat.write(result.regions));
            }
            return result;
        }
    }]);

    return ThiessenAnalystService;
}(_SpatialAnalystBase3.default);

exports.default = ThiessenAnalystService;


_SuperMap2.default.ThiessenAnalystService = ThiessenAnalystService;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TilesetsService
 * @classdesc 切片列表信息查询服务类;即查询切片地图服务的切片列表，返回切片集名称、地图切片元数据信息、切片版本集信息
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 地图服务地址。URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{服务名}/rest/maps/map；<br>
 *                       例如: "http://localhost:8090/iserver/services/test/rest/maps/tianlocal";
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var TilesetsService = function (_CommonServiceBase) {
    _inherits(TilesetsService, _CommonServiceBase);

    function TilesetsService(url, options) {
        _classCallCheck(this, TilesetsService);

        var _this = _possibleConstructorReturn(this, (TilesetsService.__proto__ || Object.getPrototypeOf(TilesetsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.TilesetsService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(TilesetsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(TilesetsService.prototype.__proto__ || Object.getPrototypeOf(TilesetsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.TilesetsService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            if (!this.url) {
                return;
            }
            var me = this;
            var end = me.url.substr(me.url.length - 1, 1);

            me.url = me.url + (end === "/" ? "tilesets" : "/tilesets") + ".json?";

            me.request({
                method: "GET",
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return TilesetsService;
}(_CommonServiceBase3.default);

exports.default = TilesetsService;


_SuperMap2.default.TilesetsService = TilesetsService;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _TransferPathParameters = __webpack_require__(261);

var _TransferPathParameters2 = _interopRequireDefault(_TransferPathParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TransferPathService
 * @classdesc 交通换乘线路查询服务类，根据交通换乘分析结果(TransferSolutionResult)，获取某一条乘车路线的详细信息。
 *            返回结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.CommonServiceBase
 * @example 例如：
 * var myService = new SuperMap.TransferPathService(url, {eventListeners: {
 *     "processCompleted": TrafficTransferCompleted,
 *     "processFailed": TrafficTransferError
 *     }
 * };
 * @param url - {string} 与客户端交互的交通换乘线路查询服务地址。
 * 例如:</br>"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var TransferPathService = function (_CommonServiceBase) {
    _inherits(TransferPathService, _CommonServiceBase);

    function TransferPathService(url, options) {
        _classCallCheck(this, TransferPathService);

        var _this = _possibleConstructorReturn(this, (TransferPathService.__proto__ || Object.getPrototypeOf(TransferPathService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.TransferPathService";
        return _this;
    }
    /**
     * @inheritDoc
     */


    _createClass(TransferPathService, [{
        key: 'destroy',
        value: function destroy() {
            _get(TransferPathService.prototype.__proto__ || Object.getPrototypeOf(TransferPathService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.TransferPathService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {SuperMap.TransferPathParameters} 交通换乘参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                method = "GET",
                jsonParameters,
                end;

            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';
            me.url += "path.json?";

            jsonParameters = {
                points: _SuperMap2.default.Util.toJSON(params.points),
                transferLines: _SuperMap2.default.Util.toJSON(params['transferLines'])
            };

            me.request({
                method: method,
                params: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return TransferPathService;
}(_CommonServiceBase3.default);

exports.default = TransferPathService;


_SuperMap2.default.TransferPathService = TransferPathService;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _CommonServiceBase2 = __webpack_require__(2);

var _CommonServiceBase3 = _interopRequireDefault(_CommonServiceBase2);

var _TransferSolutionParameters = __webpack_require__(262);

var _TransferSolutionParameters2 = _interopRequireDefault(_TransferSolutionParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TransferSolutionService
 * @classdesc
 * 交通换乘方案查询服务类。
 * 返回结果通过该类支持的事件的监听函数参数获取。
 * @param url - {string} 与客户端交互的交通换乘方案查询服务地址。
 * 例如:</br>"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
 * @param options - {Object} 参数。如</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。</br>
 * @extends SuperMap.CommonServiceBase
 * @example 例如：
 * (start code)
 * var myService = new SuperMap.TransferSolutionService(url, {eventListeners: {
     *     "processCompleted": trafficTransferCompleted,
     *     "processFailed": trafficTransferError
     *     }
     * };
 * (end)
 *
 */
var TransferSolutionService = function (_CommonServiceBase) {
    _inherits(TransferSolutionService, _CommonServiceBase);

    function TransferSolutionService(url, options) {
        _classCallCheck(this, TransferSolutionService);

        var _this = _possibleConstructorReturn(this, (TransferSolutionService.__proto__ || Object.getPrototypeOf(TransferSolutionService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.TransferSolutionService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(TransferSolutionService, [{
        key: 'destroy',
        value: function destroy() {
            _get(TransferSolutionService.prototype.__proto__ || Object.getPrototypeOf(TransferSolutionService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.TransferSolutionService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {SuperMap.TransferSolutionParameters} 交通换乘参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                method = "GET",
                jsonParameters,
                end;

            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';
            me.url += "solutions.json?";

            jsonParameters = {
                points: _SuperMap2.default.Util.toJSON(params.points),
                walkingRatio: params['walkingRatio'],
                transferTactic: params['transferTactic'],
                solutionCount: params['solutionCount'],
                transferPreference: params["transferPreference"]
            };
            if (params.evadeLines) jsonParameters["evadeLines"] = _SuperMap2.default.Util.toJSON(params.evadeLines);
            if (params.evadeStops) jsonParameters["evadeStops"] = _SuperMap2.default.Util.toJSON(params.evadeStops);
            if (params.priorLines) jsonParameters["priorLines"] = _SuperMap2.default.Util.toJSON(params.priorLines);
            if (params.priorStops) jsonParameters["priorStops"] = _SuperMap2.default.Util.toJSON(params.priorStops);
            if (params.travelTime) jsonParameters["travelTime"] = params.travelTime;

            me.request({
                method: method,
                params: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return TransferSolutionService;
}(_CommonServiceBase3.default);

exports.default = TransferSolutionService;


_SuperMap2.default.TransferSolutionService = TransferSolutionService;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _UpdateEdgeWeightParameters = __webpack_require__(266);

var _UpdateEdgeWeightParameters2 = _interopRequireDefault(_UpdateEdgeWeightParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.UpdateEdgeWeightService
 * @classdesc 更新边的边的耗费权重服务
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 *(start code)
 * var updateEdgeWeightService = new SuperMap.UpdateEdgeWeightService(url, {
 *     eventListeners: {
 *         "processCompleted": UpdateEdgeWeightCompleted,      //参数为SuperMap.UpdateEdgeWeightEventArgs
 *		   "processFailed": UpdateEdgeWeightError             //参数为SuperMap.ServiceFailedEventArgs
 *		   }
 * });
 * (end)
 * @param url - {string} 服务的访问地址。 如:<br>
 *                       http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var UpdateEdgeWeightService = function (_NetworkAnalystServic) {
    _inherits(UpdateEdgeWeightService, _NetworkAnalystServic);

    function UpdateEdgeWeightService(url, options) {
        _classCallCheck(this, UpdateEdgeWeightService);

        var _this = _possibleConstructorReturn(this, (UpdateEdgeWeightService.__proto__ || Object.getPrototypeOf(UpdateEdgeWeightService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.UpdateEdgeWeightService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(UpdateEdgeWeightService, [{
        key: 'destroy',
        value: function destroy() {
            _get(UpdateEdgeWeightService.prototype.__proto__ || Object.getPrototypeOf(UpdateEdgeWeightService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.UpdateEdgeWeightService.prototype.processAsync
         * @description 开始异步执行边的边的耗费权重的更新
         * @param params - {SuperMap.UpdateEdgeWeightParameters} 边的耗费权重更新服务参数类
         * @example
         * (code)
         *  var updateEdgeWeightParam=new SuperMapUpdateEdgeWeightParameters({
         *          edgeId:"20",
         *          fromNodeId:"26",
         *          toNodeId:"109",
         *          weightField:"time",
         *          edgeWeight:"25"
         *      });
         *  updateEdgeWeightService.processAsync(updateEdgeWeightParam);
         * (end)
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }

            var me = this,
                end = me.url.substr(me.url.length - 1, 1);
            var paramStr = me.parse(params);
            if (end === "/") {
                me.url.splice(me.url.length - 1, 1);
            }
            me.url = me.url + paramStr + ".json?";
            var data = params.edgeWeight ? params.edgeWeight : null;
            me.request({
                method: "PUT",
                scope: me,
                data: data,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /*
         * Method: parse
         * 将更新服务参数解析为用‘/’做分隔的字符串
         */

    }, {
        key: 'parse',
        value: function parse(params) {
            if (!params) {
                return;
            }
            var paramStr = "";
            for (var attr in params) {
                if (params[attr] === "" || params[attr] === "edgeWeight") continue;
                switch (attr) {
                    case "edgeId":
                        paramStr += "/edgeweight/" + params[attr];
                        break;
                    case "fromNodeId":
                        paramStr += "/fromnode/" + params[attr];
                        break;
                    case "toNodeId":
                        paramStr += "/tonode/" + params[attr];
                        break;
                    case "weightField":
                        paramStr += "/weightfield/" + params[attr];
                        break;
                    default:
                        break;
                }
            }
            return paramStr;
        }
    }]);

    return UpdateEdgeWeightService;
}(_NetworkAnalystServiceBase2.default);

exports.default = UpdateEdgeWeightService;


_SuperMap2.default.UpdateEdgeWeightService = UpdateEdgeWeightService;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _NetworkAnalystServiceBase = __webpack_require__(9);

var _NetworkAnalystServiceBase2 = _interopRequireDefault(_NetworkAnalystServiceBase);

var _UpdateTurnNodeWeightParameters = __webpack_require__(267);

var _UpdateTurnNodeWeightParameters2 = _interopRequireDefault(_UpdateTurnNodeWeightParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.UpdateTurnNodeWeightService
 * @classdesc 转向耗费权重更新服务类
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var UpdateTurnNodeWeightService = new SuperMap.UpdateTurnNodeWeightService(url, {
 *     eventListeners: {
 *         "processCompleted": UpdateTurnNodeWeightCompleted,    //参数为SuperMap.UpdateTurnNodeWeightEventArgs
 *		   "processFailed": UpdateTurnNodeWeightError          //参数为SuperMap.ServiceFailedEventArgs
 *		   }
 * });
 * @param url - {string} 服务的访问地址。如:<br>
 *                       http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var UpdateTurnNodeWeightService = function (_NetworkAnalystServic) {
    _inherits(UpdateTurnNodeWeightService, _NetworkAnalystServic);

    function UpdateTurnNodeWeightService(url, options) {
        _classCallCheck(this, UpdateTurnNodeWeightService);

        var _this = _possibleConstructorReturn(this, (UpdateTurnNodeWeightService.__proto__ || Object.getPrototypeOf(UpdateTurnNodeWeightService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.UpdateTurnNodeWeightService";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(UpdateTurnNodeWeightService, [{
        key: 'destroy',
        value: function destroy() {
            _get(UpdateTurnNodeWeightService.prototype.__proto__ || Object.getPrototypeOf(UpdateTurnNodeWeightService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.UpdateTurnNodeWeightService.prototype.processAsync
         * @description 开始异步执行转向耗费权重的更新
         * @param params - {SuperMap.UpdateTurnNodeWeightParameters} 转向耗费权重更新服务参数类
         * @example
         * (code)
         *  var updateTurnNodeWeightParam=new SuperMap.UpdateTurnNodeWeightParameters({
         *           nodeId:"106",
         *           fromEdgeId:"6508",
         *           toEdgeId:"6504",
         *           weightField:"TurnCost",
         *           turnNodeWeight:"50"
         *       });
         *  updateTurnNodeWeightService.processAsync(updateTurnNodeWeightParam);
         * (end)
         **/

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }

            var me = this,
                end = me.url.substr(me.url.length - 1, 1);
            var paramStr = me.parse(params);
            if (end === "/") {
                me.url.splice(me.url.length - 1, 1);
            }
            me.url = me.url + paramStr + ".json?";
            var data = params.turnNodeWeight ? params.turnNodeWeight : null;
            me.request({
                method: "PUT",
                scope: me,
                data: data,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /*
         * Method: parse
         * 将更新服务参数解析为用‘/’做分隔的字符串
         * */

    }, {
        key: 'parse',
        value: function parse(params) {
            if (!params) {
                return;
            }
            var paramStr = "";
            for (var attr in params) {
                if (params[attr] === "" || params[attr] === "turnNodeWeight") continue;
                switch (attr) {
                    case "nodeId":
                        paramStr += "/turnnodeweight/" + params[attr];
                        break;
                    case "fromEdgeId":
                        paramStr += "/fromedge/" + params[attr];
                        break;
                    case "toEdgeId":
                        paramStr += "/toedge/" + params[attr];
                        break;
                    case "weightField":
                        paramStr += "/weightfield/" + params[attr];
                        break;
                    default:
                        break;
                }
            }
            return paramStr;
        }
    }]);

    return UpdateTurnNodeWeightService;
}(_NetworkAnalystServiceBase2.default);

exports.default = UpdateTurnNodeWeightService;


_SuperMap2.default.UpdateTurnNodeWeightService = UpdateTurnNodeWeightService;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ProcessingServiceBase = __webpack_require__(29);

var _ProcessingServiceBase2 = _interopRequireDefault(_ProcessingServiceBase);

var _VectorClipJobsParameter = __webpack_require__(269);

var _VectorClipJobsParameter2 = _interopRequireDefault(_VectorClipJobsParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.VectorClipJobsService
 * @classdesc 矢量裁剪分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 矢量裁剪分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。
 */
var VectorClipJobsService = function (_ProcessingServiceBas) {
    _inherits(VectorClipJobsService, _ProcessingServiceBas);

    function VectorClipJobsService(url, options) {
        _classCallCheck(this, VectorClipJobsService);

        var _this = _possibleConstructorReturn(this, (VectorClipJobsService.__proto__ || Object.getPrototypeOf(VectorClipJobsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.VectorClipJobsService";

        _this.url += "/spatialanalyst/vectorclip";
        return _this;
    }

    /**
     *@inheritDoc
     */


    _createClass(VectorClipJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(VectorClipJobsService.prototype.__proto__ || Object.getPrototypeOf(VectorClipJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.VectorClipJobsService.protitype.getVectorClipJobs
         * @description 获取矢量裁剪分析所有任务
         */

    }, {
        key: 'getVectorClipJobs',
        value: function getVectorClipJobs() {
            _get(VectorClipJobsService.prototype.__proto__ || Object.getPrototypeOf(VectorClipJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.protitype.getVectorClipJob
         * @description 获取指定id的矢量裁剪分析服务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getVectorClipJob',
        value: function getVectorClipJob(id) {
            _get(VectorClipJobsService.prototype.__proto__ || Object.getPrototypeOf(VectorClipJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.VectorClipJobsService.protitype.addVectorClipJob
         * @description 新建矢量裁剪分析服务
         * @param params - {SuperMap.VectorClipJobsParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addVectorClipJob',
        value: function addVectorClipJob(params, seconds) {
            _get(VectorClipJobsService.prototype.__proto__ || Object.getPrototypeOf(VectorClipJobsService.prototype), 'addJob', this).call(this, this.url, params, _VectorClipJobsParameter2.default, seconds);
        }
    }]);

    return VectorClipJobsService;
}(_ProcessingServiceBase2.default);

exports.default = VectorClipJobsService;


_SuperMap2.default.VectorClipJobsService = VectorClipJobsService;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _elasticsearch = __webpack_require__(320);

var _elasticsearch2 = _interopRequireDefault(_elasticsearch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ElasticSearch
 * @classdesc ElasticSearch服务
 *              通用参数设置请参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-conventions.html
 * @param url - {string} 地址
 * @param options - {Object} 参数
 */

var ElasticSearch = function () {

    /**
     * @member SuperMap.ElasticSearch.prototype.events -{SuperMap.Events}
     * @description 事件
     */


    /**
     * @member SuperMap.ElasticSearch.prototype.geoFence -{Object}
     * @description 地理围栏
     * @example {
     *    radius: 1000,//单位是m
     *    center: [104.40, 30.43],
     *    unit: 'meter|degree'
     *  }
     */

    /**
     *  @member SuperMap.ElasticSearch.prototype.openGeoFence -{boolean}
     *  @description 是否开启地理围栏验证，默认为不开启。
     */

    /**
     *  @member SuperMap.ElasticSearch.prototype.client -{Object}
     *  @description client ES客户端
     */
    function ElasticSearch(url, options) {
        _classCallCheck(this, ElasticSearch);

        this.url = null;
        this.client = null;
        this.change = null;
        this.openGeoFence = false;
        this.outOfGeoFence = null;
        this.geoFence = null;
        this.EVENT_TYPES = ['change', 'error', 'outOfGeoFence'];
        this.events = null;
        this.eventListeners = null;

        options = options || {};
        var me = this;
        me.url = url;
        me.client = new _elasticsearch2.default.Client({
            host: me.url
        });
        me.change = options.change;
        me.geoFence = options.geoFence;
        me.openGeoFence = options.openGeoFence;
        me.outOfGeoFence = options.outOfGeoFence;
        me.events = new _SuperMap2.default.Events(me, null, me.EVENT_TYPES);
        me.eventListeners = options.eventListeners;
        if (me.eventListeners instanceof Object) {
            me.events.on(me.eventListeners);
        }
    }

    /**
     * @function  SuperMap.ElasticSearch.prototype.setGeoFence
     * @description 设置地理围栏，openGeoFence参数为true的时候，设置的地理围栏才生效。
     * @param geoFence - {SuperMap.Geometry} 地理围栏。
     */

    /**
     * @member SuperMap.ElasticSearch.prototype.eventListeners -{Object}
     * @description 听器对象，在构造函数中设置此参数（可选），对 MapService 支持的两个事件 processCompleted 、processFailed 进行监听，
     * 相当于调用 SuperMap.Events.on(eventListeners)。
     */


    /*
     * Constant: EVENT_TYPES
     * {Array<String>}
     * 此类支持的事件类型。
     *
     */

    /**
     *  @member SuperMap.ElasticSearch.prototype.outOfGeoFence -{function}
     *  @description 数据超出地理围栏后执行的操作
     */

    /**
     *  @member SuperMap.ElasticSearch.prototype.change -{function}
     *  @description 服务器返回数据后执行的操作
     */

    /**
     *  @member SuperMap.ElasticSearch.prototype.url -{string}
     *  @description ElasticSearch服务地址
     */


    _createClass(ElasticSearch, [{
        key: 'setGeoFence',
        value: function setGeoFence(geoFence) {
            this.geoFence = geoFence;
        }
        /**
         * @function  SuperMap.ElasticSearch.prototype.bulk
         * @description 批量操作API，允许执行多个索引/删除操作。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-bulk</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'bulk',
        value: function bulk(params, callback) {
            return this.client.bulk(params, callback);
        }
        /**
         * @function  SuperMap.ElasticSearch.prototype.clearScroll
         * @description 通过指定scroll参数进行查询来清除已经创建的scroll请求。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-clearscroll</br>
         *更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'clearScroll',
        value: function clearScroll(params, callback) {
            return this.client.clearScroll(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.count
         * @description 获取集群、索引、类型或查询的文档个数。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-count</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'count',
        value: function count(params, callback) {
            return this.client.count(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.count
         * @description 在特定索引中添加一个类型化的JSON文档，使其可搜索。如果具有相同index，type且id已经存在的文档将发生错误。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-create</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'create',
        value: function create(params, callback) {
            return this.client.create(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.delete
         * @description 根据其ID从特定索引中删除键入的JSON文档。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-delete</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'delete',
        value: function _delete(params, callback) {
            return this.client.delete(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.delete
         * @description 根据其ID从特定索引中删除键入的JSON文档。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-deletebyquery</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'deleteByQuery',
        value: function deleteByQuery(params, callback) {
            return this.client.deleteByQuery(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.delete
         * @description 根据其ID删除脚本。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-deletescript</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'deleteScript',
        value: function deleteScript(params, callback) {
            return this.client.deleteScript(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.deleteTemplate
         * @description 根据其ID删除模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-deletetemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'deleteTemplate',
        value: function deleteTemplate(params, callback) {
            return this.client.deleteTemplate(params, callback);
        }
        /**
         * @function  SuperMap.ElasticSearch.prototype.exists
         * @description 检查给定文档是否存在。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-exists</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'exists',
        value: function exists(params, callback) {
            return this.client.exists(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.existsSource
         * @description 检查资源是否存在。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-existssource</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'existsSource',
        value: function existsSource(params, callback) {
            return this.client.existsSource(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.explain
         * @description 提供与特定查询相关的特定文档分数的详细信息。它还会告诉您文档是否与指定的查询匹配。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-explain</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'explain',
        value: function explain(params, callback) {
            return this.client.explain(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.fieldCaps
         * @description 允许检索多个索引之间的字段的功能。(实验性API，可能会在未来版本中删除)</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-fieldcaps</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-field-caps.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'fieldCaps',
        value: function fieldCaps(params, callback) {
            return this.client.fieldCaps(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.get
         * @description 从索引获取一个基于其id的类型的JSON文档。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-get</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'get',
        value: function get(params, callback) {
            return this.client.get(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.getScript
         * @description 获取脚本。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-getscript</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'getScript',
        value: function getScript(params, callback) {
            return this.client.getScript(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.getSource
         * @description 通过索引，类型和ID获取文档的源。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-getsource</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'getSource',
        value: function getSource(params, callback) {
            return this.client.getSource(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.getTemplate
         * @description 获取模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-gettemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'getTemplate',
        value: function getTemplate(params, callback) {
            return this.client.getTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.index
         * @description 在索引中存储一个键入的JSON文档，使其可搜索。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-index</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'index',
        value: function index(params, callback) {
            return this.client.index(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.info
         * @description 从当前集群获取基本信息。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-info</br>
         * 更多信息参考 https://www.elastic.co/guide/index.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'info',
        value: function info(params, callback) {
            return this.client.info(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.mget
         * @description 根据索引，类型（可选）和ids来获取多个文档。mget所需的主体可以采用两种形式：文档位置数组或文档ID数组。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-mget</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'mget',
        value: function mget(params, callback) {
            return this.client.mget(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.msearch
         * @description 在同一请求中执行多个搜索请求。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-msearch</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'msearch',
        value: function msearch(params, callback) {
            var me = this;
            if (me.openGeoFence) {
                return me.client.msearch(params, callback).then(function (resp) {
                    me._update(resp.responses);
                }, function (err) {
                    me.events.triggerEvent('error', { error: err });
                });
            }
            return me.client.msearch(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.msearchTemplate
         * @description 在同一请求中执行多个搜索模板请求。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-msearchtemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'msearchTemplate',
        value: function msearchTemplate(params, callback) {
            return this.client.msearchTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.mtermvectors
         * @description 多termvectors API允许一次获得多个termvectors。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-mtermvectors</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-termvectors.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'mtermvectors',
        value: function mtermvectors(params, callback) {
            return this.client.mtermvectors(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.ping
         * @description 测试连接。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-ping</br>
         * 更多信息参考 https://www.elastic.co/guide/index.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'ping',
        value: function ping(params, callback) {
            return this.client.ping(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.putScript
         * @description 添加脚本。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-putscript</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'putScript',
        value: function putScript(params, callback) {
            return this.client.putScript(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.putTemplate
         * @description 添加模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-puttemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'putTemplate',
        value: function putTemplate(params, callback) {
            return this.client.putTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.reindex
         * @description 重新索引。</br>
         * 参数设置参考 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-reindex</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'reindex',
        value: function reindex(params, callback) {
            return this.client.reindex(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.reindexRessrottle
         * @description 重新索引。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-reindexrethrottle</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'reindexRessrottle',
        value: function reindexRessrottle(params, callback) {
            return this.client.reindexRessrottle(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.renderSearchTemplate
         * @description 搜索模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-rendersearchtemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'renderSearchTemplate',
        value: function renderSearchTemplate(params, callback) {
            return this.client.renderSearchTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.scroll
         * @description  在search()调用中指定滚动参数之后，滚动搜索请求（检索下一组结果）。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-scroll</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'scroll',
        value: function scroll(params, callback) {
            return this.client.scroll(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.search
         * @description  在search()调用中指定滚动参数之后，滚动搜索请求（检索下一组结果）。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-search</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'search',
        value: function search(params, callback) {
            var me = this;
            if (me.openGeoFence) {
                return me.client.search(params, callback).then(function (resp) {
                    me._update(resp.responses);
                }, function (err) {
                    me.events.triggerEvent('error', { error: err });
                });
            }
            return me.client.search(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.searchShards
         * @description  返回要执行搜索请求的索引和分片。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-searchshards</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'searchShards',
        value: function searchShards(params, callback) {
            return this.client.searchShards(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.searchTemplate
         * @description  搜索模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-searchtemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'searchTemplate',
        value: function searchTemplate(params, callback) {
            return this.client.searchTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.suggest
         * @description 该建议功能通过使用特定的建议者，基于所提供的文本来建议类似的术语。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-suggest</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'suggest',
        value: function suggest(params, callback) {
            return this.client.suggest(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.termvectors
         * @description 返回有关特定文档字段中的术语的信息和统计信息。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-termvectors</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'termvectors',
        value: function termvectors(params, callback) {
            return this.client.termvectors(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.update
         * @description 更新文档的部分。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-update</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'update',
        value: function update(params, callback) {
            return this.client.update(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.update
         * @description 通过查询API来更新文档。</br>
         * 参数设置参考 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-updatebyquery</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'updateByQuery',
        value: function updateByQuery(params, callback) {
            return this.client.updateByQuery(params, callback);
        }
    }, {
        key: '_update',
        value: function _update(data) {
            var me = this;
            if (!data) {
                return;
            }
            me.data = data;
            if (me.geoFence) {
                me._validateDatas(data);
            }
            me.events.triggerEvent('change', { data: me.data });
            me.change && me.change(data);
        }
    }, {
        key: '_validateDatas',
        value: function _validateDatas(datas) {
            if (!datas) {
                return;
            }
            if (!(datas instanceof Array)) {
                datas = [datas];
            }
            var i,
                len = datas.length;
            for (i = 0; i < len; i++) {
                this._validateData(datas[i]);
            }
        }
    }, {
        key: '_validateData',
        value: function _validateData(data) {
            var me = this;
            data.hits.hits.map(function (source) {
                var content = source._source;
                var meterUnit = me._getMeterPerMapUnit(me.geoFence.unit);
                var geoFenceCX = me.geoFence.center[0] * meterUnit;
                var geoFenceCY = me.geoFence.center[1] * meterUnit;
                var contentX = content.x * meterUnit;
                var contentY = content.y * meterUnit;
                var distance = me._distance(contentX, contentY, geoFenceCX, geoFenceCY);
                var radius = me.geoFence.radius;
                if (distance > radius) {
                    me.outOfGeoFence && me.outOfGeoFence(data);
                    me.events.triggerEvent('outOfGeoFence', { data: data });
                }
            });
        }
    }, {
        key: '_distance',
        value: function _distance(x1, y1, x2, y2) {
            return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
        }
    }, {
        key: '_getMeterPerMapUnit',
        value: function _getMeterPerMapUnit(mapUnit) {
            var earchRadiusInMeters = 6378137;
            var meterPerMapUnit = void 0;
            if (mapUnit === 'meter') {
                meterPerMapUnit = 1;
            } else if (mapUnit === 'degree') {
                // 每度表示多少米。
                meterPerMapUnit = Math.PI * 2 * earchRadiusInMeters / 360;
            }
            return meterPerMapUnit;
        }
    }]);

    return ElasticSearch;
}();

exports.default = ElasticSearch;

_SuperMap2.default.ElasticSearch = ElasticSearch;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Logo = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mapboxGl = __webpack_require__(20);

var _mapboxGl2 = _interopRequireDefault(_mapboxGl);

var _iClient = __webpack_require__(319);

var _iClient2 = _interopRequireDefault(_iClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class mapboxgl.supermap.LogoControl
 * @classdesc Logo控件。默认不显示</br>
 *
 * @example
 * (start code)
 *  map.addControl(new mapboxgl.supermap.LogoControl(),'bottom-right');
 * (end)
 * @param options -{Object} logo控件配置项</br>
 *        imageUrl - {string} logo图片地址</br>
 *        width - {string} logo图片宽</br>
 *        height - {string} logo图片高</br>
 *        link - {string} 跳转链接</br>
 *        alt - {string} logo图片失效时显示文本
 */
var Logo = exports.Logo = function () {
    //logo图片高

    //跳转链接
    function Logo(options) {
        _classCallCheck(this, Logo);

        this.imageUrl = null;
        this.link = null;
        this.width = null;
        this.height = null;
        this.alt = "SuperMap iClient";

        this._extend(this, options);
    }

    /**
     * @function mapboxgl.supermap.LogoControl.prototype.onAdd
     * @description 添加一个logo
     * @return {div} 返回创建的logo元素
     */

    //logo图片失效时显示文本

    //logo图片宽


    //logo图片地址


    _createClass(Logo, [{
        key: 'onAdd',
        value: function onAdd(map) {
            this._map = map;
            this._container = document.createElement('div');
            this._container.className = 'mapboxgl-ctrl iclient-logo';
            this._container.style.marginTop = 0;
            this._container.style.marginBottom = 0;
            this._container.style.marginLeft = 0;
            this._container.style.marginRight = 0;

            var imgSrc = _iClient2.default;
            if (this.imageUrl) {
                imgSrc = this.imageUrl;
            }
            var alt = this.alt;

            var imageWidth = "94px";
            var imageHeight = "29px";
            var styleSize = "width:" + imageWidth + ";height:" + imageHeight + ";";
            if (this.imageUrl) {
                imageWidth = this.width;
                imageHeight = this.height;
                styleSize = "width:" + imageWidth + ";height:" + imageHeight + ";";
                if (!imageWidth || !imageHeight) {
                    styleSize = "";
                }
            }
            var link = this.link || "http://iclient.supermapol.com";
            this._container.innerHTML = "<a href='" + link + "' target='_blank'>" + "<img src=" + imgSrc + " alt='" + alt + "' style='" + styleSize + "margin-bottom: 2px'></a>";
            this._createStyleSheet();
            return this._container;
        }
    }, {
        key: '_createStyleSheet',
        value: function _createStyleSheet() {
            var style = document.createElement('style');
            style.type = 'text/css';
            style.innerHTML = ".iclient-logo{" + "margin:0 !important;" + "}" + ".iclient-logo a{" + "border: none;" + "display: block;" + "height:31px;" + "}" + ".iclient-logo img{" + "border: none;" + "white-space: nowrap" + "}";
            document.getElementsByTagName('head')[0].appendChild(style);
        }
    }, {
        key: '_extend',
        value: function _extend(dest) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = arguments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var src = _step.value;

                    for (var k in src) {
                        dest[k] = src[k];
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return dest;
        }
    }]);

    return Logo;
}();

_mapboxGl2.default.supermap = _mapboxGl2.default.supermap || {};
_mapboxGl2.default.supermap.LogoControl = Logo;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MapvLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MapvRenderer = __webpack_require__(274);

var _MapvRenderer2 = _interopRequireDefault(_MapvRenderer);

var _mapboxGl = __webpack_require__(20);

var _mapboxGl2 = _interopRequireDefault(_mapboxGl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class mapboxgl.supermap.MapvLayer
 * @classdesc Mapv图层
 * @param map - {Object} 地图
 * @param dataSet -{Object} 数据集
 * @param mapVOptions -{Object} Mapv参数
 */
var MapvLayer = exports.MapvLayer = function () {
    function MapvLayer(map, dataSet, mapVOptions) {
        _classCallCheck(this, MapvLayer);

        this.map = map;
        this.renderer = new _MapvRenderer2.default(map, this, dataSet, mapVOptions);
        this.canvas = this._createCanvas();
        this.renderer._canvasUpdate();
        this.mapContainer = map.getCanvasContainer();
        this.mapContainer.appendChild(this.canvas);
    }

    /**
     * @function mapboxgl.supermap.MapvLayer.prototype.getTopLeft
     * @description 获取左上的距离
     */


    _createClass(MapvLayer, [{
        key: 'getTopLeft',
        value: function getTopLeft() {
            var map = this.map;
            var topLeft;
            if (map) {
                var bounds = map.getBounds();
                topLeft = bounds.getNorthWest();
            }
            return topLeft;
        }
    }, {
        key: 'show',
        value: function show() {
            if (this.renderer) {
                this.renderer._show();
            }
            return this;
        }
    }, {
        key: 'hide',
        value: function hide() {
            if (this.renderer) {
                this.renderer._hide();
            }
            return this;
        }
    }, {
        key: '_createCanvas',
        value: function _createCanvas() {
            var canvas = document.createElement('canvas');
            canvas.style.position = 'absolute';
            canvas.style.top = 0 + "px";
            canvas.style.left = 0 + "px";
            canvas.width = parseInt(this.map.getCanvas().style.width);
            canvas.height = parseInt(this.map.getCanvas().style.height);
            canvas.style.width = this.map.getCanvas().style.width;
            canvas.style.height = this.map.getCanvas().style.height;
            return canvas;
        }
    }]);

    return MapvLayer;
}();

_mapboxGl2.default.supermap = _mapboxGl2.default.supermap || {};
_mapboxGl2.default.supermap.MapvLayer = MapvLayer;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RankTheme3DLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mapboxGl = __webpack_require__(20);

var _mapboxGl2 = _interopRequireDefault(_mapboxGl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class mapboxgl.supermap.RankTheme3DLayer
 * @classdesc mapbox gl分段专题图
 * @param  id -{string} 专题图图层id
 * @param  map -{object} mapbox gl地图对象
 * @param  layerOptions -{Object} 专题图图层配置项<br>
 *             opacity -{number} 图层透明度，默认1<br>
 *             parseNumber -{boolean} 是否预处理数据，将数据转换为number，默认false<br>
 *             baseHeightField -{string} 数据中表示基础高度的字段<br>
 *             heightField -{string} 数据中表示高度的字段<br>
 *             heightStops -{Array} 数据高度分段数组<br>
 *             colorField -{string} 数据中表示颜色的字段<br>
 *             colorStops -{Array} 数据颜色分段数组<br>
 *             base -{number} 数据分段线性增量<br>
 *             showLegend -{boolean} 是否显示图例,默认显示<br>
 *             legendTitle -{string} 图例标题<br>
 *             legendTheme -{string} 图例主题，取值：'light','dark'<br>
 *             legendRatio -{number} 图例数值扩大系数，<br>
 *             legendPosition -{string} 图例位置，取值：'top-right'|'top-left'|'bottom-left'|'bottom-right'<br>
 */
var RankTheme3DLayer = exports.RankTheme3DLayer = function () {
    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.legendTheme -{string}
     * @description 图例主题，取值：'light','dark'
     * @default 'light'
     */


    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.legendTitle -{string}
     * @description 图例标题
     */

    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.base -{number}
     * @description 数据分段线性增量
     */


    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.colorField -{string}
     * @description 数据中表示颜色的字段
     */


    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.heightField -{string}
     * @description 数据中表示高度的字段
     */

    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.parseNumber -{boolean}
     * @description 是否进行数据预处理,有些字段是string类型，需要转换为number
     */


    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.map -{object}
     * @description mapbox gl地图对象
     */
    function RankTheme3DLayer(id, map, layerOptions) {
        _classCallCheck(this, RankTheme3DLayer);

        this.id = null;
        this.map = null;
        this.opacity = 1;
        this.parseNumber = false;
        this.baseHeightField = null;
        this.heightField = null;
        this.heightStops = null;
        this.colorField = null;
        this.colorStops = null;
        this.base = null;
        this.showLegend = true;
        this.legendTitle = null;
        this.legendRatio = 1;
        this.legendTheme = 'light';
        this.legendPosition = 'bottom-right';

        this.id = id;
        this.map = map;
        this._extend(this, layerOptions);
        this.heightField = layerOptions.heightField || 'height';
        this.colorField = layerOptions.colorField || this.heightField;
    }

    /**
     * @function mapboxgl.supermap.RankTheme3DLayer.prototype.setLayerOptions
     * @description 设置图层相关参数
     * @param layerOptions -{object} 该专题图图层相关参数<br>
     * *          opacity -{number} 图层透明度，默认1<br>
     *            parseNumber -{boolean} 是否预处理数据，将数据转换为number，默认false<br>
     *            baseHeightField -{string} 数据中表示基础高度的字段<br>
     *            heightField -{string} 数据中表示高度的字段<br>
     *            heightStops -{Array} 数据高度分段数组<br>
     *            colorField -{string} 数据中表示颜色的字段<br>
     *            colorStops -{Array} 数据颜色分段数组<br>
     *            base -{number} 数据分段线性增量<br>
     *            showLegend -{boolean} 是否显示图例,默认显示<br>
     *            legendTitle -{string} 图例标题<br>
     *            legendRatio -{number} 图例数值扩大系数，<br>
     *            legendTheme -{string} 图例主题，取值：'light','dark'<br>
     *            legendPosition -{string} 图例位置，取值：'top-right'|'top-left'|'bottom-left'|'bottom-right'<br>
     * @returns {mapboxgl.supermap.RankTheme3DLayer}
     */

    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.legendPosition -{string}
     * @description 图例位置，取值：'top-right'|'top-left'|'bottom-left'|'bottom-right'
     * @default 'bottom-right'
     */

    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.legendRatio -{number}
     * @description 图例数值扩大系数
     */

    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.showLegend -{Boolean}
     * @description 是否显示图例
     */

    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.colorStops -{Array}
     * @description 数据颜色分段数组
     */

    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.heightStops -{Array}
     * @description 数据高度分段数组
     */


    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.baseHeightField -{string}
     * @description 数据中表示基础高度的字段
     */

    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.opacity -{number}
     * @description 图层透明度，默认1
     */


    /**
     * @member  mapboxgl.supermap.RankTheme3DLayer.prototype.id -{string}
     * @description mapbox gl图层id
     */


    _createClass(RankTheme3DLayer, [{
        key: 'setLayerOptions',
        value: function setLayerOptions(layerOptions) {
            this._extend(this, layerOptions);
            return this;
        }

        /**
         * @function mapboxgl.supermap.RankTheme3DLayer.prototype.setData
         * @description 设置数据，数据格式必须为geojson格式
         * @param data -{object} geojson格式数据
         * @param parseNumber -{object} 是否进行数据预处理,有些字段是string类型，需要转换为number
         */

    }, {
        key: 'setData',
        value: function setData(data, parseNumber) {
            var me = this;
            me.data = data;
            if (parseNumber != null) {
                me.parseNumber = parseNumber;
            }
            me.parseNumber && me.data && me.data.features && me.data.features.map(function (val, index) {
                if (me.baseHeightField && val.properties[me.baseHeightField]) {
                    val.properties[baseHeightField] = parseFloat(val.properties[baseHeightField]);
                }
                if (me.heightField && val.properties[me.heightField]) {
                    val.properties[me.heightField] = parseFloat(val.properties[me.heightField]);
                }
            });
            return this;
        }

        /**
         * @function mapboxgl.supermap.RankTheme3DLayer.prototype.getData
         * @description 获取数据，返回的数据格式为geojson
         * @returns {Object}
         */

    }, {
        key: 'getData',
        value: function getData() {
            return this.data;
        }

        /**
         * @function mapboxgl.supermap.RankTheme3DLayer.prototype.show
         * @description 显示图层
         * @param options -{object} 图层相关参数，如图例标题和主题等
         * @returns {mapboxgl.supermap.RankTheme3DLayer}
         */

    }, {
        key: 'show',
        value: function show(options) {
            this._addLayer();
            this._extend(this, options);
            if (this.showLegend) {
                if (this.legend) {
                    map.addControl(legend, this.legendPosition);
                } else {
                    var defaultLegend = this._createLegendControl();
                    this.map.addControl(defaultLegend, this.legendPosition);
                }
            }
            return this;
        }
    }, {
        key: '_createLegendControl',
        value: function _createLegendControl(html) {
            var me = this;

            function LegendControl() {}

            LegendControl.prototype.onAdd = function (map) {
                this._map = map;
                this._container = document.createElement('div');
                var className = 'mapboxgl-ctrl legend ';
                var theme = 'legend-light';
                if (me.legendTheme === 'dark') {
                    theme = 'legend-dark';
                }
                this._container.className = className + theme;

                if (html) {
                    this._container.innerHTML = html;
                } else {
                    this._container.innerHTML = me._createLegendElement.call(me);
                }
                me._appendLegendCSSStyle();
                return this._container;
            };

            LegendControl.prototype.onRemove = function () {
                this._container.parentNode.removeChild(this._container);
                this._map = undefined;
            };

            return new LegendControl();
        }
    }, {
        key: '_createLegendElement',
        value: function _createLegendElement() {
            var len = this.colorStops && this.colorStops.length || 0;
            var titleWidth = len * 60;
            //图例标题
            var titleElement = "";
            var legendTitle = this.legendTitle || "";
            titleElement = " <p class='legend-title' style='width: " + titleWidth + ";'>" + legendTitle + "</p>";
            //颜色分段对应标识
            var colorGalleryElement = "<ul>";
            var valueGalleryElement = "<ul>";
            for (var i = 0; i < len; i++) {
                var value = this.colorStops[i][0];
                this.legendRatio = this.legendRatio == null ? 1 : this.legendRatio;
                value = value * this.legendRatio;
                var text = this._getWrapperText(value);
                var color = this.colorStops[i][1];
                colorGalleryElement += "<li style='background-color:" + color + ";'></li>";
                valueGalleryElement += "<li>" + text + "</li>";
            }
            colorGalleryElement += "</ul>";
            valueGalleryElement += "</ul>";
            return titleElement + colorGalleryElement + valueGalleryElement;
        }
    }, {
        key: '_appendLegendCSSStyle',
        value: function _appendLegendCSSStyle() {
            var legendStyle = document.createElement('style');
            legendStyle.type = 'text/css';
            legendStyle.innerHTML = " .legend {\n" + "            display: inline-block;\n" + "            padding: 4px 10px;\n" + "            border-radius: 2px;\n" + "            -moz-border-radius: 2px;\n" + "            -webkit-border-radius: 2px;\n" + "            font-size: 12px;\n" + "            color: rgba(0, 0, 0, 0.8);\n" + "            background-color: rgb(255, 255, 255);\n" + "        }\n" + "        .legend-light {\n" + "            color: rgba(0, 0, 0, 0.8);\n" + "            background-color: rgb(255, 255, 255);\n" + "        }\n" + "        .legend-dark {\n" + "            color: rgba(255, 255, 255, 0.8);\n" + "            background-color: rgb(64, 64, 64);\n" + "        }\n" + "        .legend ul {\n" + "            clear: both;\n" + "            overflow: auto;\n" + "            padding: 0;\n" + "            margin: 0;\n" + "            height: 100%;\n" + "            display: block;\n" + "            list-style: none;\n" + "            box-sizing: border-box;\n" + "            -webkit-font-smoothing: antialiased;\n" + "        }\n" + "        .legend li {\n" + "            float: left;\n" + "            width: 50px;\n" + "            height: 28px;\n" + "            overflow: hidden;\n" + "            text-overflow: clip;\n" + "            padding: 0 4px;\n" + "            line-height: 28px;\n" + "        }\n" + "        .legend .legend-title {\n" + "            min-height: 14px;\n" + "            max-width: 500px;\n" + "            margin: 4px 0;\n" + "        }\n" + "       .legend-light .legend-title {\n" + "            color: rgba(0, 0, 0, 0.8);\n" + "        }\n" + "        .legend-dark .legend-title {\n" + "            color: rgba(255, 255, 255, 0.8);\n" + "        }";
            document.getElementsByTagName('head')[0].appendChild(legendStyle);
        }
    }, {
        key: '_getWrapperText',
        value: function _getWrapperText(number) {
            //单个颜色值宽度为60px,最大只能完全显示1000000，否则就超出宽度，则显示以为k计数单位的值
            var num = parseFloat(number);
            if (num % 1000000 <= 1000000) {
                return num.toString();
            }
            return parseInt(num / 1000) + 'k';
        }
    }, {
        key: '_addLayer',
        value: function _addLayer() {
            var paintOptions = this._getPaintOptions();
            var id = this.id ? this.id : "rankTheme";
            var sourceId = id + 'Source';
            if (!this.map.getSource(sourceId)) {
                this.map.addSource(sourceId, {
                    'type': 'geojson',
                    'data': this.data
                });
            } else {
                this.map.removeSource(sourceId);
                this.map.addSource(sourceId, {
                    'type': 'geojson',
                    'data': this.data
                });
            }
            this.map.addLayer({
                'id': id,
                'type': 'fill-extrusion',
                'source': sourceId,
                'paint': paintOptions
            }, id);
            this.map.moveLayer(id);
        }
    }, {
        key: '_getPaintOptions',
        value: function _getPaintOptions() {
            var opacity = this.opacity == null ? 1 : this.opacity;
            opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
            var reg = /^[0-9]+.?[0-9]*$/;
            var options = {
                'fill-extrusion-color': {
                    'stops': this.colorStops,
                    'property': this.colorField || this.heightField,
                    'base': reg.test(this.base) ? this.base : 1
                },
                'fill-extrusion-opacity': opacity
            };
            if (this.heightStops) {
                options['fill-extrusion-height'] = {
                    'stops': this.heightStops,
                    'property': this.heightField || 'height',
                    'base': reg.test(this.base) ? this.base : 1
                };
            } else {
                options['fill-extrusion-height'] = {
                    'property': this.heightField || 'height',
                    'type': 'identity'
                };
            }

            if (this.baseHeightField) {
                options['fill-extrusion-base'] = {
                    'property': this.baseHeightField,
                    'type': 'identity'
                };
            }
            return options;
        }
    }, {
        key: '_extend',
        value: function _extend(dest) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = arguments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var src = _step.value;

                    for (var k in src) {
                        dest[k] = src[k];
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return dest;
        }
    }]);

    return RankTheme3DLayer;
}();

_mapboxGl2.default.supermap = _mapboxGl2.default.supermap || {};
_mapboxGl2.default.supermap.RankTheme3DLayer = RankTheme3DLayer;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setPaintProperty = exports.setBackground = exports.getDefaultVectorTileStyle = undefined;

var _mapboxGl = __webpack_require__(20);

var _mapboxGl2 = _interopRequireDefault(_mapboxGl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_mapboxGl2.default.supermap = _mapboxGl2.default.supermap || {};
_mapboxGl2.default.supermap.map = _mapboxGl2.default.supermap.map || {};

/**
 * 配置默认底图样式
 */
var getDefaultVectorTileStyle = exports.getDefaultVectorTileStyle = function getDefaultVectorTileStyle(urlTemplate, options) {
    options = options || {};
    var defaultOptions = {};
    defaultOptions.version = options.version || 8;
    defaultOptions.layers = options.layers || [];
    defaultOptions.light = options.light || {
        "anchor": "viewport",
        "color": "#fcf6ef",
        "intensity": 0.5,
        "position": [1.15, 201, 20]
    };

    var style = {
        "version": defaultOptions.version,
        "sources": {
            "vector-tiles": {
                "type": "vector",
                "tiles": [urlTemplate]
            }
        },
        "layers": defaultOptions.layers,
        "light": defaultOptions.light
    };
    if (options.sprite != null) {
        style.sprite = options.sprite;
    }
    if (options.glyphs != null) {
        style.glyphs = options.glyphs;
    }
    return style;
};

/**
 * 设置地图背景
 */
var setBackground = exports.setBackground = function setBackground(map, color) {
    if (color && map) {
        map.addLayer({
            "id": "background",
            "type": "background",
            "paint": {
                "background-color": color
            }
        }, "background");
    }
};

/**
 * 设置图层风格
 * @param map
 * @param layerIds
 * @param type
 * @param paint
 * @param source 非必填，默认vector-tiles
 * @param sourceLayers 非必填，默认与id对应
 */
var setPaintProperty = exports.setPaintProperty = function setPaintProperty(map, layerIds, type, paint, source, sourceLayers) {
    if (layerIds && map) {
        if (Object.prototype.toString.call(layerIds) !== '[object Array]') {
            layerIds = [layerIds];
        }
        for (var i = 0; i < layerIds.length; i++) {
            var sourceLayer = sourceLayers ? sourceLayers[i] : null;
            var layer = getLayer(layerIds[i], type, source, sourceLayer, paint);
            map.addLayer(layer, layerIds[i]);
            map.moveLayer(layerIds[i]);
        }
    }
};

function getLayer(id, type, source, sourceLayer, paint) {
    var sourceType = source || "vector-tiles";
    var sLayer = sourceLayer || id;
    var layer = {
        "id": id,
        "type": type,
        "source": sourceType,
        "source-layer": sLayer,
        "paint": paint
    };
    return layer;
}

_mapboxGl2.default.supermap.map.getDefaultVectorTileStyle = getDefaultVectorTileStyle;
_mapboxGl2.default.supermap.map.setBackground = setBackground;
_mapboxGl2.default.supermap.map.setPaintProperty = setPaintProperty;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MapvDataSet = undefined;

var _mapboxGl = __webpack_require__(20);

var _mapboxGl2 = _interopRequireDefault(_mapboxGl);

var _mapv = __webpack_require__(81);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_mapboxGl2.default.supermap = _mapboxGl2.default.supermap || {};

var MapvDataSet = exports.MapvDataSet = {

    /**
     * 返回mapv点数据集
     */
    getPoint: function getPoint(center) {
        if (center && center instanceof Array) {
            return new _mapv.DataSet([{
                geometry: {
                    type: 'Point',
                    coordinates: center
                }
            }]);
        }
    },

    /**
     * 返回mapv多点数据集
     */
    getPoints: function getPoints(points) {
        if (points && points instanceof Array) {
            var mPoints = [];
            points.map(function (data) {
                mPoints.push({
                    geometry: {
                        type: 'Point',
                        coordinates: data.geometry.coordinates
                    }
                });
                return data;
            });
            return new _mapv.DataSet(mPoints);
        }
    },

    /**
     * 返回mapv弧形线数据集
     */
    getCurveLines: function getCurveLines(startPoint, LinePoints) {
        if (startPoint && startPoint instanceof Array && LinePoints && LinePoints instanceof Array) {
            var lineData = [];
            LinePoints.map(function (data) {
                var coords = data.geometry && data.geometry.coordinates;
                var toCenter = { lng: coords[0], lat: coords[1] };
                var fromCenter = { lng: startPoint[0], lat: startPoint[1] };
                var cv = _mapv.utilCurve.getPoints([fromCenter, toCenter]);
                lineData.push({
                    geometry: {
                        type: 'LineString',
                        coordinates: cv
                    }
                });
                return data;
            });
            return new _mapv.DataSet(lineData);
        }
    },

    /**
     * 返回mapv弧形动态点数据集
     */
    getCurveDynamicPoints: function getCurveDynamicPoints(center, endPoints) {
        if (center && center instanceof Array && endPoints && endPoints instanceof Array) {
            var timeData = [];
            endPoints.map(function (data) {
                var coords = data.geometry && data.geometry.coordinates;
                var toCenter = { lng: coords[0], lat: coords[1] };
                var fromCenter = { lng: center[0], lat: center[1] };
                var cv = _mapv.utilCurve.getPoints([fromCenter, toCenter]);
                for (var j = 0; j < cv.length; j++) {
                    timeData.push({
                        geometry: {
                            type: 'Point',
                            coordinates: cv[j]
                        },
                        time: j
                    });
                }
                return data;
            });
            return new _mapv.DataSet(timeData);
        }
    }
};
_mapboxGl2.default.supermap.MapvDataSet = MapvDataSet;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
    factory(exports, module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, mod);
    global.fetchJsonp = mod.exports;
  }
})(undefined, function (exports, module) {
  'use strict';

  var defaultOptions = {
    timeout: 5000,
    jsonpCallback: 'callback',
    jsonpCallbackFunction: null
  };

  function generateCallbackFunction() {
    return 'jsonp_' + Date.now() + '_' + Math.ceil(Math.random() * 100000);
  }

  // Known issue: Will throw 'Uncaught ReferenceError: callback_*** is not defined'
  // error if request timeout
  function clearFunction(functionName) {
    // IE8 throws an exception when you try to delete a property on window
    // http://stackoverflow.com/a/1824228/751089
    try {
      delete window[functionName];
    } catch (e) {
      window[functionName] = undefined;
    }
  }

  function removeScript(scriptId) {
    var script = document.getElementById(scriptId);
    document.getElementsByTagName('head')[0].removeChild(script);
  }

  function fetchJsonp(_url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    // to avoid param reassign
    var url = _url;
    var timeout = options.timeout || defaultOptions.timeout;
    var jsonpCallback = options.jsonpCallback || defaultOptions.jsonpCallback;

    var timeoutId = undefined;

    return new Promise(function (resolve, reject) {
      var callbackFunction = options.jsonpCallbackFunction || generateCallbackFunction();
      var scriptId = jsonpCallback + '_' + callbackFunction;

      window[callbackFunction] = function (response) {
        resolve({
          ok: true,
          // keep consistent with fetch API
          json: function json() {
            return Promise.resolve(response);
          }
        });

        if (timeoutId) clearTimeout(timeoutId);

        removeScript(scriptId);

        clearFunction(callbackFunction);
      };

      // Check if the user set their own params, and if not add a ? to start a list of params
      url += url.indexOf('?') === -1 ? '?' : '&';

      var jsonpScript = document.createElement('script');
      jsonpScript.setAttribute('src', '' + url + jsonpCallback + '=' + callbackFunction);
      jsonpScript.id = scriptId;
      document.getElementsByTagName('head')[0].appendChild(jsonpScript);

      timeoutId = setTimeout(function () {
        reject(new Error('JSONP request to ' + _url + ' timed out'));

        clearFunction(callbackFunction);
        removeScript(scriptId);
      }, timeout);
    });
  }

  // export as global function
  /*
  let local;
  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }
  local.fetchJsonp = fetchJsonp;
  */

  module.exports = fetchJsonp;
});

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var whatwgFetch = function (self) {
  'use strict';

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && function () {
      try {
        new Blob();
        return true;
      } catch (e) {
        return false;
      }
    }(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name');
    }
    return name.toLowerCase();
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value;
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function next() {
        var value = items.shift();
        return { done: value === undefined, value: value };
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function () {
        return iterator;
      };
    }

    return iterator;
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function (value, name) {
        this.append(name, value);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function (name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function (name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var list = this.map[name];
    if (!list) {
      list = [];
      this.map[name] = list;
    }
    list.push(value);
  };

  Headers.prototype['delete'] = function (name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function (name) {
    var values = this.map[normalizeName(name)];
    return values ? values[0] : null;
  };

  Headers.prototype.getAll = function (name) {
    return this.map[normalizeName(name)] || [];
  };

  Headers.prototype.has = function (name) {
    return this.map.hasOwnProperty(normalizeName(name));
  };

  Headers.prototype.set = function (name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)];
  };

  Headers.prototype.forEach = function (callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function (name) {
      this.map[name].forEach(function (value) {
        callback.call(thisArg, value, name, this);
      }, this);
    }, this);
  };

  Headers.prototype.keys = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push(name);
    });
    return iteratorFor(items);
  };

  Headers.prototype.values = function () {
    var items = [];
    this.forEach(function (value) {
      items.push(value);
    });
    return iteratorFor(items);
  };

  Headers.prototype.entries = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items);
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'));
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function (resolve, reject) {
      reader.onload = function () {
        resolve(reader.result);
      };
      reader.onerror = function () {
        reject(reader.error);
      };
    });
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    reader.readAsArrayBuffer(blob);
    return fileReaderReady(reader);
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    reader.readAsText(blob);
    return fileReaderReady(reader);
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function (body) {
      this._bodyInit = body;
      if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (!body) {
        this._bodyText = '';
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type');
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob');
        } else {
          return Promise.resolve(new Blob([this._bodyText]));
        }
      };

      this.arrayBuffer = function () {
        return this.blob().then(readBlobAsArrayBuffer);
      };

      this.text = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };
    } else {
      this.text = function () {
        var rejected = consumed(this);
        return rejected ? rejected : Promise.resolve(this._bodyText);
      };
    }

    if (support.formData) {
      this.formData = function () {
        return this.text().then(decode);
      };
    }

    this.json = function () {
      return this.text().then(JSON.parse);
    };

    return this;
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read');
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = input;
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests');
    }
    this._initBody(body);
  }

  Request.prototype.clone = function () {
    return new Request(this);
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function (bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form;
  }

  function headers(xhr) {
    var head = new Headers();
    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n');
    pairs.forEach(function (header) {
      var split = header.trim().split(':');
      var key = split.shift().trim();
      var value = split.join(':').trim();
      head.append(key, value);
    });
    return head;
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText;
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function () {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    });
  };

  Response.error = function () {
    var response = new Response(null, { status: 0, statusText: '' });
    response.type = 'error';
    return response;
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function (url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code');
    }

    return new Response(null, { status: status, headers: { location: url } });
  };

  // self.Headers = Headers
  // self.Request = Request
  // self.Response = Response

  var fetch = function fetch(input, init) {
    // console.log('whatwgFetchWidthTimeout--->'+input, init);
    init = init || { timeout: 30000 };
    return new Promise(function (resolve, reject) {
      var request;
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input;
      } else {
        request = new Request(input, init);
      }

      var xhr = new XMLHttpRequest();

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL;
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL');
        }

        return;
      }

      xhr.onload = function () {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        };
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function () {
        reject(new TypeError('Network request failed due to timeout'));
      };

      xhr.open(request.method, request.url, true);
      xhr.timeout = init.timeout || 30000;

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    });
  };
  return fetch;
}(typeof self !== 'undefined' ? self : undefined);

module.exports = whatwgFetch;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Credential
 * @description SuperMap的安全证书类，其中包括token等安全验证信息。
 *
 * 需要使用用户名和密码在："http://localhost:8090/iserver/services/security/tokens"下申请value
 *
 * 获得形如："2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ.."的value
 *
 * 目前支持的功能包括：地图服务、专题图、量算、查询、公交换乘、空间分析、网络分析，不支持轮询功能。
 */
var Credential = function () {

  /**
   * Constructor: SuperMap.Credential
   * SuperMap地图服务安全验证类。
   *
   * 例如:
   * (start code)
   * var pixcel = new SuperMap.Credential("valueString","token");
   * pixcel.destroy();
   * (end)
   *
   * Parameters:
   * value - {String}  访问受安全限制的服务时用于通过安全认证的验证信息。
   * name - {String}  验证信息前缀，name=value部分的name部分，默认为“token”。
   */

  /**
   * APIProperty: value
   * {String} 访问受安全限制的服务时用于通过安全认证的验证信息。
   */
  function Credential(value, name) {
    _classCallCheck(this, Credential);

    this.value = "";
    this.name = "token";
    this.CLASS_NAME = "SuperMap.Credential";

    this.value = value ? value : this.value;
    this.name = name ? name : this.name;
  }

  /**
   * Property: getUrlParameters
   *
   * 例如:
   * (start code)
   * var credential = new SuperMap.Credential("valueString","token");
   * //这里 str = "token=valueString";
   * var str = credential.getUrlParameters();
   * (end)
   *
   * Returns:
   * {String} 返回安全信息组成的url片段。
   */


  /**
   * APIProperty: name
   * {String} 验证信息前缀，name=value部分的name部分，默认为“token”。
   */


  _createClass(Credential, [{
    key: "getUrlParameters",
    value: function getUrlParameters() {
      //当需要其他安全信息的时候，则需要return this.name + "=" + this.value + "&" + "...";的形式添加。
      return this.name + "=" + this.value;
    }

    /**
     * APIProperty: getValue
     * 获取value
     *
     * 例如:
     * (start code)
     * var credential = new SuperMap.Credential("2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ..","token");
     * //这里 str = "2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ..";
     * var str = credential.getValue();
     * (end)
     *
     * Returns:
     * {String} 返回value字符串，在iServer服务下该value值即为token值。
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this.value;
    }

    /**
     *
     * APIMethod: destroy
     * 销毁此对象。
     * 销毁后此对象的所有属性为null，而不是初始值。
     *
     * 例如:
     * (start code)
     * var credential = new SuperMap.Credential("valueString","token");
     * credential.destroy();
     * (end)
     *
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.value = null;
      this.name = null;
    }
  }]);

  return Credential;
}();

exports.default = Credential;

_SuperMap2.default.Credential = Credential;
/**
 * Constant: CREDENTIAL
 * {<SuperMap.Credential>} 这个对象保存一个安全类的实例，在服务端需要安全验证的时候必须进行
 * 设置。
 *
 * 代码实例:
 * (code)
 *  // 当iServer启用服务安全的时候，下边的代码是必须的。安全证书类能够接收一个value和一个name参数。
 *  var value = "(以iServer为例，这里是申请的token值)";
 *  var name = "token";
 *  // 默认name参数为token，所以当使用iServer服务的时候可以不进行设置。
 *  SuperMap.Credential.CREDENTIAL = new SuperMap.Credential(value, name);
 * (end)
 *
 */

_SuperMap2.default.Credential.CREDENTIAL = null;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Element = undefined;

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _BaseTypes = __webpack_require__(21);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @name Element
 * @memberOf SuperMap
 * @namespace
 * @description SuperMap.Element实现元素的显示，隐藏，删除，取得高度，取得范围等功能。
 */
var Element = exports.Element = _SuperMap2.default.Element = {

    /**
     * @description 判断元素是否可见。
     * @example
     *  //element 必须是页面已经存在了的元素
     * var visible = SuperMap.Element.visible(element);
     * @param element - {HTMLElement} 要进行判断的元素。
     * @returns {Boolean} 返回元素可见性。
     */
    visible: function visible(element) {
        return _Util.Util.getElement(element).style.display !== 'none';
    },

    /**
     * @description 切换传入的DOM元素的可见性。
     * @example
     *  //element1、element2 必须是页面已经存在了的元素
     * //这里传入的数量可以是任意个数
     * SuperMap.Element.toggle(element1,element2);
     * @param element - {HTMLElement} DOM元素，用户可以传入任意数量的元素。
     */
    toggle: function toggle() {
        for (var i = 0, len = arguments.length; i < len; i++) {
            var element = _Util.Util.getElement(arguments[i]);
            var display = Element.visible(element) ? 'none' : '';
            element.style.display = display;
        }
    },

    /**
     * @description 从DOM中删除指定的元素。（自动寻找到父元素，将当前元素删除）
     * @example
     * (start code)
     *  //element 必须是页面已经存在了的元素
     * SuperMap.Element.remove(element);
     * @param element - {HTMLElement} 指定要删除的DOM元素。
     */
    remove: function remove(element) {
        element = _Util.Util.getElement(element);
        element.parentNode.removeChild(element);
    },

    /**
     * @description 获取指定DOM元素的高度。
     * @example
     *  //element 必须是页面已经存在了的元素
     * var height = SuperMap.Element.getHeight(element);
     * @param element - {HTMLElement} 指定要获取高度的DOM元素。
     * @returns {Integer} 指定DOM元素的高度。
     */
    getHeight: function getHeight(element) {
        element = _Util.Util.getElement(element);
        return element.offsetHeight;
    },

    /**
     * @description 获取DOM元素是否设置了className（class ，用于修改CSS）
     * @example
     *  //element 必须是页面已经存在了的元素
     *  //假设 element.className = "className"，那么 isHas = true
     * var isHas = SuperMap.Element.hasClass(element,"className");
     * @param element - {HTMLElement} DOM元素
     * @param name - {string} 需要判定的DOM className
     * @returns {Boolean} 返回DOM元素是否设置了 name这个className属性
     */
    hasClass: function hasClass(element, name) {
        if (!element || !element.className) return false;
        var names = element.className;
        return !!names && new RegExp("(^|\\s)" + name + "(\\s|$)").test(names);
    },

    /**
     * @description 给当前DOM元素的属性className上添加新的name（如果存在了，则不添加）
     * @example
     *  //element 必须是页面已经存在了的元素
     * var element = SuperMap.Element.addClass(element,"className2");
     *  //假设  element.className = "className1";
     *  //添加后  element.className = "className1 className2";
     * @param element - {HTMLElement} DOM元素
     * @param name - {string} 需要新添加的 className
     * @returns {HTMLElement} 返回添加后的DOM元素
     */
    addClass: function addClass(element, name) {
        if (!element) return;
        if (!Element.hasClass(element, name)) {
            element.className += (element.className ? " " : "") + name;
        }
        return element;
    },

    /**
     * @description 在当前DOM元素的属性 className 上移除name
     * @example
     *  //element 必须是页面已经存在了的元素
     * var element = SuperMap.Element.removeClass(element,"className2");
     *  //假设  element.className = "className1 className2";
     *  //移除后 element.className = "className1";
     * @param element - {HTMLElement} DOM元素
     * @param name - {string} 需要移除的  className
     * @returns {HTMLElement} 返回移除后的DOM元素
     */
    removeClass: function removeClass(element, name) {
        if (!Element.hasClass(element, name)) return;
        var names = element.className;
        if (names) {
            element.className = _SuperMap2.default.String.trim(names.replace(new RegExp("(^|\\s+)" + name + "(\\s+|$)"), " "));
        }
        return element;
    },

    /**
     * @description 给DOM移除（存在了name）或添加（不存在）
     * @example
     * //element 必须是页面已经存在了的元素
     * var element = SuperMap.Element.toggleClass(element,"className");
     * @param element - {HTMLElement} DOM对象
     * @param name - {string} 需要判定的className，存在就移除，不存在，就添加
     * @returns {HTMLElement} 修改后的DOM对象
     */
    toggleClass: function toggleClass(element, name) {
        if (Element.hasClass(element, name)) {
            Element.removeClass(element, name);
        } else {
            Element.addClass(element, name);
        }
        return element;
    },

    /**
     * @description 获取指定DOM元素的某一样式的值。
     * @example
     *  //假设界面上有 < canvas id="example" width="150" height="220" style="background-color: #ff0000;">
     *  var element = document.getElementById('example');
     * var style = SuperMap.Element.getStyle(element,"background-color");
     * //style = "rgb(255, 0, 0)";
     * @param element - {HTMLElement} 指定获取样式的DOM元素。
     * @param style - {string} 指定样式名称。
     * @returns {Boolean|String} 返回指定的样式名称对应的样式值。
     */
    getStyle: function getStyle(element, style) {
        element = _Util.Util.getElement(element);

        var value = null;
        if (element && element.style) {
            value = element.style[_BaseTypes.StringExt.camelize(style)];
            if (!value) {
                if (document.defaultView && document.defaultView.getComputedStyle) {

                    var css = document.defaultView.getComputedStyle(element, null);
                    value = css ? css.getPropertyValue(style) : null;
                } else if (element.currentStyle) {
                    value = element.currentStyle[_BaseTypes.StringExt.camelize(style)];
                }
            }

            var positions = ['left', 'top', 'right', 'bottom'];
            if (window.opera && _Util.Util.indexOf(positions, style) !== -1 && Element.getStyle(element, 'position') === 'static') {
                value = 'auto';
            }
        }

        return value === 'auto' ? null : value;
    },

    /**
     * @description 获取指定DOM元素位置信息。
     * @example
     * //假设界面上有 < canvas id="example" width="150" height="220" style="background-color: #ff0000;">
     * var element = document.getElementById('example');
     * var style = SuperMap.Element.getPosition(element);
     * @param node - {HTMLElement} 指定获取样式的DOM元素。。
     * @returns {Object} 返回指定的样式名称对应的位置信息。
     */
    getPosition: function getPosition(node) {
        var scrollx = document.documentElement.scrollLeft || document.body.scrollLeft,
            scrollt = document.documentElement.scrollTop || document.body.scrollTop;
        var pos = node.getBoundingClientRect();
        return { top: pos.top + scrollt, right: pos.right + scrollx, bottom: pos.bottom + scrollt, left: pos.left + scrollx };
    }
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Pixel = __webpack_require__(37);

var _Pixel2 = _interopRequireDefault(_Pixel);

var _Event = __webpack_require__(44);

var _Event2 = _interopRequireDefault(_Event);

var _BaseTypes = __webpack_require__(21);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class: SuperMap.Events
 */
var Events = function () {

    /**
     * Constructor: SuperMap.Events
     * SuperMap.Events 构造函数。
     *
     * Parameters:
     * object - {Object} 当前事件对象被添加到的JS对象
     * element - {DOMElement} 响应浏览器事件的dom元素
     * eventTypes - {Array(String)} 自定义应用事件的数组
     * fallThrough - {Boolean} 是否允许事件处理之后向上传递（冒泡），为false的时候阻止事件冒泡
     * options - {Object} 事件对象选项。
     */


    /**
     * Property: extensionCount
     * {Object} Keys are event types (like in <listeners>), values are the
     *     number of extension listeners for each event type.
     */


    /**
     * APIProperty: includeXY
     * {Boolean} 判断是否让.xy属性自动创建到浏览器上的鼠标事件，一般设置为false，如果设置为true，鼠标事件将会在事件传递过程中自动产生.xy属性。
     * 可根据事件对象的'evt.object'属性在相关的事件句柄上调用getMousePosition函数，如：
     * (code)
     *  function named(evt) {
     *        this.xy = this.object.events.getMousePosition(evt)
     *  }
     * (end)
     *
     * 这个选项习惯默认为false的原因在于，当创建一个事件对象，其主要目的是管理
     * 在一个div的相对定位的鼠标事件,将其设为true也是有意义的。
     *
     * 这个选项也可以用来控制是否抵消缓存。如果设为false不抵消，如果设为true，用this.clearMouseCache() 清除缓存偏移（边界元素偏移，元素在页面的位置偏移）。
     *
     *
     */


    /**
     * Property: eventHandler
     * {Function}  bound event handler attached to elements
     */


    /**
     * Property: element
     * {DOMElement}  the DOM element receiving browser events
     */


    /**
     * Property: listeners
     * {Object} Hashtable of Array(Function): events listener functions
     */
    function Events(object, element, eventTypes, fallThrough, options) {
        _classCallCheck(this, Events);

        this.BROWSER_EVENTS = ["mouseover", "mouseout", "mousedown", "mouseup", "mousemove", "click", "dblclick", "rightclick", "dblrightclick", "resize", "focus", "blur", "touchstart", "touchmove", "touchend", "keydown", "MSPointerDown", "MSPointerUp", "pointerdown", "pointerup", "MSGestureStart", "MSGestureChange", "MSGestureEnd", "contextmenu"];
        this.listeners = null;
        this.object = null;
        this.element = null;
        this.eventTypes = null;
        this.eventHandler = null;
        this.fallThrough = null;
        this.includeXY = false;
        this.extensions = null;
        this.extensionCount = null;
        this.clearMouseListener = null;
        this.CLASS_NAME = "SuperMap.Events";

        _Util.Util.extend(this, options);
        this.object = object;
        this.fallThrough = fallThrough;
        this.listeners = {};
        this.extensions = {};
        this.extensionCount = {};

        // keep a bound copy of handleBrowserEvent() so that we can
        // pass the same function to both Event.observe() and .stopObserving()
        //this.eventHandler = SuperMap.Function.bindAsEventListener(
        //    this.handleBrowserEvent, this
        //);

        // to be used with observe and stopObserving
        //this.clearMouseListener = SuperMap.Function.bind(
        //    this.clearMouseCache, this
        //);

        // if eventTypes is specified, create a listeners list for each
        // custom application event.
        this.eventTypes = [];
        if (eventTypes != null) {
            for (var i = 0, len = eventTypes.length; i < len; i++) {
                this.addEventType(eventTypes[i]);
            }
        }

        // if a dom element is specified, add a listeners list
        // for browser events on the element and register them
        if (element != null) {
            this.attachToElement(element);
        }
    }

    /**
     * APIMethod: destroy
     * 移除当前要素element上的所有事件监听和处理。
     */

    /**
     * Method: clearMouseListener
     * A version of <clearMouseCache> that is bound to this instance so that
     *     it can be used with <SuperMap.Event.observe> and
     *     <SuperMap.Event.stopObserving>.
     */


    /**
     * APIProperty: extensions
     * {Object} Event extensions registered with this instance. Keys are
     *     event types, values are {SuperMap.Events.*} extension instances or
     *     {Boolean} for events that an instantiated extension provides in
     *     addition to the one it was created for.
     *
     * Extensions create an event in addition to browser events, which usually
     * fires when a sequence of browser events is completed. Extensions are
     * automatically instantiated when a listener is registered for an event
     * provided by an extension.
     *
     * Extensions are created in the <SuperMap.Events> namespace using
     * <SuperMap.Class>, and named after the event they provide.
     * The constructor receives the target <SuperMap.Events> instance as
     * argument. Extensions that need to capture browser events before they
     * propagate can register their listeners events using <register>, with
     * {extension: true} as 4th argument.
     *
     * If an extension creates more than one event, an alias for each event
     * type should be created and reference the same class. The constructor
     * should set a reference in the target's extensions registry to itself.
     *
     * Below is a minimal extension that provides the "foostart" and "fooend"
     * event types, which replace the native "click" event type if clicked on
     * an element with the css class "foo":
     *
     * (code)
     *   SuperMap.Events.foostart = SuperMap.Class({
     *       initialize: function(target) {
     *           this.target = target;
     *           this.target.register("click", this, this.doStuff, {extension: true});
     *           // only required if extension provides more than one event type
     *           this.target.extensions["foostart"] = true;
     *           this.target.extensions["fooend"] = true;
     *       },
     *       destroy: function() {
     *           var target = this.target;
     *           target.unregister("click", this, this.doStuff);
     *           delete this.target;
     *           // only required if extension provides more than one event type
     *           delete target.extensions["foostart"];
     *           delete target.extensions["fooend"];
     *       },
     *       doStuff: function(evt) {
     *           var propagate = true;
     *           if (SuperMap.Event.element(evt).className === "foo") {
     *               propagate = false;
     *               var target = this.target;
     *               target.triggerEvent("foostart");
     *               window.setTimeout(function() {
     *                   target.triggerEvent("fooend");
     *               }, 1000);
     *           }
     *           return propagate;
     *       }
     *   });
     *   // only required if extension provides more than one event type
     *   SuperMap.Events.fooend = SuperMap.Events.foostart;
     * (end)
     *
     */


    /**
     * APIProperty: fallThrough
     * {Boolean} 是否允许事件处理之后向上传递（冒泡），为false的时候阻止事件冒泡。
     */


    /**
     * Property: eventTypes
     * {Array(String)}  list of support application events
     */


    /**
     * Property: object
     * {Object}  the code object issuing application events
     */


    /**
     * Constant: BROWSER_EVENTS
     * {Array(String)} 支持的事件。
     */


    _createClass(Events, [{
        key: 'destroy',
        value: function destroy() {
            for (var e in this.extensions) {
                if (typeof this.extensions[e] !== "boolean") {
                    this.extensions[e].destroy();
                }
            }
            this.extensions = null;
            if (this.element) {
                _Event2.default.stopObservingElement(this.element);
                if (this.element.hasScrollEvent) {
                    _Event2.default.stopObserving(window, "scroll", this.clearMouseListener);
                }
            }
            this.element = null;

            this.listeners = null;
            this.object = null;
            this.eventTypes = null;
            this.fallThrough = null;
            this.eventHandler = null;
        }

        /**
         * APIMethod: addEventType
         * 在此事件对象中添加新的事件类型，如果这个事件类型已经添加过了，则不做任何事情。
         *
         * Parameters:
         * eventName - {String} 事件名。
         */

    }, {
        key: 'addEventType',
        value: function addEventType(eventName) {
            if (!this.listeners[eventName]) {
                this.eventTypes.push(eventName);
                this.listeners[eventName] = [];
            }
        }

        /**
         * Method: attachToElement
         *
         * Parameters:
         * element - {HTMLDOMElement} a DOM element to attach browser events to
         */

    }, {
        key: 'attachToElement',
        value: function attachToElement(element) {
            if (this.element) {
                _Event2.default.stopObservingElement(this.element);
            } else {
                // keep a bound copy of handleBrowserEvent() so that we can
                // pass the same function to both Event.observe() and .stopObserving()
                this.eventHandler = _BaseTypes.FunctionExt.bindAsEventListener(this.handleBrowserEvent, this);

                // to be used with observe and stopObserving
                this.clearMouseListener = _BaseTypes.FunctionExt.bind(this.clearMouseCache, this);
            }
            this.element = element;
            for (var i = 0, len = this.BROWSER_EVENTS.length; i < len; i++) {
                var eventType = this.BROWSER_EVENTS[i];

                // every browser event has a corresponding application event
                // (whether it's listened for or not).
                this.addEventType(eventType);

                // use Prototype to register the event cross-browser
                _Event2.default.observe(element, eventType, this.eventHandler);
            }
            // disable dragstart in IE so that mousedown/move/up works normally
            _Event2.default.observe(element, "dragstart", _Event2.default.stop);
        }

        /**
         * APIMethod: on
         * 在一个相同的范围内注册监听器的方法，此方法调用register函数。
         *
         * Example use:
         * (code)
         * // 注册一个"loadstart"监听事件
         * events.on({"loadstart": loadStartListener});
         *
         * // 同样注册一个"loadstart"监听事件
         * events.register("loadstart", undefined, loadStartListener);
         *
         * // 同时为对象注册多个监听事件
         * events.on({
         *     "loadstart": loadStartListener,
         *     "loadend": loadEndListener,
         *     scope: object
         * });
         *
         * // 同时为对象注册多个监听事件，多次调用register方法
         * events.register("loadstart", object, loadStartListener);
         * events.register("loadend", object, loadEndListener);
         * (end)
         *
         * Parameters:
         *  object - {Object}
         */

    }, {
        key: 'on',
        value: function on(object) {
            for (var type in object) {
                if (type !== "scope" && object.hasOwnProperty(type)) {
                    this.register(type, object.scope, object[type]);
                }
            }
        }

        /**
         * APIMethod: register
         * 在事件对象上注册一个事件。当事件被触发时，'func'函数被调用，假设我们触发一个事件，
         * 指定SuperMap.Bounds作为‘obj’,当事件被触发时，回调函数的上下文作为Bounds对象，
         *
         * Parameters:
         * type - {String} 事件注册者的名字
         * obj - {Object} 对象绑定的回调。如果没有特定的对象，则默认是事件的object属性
         * func - {Function} 回调函数，如果没有特定的回调，则这个函数不做任何事情
         * priority - {Boolean|Object} 当为true时将新的监听加在事件队列的前面。
         */

    }, {
        key: 'register',
        value: function register(type, obj, func, priority) {
            if (type in Events && !this.extensions[type]) {
                this.extensions[type] = new Events[type](this);
            }
            if (func != null && _Util.Util.indexOf(this.eventTypes, type) !== -1) {

                if (obj == null) {
                    obj = this.object;
                }
                var listeners = this.listeners[type];
                if (!listeners) {
                    listeners = [];
                    this.listeners[type] = listeners;
                    this.extensionCount[type] = 0;
                }
                var listener = { obj: obj, func: func };
                if (priority) {
                    listeners.splice(this.extensionCount[type], 0, listener);
                    if ((typeof priority === 'undefined' ? 'undefined' : _typeof(priority)) === "object" && priority.extension) {
                        this.extensionCount[type]++;
                    }
                } else {
                    listeners.push(listener);
                }
            }
        }

        /**
         * APIMethod: registerPriority
         * 相同的注册方法，但是在前面增加新的监听者事件查询而代替到方法的结束
         *
         * Parameters:
         * type - {String} 事件注册者的名字
         * obj - {Object} 对象绑定方面的回调。如果没有特定的对象，则默认是事件的object属性
         * func - {Function} 回调函数，如果没有特定的回调，则这个函数不做任何事情
         */

    }, {
        key: 'registerPriority',
        value: function registerPriority(type, obj, func) {
            this.register(type, obj, func, true);
        }

        /**
         * APIMethod: un
         * 在一个相同的范围内取消注册监听器的方法，此方法调用<unregister>函数。
         *
         * Example use:
         * (code)
         * // 移除"loadstart" 事件监听
         * events.un({"loadstart": loadStartListener});
         *
         * // 使用unregister方法移除"loadstart" 事件监听
         * events.unregister("loadstart", undefined, loadStartListener);
         *
         * // 取消对象多个事件监听
         * events.un({
         *     "loadstart": loadStartListener,
         *     "loadend": loadEndListener,
         *     scope: object
         * });
         *
         * // 取消对象多个事件监听，多次调用unregister方法
         * events.unregister("loadstart", object, loadStartListener);
         * events.unregister("loadend", object, loadEndListener);
         * (end)
         */

    }, {
        key: 'un',
        value: function un(object) {
            for (var type in object) {
                if (type !== "scope" && object.hasOwnProperty(type)) {
                    this.unregister(type, object.scope, object[type]);
                }
            }
        }

        /**
         * APIMethod: unregister
         * 反注册
         *
         * Parameters:
         * type - {String}
         * obj - {Object} 默认为 this.object。
         * func - {Function}
         */

    }, {
        key: 'unregister',
        value: function unregister(type, obj, func) {
            if (obj == null) {
                obj = this.object;
            }
            var listeners = this.listeners[type];
            if (listeners != null) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    if (listeners[i].obj === obj && listeners[i].func === func) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        }

        /**
         * Method: remove
         * Remove all listeners for a given event type. If type is not registered,
         *     does nothing.
         *
         * Parameters:
         * type - {String}
         */

    }, {
        key: 'remove',
        value: function remove(type) {
            if (this.listeners[type] != null) {
                this.listeners[type] = [];
            }
        }

        /**
         * APIMethod: triggerEvent
         * 触发一个特定的注册事件.
         *
         * Parameters:
         * type - {String} 触发事件类型。
         * evt - {Event} 事件。
         *
         * Returns:
         * {Boolean} 返回监听对象，如果返回是faler(假)，则停止监听。
         */

    }, {
        key: 'triggerEvent',
        value: function triggerEvent(type, evt) {
            var listeners = this.listeners[type];

            // fast path
            if (!listeners || listeners.length == 0) {
                return undefined;
            }

            // prep evt object with object & div references
            if (evt == null) {
                evt = {};
            }
            evt.object = this.object;
            evt.element = this.element;
            if (!evt.type) {
                evt.type = type;
            }

            // execute all callbacks registered for specified type
            // get a clone of the listeners array to
            // allow for splicing during callbacks
            listeners = listeners.slice();
            var continueChain;
            for (var i = 0, len = listeners.length; i < len; i++) {
                var callback = listeners[i];
                // bind the context to callback.obj
                continueChain = callback.func.apply(callback.obj, [evt]);

                if (continueChain != undefined && continueChain == false) {
                    // if callback returns false, execute no more callbacks.
                    break;
                }
            }
            // don't fall through to other DOM elements
            if (!this.fallThrough) {
                _Event2.default.stop(evt, true);
            }
            return continueChain;
        }

        /**
         * Method: handleBrowserEvent
         * Basically just a wrapper to the triggerEvent() function, but takes
         *     care to set a property 'xy' on the event with the current mouse
         *     position.
         *
         * Parameters:
         * evt - {Event}
         */

    }, {
        key: 'handleBrowserEvent',
        value: function handleBrowserEvent(evt) {
            var type = evt.type,
                listeners = this.listeners[type];
            if (!listeners || listeners.length == 0) {
                // noone's listening, bail out
                return;
            }
            // add clientX & clientY to all events - corresponds to average x, y
            var touches = evt.touches;
            if (touches && touches[0]) {
                var x = 0;
                var y = 0;
                var num = touches.length;
                var touch;
                for (var i = 0; i < num; ++i) {
                    touch = touches[i];
                    x += touch.clientX;
                    y += touch.clientY;
                }
                evt.clientX = x / num;
                evt.clientY = y / num;
            }
            if (this.includeXY) {
                evt.xy = this.getMousePosition(evt);
            }
            this.triggerEvent(type, evt);
        }

        /**
         * APIMethod: clearMouseCache
         * 清除鼠标缓存。
         */

    }, {
        key: 'clearMouseCache',
        value: function clearMouseCache() {
            this.element.scrolls = null;
            this.element.lefttop = null;
            // SuperMap.Util.pagePosition needs to use
            // element.getBoundingClientRect to correctly calculate the offsets
            // for the iPhone, but once the page is scrolled, getBoundingClientRect
            // returns incorrect offsets. So our best bet is to not invalidate the
            // offsets once we have them, and hope that the page was not scrolled
            // when we did the initial calculation.
            var body = document.body;
            if (body && !((body.scrollTop != 0 || body.scrollLeft != 0) && navigator.userAgent.match(/iPhone/i))) {
                this.element.offsets = null;
            }
        }

        /**
         * Method: getMousePosition
         *
         * Parameters:
         * evt - {Event}
         *
         * Returns:
         * {<SuperMap.Pixel>} The current xy coordinate of the mouse, adjusted
         *                      for offsets
         */

    }, {
        key: 'getMousePosition',
        value: function getMousePosition(evt) {
            if (!this.includeXY) {
                this.clearMouseCache();
            } else if (!this.element.hasScrollEvent) {
                _Event2.default.observe(window, "scroll", this.clearMouseListener);
                this.element.hasScrollEvent = true;
            }

            if (!this.element.scrolls) {
                var viewportElement = _Util.Util.getViewportElement();
                this.element.scrolls = [viewportElement.scrollLeft, viewportElement.scrollTop];
            }

            if (!this.element.lefttop) {
                this.element.lefttop = [document.documentElement.clientLeft || 0, document.documentElement.clientTop || 0];
            }

            if (!this.element.offsets) {
                this.element.offsets = _Util.Util.pagePosition(this.element);
            }

            return new _Pixel2.default(evt.clientX + this.element.scrolls[0] - this.element.offsets[0] - this.element.lefttop[0], evt.clientY + this.element.scrolls[1] - this.element.offsets[1] - this.element.lefttop[1]);
        }
    }]);

    return Events;
}();

exports.default = Events;

_SuperMap2.default.Events = Events;
_SuperMap2.default.Events.prototype.BROWSER_EVENTS = ["mouseover", "mouseout", "mousedown", "mouseup", "mousemove", "click", "dblclick", "rightclick", "dblrightclick", "resize", "focus", "blur", "touchstart", "touchmove", "touchend", "keydown", "MSPointerDown", "MSPointerUp", "pointerdown", "pointerup", "MSGestureStart", "MSGestureChange", "MSGestureEnd", "contextmenu"];

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Marker = __webpack_require__(159);

var _Marker2 = _interopRequireDefault(_Marker);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Feature
 * 要素类组合了地理和属性，Feature 类同时具有 marker 和 lonlat 属性。
 */
var Feature = function () {

    /**
     * Constructor: SuperMap.Feature
     * 构造函数，用来创建新的feature对象。
     *
     * Parameters:
     * layer - {<SuperMap.Layer>} 图层。
     * lonlat - {<SuperMap.LonLat>} 经纬度。
     * data - {Object} 数据对象。
     *
     * Returns:
     * {<SuperMap.Feature>}返回一个要素类。
     */


    /**
     * APIProperty: popupClass
     * {<SuperMap.Class>} 用来实例化新的弹出窗口。默认为SuperMap.Popup.AnchoredBubble。
     */


    /**
     * Property: data
     * {Object}
     */


    /**
     * Property: id
     * {String}
     */
    function Feature(layer, lonlat, data) {
        _classCallCheck(this, Feature);

        this.layer = null;
        this.id = null;
        this.lonlat = null;
        this.data = null;
        this.marker = null;
        this.popupClass = null;
        this.popup = null;
        this.CLASS_NAME = "SuperMap.Feature";

        this.layer = layer;
        this.lonlat = lonlat;
        this.data = data != null ? data : {};
        this.id = _Util.Util.createUniqueID(this.CLASS_NAME + "_");
    }

    /**
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */


    /**
     * Property: popup
     * {<SuperMap.Popup>}
     */


    /**
     * Property: marker
     * {<SuperMap.Marker>}
     */


    /**
     * Property: lonlat
     * {<SuperMap.LonLat>}
     */


    /**
     * Property: layer
     * {<SuperMap.Layer>}
     */


    _createClass(Feature, [{
        key: 'destroy',
        value: function destroy() {

            //remove the popup from the map
            if (this.layer != null && this.layer.map != null) {
                if (this.popup != null) {
                    this.layer.map.removePopup(this.popup);
                }
            }
            // remove the marker from the layer
            if (this.layer != null && this.marker != null) {
                this.layer.removeMarker(this.marker);
            }

            this.layer = null;
            this.id = null;
            this.lonlat = null;
            this.data = null;
            if (this.marker != null) {
                this.destroyMarker(this.marker);
                this.marker = null;
            }
            if (this.popup != null) {
                this.destroyPopup(this.popup);
                this.popup = null;
            }
        }

        /**
         * Method: onScreen
         *
         * Returns:
         * {Boolean} Whether or not the feature is currently visible on screen
         *           (based on its 'lonlat' property)
         */

    }, {
        key: 'onScreen',
        value: function onScreen() {
            var onScreen = false;
            if (this.layer != null && this.layer.map != null) {
                var screenBounds = this.layer.map.getExtent();
                onScreen = screenBounds.containsLonLat(this.lonlat);
            }
            return onScreen;
        }

        /**
         * Method: createMarker
         * Based on the data associated with the Feature, create and return a marker object.
         *
         * Returns:
         * {<SuperMap.Marker>} A Marker Object created from the 'lonlat' and 'icon' properties
         *          set in this.data. If no 'lonlat' is set, returns null. If no
         *          'icon' is set, SuperMap.Marker() will load the default image.
         *
         *          Note - this.marker is set to return value
         *
         */

    }, {
        key: 'createMarker',
        value: function createMarker() {
            if (this.lonlat != null) {
                this.marker = new _Marker2.default(this.lonlat, this.data.icon);
            }
            return this.marker;
        }

        /**
         * Method: destroyMarker
         * Destroys marker.
         * If user overrides the createMarker() function, s/he should be able
         *   to also specify an alternative function for destroying it
         */

    }, {
        key: 'destroyMarker',
        value: function destroyMarker() {
            this.marker.destroy();
        }

        /**
         * Method: createPopup
         * Creates a popup object created from the 'lonlat', 'popupSize',
         *     and 'popupContentHTML' properties set in this.data. It uses
         *     this.marker.icon as default anchor.
         *
         *  If no 'lonlat' is set, returns null.
         *  If no this.marker has been created, no anchor is sent.
         *
         *  Note - the returned popup object is 'owned' by the feature, so you
         *      cannot use the popup's destroy method to discard the popup.
         *      Instead, you must use the feature's destroyPopup
         *
         *  Note - this.popup is set to return value
         *
         * Parameters:
         * closeBox - {Boolean} create popup with closebox or not
         *
         * Returns:
         * {<SuperMap.Popup>} Returns the created popup, which is also set
         *     as 'popup' property of this feature. Will be of whatever type
         *     specified by this feature's 'popupClass' property, but must be
         *     of type <SuperMap.Popup>.
         *
         */

    }, {
        key: 'createPopup',
        value: function createPopup(closeBox) {
            if (this.lonlat != null) {
                if (!this.popup) {
                    var anchor = this.marker ? this.marker.icon : null;
                    var popupClass = this.popupClass ? this.popupClass : _SuperMap2.default.Popup.AnchoredBubble;
                    this.popup = new popupClass(this.id + "_popup", this.lonlat, this.data.popupSize, this.data.popupContentHTML, anchor, closeBox);
                }
                if (this.data.overflow != null) {
                    this.popup.contentDiv.style.overflow = this.data.overflow;
                }

                this.popup.feature = this;
            }
            return this.popup;
        }

        /**
         * Method: destroyPopup
         * Destroys the popup created via createPopup.
         *
         * As with the marker, if user overrides the createPopup() function, s/he
         *   should also be able to override the destruction
         */

    }, {
        key: 'destroyPopup',
        value: function destroyPopup() {
            if (this.popup) {
                this.popup.feature = null;
                this.popup.destroy();
                this.popup = null;
            }
        }
    }]);

    return Feature;
}();

exports.default = Feature;

_SuperMap2.default.Feature = Feature;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Event = __webpack_require__(44);

var _Event2 = _interopRequireDefault(_Event);

var _Size = __webpack_require__(45);

var _Size2 = _interopRequireDefault(_Size);

var _Pixel = __webpack_require__(37);

var _Pixel2 = _interopRequireDefault(_Pixel);

var _Element = __webpack_require__(154);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Icon
 *
 * @description 图标类，表示显示在屏幕上的图标，通常与 {<SuperMap.Marker>} 配合使用表示屏幕上显示的Marker。<br>
 *              Icon具有url,size和position属性。也包含偏移量属性，<br>
 *              可以提供作为一个固定的偏移量，也可以函数计算得到期望的偏移量。<br>
 */
var Icon = function () {

    /**
     * Constructor: SuperMap.Icon
     * 创建图标，在网页中表现为div标签中的image标签。
     *
     * 例如:
     * (start code)
     *  size = new SuperMap.Size(44, 33),
     *  offset = new SuperMap.Pixel(-(size.w/2), -size.h),
     *  icon = new SuperMap.Icon("../theme/images/marker.png", size, offset);
     * (end)
     *
     * Parameters:
     * url - {String} 图标对应图片的url地址。
     * size - {<SuperMap.Size>} 指定图标的大小， 为 <SuperMap.Size> 对象。
     * offset - {<SuperMap.Pixel>} 指定图标的偏移量，为 <SuperMap.Pixel> 对象。
     * calculateOffset - {Function}  用于计算偏移量的方法。
     */


    /**
     * Property: imageDiv
     * {DOMElement}
     */


    /**
     * Property: offset
     * {<SuperMap.Pixel>} distance in pixels to offset the image when being rendered
     */


    /**
     * Property: url
     * {String}  image url
     */
    function Icon(url, size, offset, calculateOffset) {
        _classCallCheck(this, Icon);

        this.url = null;
        this.size = null;
        this.offset = null;
        this.calculateOffset = null;
        this.imageDiv = null;
        this.px = null;
        this.CLASS_NAME = "SuperMap.Icon";

        this.url = url;
        this.size = size ? size : new _Size2.default(20, 20);
        this.offset = offset ? offset : new _Pixel2.default(-(this.size.w / 2), -(this.size.h / 2));
        this.calculateOffset = calculateOffset;

        var id = _Util.Util.createUniqueID("SM_icon_");
        this.imageDiv = _Util.Util.createAlphaImageDiv(id);
    }

    /**
     * Method: destroy
     * Nullify references and remove event listeners to prevent circular
     * references and memory leaks
     */


    /**
     * Property: px
     * {<SuperMap.Pixel>}
     */


    /**
     * Property: calculateOffset
     * {<SuperMap.Pixel>} Function to calculate the offset (based on the size)
     */


    /**
     * Property: size
     * {<SuperMap.Size>}
     */


    _createClass(Icon, [{
        key: 'destroy',
        value: function destroy() {
            // erase any drawn elements
            this.erase();
            _Event2.default.stopObservingElement(this.imageDiv.firstChild);
            this.imageDiv.innerHTML = "";
            this.imageDiv = null;
        }

        /**
         * Method: clone
         *
         * Returns:
         * {<SuperMap.Icon>} A fresh copy of the icon.
         */

    }, {
        key: 'clone',
        value: function clone() {
            return new Icon(this.url, this.size, this.offset, this.calculateOffset);
        }

        /**
         * Method: setSize
         *
         * Parameters:
         * size - {<SuperMap.Size>}
         */

    }, {
        key: 'setSize',
        value: function setSize(size) {
            if (size != null) {
                this.size = size;
            }
            this.draw();
        }

        /**
         * Method: setUrl
         *
         * Parameters:
         * url - {String}
         */

    }, {
        key: 'setUrl',
        value: function setUrl(url) {
            if (url != null) {
                this.url = url;
            }
            this.draw();
        }

        /**
         * Method: draw
         * Move the div to the given pixel.
         *
         * Parameters:
         * px - {<SuperMap.Pixel>}
         *
         * Returns:
         * {DOMElement} A new DOM Image of this icon set at the location passed-in
         */

    }, {
        key: 'draw',
        value: function draw(px) {
            _Util.Util.modifyAlphaImageDiv(this.imageDiv, null, null, this.size, this.url, "absolute");
            this.imageDiv.style.cursor = "pointer";
            this.moveTo(px);
            return this.imageDiv;
        }

        /**
         * Method: erase
         * Erase the underlying image element.
         *
         */

    }, {
        key: 'erase',
        value: function erase() {
            if (this.imageDiv != null && this.imageDiv.parentNode != null) {
                _Element.Element.remove(this.imageDiv);
            }
        }

        /**
         * Method: setOpacity
         * Change the icon's opacity
         *
         * Parameters:
         * opacity - {float}
         */

    }, {
        key: 'setOpacity',
        value: function setOpacity(opacity) {
            _Util.Util.modifyAlphaImageDiv(this.imageDiv, null, null, null, null, null, null, null, opacity);
        }

        /**
         * Method: moveTo
         * move icon to passed in px.
         *
         * Parameters:
         * px - {<SuperMap.Pixel>}
         */

    }, {
        key: 'moveTo',
        value: function moveTo(px) {
            //if no px passed in, use stored location
            if (px != null) {
                this.px = px;
            }

            if (this.imageDiv != null) {
                if (this.px == null) {
                    this.display(false);
                } else {
                    if (this.calculateOffset) {
                        this.offset = this.calculateOffset(this.size);
                    }
                    var offsetPx = this.px.offset(this.offset);
                    _Util.Util.modifyAlphaImageDiv(this.imageDiv, null, offsetPx);
                }
            }
        }

        /**
         * Method: display
         * Hide or show the icon
         *
         * Parameters:
         * display - {Boolean}
         */

    }, {
        key: 'display',
        value: function display(_display) {
            this.imageDiv.style.display = _display ? "" : "none";
        }

        /**
         * APIMethod: isDrawn
         *
         * Returns:
         * {Boolean} 图标是否重绘。
         */

    }, {
        key: 'isDrawn',
        value: function isDrawn() {
            // nodeType 11 for ie, whose nodes *always* have a parentNode
            // (of type document fragment)
            var isDrawn = this.imageDiv && this.imageDiv.parentNode && this.imageDiv.parentNode.nodeType !== 11;

            return isDrawn;
        }
    }]);

    return Icon;
}();

exports.default = Icon;

_SuperMap2.default.Icon = Icon;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Projection = __webpack_require__(22);

var _Projection2 = _interopRequireDefault(_Projection);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.LonLat
 * @description 这个类用来表示经度和纬度对。
 */
var LonLat = function () {

    /**
     * Constructor: SuperMap.LonLat
     * 创建一个新的地图位置对象。如：
     * (start code)
     *  var lonLat = new SuperMap.LonLat(30,45);
     *  (end)
     *
     * Parameters (two arguments):
     * lon - {Number} 地图单位上的X轴坐标，如果地图是地理投影，则此值是经度，否则，此值是地图地理位置的x坐标。
     * lat - {Number} 地图单位上的Y轴坐标，如果地图是地理投影，则此值是纬度，否则，此值是地图地理位置的y坐标。
     *
     * Parameters (single argument):
     * location - {Array(Float)} [lon, lat]  横纵坐标组成的数组。
     */


    /**
     * APIProperty: lon
     * {Float} 地图的单位的X轴（横轴）坐标，默认为0.0。
     */
    function LonLat(lon, lat) {
        _classCallCheck(this, LonLat);

        this.lon = 0.0;
        this.lat = 0.0;
        this.CLASS_NAME = "SuperMap.LonLat";

        if (_Util.Util.isArray(lon)) {
            lat = lon[1];
            lon = lon[0];
        }
        this.lon = lon ? _Util.Util.toFloat(lon) : this.lon;
        this.lat = lat ? _Util.Util.toFloat(lat) : this.lat;
    }

    /**
     * APIMethod: toString
     * 返回此对象的字符串形式
     *
     * 例如:
     * (start code)
     * var lonLat = new SuperMap.LonLat(100,50);
     * var str = lonLat.toString();
     * (end)
     *
     * Returns:
     * {String} 例如: "lon=100,lat=50"
     */


    /**
     * APIProperty: lat
     * {Float} 地图的单位的Y轴（纵轴）坐标，默认为0.0。
     */


    _createClass(LonLat, [{
        key: 'toString',
        value: function toString() {
            return "lon=" + this.lon + ",lat=" + this.lat;
        }

        /**
         * APIMethod: toShortString
         * 将经度纬度转换成简单字符串。
         *
         * 例如:
         * (start code)
         * var lonLat = new SuperMap.LonLat(100,50);
         * var str = lonLat.toShortString();
         * (end)
         *
         * Returns:
         * {String} 返回处理后的经纬度字符串。例如："100,50"
         */

    }, {
        key: 'toShortString',
        value: function toShortString() {
            return this.lon + "," + this.lat;
        }

        /**
         * APIMethod: clone
         * 复制坐标对象，并返回复制后的新对象。
         *
         * 例如:
         * (start code)
         * var lonLat1 = new SuperMap.LonLat(100,50);
         * var lonLat2 = lonLat1.clone();
         * (end)
         *
         * Returns:
         * {<SuperMap.LonLat>}  返回相同坐标值的新的坐标对象。
         */

    }, {
        key: 'clone',
        value: function clone() {
            return new LonLat(this.lon, this.lat);
        }

        /**
         * APIMethod: add
         * 在已有坐标对象的经纬度基础上加上新的坐标经纬度，并返回新的坐标对象。
         *
         * 例如:
         * (start code)
         * var lonLat1 = new SuperMap.LonLat(100,50);
         * //lonLat2 是新的对象
         * var lonLat2 = lonLat1.add(100,50);
         * (end)
         *
         * Parameters:
         * lon - {Float} 传入的精度参数。
         * lat - {Float} 传入的纬度参数。
         *
         * Returns:
         * {<SuperMap.LonLat>} 返回一个新的LonLat对象，此对象的经纬度是由传
         *      入的经纬度与当前的经纬度相加所得。
         */

    }, {
        key: 'add',
        value: function add(lon, lat) {
            if (lon == null || lat == null) {
                throw new TypeError('LonLat.add cannot receive null values');
            }
            return new LonLat(this.lon + _Util.Util.toFloat(lon), this.lat + _Util.Util.toFloat(lat));
        }

        /**
         * APIMethod: equals
         * 判断两个坐标对象是否相等。
         *
         * 例如:
         * (start code)
         * var lonLat1 = new SuperMap.LonLat(100,50);
         * var lonLat2 = new SuperMap.LonLat(100,50);
         * var isEquals = lonLat1.equals(lonLat2);
         * (end)
         *
         * Parameters:
         * ll - {<SuperMap.LonLat>} 需要进行比较的坐标对象。
         *
         * Returns:
         * {Boolean} 如果LonLat对象的经纬度和传入的经纬度一致则返回true,不一
         *      致或传入的ll参数为NULL则返回false。
         */

    }, {
        key: 'equals',
        value: function equals(ll) {
            var equals = false;
            if (ll != null) {
                equals = this.lon === ll.lon && this.lat === ll.lat || isNaN(this.lon) && isNaN(this.lat) && isNaN(ll.lon) && isNaN(ll.lat);
            }
            return equals;
        }

        /**
         * APIMethod: transform
         * 经纬度对象的投影转换。
         * （在自身上做投影转换）
         *
         * 例如:
         * (start code)
         * var lonLat1 = new SuperMap.LonLat(100,50);
         * //这里 lonLat1 = lonLat2
         * var lonLat2 = lonLat1.transform(
         *      new SuperMap.Projection("EPSG:4326"),
         *      new SuperMap.Projection("EPSG:3857")
         *  );
         * (end)
         *
         * Parameters:
         * source - {<SuperMap.Projection>} 源投影
         * dest   - {<SuperMap.Projection>} 目标投影
         *
         * Returns:
         * {<SuperMap.LonLat>} 返回转换后的LonLat（坐标对象）。
         */

    }, {
        key: 'transform',
        value: function transform(source, dest) {
            var point = _Projection2.default.transform({ 'x': this.lon, 'y': this.lat }, source, dest);
            this.lon = point.x;
            this.lat = point.y;
            return this;
        }

        /**
         * APIMethod: wrapDateLine
         * 通过传入的范围对象对坐标对象转换到该范围内。
         * 如果经度小于给定范围最小精度，则在原经度基础上加上范围宽度，
         * 直到精度在范围内为止，如果经度大于给定范围则在原经度基础上减去范围宽度。
         * 换句话说就是将不在经度范围内的坐标转换到范围以内。
         *  （只会转换lon，不会转换lat，主要用于转移到日界线以内）
         *
         * 例如:
         * (start code)
         * var lonLat1 = new SuperMap.LonLat(420,50);
         * var lonLat2 = lonLat1.wrapDateLine(
         *      new SuperMap.Bounds(-180,-90,180,90)
         *  );
         * (end)
         *
         * Parameters:
         * maxExtent - {<SuperMap.Bounds>} 最大边界的范围。
         *
         * Returns:
         * {<SuperMap.LonLat>} 将坐标转换到范围对象以内，并返回新的坐标。
         */

    }, {
        key: 'wrapDateLine',
        value: function wrapDateLine(maxExtent) {

            var newLonLat = this.clone();

            if (maxExtent) {
                //shift right?
                while (newLonLat.lon < maxExtent.left) {
                    newLonLat.lon += maxExtent.getWidth();
                }

                //shift left?
                while (newLonLat.lon > maxExtent.right) {
                    newLonLat.lon -= maxExtent.getWidth();
                }
            }

            return newLonLat;
        }

        /**
         *
         * APIMethod: destroy
         * 销毁此对象。
         * 销毁后此对象的所有属性为null，而不是初始值。
         *
         * 例如:
         * (start code)
         * var lonLat = new SuperMap.LonLat(100,50);
         * lonLat.destroy();
         * (end)
         *
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.lon = null;
            this.lat = null;
        }

        /**
         * APIMethod: fromString
         * 通过字符串生成一个<SuperMap.LonLat>对象
         *
         * 例如:
         * (start code)
         * var str = "100,50";
         * var lonLat = SuperMap.LonLat.fromString(str);
         * (end)
         *
         * Parameters:
         * str - {String} 字符串的格式：Lon+","+Lat。如："100,50"
         *
         * Returns:
         * {<SuperMap.LonLat>} 返回一个 <SuperMap.LonLat> 对象
         */

    }], [{
        key: 'fromString',
        value: function fromString(str) {
            var pair = str.split(",");
            return new LonLat(pair[0], pair[1]);
        }

        /**
         * APIMethod: fromArray
         * 通过数组生成一个<SuperMap.LonLat>对象
         *
         * Parameters:
         * arr - {Array(Float)} 数组的格式，长度只能为2,：[Lon,Lat]。如： [5,-42]
         *
         * Returns:
         * {<SuperMap.LonLat>} 返回一个 <SuperMap.LonLat> 对象
         */

    }, {
        key: 'fromArray',
        value: function fromArray(arr) {
            var gotArr = _Util.Util.isArray(arr),
                lon = gotArr && arr[0],
                lat = gotArr && arr[1];
            return new LonLat(lon, lat);
        }
    }]);

    return LonLat;
}();

exports.default = LonLat;

_SuperMap2.default.LonLat = LonLat;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Icon = __webpack_require__(157);

var _Icon2 = _interopRequireDefault(_Icon);

var _Size = __webpack_require__(45);

var _Size2 = _interopRequireDefault(_Size);

var _Pixel = __webpack_require__(37);

var _Pixel2 = _interopRequireDefault(_Pixel);

var _Event = __webpack_require__(44);

var _Event2 = _interopRequireDefault(_Event);

var _BaseTypes = __webpack_require__(21);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  SuperMap.Marker
 * @description 标记覆盖物，对地图上的点进行标注，可以自定义选择标注的图标，需添加到 Markers 图层上显示。
 */
var Marker = function () {

    /**
     * Constructor: SuperMap.Marker
     * 创建标记。通常通过调用 <SuperMap.Layer.Markers> 将标记添加到指定的标记图层。如：
     *
     * (code)
     * var markers = new SuperMap.Layer.Markers( "Markers" );
     * map.addLayer(markers);
     *
     * var size = new SuperMap.Size(21,25);
     * var offset = new SuperMap.Pixel(-(size.w/2), -size.h);
     * var icon = new SuperMap.Icon('..img/marker.png', size, offset);
     * markers.addMarker(new SuperMap.Marker(new SuperMap.LonLat(0,0),icon));
     * (end)
     *
     * Parameters:
     * lonlat - {<SuperMap.LonLat>} 当前标记的位置。
     * icon - {<SuperMap.Icon>}  当前标记的图标。
     */


    /**
     * APIProperty: events
     * {<SuperMap.Events>} the event handler.
     *
     * 支持事件类型:
     * click - 当鼠标单击maker时触发此事件。
     * dblclick - 当鼠标双击maker时触发此事件。
     * mousedown - 当鼠标在maker上按下时触发此事件。
     * mouseup - 当鼠标在maker上按下并放开时触发此事件。
     * mousemove - 当鼠标移过maker时触发此事件。
     * mouseout - 当鼠标移出maker时触发此事件。
     * mouseover - 当鼠标移进maker时触发此事件。
     * rightclick -  当鼠标右键单击maker时触发此事件。
     * touchstart - 当在触摸屏上对marker开始进行触摸时触发此事件。
     * touchmove -  当在触摸屏上对marker进行触摸并移动时触发此事件。
     * touchend -  当在触摸屏上对marker触摸完成时触发此事件。
     *
     *
     *
     * (start code)
     * //例如点击marker弹出popup
     * marker.events.on({
     *    "click":openInfoWin,
     *    "scope": marker
     * });
     *
     * function openInfoWin(){
     *     var marker = this;
     *     var lonlat = marker.getLonLat();
     *     var contentHTML = "<div style='font-size:.8em; opacity: 0.8; overflow-y:hidden;'>";
     *     contentHTML += "<div>"+marker.sm_capital+"</div></div>";
     *
     *     var popup = new SuperMap.Popup.FramedCloud("popwin",new SuperMap.LonLat(lonlat.lon,lonlat.lat),null,contentHTML,null,true);
     *     map.addPopup(popup);
     * }
     * (end)
     */


    /**
     * Property: icon
     * {<SuperMap.Icon>} The icon used by this marker.
     */
    function Marker(lonlat, icon) {
        _classCallCheck(this, Marker);

        this.icon = null;
        this.lonlat = null;
        this.events = null;
        this.map = null;
        this.CLASS_NAME = "SuperMap.Marker";

        var t = this;
        this.lonlat = lonlat;

        var newIcon = icon ? icon.clone() : Marker.defaultIcon();
        if (this.icon == null) {
            this.icon = newIcon;
        } else {
            this.icon.url = newIcon.url;
            this.icon.size = newIcon.size;
            this.icon.offset = newIcon.offset;
            this.icon.calculateOffset = newIcon.calculateOffset;
        }
        this.events = new Events(this, this.icon.imageDiv, ["rightclick"]);

        var eventHandler = _BaseTypes.FunctionExt.bindAsEventListener(function (evt) {
            if (evt.preventDefault) evt.preventDefault();
            t.events.triggerEvent("rightclick", evt);
            return false;
        }, this.events);

        _Event2.default.observe(this.icon.imageDiv, "contextmenu", eventHandler);
    }

    /**
     * APIMethod: getLonLat
     * 获取marker的当前坐标
     *
     * Returns:
     * {SuperMap.LonLat}
     */


    /**
     * Property: map
     * {<SuperMap.Map>} the map this marker is attached to
     */


    /**
     * Property: lonlat
     * {<SuperMap.LonLat>} location of object
     */


    _createClass(Marker, [{
        key: 'getLonLat',
        value: function getLonLat() {
            return this.lonlat;
        }

        /**
         * APIMethod: destroy
         * 清除标记，需要首先移除图层上添加的标记，在标记内不能执行此操作，因为不知道标记连接到哪个图层。
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            // erase any drawn features
            this.erase();

            this.map = null;

            this.events.destroy();
            this.events = null;

            if (this.icon != null) {
                this.icon.destroy();
                this.icon = null;
            }
        }

        /**
         * Method: draw
         * Calls draw on the icon, and returns that output.
         *
         * Parameters:
         * px - {<SuperMap.Pixel>}
         *
         * Returns:
         * {DOMElement} A new DOM Image with this marker's icon set at the
         * location passed-in
         */

    }, {
        key: 'draw',
        value: function draw(px) {
            return this.icon.draw(px);
        }

        /**
         * Method: erase
         * Erases any drawn elements for this marker.
         */

    }, {
        key: 'erase',
        value: function erase() {
            if (this.icon != null) {
                this.icon.erase();
            }
        }

        /**
         * Method: moveTo
         * Move the marker to the new location.
         *
         * Parameters:
         * px - {<SuperMap.Pixel>} the pixel position to move to
         */

    }, {
        key: 'moveTo',
        value: function moveTo(px) {
            if (px != null && this.icon != null) {
                this.icon.moveTo(px);
            }
            this.lonlat = this.map.getLonLatFromLayerPx(px);
        }

        /**
         * APIMethod: isDrawn
         * 获取标记是否绘制。
         * Returns:
         * {Boolean} 标记是否被绘制。
         */

    }, {
        key: 'isDrawn',
        value: function isDrawn() {
            var isDrawn = this.icon && this.icon.isDrawn();
            return isDrawn;
        }

        /**
         * Method: onScreen
         *
         * Returns:
         * {Boolean} Whether or not the marker is currently visible on screen.
         */

    }, {
        key: 'onScreen',
        value: function onScreen() {
            var onScreen = false;
            if (this.map) {
                var screenBounds = this.map.getExtent();
                onScreen = screenBounds.containsLonLat(this.lonlat);
            }
            return onScreen;
        }

        /**
         * Method: inflate
         * Englarges the markers icon by the specified ratio.
         *
         * Parameters:
         * inflate - {float} the ratio to enlarge the marker by (passing 2
         *                   will double the size).
         */

    }, {
        key: 'inflate',
        value: function inflate(_inflate) {
            if (this.icon) {
                var newSize = new _Size2.default(this.icon.size.w * _inflate, this.icon.size.h * _inflate);
                this.icon.setSize(newSize);
            }
        }

        /**
         * Method: setOpacity
         * Change the opacity of the marker by changin the opacity of
         *   its icon
         *
         * Parameters:
         * opacity - {float}  Specified as fraction (0.4, etc)
         */

    }, {
        key: 'setOpacity',
        value: function setOpacity(opacity) {
            this.icon.setOpacity(opacity);
        }

        /**
         * Method: setUrl
         * Change URL of the Icon Image.
         *
         * url - {String}
         */

    }, {
        key: 'setUrl',
        value: function setUrl(url) {
            this.icon.setUrl(url);
        }

        /**
         * Method: display
         * Hide or show the icon
         *
         * display - {Boolean}
         */

    }, {
        key: 'display',
        value: function display(_display) {
            this.icon.display(_display);
        }

        /**
         * Function: defaultIcon
         * Creates a default <SuperMap.Icon>.
         *
         * Returns:
         * {<SuperMap.Icon>} A default SuperMap.Icon to use for a marker
         */

    }], [{
        key: 'defaultIcon',
        value: function defaultIcon() {
            var url = "";
            var size = new _Size2.default(21, 25);
            var calculateOffset = function calculateOffset(size) {
                return new _Pixel2.default(-(size.w / 2), -size.h);
            };

            return new _Icon2.default(url, size, null, calculateOffset);
        }
    }]);

    return Marker;
}();

exports.default = Marker;


_SuperMap2.default.Marker = Marker;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Feature2 = __webpack_require__(156);

var _Feature3 = _interopRequireDefault(_Feature2);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// TRASH THIS
_SuperMap2.default.State = {
    /** states */
    UNKNOWN: 'Unknown',
    INSERT: 'Insert',
    UPDATE: 'Update',
    DELETE: 'Delete'
};

/**
 * @requires SuperMap/Feature.js
 * @requires SuperMap/Util.js
 */

/**
 * Class: SuperMap.Feature.Vector
 * 矢量要素类。该类具有 Geometry 属性存放几何信息，
 * attributes 属性存放非几何信息，另外还包含了 style 属性，用来定义矢量要素的样式，
 * 其中，默认的样式在 <SuperMap.Feature.Vector.style> 类中定义，如果没有特别的指定将使用默认的样式，
 *
 * Inherits from:
 *  - <SuperMap.Feature>
 */

var Vector = function (_Feature) {
    _inherits(Vector, _Feature);

    /**
     * Constructor: SuperMap.Feature.Vector
     * 实例化矢量要素。
     * (code)
     *  var geometry = new SuperMap.Geometry.Point(-115,10);
     *  var style = {
     *      strokeColor:"#339933",
     *      strokeOpacity:1,
     *      strokeWidth:3,
     *      pointRadius:6
     *  }
     *  var pointFeature = new SuperMap.Feature.Vector(geometry,null,style);
     *  vectorLayer.addFeatures(pointFeature);
     * (end)
     *
     * Parameters:
     * geometry - {<SuperMap.Geometry>} 代表要素的几何形状。
     * attributes - {Object} 描述要素的任意的可序列化属性，将要映射到 attributes 属性中的可选对象。
     * style - {Object} 一个可选的样式对象。
     */


    /**
     * APIProperty: renderIntent
     * {String} Feature要素即被被渲染的样式状态，对应StyleMap中的状态定义的可选值。
     */


    /**
     * APIProperty: style
     * {Object} 要素的样式属性，地图查询返回的feature的style，8C变为null。
     */


    /**
     * Property: bounds
     * {<SuperMap.Bounds>} The box bounding that feature's geometry, that
     *     property can be set by an <SuperMap.Format> object when
     *     deserializing the feature, so in most cases it represents an
     *     information set by the server.
     */


    /**
     * APIProperty: geometry
     * {<SuperMap.Geometry>} 该属性用于存放几何信息。
     */
    function Vector(geometry, attributes, style) {
        _classCallCheck(this, Vector);

        var _this = _possibleConstructorReturn(this, (Vector.__proto__ || Object.getPrototypeOf(Vector)).call(this, null, null, attributes));

        _this.fid = null;
        _this.geometry = null;
        _this.attributes = null;
        _this.bounds = null;
        _this.state = null;
        _this.style = null;
        _this.url = null;
        _this.renderIntent = "default";
        _this.modified = null;
        _this.CLASS_NAME = "SuperMap.Feature.Vector";

        _this.lonlat = null;
        _this.geometry = geometry ? geometry : null;
        _this.state = null;
        _this.attributes = {};
        if (attributes) {
            _this.attributes = _Util.Util.extend(_this.attributes, attributes);
        }
        _this.style = style ? style : null;
        return _this;
    }

    /**
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */


    /**
     * APIProperty: modified
     * {Object} 一个具有可以被改变的原始几何形状和属性，被 <SuperMap.Control.ModifyFeature> 写入。
     * 应用程序可以在attributes中设置原始的能被修改的属性，需要注意的是，
     * 应用程序需要在使用某个对象及其属性前检测这个对象及其 attributes 属性是否创建，用 ModifyFeature
     * 改变之后，这个对象如下所示：
     *
     * (code)
     * {
     *     geometry: >Object
     * }
     * (end)
     *
     * 当应用程序需要对要素的 attributes 进行修改，则需要如下设置 attributes：
     *
     * (code)
     * {
     *     attributes: {
     *         myAttribute: "original"
     *     }
     * }
     * (end)
     *
     */


    /**
     * APIProperty: url
     * {String} 如果设置了这个属性，在更新或者删除要素时需要考虑 <SuperMap.HTTP> 。
     */


    /**
     * Property: state
     * {String}
     */


    /**
     * APIProperty: attributes
     * {Object} 描述要素的任意的可序列化属性。
     */


    /**
     * Property: fid
     * {String}
     */


    _createClass(Vector, [{
        key: 'destroy',
        value: function destroy() {
            if (this.layer) {
                this.layer.removeFeatures(this);
                this.layer = null;
            }

            this.geometry = null;
            this.modified = null;
            _get(Vector.prototype.__proto__ || Object.getPrototypeOf(Vector.prototype), 'destroy', this).call(this);
        }

        /**
         * Method: clone
         * Create a clone of this vector feature.  Does not set any non-standard
         *     properties.
         *
         * Returns:
         * {<SuperMap.Feature.Vector>} An exact clone of this vector feature.
         */

    }, {
        key: 'clone',
        value: function clone() {
            return new Vector(this.geometry ? this.geometry.clone() : null, this.attributes, this.style);
        }

        /**
         * Method: onScreen
         * Determine whether the feature is within the map viewport.  This method
         *     tests for an intersection between the geometry and the viewport
         *     bounds.  If a more effecient but less precise geometry bounds
         *     intersection is desired, call the method with the boundsOnly
         *     parameter true.
         *
         * Parameters:
         * boundsOnly - {Boolean} Only test whether a feature's bounds intersects
         *     the viewport bounds.  Default is false.  If false, the feature's
         *     geometry must intersect the viewport for onScreen to return true.
         *
         * Returns:
         * {Boolean} The feature is currently visible on screen (optionally
         *     based on its bounds if boundsOnly is true).
         */

    }, {
        key: 'onScreen',
        value: function onScreen(boundsOnly) {
            var onScreen = false;
            if (this.layer && this.layer.map) {
                var screenBounds = this.layer.map.getExtent();
                if (boundsOnly) {
                    var featureBounds = this.geometry.getBounds();
                    onScreen = screenBounds.intersectsBounds(featureBounds);
                } else {
                    var screenPoly = screenBounds.toGeometry();
                    onScreen = screenPoly.intersects(this.geometry);
                }
            }
            return onScreen;
        }

        /**
         * Method: getVisibility
         * Determine whether the feature is displayed or not. It may not displayed
         *     because:
         *     - its style display property is set to 'none',
         *     - it doesn't belong to any layer,
         *     - the styleMap creates a symbolizer with display property set to 'none'
         *          for it,
         *     - the layer which it belongs to is not visible.
         *
         * Returns:
         * {Boolean} The feature is currently displayed.
         */

    }, {
        key: 'getVisibility',
        value: function getVisibility() {
            return !(this.style && this.style.display === 'none' || !this.layer || this.layer && this.layer.styleMap && this.layer.styleMap.createSymbolizer(this, this.renderIntent).display === 'none' || this.layer && !this.layer.getVisibility());
        }

        /**
         * Method: createMarker
         * HACK - we need to decide if all vector features should be able to
         *     create markers
         *
         * Returns:
         * {<SuperMap.Marker>} For now just returns null
         */

    }, {
        key: 'createMarker',
        value: function createMarker() {
            return null;
        }

        /**
         * Method: destroyMarker
         * HACK - we need to decide if all vector features should be able to
         *     delete markers
         *
         * If user overrides the createMarker() function, s/he should be able
         *   to also specify an alternative function for destroying it
         */

    }, {
        key: 'destroyMarker',
        value: function destroyMarker() {}
        // pass


        /**
         * Method: createPopup
         * HACK - we need to decide if all vector features should be able to
         *     create popups
         *
         * Returns:
         * {<SuperMap.Popup>} For now just returns null
         */

    }, {
        key: 'createPopup',
        value: function createPopup() {
            return null;
        }

        /**
         * Method: atPoint
         * Determins whether the feature intersects with the specified location.
         *
         * Parameters:
         * lonlat - {<SuperMap.LonLat>}
         * toleranceLon - {float} Optional tolerance in Geometric Coords
         * toleranceLat - {float} Optional tolerance in Geographic Coords
         *
         * Returns:
         * {Boolean} Whether or not the feature is at the specified location
         */

    }, {
        key: 'atPoint',
        value: function atPoint(lonlat, toleranceLon, toleranceLat) {
            var atPoint = false;
            if (this.geometry) {
                atPoint = this.geometry.atPoint(lonlat, toleranceLon, toleranceLat);
            }
            return atPoint;
        }

        /**
         * Method: destroyPopup
         * HACK - we need to decide if all vector features should be able to
         * delete popups
         */

    }, {
        key: 'destroyPopup',
        value: function destroyPopup() {}
        // pass


        /**
         * Method: move
         * Moves the feature and redraws it at its new location
         *
         * Parameters:
         * state - {SuperMap.LonLat or SuperMap.Pixel} the
         *         location to which to move the feature.
         */

    }, {
        key: 'move',
        value: function move(location) {

            if (!this.layer || !this.geometry.move) {
                //do nothing if no layer or immoveable geometry
                return undefined;
            }

            var pixel;
            if (location.CLASS_NAME === "SuperMap.LonLat") {
                pixel = this.layer.getViewPortPxFromLonLat(location);
            } else {
                pixel = location;
            }

            var lastPixel = this.layer.getViewPortPxFromLonLat(this.geometry.getBounds().getCenterLonLat());
            var res = this.layer.map.getResolution();
            this.geometry.move(res * (pixel.x - lastPixel.x), res * (lastPixel.y - pixel.y));
            this.layer.drawFeature(this);
            return lastPixel;
        }

        /**
         * Method: toState
         * Sets the new state
         *
         * Parameters:
         * state - {String}
         */

    }, {
        key: 'toState',
        value: function toState(state) {
            if (state === _SuperMap2.default.State.UPDATE) {
                switch (this.state) {
                    case _SuperMap2.default.State.UNKNOWN:
                    case _SuperMap2.default.State.DELETE:
                        this.state = state;
                        break;
                    case _SuperMap2.default.State.UPDATE:
                    case _SuperMap2.default.State.INSERT:
                        break;
                }
            } else if (state === _SuperMap2.default.State.INSERT) {
                switch (this.state) {
                    case _SuperMap2.default.State.UNKNOWN:
                        break;
                    default:
                        this.state = state;
                        break;
                }
            } else if (state === _SuperMap2.default.State.DELETE) {
                switch (this.state) {
                    case _SuperMap2.default.State.INSERT:
                        // the feature should be destroyed
                        break;
                    case _SuperMap2.default.State.DELETE:
                        break;
                    case _SuperMap2.default.State.UNKNOWN:
                    case _SuperMap2.default.State.UPDATE:
                        this.state = state;
                        break;
                }
            } else if (state === _SuperMap2.default.State.UNKNOWN) {
                this.state = state;
            }
        }

        /**
         * Constant: SuperMap.Feature.Vector.style
         * SuperMap.features有大量的样式属性，如果没有特别的指定将使用默认的样式，
         * 大部分样式通过SVG标准定义属性。
         *  fill properties资料介绍: http://www.w3.org/TR/SVG/painting.html#FillProperties
         *  stroke properties资料介绍: http://www.w3.org/TR/SVG/painting.html#StrokeProperties
         *
         * Symbolizer properties:
         * fill - {Boolean} 不需要填充则设置为false。
         * fillColor - {String} 十六进制填充颜色，默认为"#ee9900"。
         * fillOpacity - {Number} 填充不透明度。默认为0.4。
         * stroke - {Boolean} 不需要描边则设为false。
         * strokeColor - {String} 十六进制描边颜色。
         * strokeOpacity - {Number} 描边的不透明度(0-1),默认为0.4。
         * strokeWidth - {Number} 像素描边宽度，默认为1。
         * strokeLinecap - {String} strokeLinecap有三种类型butt，round，square，默认为"round"。
         * strokeDashstyle - {String} 有dot,dash,dashot,longdash,longdashdot,solid几种样式，默认为"solid"。
         * graphic - {Boolean} 不需要则设置为false。
         * pointRadius - {Number} 像素点半径，默认为6
         * pointerEvents - {String}  默认为"visiblePainted"。
         * cursor - {String} 默认为""。
         * allowRotate -{String} 是否允许图标随着运行方向旋转，默认为false。用于时空数据图层
         * externalGraphic - {String} 连接到用来渲染点的外部的图形。
         * graphicWidth - {Number} 外部图表的像素宽度。
         * graphicHeight - {Number} 外部图表的高宽度。
         * graphicOpacity - {Number} 外部图表的不透明度(0-1)。
         * graphicXOffset - {Number} 外部图表沿着x方向的偏移量。
         * graphicYOffset - {Number} 外部图表沿着y方向的偏移量Pixel。
         * rotation - {Number} 一个图表沿着其中心点（或者偏移中心指定点）在顺时针方向旋转。
         * graphicZIndex - {Number} 渲染时使用的索引值。The integer z-index value to use in rendering。
         * graphicName - {String} 渲染点时图标使用的名字。支持"circle" , "square", "star", "x", "cross", "triangle"，
         * 默认为"circle"。
         * graphicTitle - {String} 外部图表的提示框。
         * backgroundGraphic - {String} 外部图表的背景。
         * backgroundGraphicZIndex - {Number} 背景图渲染时使用的索引值。
         * backgroundXOffset - {Number} 背景图在x轴的偏移量。
         * backgroundYOffset - {Number} 背景图在x轴的偏移量。
         * backgroundHeight - {Number} 背景图的高度。如果没有设置，将用graphicHeight。
         * backgroundWidth - {Number} 背景图的宽度。如果没有设置，将用graphicWidth。
         * isUnicode - {Boolean} 这个属性要配合label属性来用，当为true时，label就可以使用unicode编码，
         * 比如"a"的unicode十六进制编码为61，则label属性可以为"&#x61;",其中"&#"为前缀，标志这个为unicode编码，
         * "x"是指16进制,这时页面显示的是"a"；当此值为false的时候，label的内容会被直接输出，
         * 比如，label为"&#x61;"，这时页面显示的也是"&#x61;"。默认为false。
         * label - {String} 可选的标签文本。
         * labelAlign - {String} 标签对齐，是由两个字符组成的字符串，如："lt", "cm", "rb"，
         * 其中第一个字符代表水平方向上的对齐，"l"=left, "c"=center, "r"=right；
         * 第二个字符代表垂直方向上的对齐，"t"=top, "m"=middle, "b"=bottom。
         * labelXOffset - {Number} 标签在x轴方向的偏移量。
         * labelYOffset - {Number} 标签在y轴方向的偏移量。
         * labelSelect - {Boolean} 如果设为true，标签可以选用SelectFeature或者similar控件，默认为false。
         * fontColor - {String} 标签字体颜色。
         * fontOpacity - {Number} 标签透明度 (0-1)。
         * fontFamily - {String} 标签的字体类型。
         * fontSize - {String} 标签的字体大小。
         * fontStyle - {String} 标签的字体样式。
         * fontWeight - {String} 标签的字体粗细。
         * display - {String} 如果display属性设置为“none”，符号将没有任何效果。
         * (start code)
         *  // label的用法如下：
         *  function addGeoTest(){
        *  var geometry = new SuperMap.Geometry.Point(105, 35);
        *  var pointFeature = new SuperMap.Feature.Vector(geometry);
        *  var styleTest = {
        *        label:"supermap",
        *        fontColor:"#0000ff",
        *        fontOpacity:"0.5",
        *        fontFamily:"隶书",
        *        fontSize:"8em",
        *        fontWeight:"bold",
        *        fontStyle:"italic",
        *        labelSelect:"true",
        *     }
        *           pointFeature.style = styleTest;
        *          vectorLayer.addFeatures([pointFeature]);
        *         }
         * (end)
         */

    }]);

    return Vector;
}(_Feature3.default);

Vector.style = {
    'default': {
        fillColor: "#ee9900",
        fillOpacity: 0.4,
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#ee9900",
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    },
    'select': {
        fillColor: "blue",
        fillOpacity: 0.4,
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "blue",
        strokeOpacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "pointer",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'temporary': {
        fillColor: "#66cccc",
        fillOpacity: 0.2,
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#66cccc",
        strokeOpacity: 1,
        strokeLinecap: "round",
        strokeWidth: 2,
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        //cursor:"inherit",
        cursor: "default",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'delete': {
        display: "none"
    }
};
exports.default = Vector;

_SuperMap2.default.Feature.Vector = Vector;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _MultiPoint2 = __webpack_require__(46);

var _MultiPoint3 = _interopRequireDefault(_MultiPoint2);

var _Projection = __webpack_require__(22);

var _Projection2 = _interopRequireDefault(_Projection);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.Curve
 * @classdesc 几何对象曲线类。
 * @extends SuperMap.Geometry.MultiPoint
 * @param components - {Array<SuperMap.Geometry.Point>}几何对象数组。
 * @example
 * var point1 = new SuperMap.Geometry.Point(10,20);
 * var point2 = new SuperMap.Geometry.Point(30,40);
 * var curve = new SuperMap.Geometry.Curve([point1,point2]);
 */
var Curve = function (_MultiPoint) {
    _inherits(Curve, _MultiPoint);

    function Curve(points) {
        _classCallCheck(this, Curve);

        var _this = _possibleConstructorReturn(this, (Curve.__proto__ || Object.getPrototypeOf(Curve)).call(this, points));

        _this.componentTypes = ["SuperMap.Geometry.Point", "SuperMap.PointWithMeasure"];
        _this.CLASS_NAME = "SuperMap.Geometry.Curve";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.Curve.prototype.getLength
     * @description 获取曲线的总长度。
     * @returns {number} 曲线对象的长度。
     */


    /**
     * @member SuperMap.Geometry.Curve.prototype.componentTypes -{Array<string>}
     * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
     * @readonly
     * @default ["{@link SuperMap.Geometry.Point}", "{@link SuperMap.PointWithMeasure}"]
     */


    _createClass(Curve, [{
        key: 'getLength',
        value: function getLength() {
            var length = 0.0;
            if (this.components && this.components.length > 1) {
                for (var i = 1, len = this.components.length; i < len; i++) {
                    length += this.components[i - 1].distanceTo(this.components[i]);
                }
            }
            return length;
        }

        /**
         * @function SuperMap.Geometry.Curve.prototype.getGeodesicLength
         * @description 计算几何对象投影到球面上的近似大地测量长度。
         * @param projection - {SuperMap.Projection} 空间参考系统的几何坐标。如果没有设置，默认 WGS84。
         * @returns {number} 几何图形的近似大地测量长度，单位：meters。
         */

    }, {
        key: 'getGeodesicLength',
        value: function getGeodesicLength(projection) {
            var geom = this; // so we can work with a clone if needed
            if (projection) {
                var gg = new _Projection2.default("EPSG:4326");
                if (!gg.equals(projection)) {
                    geom = this.clone().transform(projection, gg);
                }
            }
            var length = 0.0;
            if (geom.components && geom.components.length > 1) {
                var p1, p2;
                for (var i = 1, len = geom.components.length; i < len; i++) {
                    p1 = geom.components[i - 1];
                    p2 = geom.components[i];
                    // this returns km and requires lon/lat properties
                    length += _Util.Util.distVincenty({ lon: p1.x, lat: p1.y }, { lon: p2.x, lat: p2.y });
                }
            }
            // convert to m
            return length * 1000;
        }
    }]);

    return Curve;
}(_MultiPoint3.default);

exports.default = Curve;

_SuperMap2.default.Geometry.Curve = Curve;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TimeControlBase
 * @classdesc 时间控制基类类。
 * @param options - {Object} 该类开放的可选属性。如：<br>
 *        speed - {number}速度。不能小于0，默认为1（表示每帧渲染的数据之间的间隔为1），设置越大速度越快。<br>
 *        startTime - {number}的起始时间，必须为数字，且小于等于endTime。如果不设置，初始化时为0，建议设置。<br>
 *        endTime - {number}的结束时间，必须为数字，且大于等于startTime。如果不设置，初始化时以当前时间进行设置，建议设置。<br>
 *        repeat - {boolean} 是否重复循环。默认为true。<br>
 *        reverse - {boolean} 是否反向。默认为false。<br>
 *        geoFence - {SuperMap.Geometry} 地理围栏。
 */
var TimeControlBase = function () {

    /*
     * Constant: EVENT_TYPES
     * {Array<String>}
     * 此类支持的事件类型。
     *
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.running -{boolean}
     * @description 记录当前是否处于运行中，默认为false。
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.currentTime -{number}
     * @description 记录近期的时间，也就是当前帧运行到的时间。
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.endTime -{number}
     * @description 记录的结束时间，必须为数字，
     *              如果不设置，初始化时以当前时间进行设置，建议设置
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.frequency -{number}
     * @description 刷新频率(单位ms)，服务器刷新的时间间隔，默认为1s
     */
    function TimeControlBase(options) {
        _classCallCheck(this, TimeControlBase);

        this.speed = 1;
        this.frequency = 1000;
        this.startTime = null;
        this.endTime = null;
        this.repeat = true;
        this.currentTime = null;
        this.oldTime = null;
        this.running = false;
        this.reverse = false;
        this.EVENT_TYPES = ["start", "pause", "stop"];
        this.events = null;
        this.CLASS_NAME = "SuperMap.TimeControlBase";

        //设置步长，刷新频率、开始结束时间、是否循环、是否反向
        var me = this;
        options = options || {};
        me.speed = options.speed && options.speed >= 0 ? options.speed : me.speed;
        me.frequency = options.speed && options.frequency >= 0 ? options.frequency : me.frequency;
        me.startTime = options.startTime && options.startTime != null ? options.startTime : 0;
        me.endTime = options.endTime && options.endTime != null && options.endTime >= me.startTime ? options.endTime : +new Date();
        me.repeat = options.repeat != undefined ? options.repeat : me.repeat;
        me.reverse = options.reverse != undefined ? options.reverse : me.reverse;

        me.speed = Number(me.speed);
        me.frequency = Number(me.frequency);
        me.startTime = Number(me.startTime);
        me.endTime = Number(me.endTime);

        me.events = new _SuperMap2.default.Events(this, null, this.EVENT_TYPES);
        me.startTime = Date.parse(new Date(this.startTime));
        me.endTime = Date.parse(new Date(this.endTime));

        //初始化处于非运行阶段
        me.running = false;

        //初始化当前时间
        me.currentTime = me.startTime;
    }

    /**
     * @function SuperMap.TimeControlBase.prototype.updateOptions
     * @param options - {Object} 设置参数得可选参数。设置步长，刷新频率、开始结束时间、是否循环、是否反向。
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.events -{SuperMap.Events}
     * @description 事件
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.reverse -{boolean}
     * @description 是否反向，默认为false。
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.oldTime -{number}
     * @description 记录上一帧的时间，也就是之前运行到的时间。
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.repeat -{boolean}
     * @description 是否重复循环，默认为true。
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.startTime -{number}
     * @description 记录的起始时间，必须为数字，
     *              如果不设置，初始化时为0，建议设置
     */


    /**
     * @member SuperMap.TimeControlBase.prototype.speed -{number}
     * @description 步长，必须为非负数，默认为1（表示前后两次渲染的数据之间的间隔为1）
     */


    _createClass(TimeControlBase, [{
        key: "updateOptions",
        value: function updateOptions(options) {
            //设置步长，刷新频率、开始结束时间、是否循环、是否反向
            var me = this;
            options = options || {};
            if (options.speed && options.speed >= 0) {
                me.speed = options.speed;
                me.speed = Number(me.speed);
            }

            if (options.speed && options.frequency >= 0) {
                me.frequency = options.frequency;
                me.frequency = Number(me.frequency);
            }

            if (options.startTime && options.startTime != null) {
                me.startTime = options.startTime;
                me.startTime = Date.parse(new Date(me.startTime));
            }

            if (options.endTime && options.endTime != null && options.endTime >= me.startTime) {
                me.endTime = options.endTime;
                me.endTime = Date.parse(new Date(me.endTime));
            }

            if (options.repeat != null) {
                me.repeat = options.repeat;
            }

            if (options.reverse != null) {
                me.reverse = options.reverse;
            }
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.start
         * @description 开始
         */

    }, {
        key: "start",
        value: function start() {
            var me = this;

            if (!me.running) {
                me.running = true;
                me.tick();
                me.events.triggerEvent('start', me.currentTime);
            }
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.pause
         * @description 暂停
         */

    }, {
        key: "pause",
        value: function pause() {
            var me = this;
            me.running = false;
            me.events.triggerEvent('pause', me.currentTime);
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.stop
         * @description 停止，停止后返回起始状态
         */

    }, {
        key: "stop",
        value: function stop() {
            var me = this;
            //停止时 时间设置为开始时间
            me.currentTime = me.startTime;
            //如果正在运行，修改为初始时间即可绘制一帧
            if (me.running) {
                me.running = false;
            }
            me.events.triggerEvent('stop', me.currentTime);
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.toggle
         * @description 开关切换，切换的是开始和暂停
         */

    }, {
        key: "toggle",
        value: function toggle() {
            var me = this;

            if (me.running) {
                me.pause();
            } else {
                me.start();
            }
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setSpeed
         * @description 设置步长。
         * @param speed - {number}步长，必须为非负数，默认为1
         * @return {Boolean} true代表设置成功，false设置失败（speed小于0时失败）
         */

    }, {
        key: "setSpeed",
        value: function setSpeed(speed) {
            var me = this;
            if (speed >= 0) {
                me.speed = speed;
                return true;
            }
            return false;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getSpeed
         * @description 获取步长。
         * @return {number} 返回当前的步长
         */

    }, {
        key: "getSpeed",
        value: function getSpeed() {
            return this.speed;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setFrequency
         * @description 设置刷新频率。
         * @param speed - {number}刷新频率，单位为ms，默认为1s
         * @return {Boolean} true代表设置成功，false设置失败（frequency小于0时失败）
         */

    }, {
        key: "setFrequency",
        value: function setFrequency(frequency) {
            var me = this;
            if (frequency >= 0) {
                me.frequency = frequency;
                return true;
            }
            return false;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getFrequency
         * @description 获取刷新频率。
         * @return {number} 返回当前的刷新频率
         */

    }, {
        key: "getFrequency",
        value: function getFrequency() {
            return this.frequency;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setStartTime
         * @description 设置起始时间，设置完成后如果当前时间小于起始时间，则从起始时间开始
         * @param startTime - {number}需要设置的起始时间
         * @return {Boolean} true代表设置成功，false设置失败（startTime 大于结束时间时失败）
         */

    }, {
        key: "setStartTime",
        value: function setStartTime(startTime) {
            var me = this;
            startTime = Date.parse(new Date(startTime));
            //起始时间不得大于结束时间
            if (startTime > me.endTime) {
                return false;
            }
            me.startTime = startTime;
            //如果当前时间小于了起始时间，则从当前起始时间开始
            if (me.currentTime < me.startTime) {
                me.currentTime = me.startTime;
                me.tick();
            }
            return true;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getStartTime
         * @description 获取起始时间
         * @return {number} 返回当前的起始时间
         */

    }, {
        key: "getStartTime",
        value: function getStartTime() {
            return this.startTime;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setEndTime
         * @description 设置结束时间，设置完成后如果当前时间大于结束，则从起始时间开始
         * @param endTime - {number}需要设置的结束时间
         * @return {Boolean} true代表设置成功，false设置失败（endTime 小于开始时间时失败）
         */

    }, {
        key: "setEndTime",
        value: function setEndTime(endTime) {
            var me = this;
            me.endTime = Date.parse(new Date(me.endTime));
            //结束时间不得小于开始时间
            if (endTime < me.startTime) {
                return false;
            }
            me.endTime = endTime;
            //如果当前时间大于了结束时间，则从起始时间开始
            if (me.currentTime >= me.endTime) {
                me.currentTime = me.startTime;
                me.tick();
            }
            return true;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getEndTime
         * @description 获取结束时间
         * @return {number} 返回当前的结束时间
         */

    }, {
        key: "getEndTime",
        value: function getEndTime() {
            return this.endTime;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setCurrentTime
         * @description 设置当前时间
         * @param currentTime - {number}需要设置的当前时间
         * @return {Boolean} true代表设置成功，false设置失败
         */

    }, {
        key: "setCurrentTime",
        value: function setCurrentTime(currentTime) {
            var me = this;
            me.currentTime = Date.parse(new Date(me.currentTime));
            //结束时间不得小于开始时间
            if (currentTime >= me.startTime && currentTime <= me.endTime) {
                me.currentTime = currentTime;
                me.startTime = me.currentTime;
                me.tick();
                return true;
            }
            return false;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getCurrentTime
         * @description 获取当前时间
         * @return {number} 返回当前时间
         */

    }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
            return this.currentTime;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setRepeat
         * @description 设置是否重复循环
         * @param repeat - {boolean} 是否重复循环
         */

    }, {
        key: "setRepeat",
        value: function setRepeat(repeat) {
            this.repeat = repeat;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getRepeat
         * @description 获取是否重复循环，默认是true。
         * @return {Boolean} 返回是否重复循环
         */

    }, {
        key: "getRepeat",
        value: function getRepeat() {
            return this.repeat;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setReverse
         * @description 设置是否反向
         * @param reverse - {boolean} 是否反向
         */

    }, {
        key: "setReverse",
        value: function setReverse(reverse) {
            this.reverse = reverse;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getReverse
         * @description 获取是否反向，默认是false。
         * @return {Boolean} 返回是否反向
         */

    }, {
        key: "getReverse",
        value: function getReverse() {
            return this.reverse;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getRunning
         * @description 获取运行状态
         * @return {Boolean} true代表正在运行，false发表没有运行
         */

    }, {
        key: "getRunning",
        value: function getRunning() {
            return this.running;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.destroy
         * @description 销毁Animator对象，释放资源。
         */

    }, {
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.speed = null;
            me.frequency = null;
            me.startTime = null;
            me.endTime = null;
            me.currentTime = null;
            me.repeat = null;
            me.running = false;
            me.reverse = null;
        }
    }, {
        key: "tick",
        value: function tick() {
            //TODO 每次刷新执行的操作。子类实现
        }
    }]);

    return TimeControlBase;
}();

exports.default = TimeControlBase;


_SuperMap2.default.TimeControlBase = TimeControlBase;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Format2 = __webpack_require__(65);

var _Format3 = _interopRequireDefault(_Format2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Format.JSON
 * @classdesc 安全的读写JSON的解析类。使用<SuperMap.Format.JSON> 构造函数创建新实例。
 * @extends SuperMap.Format
 * @param options - {Object} 选项对象，其属性会被直接设置到JSON实例。
 */
var JSONFormat = function (_Format) {
    _inherits(JSONFormat, _Format);

    function JSONFormat() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, JSONFormat);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = JSONFormat.__proto__ || Object.getPrototypeOf(JSONFormat)).call.apply(_ref, [this].concat(args))), _this), _this.indent = "    ", _this.space = " ", _this.newline = "\n", _this.level = 0, _this.pretty = false, _this.nativeJSON = function () {
            return !!(window.JSON && typeof JSON.parse === "function" && typeof JSON.stringify === "function");
        }(), _this.serialize = {
            /**
             * @function SuperMap.Format.JSON.serialize.object
             * @description Transform an object into a JSON string.
             * @param object - {Object} The object to be serialized.
             * @return {string} A JSON string representing the object.
             */
            'object': function object(_object) {
                // three special objects that we want to treat differently
                if (_object == null) {
                    return "null";
                }
                if (_object.constructor === Date) {
                    return this.serialize.date.apply(this, [_object]);
                }
                if (_object.constructor === Array) {
                    return this.serialize.array.apply(this, [_object]);
                }
                var pieces = ['{'];
                this.level += 1;
                var key, keyJSON, valueJSON;

                var addComma = false;
                for (key in _object) {
                    if (_object.hasOwnProperty(key)) {
                        // recursive calls need to allow for sub-classing
                        keyJSON = _SuperMap2.default.Format.JSON.prototype.write.apply(this, [key, this.pretty]);
                        valueJSON = _SuperMap2.default.Format.JSON.prototype.write.apply(this, [_object[key], this.pretty]);
                        if (keyJSON != null && valueJSON != null) {
                            if (addComma) {
                                pieces.push(',');
                            }
                            pieces.push(this.writeNewline(), this.writeIndent(), keyJSON, ':', this.writeSpace(), valueJSON);
                            addComma = true;
                        }
                    }
                }

                this.level -= 1;
                pieces.push(this.writeNewline(), this.writeIndent(), '}');
                return pieces.join('');
            },

            /**
             * @function SuperMap.Format.JSON.serialize.array
             * @description Transform an array into a JSON string.
             * @param array - {Array} The array to be serialized
             * @return {string} A JSON string representing the array.
             */
            'array': function array(_array) {
                var json;
                var pieces = ['['];
                this.level += 1;

                for (var i = 0, len = _array.length; i < len; ++i) {
                    // recursive calls need to allow for sub-classing
                    json = _SuperMap2.default.Format.JSON.prototype.write.apply(this, [_array[i], this.pretty]);
                    if (json != null) {
                        if (i > 0) {
                            pieces.push(',');
                        }
                        pieces.push(this.writeNewline(), this.writeIndent(), json);
                    }
                }

                this.level -= 1;
                pieces.push(this.writeNewline(), this.writeIndent(), ']');
                return pieces.join('');
            },

            /**
             * @function SuperMap.Format.JSON.serialize.string
             * @description Transform a string into a JSON string.
             * @param string - {string} The string to be serialized
             * @return {string} A JSON string representing the string.
             */
            'string': function string(_string) {
                // If the string contains no control characters, no quote characters, and no
                // backslash characters, then we can simply slap some quotes around it.
                // Otherwise we must also replace the offending characters with safe
                // sequences.
                var m = {
                    '\b': '\\b',
                    '\t': '\\t',
                    '\n': '\\n',
                    '\f': '\\f',
                    '\r': '\\r',
                    '"': '\\"',
                    '\\': '\\\\'
                };
                if (/["\\\x00-\x1f]/.test(_string)) {
                    return '"' + _string.replace(/([\x00-\x1f\\"])/g, function (a, b) {
                        var c = m[b];
                        if (c) {
                            return c;
                        }
                        c = b.charCodeAt();
                        return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
                    }) + '"';
                }
                return '"' + _string + '"';
            },

            /**
             * @function SuperMap.Format.JSON.serialize.number
             * @description Transform a number into a JSON string.
             * @param number - {number}The number to be serialized.
             * @return {string} A JSON string representing the number.
             */
            'number': function number(_number) {
                return isFinite(_number) ? String(_number) : "null";
            },

            /**
             * @function SuperMap.Format.JSON.serialize.boolean
             * @description Transform a boolean into a JSON string.
             * @param bool - {boolean} The boolean to be serialized.
             * @return {string} A JSON string representing the boolean.
             */
            'boolean': function boolean(bool) {
                return String(bool);
            },

            /**
             * @function SuperMap.Format.JSON.serialize.object
             * @description Transform a date into a JSON string.
             * @param date - {Date} The date to be serialized.
             * @return {string} A JSON string representing the date.
             */
            'date': function date(_date) {
                function format(number) {
                    // Format integers to have at least two digits.
                    return number < 10 ? '0' + number : number;
                }

                return '"' + _date.getFullYear() + '-' + format(_date.getMonth() + 1) + '-' + format(_date.getDate()) + 'T' + format(_date.getHours()) + ':' + format(_date.getMinutes()) + ':' + format(_date.getSeconds()) + '"';
            }
        }, _this.CLASS_NAME = "SuperMap.Format.JSON", _temp), _possibleConstructorReturn(_this, _ret);
    }

    /**
     * @member SuperMap.Format.JSON.prototype.indent -{string}
     * @description 用于格式化输出，indent字符串会在每次缩进的时候使用一次；
     */


    /**
     * @member SuperMap.Format.JSON.prototype.space -{string}
     * @description 用于格式化输出，space字符串会在名值对的":"后边添加。
     */


    /**
     * @member SuperMap.Format.JSON.prototype.newline -{string}
     * @description 用于格式化输出, newline字符串会用在每一个名值对或数组项末尾。
     */


    /**
     * @member SuperMap.Format.JSON.prototype.level -{Integer}
     * @description 用于格式化输出, 表示的是缩进级别。
     */


    /**
     * @member SuperMap.Format.JSON.prototype.pretty -{boolean}
     * @description 是否在序列化的时候使用额外的空格控制结构。在 <write> 方法中使用
     *              默认值为false。
     */


    /**
     * @member SuperMap.Format.JSON.prototype.nativeJSON -{boolean}
     * @description 判断浏览器是否原生支持JSON格式数据；
     */


    _createClass(JSONFormat, [{
        key: 'read',


        /**
         * @function SuperMap.Format.JSON.prototype.read
         * @description 将一个符合json结构的字符串进行解析。
         * @param json - {string} 符合json结构的字符串。
         * @param filter - {Function} 过滤方法，最终结果的每一个键值对都会调用该过滤方法，并在对应的值的位置替换成该方法返回的值。
         * @return {Object} 对象，数组，字符串或数字。
         */
        value: function read(json, filter) {
            var object;
            if (this.nativeJSON) {
                try {
                    object = JSON.parse(json, filter);
                } catch (e) {
                    // Fall through if the regexp test fails.
                }
            }

            if (this.keepData) {
                this.data = object;
            }

            return object;
        }

        /**
         * @function SuperMap.Format.JSON.prototype.write
         * @description 序列化一个对象到一个符合JSON格式的字符串。
         * @param value - {object}|{string}|<Array>|{number}|{boolean} 需要被序列化的对象，数组，字符串，数字，布尔值。
         * @param pretty -{boolean}
         * @return {string} 符合JSON格式的字符串。
         *
         */

    }, {
        key: 'write',
        value: function write(value, pretty) {
            this.pretty = !!pretty;
            var json = null;
            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
            if (this.serialize[type]) {
                try {
                    json = !this.pretty && this.nativeJSON ? JSON.stringify(value) : this.serialize[type].apply(this, [value]);
                } catch (err) {
                    //SuperMap.Console.error("Trouble serializing: " + err);
                }
            }
            return json;
        }

        /**
         * @function SuperMap.Format.JSON.prototype.writeIndent
         * @description 根据缩进级别输出一个缩进字符串。
         * @return {string} 一个适当的缩进字符串。
         */

    }, {
        key: 'writeIndent',
        value: function writeIndent() {
            var pieces = [];
            if (this.pretty) {
                for (var i = 0; i < this.level; ++i) {
                    pieces.push(this.indent);
                }
            }
            return pieces.join('');
        }

        /**
         * @function SuperMap.Format.JSON.prototype.writeNewline
         * @description 在格式化输出模式情况下输出代表新一行的字符串。
         * @return {string} 代表新的一行的字符串。
         */

    }, {
        key: 'writeNewline',
        value: function writeNewline() {
            return this.pretty ? this.newline : '';
        }

        /**
         * @function SuperMap.Format.JSON.prototype.writeSpace
         * @description 在格式化输出模式情况下输出一个代表空格的字符串。
         * @return {string} A space.
         */

    }, {
        key: 'writeSpace',
        value: function writeSpace() {
            return this.pretty ? this.space : '';
        }

        /**
         * @member SuperMap.Format.JSON.prototype.serialize
         * @description Object with properties corresponding to the serializable data types.
         *              Property values are functions that do the actual serializing.
         */

    }]);

    return JSONFormat;
}(_Format3.default);

exports.default = JSONFormat;


_SuperMap2.default.Format.JSON = JSONFormat;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Format2 = __webpack_require__(65);

var _Format3 = _interopRequireDefault(_Format2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class: SuperMap.Format.WKT
 * 用于读写常见文本的类。通过 <SuperMap.Format.WKT> 构造器来创建一个新
 *      的实例。
 *
 * Inherits from:
 *  - <SuperMap.Format>
 */
var WKT = function (_Format) {
    _inherits(WKT, _Format);

    /**
     * Constructor: SuperMap.Format.WKT
     * 创建一个新的WKT解析器。
     *
     * Parameters:
     * options - {Object} 可选的选项对象，其属性将被设置到实例。
     *
     * Returns:
     * {<SuperMap.Format.WKT>} 新的WKT解析器。
     */
    function WKT(options) {
        _classCallCheck(this, WKT);

        var _this = _possibleConstructorReturn(this, (WKT.__proto__ || Object.getPrototypeOf(WKT)).call(this, options));

        _this.extract = {
            /**
             * Return a space delimited string of point coordinates.
             * @param {SuperMap.Geometry.Point} point
             * @returns {String} A string of coordinates representing the point
             */
            'point': function point(_point) {
                return _point.x + ' ' + _point.y;
            },

            /**
             * Return a comma delimited string of point coordinates from a multipoint.
             * @param {SuperMap.Geometry.MultiPoint} multipoint
             * @returns {String} A string of point coordinate strings representing
             *                  the multipoint
             */
            'multipoint': function multipoint(_multipoint) {
                var array = [];
                for (var i = 0, len = _multipoint.components.length; i < len; ++i) {
                    array.push('(' + this.extract.point.apply(this, [_multipoint.components[i]]) + ')');
                }
                return array.join(',');
            },


            /**
             * Return a comma delimited string of point coordinates from a line.
             * @param {SuperMap.Geometry.LineString} linestring
             * @returns {String} A string of point coordinate strings representing
             *                  the linestring
             */
            'linestring': function linestring(_linestring) {
                var array = [];
                for (var i = 0, len = _linestring.components.length; i < len; ++i) {
                    array.push(this.extract.point.apply(this, [_linestring.components[i]]));
                }
                return array.join(',');
            },


            /**
             * Return a comma delimited string of linestring strings from a multilinestring.
             * @param {SuperMap.Geometry.MultiLineString} multilinestring
             * @returns {String} A string of of linestring strings representing
             *                  the multilinestring
             */
            'multilinestring': function multilinestring(_multilinestring) {
                var array = [];
                for (var i = 0, len = _multilinestring.components.length; i < len; ++i) {
                    array.push('(' + this.extract.linestring.apply(this, [_multilinestring.components[i]]) + ')');
                }
                return array.join(',');
            },


            /**
             * Return a comma delimited string of linear ring arrays from a polygon.
             * @param {SuperMap.Geometry.Polygon} polygon
             * @returns {String} An array of linear ring arrays representing the polygon
             */
            'polygon': function polygon(_polygon) {
                var array = [];
                for (var i = 0, len = _polygon.components.length; i < len; ++i) {
                    array.push('(' + this.extract.linestring.apply(this, [_polygon.components[i]]) + ')');
                }
                return array.join(',');
            },


            /**
             * Return an array of polygon arrays from a multipolygon.
             * @param {SuperMap.Geometry.MultiPolygon} multipolygon
             * @returns {String} An array of polygon arrays representing
             *                  the multipolygon
             */
            'multipolygon': function multipolygon(_multipolygon) {
                var array = [];
                for (var i = 0, len = _multipolygon.components.length; i < len; ++i) {
                    array.push('(' + this.extract.polygon.apply(this, [_multipolygon.components[i]]) + ')');
                }
                return array.join(',');
            },


            /**
             * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an <SuperMap.Geometry.Collection>
             * @param {SuperMap.Geometry.Collection} collection
             * @returns {String} internal WKT representation of the collection
             */
            'collection': function collection(_collection) {
                var array = [];
                for (var i = 0, len = _collection.components.length; i < len; ++i) {
                    array.push(this.extractGeometry.apply(this, [_collection.components[i]]));
                }
                return array.join(',');
            }
        };
        _this.parse = {
            /**
             * Return point feature given a point WKT fragment.
             * @param {String} str A WKT fragment representing the point
             * @returns {SuperMap.Feature.Vector} A point feature
             * @private
             */
            'point': function point(str) {
                var coords = _SuperMap2.default.String.trim(str).split(this.regExes.spaces);
                return new _SuperMap2.default.Feature.Vector(new Supermap.Point(coords[0], coords[1]));
            },

            /**
             * Return a multipoint feature given a multipoint WKT fragment.
             * @param {String} A WKT fragment representing the multipoint
             * @returns {SuperMap.Feature.Vector} A multipoint feature
             * @private
             */
            'multipoint': function multipoint(str) {
                var point;
                var points = _SuperMap2.default.String.trim(str).split(',');
                var components = [];
                for (var i = 0, len = points.length; i < len; ++i) {
                    point = points[i].replace(this.regExes.trimParens, '$1');
                    components.push(this.parse.point.apply(this, [point]).geometry);
                }
                return new _SuperMap2.default.Feature.Vector(new Supermap.MultiPoint(components));
            },

            /**
             * Return a linestring feature given a linestring WKT fragment.
             * @param {String} A WKT fragment representing the linestring
             * @returns {SuperMap.Feature.Vector} A linestring feature
             * @private
             */
            'linestring': function linestring(str) {
                var points = _SuperMap2.default.String.trim(str).split(',');
                var components = [];
                for (var i = 0, len = points.length; i < len; ++i) {
                    components.push(this.parse.point.apply(this, [points[i]]).geometry);
                }
                return new _SuperMap2.default.Feature.Vector(new Supermap.LineString(components));
            },

            /**
             * Return a multilinestring feature given a multilinestring WKT fragment.
             * @param {String} A WKT fragment representing the multilinestring
             * @returns {SuperMap.Feature.Vector} A multilinestring feature
             * @private
             */
            'multilinestring': function multilinestring(str) {
                var line;
                var lines = _SuperMap2.default.String.trim(str).split(this.regExes.parenComma);
                var components = [];
                for (var i = 0, len = lines.length; i < len; ++i) {
                    line = lines[i].replace(this.regExes.trimParens, '$1');
                    components.push(this.parse.linestring.apply(this, [line]).geometry);
                }
                return new _SuperMap2.default.Feature.Vector(new Supermap.MultiLineString(components));
            },

            /**
             * Return a polygon feature given a polygon WKT fragment.
             * @param {String} A WKT fragment representing the polygon
             * @returns {SuperMap.Feature.Vector} A polygon feature
             * @private
             */
            'polygon': function polygon(str) {
                var ring, linestring, linearring;
                var rings = _SuperMap2.default.String.trim(str).split(this.regExes.parenComma);
                var components = [];
                for (var i = 0, len = rings.length; i < len; ++i) {
                    ring = rings[i].replace(this.regExes.trimParens, '$1');
                    linestring = this.parse.linestring.apply(this, [ring]).geometry;
                    linearring = new Supermap.LinearRing(linestring.components);
                    components.push(linearring);
                }
                return new _SuperMap2.default.Feature.Vector(new Supermap.Polygon(components));
            },

            /**
             * Return a multipolygon feature given a multipolygon WKT fragment.
             * @param {String} A WKT fragment representing the multipolygon
             * @returns {SuperMap.Feature.Vector} A multipolygon feature
             * @private
             */
            'multipolygon': function multipolygon(str) {
                var polygon;
                var polygons = _SuperMap2.default.String.trim(str).split(this.regExes.doubleParenComma);
                var components = [];
                for (var i = 0, len = polygons.length; i < len; ++i) {
                    polygon = polygons[i].replace(this.regExes.trimParens, '$1');
                    components.push(this.parse.polygon.apply(this, [polygon]).geometry);
                }
                return new _SuperMap2.default.Feature.Vector(new Supermap.MultiPolygon(components));
            },

            /**
             * Return an array of features given a geometrycollection WKT fragment.
             * @param {String} A WKT fragment representing the geometrycollection
             * @returns {Array} An array of SuperMap.Feature.Vector
             * @private
             */
            'geometrycollection': function geometrycollection(str) {
                // separate components of the collection with |
                str = str.replace(/,\s*([A-Za-z])/g, '|$1');
                var wktArray = _SuperMap2.default.String.trim(str).split('|');
                var components = [];
                for (var i = 0, len = wktArray.length; i < len; ++i) {
                    components.push(WKT.read(wktArray[i]));
                }
                return components;
            }

        };
        _this.CLASS_NAME = "SuperMap.Format.WKT";

        _this.regExes = {
            'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            'spaces': /\s+/,
            'parenComma': /\)\s*,\s*\(/,
            'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
            'trimParens': /^\s*\(?(.*?)\)?\s*$/
        };
        return _this;
    }

    /**
     * Method: read
     * Deserialize a WKT string and return a vector feature or an
     * array of vector features.  Supports WKT for POINT, MULTIPOINT,
     * LINESTRING, MULTILINESTRING, POLYGON, MULTIPOLYGON, and
     * GEOMETRYCOLLECTION.
     *
     * Parameters:
     * wkt - {String} A WKT string
     *
     * Returns:
     * {SuperMap.Feature.Vector|Array} A feature or array of features for
     * GEOMETRYCOLLECTION WKT.
     */


    _createClass(WKT, [{
        key: 'read',
        value: function read(wkt) {
            var features, type, str;
            wkt = wkt.replace(/[\n\r]/g, " ");
            var matches = this.regExes.typeStr.exec(wkt);
            if (matches) {
                type = matches[1].toLowerCase();
                str = matches[2];
                if (this.parse[type]) {
                    features = this.parse[type].apply(this, [str]);
                }
                if (this.internalProjection && this.externalProjection) {
                    if (features && features.CLASS_NAME === "SuperMap.Feature.Vector") {
                        features.geometry.transform(this.externalProjection, this.internalProjection);
                    } else if (features && type !== "geometrycollection" && (typeof features === 'undefined' ? 'undefined' : _typeof(features)) === "object") {
                        for (var i = 0, len = features.length; i < len; i++) {
                            var component = features[i];
                            component.geometry.transform(this.externalProjection, this.internalProjection);
                        }
                    }
                }
            }
            return features;
        }

        /**
         * Method: write
         * Serialize a feature or array of features into a WKT string.
         *
         * Parameters:
         * features - {SuperMap.Feature.Vector|Array} A feature or array of
         *            features
         *
         * Returns:
         * {String} The WKT string representation of the input geometries
         */

    }, {
        key: 'write',
        value: function write(features) {
            var collection, geometry, type, data, isCollection;
            if (features.constructor === Array) {
                collection = features;
                isCollection = true;
            } else {
                collection = [features];
                isCollection = false;
            }
            var pieces = [];
            if (isCollection) {
                pieces.push('GEOMETRYCOLLECTION(');
            }
            for (var i = 0, len = collection.length; i < len; ++i) {
                if (isCollection && i > 0) {
                    pieces.push(',');
                }
                geometry = collection[i].geometry;
                pieces.push(this.extractGeometry(geometry));
            }
            if (isCollection) {
                pieces.push(')');
            }
            return pieces.join('');
        }

        /**
         * Method: extractGeometry
         * Entry point to construct the WKT for a single Geometry object.
         *
         * Parameters:
         * geometry - {<SuperMap.Geometry.Geometry>}
         *
         * Returns:
         * {String} A WKT string of representing the geometry
         */

    }, {
        key: 'extractGeometry',
        value: function extractGeometry(geometry) {
            var type = geometry.CLASS_NAME.split('.')[2].toLowerCase();
            if (!this.extract[type]) {
                return null;
            }
            if (this.internalProjection && this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(this.internalProjection, this.externalProjection);
            }
            var wktType = type === 'collection' ? 'GEOMETRYCOLLECTION' : type.toUpperCase();
            var data = wktType + '(' + this.extract[type].apply(this, [geometry]) + ')';
            return data;
        }

        /**
         * Object with properties corresponding to the geometry types.
         * Property values are functions that do the actual data extraction.
         */


        /**
         * Object with properties corresponding to the geometry types.
         * Property values are functions that do the actual parsing.
         */

    }]);

    return WKT;
}(_Format3.default);

exports.default = WKT;

_SuperMap2.default.Format.WKT = WKT;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.AreaSolarRadiationParameters
 * @classdesc 地区太阳辐射参数类。
 * @param options -{Object} 可选参数。如</br>
 *        dataset - {string} 要用来做地区太阳辐射数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。（必设参数）。</br>
 *        targetDatasourceName - {string}  指定的存储结果数据集的数据源名称（必设参数）, 例如："Jingjin"。</br>
 *        totalGridName - {string} 指定地区太阳辐射总辐射量数据集的名称（必设参数）。</br>
 *        diffuseDatasetGridName - {string} 指定地区太阳辐射散射辐射量数据集的名称。</br>
 *        durationDatasetGridName - {string} 指定地区太阳辐射太阳直射持续时间数据集的名称。</br>
 *        directDatasetGridName - {string} 指定地区太阳辐射直射辐射量数据集的名称。</br>
 *        latitude - {number}待计算区域的纬度值。</br>
 *        timeMode - {string} 时间模式。可设置有“WITHINDAY”（单日）和“MULTIDAYS”（多日）；默认值为"MULTIDAYS";</br>
 *        dayStart - {number}起始日期（年内的第几天）。（必设参数）</br>
 *        dayEnd - {number}结束日期（年内的第几天）。（必设参数）</br>
 *        hourStart - {number}起始时间（一天中的第几个小时）。</br>
 *        hourEnd - {number}结束时间（一天中的第几个小时）。</br>
 *        transmittance - {number}太阳辐射穿过大气的透射率。</br>
 *        hourInterval - {number}计算时的小时间隔（设置的越小计算量越大并且计算结果更精确, 默认为0.5小时，如果修改此参数，必须使用整数）</br>
 *        dayInterval - {number}计算时的天数间隔（设置的越小计算量越大并且计算结果更精确, 默认为5天，必须使用整数）</br>
 *        deleteExistResultDataset - {boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
 */
var AreaSolarRadiationParameters = function () {

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.dayInterval -{number}
     * @description 计算时的天数间隔（设置的越小计算量越大并且计算结果更精确, 默认为5天，必须使用整数）
     */


    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.transmittance -{number}
     * @description 太阳辐射穿过大气的透射率。
     */


    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.hourStart -{number}
     * @description 起始时间（一天中的第几个小时）。
     */


    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.dayStart -{number}
     *  @description 起始日期（年内的第几天）。（必设参数）
     */


    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.latitude -{number}
     * @description 待计算区域的纬度值。
     */


    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.durationDatasetGridName -{string}
     * @description  指定地区太阳辐射太阳直射持续时间数据集的名称。
     */


    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.totalGridName -{string}
     * @description 指定地区太阳辐射总辐射量数据集的名称（必设参数）。
     */


    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.dataset -{string}
     *  @description  要用来做地区太阳辐射数据源中数据集的名称。
     *  该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin （必设参数）。注：地区太阳辐射数据必须为栅格数据集。
     */
    function AreaSolarRadiationParameters(options) {
        _classCallCheck(this, AreaSolarRadiationParameters);

        this.dataset = null;
        this.targetDatasourceName = null;
        this.totalGridName = null;
        this.diffuseDatasetGridName = null;
        this.durationDatasetGridName = null;
        this.directDatasetGridName = null;
        this.latitude = null;
        this.timeMode = "MULTIDAYS";
        this.dayStart = null;
        this.dayEnd = null;
        this.hourStart = null;
        this.hourEnd = null;
        this.transmittance = null;
        this.hourInterval = null;
        this.dayInterval = null;
        this.deleteExistResultDataset = false;
        this.CLASS_NAME = "SuperMap.AreaSolarRadiationParameters";

        if (!options) {
            return this;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.AreaSolarRadiationParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.deleteExistResultDataset -{boolean}
     * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
     */


    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.hourInterval -{number}
     *  @description 计算时的小时间隔（设置的越小计算量越大并且计算结果更精确, 默认为0.5小时，如果修改此参数，必须使用整数）
     */


    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.hourEnd -{number}
     * @description 结束时间（一天中的第几个小时）。
     */


    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.dayEnd -{number}
     * @description 结束日期（年内的第几天）。（必设参数）
     */


    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.timeMode -{string}
     *  @description 时间模式。可设置有“WITHINDAY”（单日）和“MULTIDAYS”（多日）；默认值为"MULTIDAYS";
     */


    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.durationDatasetGridName -{string}
     * @description 指定地区太阳辐射直射辐射量数据集的名称。
     */


    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.diffuseDatasetGridName -{string}
     * @description 指定地区太阳辐射散射辐射量数据集的名称。
     */


    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.targetDatasourceName -{string}
     * @description 指定的存储结果数据集的数据源名称（必设参数）； 例如："Jingjin"。
     */


    _createClass(AreaSolarRadiationParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.dataset = null;
            me.zFactor = 1.0;
            me.averageCurvatureName = null;
            me.profileCurvatureName = null;
            me.planCurvatureName = null;
            me.deleteExistResultDataset = true;
        }
        /**
         * @function SuperMap.AreaSolarRadiationParameters.toObject
         * @param derrainCurvatureCalculationParameters -{Object} 区域太阳辐射参数。
         * @param tempObj - {Object} 目标对象
         * @description 生成区域太阳辐射对象
         */

    }], [{
        key: "toObject",
        value: function toObject(derrainCurvatureCalculationParameters, tempObj) {
            var parameter = {};
            for (var name in derrainCurvatureCalculationParameters) {
                if (name !== "dataset") {
                    var name1 = name === "latitude" || name === "timeMode" || name === "dayStart";
                    var name2 = name === "dayEnd" || name === "hourStart" || name === "hourEnd";
                    var name3 = name === "transmittance" || name === "hourInterval" || name === "dayInterval";
                    if (name1 || name2 || name3) {
                        parameter[name] = derrainCurvatureCalculationParameters[name];
                    } else {
                        tempObj[name] = derrainCurvatureCalculationParameters[name];
                    }
                }
            }
            tempObj["parameter"] = parameter;
        }
    }]);

    return AreaSolarRadiationParameters;
}();

exports.default = AreaSolarRadiationParameters;


_SuperMap2.default.AreaSolarRadiationParameters = AreaSolarRadiationParameters;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.BufferDistance
 * @classdesc 缓冲区分析的缓冲距离类。通过该类可以设置缓冲区分析的缓冲距离，距离可以是数值也可以是数值型的字段表达式。
 * @param options - {string} 缓冲区分析可选参数。如：<br>
 *        exp -{string} 以数值型的字段表达式作为缓冲区分析的距离值。<br>
 *        value -{number}以数值作为缓冲区分析的距离值。默认为100，单位：米。
 */
var BufferDistance = function () {

    /**
     * @member SuperMap.BufferDistance.prototype.exp -{string}
     * @description 以数值型的字段表达式作为缓冲区分析的距离值。
     */
    function BufferDistance(options) {
        _classCallCheck(this, BufferDistance);

        this.exp = null;
        this.value = 100;
        this.CLASS_NAME = "SuperMap.BufferDistance";

        if (!options) {
            return this;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.BufferDistance.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.BufferDistance.prototype.value -{number}
     * @description 以数值作为缓冲区分析的距离值。默认为100，单位：米。
     */


    _createClass(BufferDistance, [{
        key: "destroy",
        value: function destroy() {
            this.exp = null;
            this.value = null;
        }
    }]);

    return BufferDistance;
}();

exports.default = BufferDistance;

_SuperMap2.default.BufferDistance = BufferDistance;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _BufferDistance = __webpack_require__(166);

var _BufferDistance2 = _interopRequireDefault(_BufferDistance);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.BufferSetting
 * @classdesc 缓冲区分析通用设置类
 * @param options - {Object} 缓冲区分析设置可选参数。如：<br>
 *        endType -{SuperMap.BufferEndType} 缓冲区端点枚举值。<br>
 *        leftDistance -{SuperMap.BufferDistance} 左侧缓冲距离。<br>
 *        rightDistance -{SuperMap.BufferDistance} 右侧缓冲距离。<br>
 *        semicircleLineSegment -{number} 圆头缓冲圆弧处线段的个数。<br>
 *        radiusUnit -{Enum} 缓冲半径单位。
 */
var BufferSetting = function () {

    /**
     * @member SuperMap.BufferSetting.prototype.semicircleLineSegment -{number}
     * @description 圆头缓冲圆弧处线段的个数。即用多少个线段来模拟一个半圆，默认值为4。
     */


    /**
     * @member SuperMap.BufferSetting.prototype.leftDistance -{SuperMap.BufferDistance}
     * @description 左侧缓冲距离。
     * 默认为100。当为GeometryBufferAnalyst时，单位为默认地图的投影系的单位（如3857为米，4326为度），
     * 当为DatasetBufferAnalyst时，单位通过BufferSetting.radiusUnit设置（默认全部为米）。
     */
    function BufferSetting(options) {
        _classCallCheck(this, BufferSetting);

        this.endType = _REST.BufferEndType.FLAT;
        this.leftDistance = null;
        this.rightDistance = null;
        this.semicircleLineSegment = 4;
        this.radiusUnit = _REST.Unit.METER;
        this.CLASS_NAME = "SuperMap.BufferSetting";

        var me = this;
        me.leftDistance = new _BufferDistance2.default();
        me.rightDistance = new _BufferDistance2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.BufferSetting.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.BufferSetting.prototype.radiusUnit -{Enum}
     * @description 缓冲半径单位，默认值为SuperMap.Unit.METER，还可以是SuperMap.Unit.MILIMETER、SuperMap.Unit.CENTIMETER、SuperMap.Unit.DECIMETER、SuperMap.Unit.KILOMETER、SuperMap.Unit.FOOT、SuperMap.Unit.INCH、SuperMap.Unit.MILE、SuperMap.Unit.YARD。仅对DatasetBufferAnalyst有效
     */


    /**
     * @member SuperMap.BufferSetting.prototype.rightDistance -{SuperMap.BufferDistance}
     * @description 右侧缓冲距离。
     * 默认为100。当为GeometryBufferAnalyst时，单位为默认地图的投影系的单位（如3857为米，4326为度），
     * 当为DatasetBufferAnalyst时，单位通过BufferSetting.radiusUnit设置（默认全部为米）。
     */

    /**
     * @member SuperMap.BufferSetting.prototype.endType -{SuperMap.BufferEndType}
     * @description 缓冲区端点枚举值。分为平头和圆头两种，默认为平头，即 SuperMap.BufferEndType.FLAT
     */


    _createClass(BufferSetting, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.endType = null;
            if (me.leftDistance) {
                me.leftDistance.destroy();
                me.leftDistance = null;
            }
            if (me.rightDistance) {
                me.rightDistance.destroy();
                me.rightDistance = null;
            }
            me.semicircleLineSegment = null;
            me.radiusUnit = null;
        }
    }]);

    return BufferSetting;
}();

exports.default = BufferSetting;

_SuperMap2.default.BufferSetting = BufferSetting;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.BurstPipelineAnalystParameters
 * @classdesc 爆管分析参数类。
 * @param options - {Object} 可选参数。如：<br>
 *         sourceNodeIDs - {Array<number>} 指定的设施点ID数组。<br>
 *         edgeID - {number}指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。<br>
 *         nodeID - {number}指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。<br>
 *         isUncertainDirectionValid - {boolean} 指定不确定流向是否有效；默认false，无效。
 */
var BurstPipelineAnalystParameters = function () {

    /**
     * @member SuperMap.BurstPipelineAnalystParameters.prototype.nodeID -{number}
     * @description 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。
     */


    /**
     * @member SuperMap.BurstPipelineAnalystParameters.prototype.sourceNodeIDs -{Array<number>}
     * @description 指定的设施点ID数组,可以为空。
     */
    function BurstPipelineAnalystParameters(options) {
        _classCallCheck(this, BurstPipelineAnalystParameters);

        this.sourceNodeIDs = null;
        this.edgeID = null;
        this.nodeID = null;
        this.isUncertainDirectionValid = false;
        this.CLASS_NAME = "SuperMap.BurstPipelineAnalystParameters";

        var me = this;
        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(me, options);
    }

    /**
     * @function SuperMap.BurstPipelineAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.BurstPipelineAnalystParameters.prototype.isUncertainDirectionValid -{boolean}
     * @description 指定不确定流向是否有效，默认为false。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；<br>
     *              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
     */


    /**
     * @member SuperMap.BurstPipelineAnalystParameters.prototype.edgeID -{number}
     * @description 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。
     */


    _createClass(BurstPipelineAnalystParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.sourceNodeIDs = null;
            me.edgeID = null;
            me.nodeID = null;
            me.isUncertainDirectionValid = null;
        }
    }]);

    return BurstPipelineAnalystParameters;
}();

exports.default = BurstPipelineAnalystParameters;

_SuperMap2.default.BurstPipelineAnalystParameters = BurstPipelineAnalystParameters;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ChartQueryFilterParameter
 * @classdesc 海图查询过滤参数类，用于设置海图查询的过滤参数。包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。
 * @param options - {Object} 可选参数。如：<br>
 *        isQueryPoint - {boolean} 是否查询点。
 *        isQueryLine  - {boolean} 是否查询线。
 *        isQueryRegion  - {boolean} 是否查询面。
 *        attributeFilter - {string} 属性字段过滤条件。
 *        chartFeatureInfoSpecCode - {number}查询的物标代号。
 */
var ChartQueryFilterParameter = function () {

    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.attributeFilter -{string}
     * @description 属性字段过滤条件。
     */


    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.isQueryLine -{boolean}
     * @description 是否查询线。
     */
    function ChartQueryFilterParameter(options) {
        _classCallCheck(this, ChartQueryFilterParameter);

        this.isQueryPoint = null;
        this.isQueryLine = null;
        this.isQueryRegion = null;
        this.attributeFilter = null;
        this.chartFeatureInfoSpecCode = null;
        this.CLASS_NAME = "SuperMap.ChartQueryFilterParameter";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.ChartQueryFilterParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.chartFeatureInfoSpecCode -{number}
     * @description 查询的物标代号。
     */


    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.isQueryRegion -{boolean}
     * @description 是否查询面。
     */


    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.isQueryPoint -{boolean}
     * @description 是否查询点。
     */


    _createClass(ChartQueryFilterParameter, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.isQueryPoint = null;
            me.isQueryLine = null;
            me.isQueryRegion = null;
            me.attributeFilter = null;
            me.chartFeatureInfoSpecCode = null;
        }

        /**
         * @function  SuperMap.ChartQueryFilterParameter.prototype.toJson
         * @description 将属性信息转化成JSON格式字符串。
         */

    }, {
        key: "toJson",
        value: function toJson() {
            var json = "";
            json += "\"isQueryPoint\":" + this.isQueryPoint + ",";
            json += "\"isQueryLine\":" + this.isQueryLine + ",";
            json += "\"isQueryRegion\":" + this.isQueryRegion + ",";
            if (this.attributeFilter) {
                json += "\"attributeFilter\": \"" + this.attributeFilter + "\",";
            }
            json += "\"chartFeatureInfoSpecCode\":" + this.chartFeatureInfoSpecCode;
            json = "{" + json + "}";
            return json;
        }
    }]);

    return ChartQueryFilterParameter;
}();

exports.default = ChartQueryFilterParameter;

_SuperMap2.default.ChartQueryFilterParameter = ChartQueryFilterParameter;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ChartQueryFilterParameter = __webpack_require__(169);

var _ChartQueryFilterParameter2 = _interopRequireDefault(_ChartQueryFilterParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ChartQueryParameters
 * @classdesc 海图查询参数类，该类用于设置海图查询时的相关参数，海图查询分为海图属性<br>
 *               查询和海图范围查询两类，通过属性queryMode指定查询模式。必设属性有：<br>
 *               queryMode、chartLayerNames、chartQueryFilterParameters。当进行海图范围查询时，必设属性还包括bounds。
 * @param options - {Object} 可选参数。如：<br>
 *         queryMode - {string} 海图查询模式类型，SuperMap iClient for JavaScript对
 *                              海图支持两种查询方式：海图属性查询（"ChartAttributeQuery"）和海图空间查询（"ChartBoundsQuery"） 。<br>
 *         bounds - {SuperMap.Bounds}  海图查询范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。<br>
 *         chartLayerNames - {Array<string>} 查询的海图图层的名称。<br>
 *         chartQueryFilterParameters - {Array <SuperMap.ChartQueryFilterParameter>} 海图查询过滤参数。包括：物标代码、
 *                                                                         物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。<br>
 *         returnContent - {boolean} 获取或设置是返回查询结果记录集 recordsets，还
 *                                   是返回查询结果的资源 resourceInfo。默认为 true，表示返回 recordsets。<br>
 *         startRecord - {number}查询起始记录位置，默认为0。<br>
 *         expectCount - {number}期望查询结果返回的记录数，该值大于0。
 */
var ChartQueryParameters = function () {

    /**
     * @member SuperMap.ChartQueryParameters.prototype.startRecord -{number}
     * @description 查询起始记录位置，默认为0。
     */


    /**
     * @member SuperMap.ChartQueryParameters.prototype.chartQueryFilterParameters -{Array<SuperMap.ChartQueryFilterParameter>}
     * @description 海图查询过滤参数。<br>
     *               包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。
     */


    /**
     * @member SuperMap.ChartQueryParameters.prototype.bounds
     * @description 海图查询范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
     */
    function ChartQueryParameters(options) {
        _classCallCheck(this, ChartQueryParameters);

        this.queryMode = null;
        this.bounds = null;
        this.chartLayerNames = null;
        this.chartQueryFilterParameters = null;
        this.returnContent = true;
        this.startRecord = 0;
        this.expectCount = null;
        this.CLASS_NAME = "SuperMap.ChartQueryParameters";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.ChartQueryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ChartQueryParameters.prototype.expectCount -{number}
     * @description 期望查询结果返回的记录数，该值大于0。
     */


    /**
     * @member SuperMap.ChartQueryParameters.prototype.returnContent -{boolean}
     * @description 获取或设置是返回查询结果记录集 recordsets，还是返回查询结果的
     *      资源 resourceInfo。默认为 true，表示返回 recordsets。
     * @example
     *  Recordsets 和 ResourceInfo 都存储在查询结果类 QueryResult 中。
     *  当:ReturnContent = true表示返回查询记录集，这时查询结果存储在:QueryResult.Recordsets中，而QueryResult.ResourceInfo为空；
     *  当:ReturnContent = false时，表示返回查询结果资源，这时查询结果存储在:QueryResult.ResourceInfo中，而QueryResult.Recordsets为空。
     */


    /**
     * @member SuperMap.ChartQueryParameters.prototype.chartLayerNames -{Array<string>}
     * @description 查询的海图图层的名称。
     */


    /**
     * @member SuperMap.ChartQueryParameters.prototype.queryMode -{string}
     * @description 海图查询模式类型，SuperMap iClient for JavaScript对海图支持两种<br>
     *              查询方式：海图属性查询（"ChartAttributeQuery"）和海图空间查询（"ChartBoundsQuery"） 。
     */


    _createClass(ChartQueryParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.queryMode = null;
            me.bounds = null;
            me.chartLayerNames = null;
            me.chartQueryFilterParameters = null;
            me.returnContent = true;
            me.startRecord = 0;
            me.expectCount = null;
        }

        /**
         * @function @member SuperMap.ChartQueryParameters.prototype.getVariablesJson
         * @description 将属性信息转换成能够被服务识别的JSON格式字符串。
         */

    }, {
        key: 'getVariablesJson',
        value: function getVariablesJson() {
            var json = "";

            json += "\"queryMode\":\"" + this.queryMode + "\",";

            if (this.chartLayerNames && this.chartLayerNames.length) {
                var chartLayersArray = [];
                var layerLength = this.chartLayerNames.length;
                for (var i = 0; i < layerLength; i++) {
                    chartLayersArray.push("\"" + this.chartLayerNames[i] + "\"");
                }
                var layerNames = "[" + chartLayersArray.join(",") + "]";
                json += "\"chartLayerNames\":" + layerNames + ",";
            }

            if (this.queryMode === "ChartBoundsQuery" && this.bounds) {
                json += "\"bounds\":" + "{" + "\"leftBottom\":" + "{" + "\"x\":" + this.bounds.left + "," + "\"y\":" + this.bounds.bottom + "}" + "," + "\"rightTop\":" + "{" + "\"x\":" + this.bounds.right + "," + "\"y\":" + this.bounds.top + "}" + "},";
            }

            if (this.chartQueryFilterParameters && this.chartQueryFilterParameters.length) {
                var chartParamArray = [];
                var chartLength = this.chartQueryFilterParameters.length;
                for (var j = 0; j < chartLength; j++) {
                    var chartQueryFilterParameter = new _ChartQueryFilterParameter2.default();
                    chartQueryFilterParameter = this.chartQueryFilterParameters[j];
                    chartParamArray.push(chartQueryFilterParameter.toJson());
                }
                var chartParamsJson = "[" + chartParamArray.join(",") + "]";
                chartParamsJson = "\"chartQueryParams\":" + chartParamsJson + ",";
                chartParamsJson += "\"startRecord\":" + this.startRecord + ",";
                chartParamsJson += "\"expectCount\":" + this.expectCount;
                chartParamsJson = "{" + chartParamsJson + "}";
                json += "\"chartQueryParameters\":" + chartParamsJson;
            }
            json = "{" + json + "}";
            return json;
        }
    }]);

    return ChartQueryParameters;
}();

exports.default = ChartQueryParameters;

_SuperMap2.default.ChartQueryParameters = ChartQueryParameters;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerColor = __webpack_require__(12);

var _ServerColor2 = _interopRequireDefault(_ServerColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ColorDictionary
 * @classdesc 颜色对照表类。
 * @description 颜色对照表中的键名为具体的高程值，键值表示该高程值要显示的颜色。<br>
 *              对于栅格图层中高程值小于颜色对照表中高程最小值的点使用颜色对照表中高程最小值对应的颜色，<br>
 *              对于栅格图层中高程值大于颜色对照表中高程最大值的点使用颜色对照表中高程最大值对应的颜色，<br>
 *              对于栅格图层中高程值在颜色对照表中没有对应颜色的点，则查找颜色对照表中与当前高程值相邻的两个高程对应的颜色，<br>
 *              然后通过渐变运算要显示的颜色。如果设置了颜色对照表的话，则颜色表设置无效。
 * @param options - {Object} 颜色对照表类可选参数。如：<br>
 *        elevation - {number}高程值。<br>
 *        color -{SuperMap.ServerColor} 服务端颜色类。
 */
var ColorDictionary = function () {

    /**
     * @member SuperMap.ColorDictionary.prototype.elevation -{number}
     * @description 高程值。
     */
    function ColorDictionary(options) {
        _classCallCheck(this, ColorDictionary);

        this.elevation = null;
        this.color = null;
        this.CLASS_NAME = "SuperMap.ColorDictionary";

        options = options || {};
        _SuperMap2.default.Util.extend(this, options);

        var me = this,
            c = me.color;
        if (c) {
            me.color = new _ServerColor2.default(c.red, c.green, c.blue);
        }
    }

    /**
     * @function SuperMap.ColorDictionary.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ColorDictionary.prototype.color -{SuperMap.ServerColor}
     * @description 服务端颜色类。
     */


    _createClass(ColorDictionary, [{
        key: 'destroy',
        value: function destroy() {
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.ColorDictionary.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var dataObj = {};
            dataObj = _SuperMap2.default.Util.copyAttributes(dataObj, this);
            return dataObj;
        }
    }]);

    return ColorDictionary;
}();

exports.default = ColorDictionary;


_SuperMap2.default.ColorDictionary = ColorDictionary;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _TransportationAnalystParameter = __webpack_require__(17);

var _TransportationAnalystParameter2 = _interopRequireDefault(_TransportationAnalystParameter);

__webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ComputeWeightMatrixParameters
 * @classdesc 耗费矩阵分析参数类。<br>
 *            根据交通网络分析参数中的耗费字段返回一个耗费矩阵。该矩阵是一个二维数组，用来存储任意两点间的资源消耗。
 * @param options - {Object} 可选参数。如：<br>
 *         isAnalyzeById - {boolean} 是否通过节点 ID 指定路径分析的结点。<br>
 *         nodes - {Array<Object>|Array<number>} 要计算耗费矩阵的点数组，必设字段。<br>
 *         点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *         parameter - {SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。
 */
var ComputeWeightMatrixParameters = function () {

  /**
   * @member SuperMap.ComputeWeightMatrixParameters.prototype.nodes {Array<Object>|Array<number>}
   * @description 要计算耗费矩阵的点数组，必设字段。<br>
   *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
   *              当 SuperMap.ComputeWeightMatrixParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；<br>
   *              当 SuperMap.ComputeWeightMatrixParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
   */
  function ComputeWeightMatrixParameters(options) {
    _classCallCheck(this, ComputeWeightMatrixParameters);

    this.isAnalyzeById = false;
    this.nodes = null;
    this.parameter = null;
    this.CLASS_NAME = "SuperMap.ComputeWeightMatrixParameters";

    var me = this;
    me.parameter = new _TransportationAnalystParameter2.default();
    if (!options) {
      return;
    }
    _SuperMap2.default.Util.extend(this, options);
  }

  /**
   * @function SuperMap.ComputeWeightMatrixParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  /**
   * @member SuperMap.ComputeWeightMatrixParameters.prototype.parameter {SuperMap.TransportationAnalystParameter}
   * @description 交通网络分析通用参数。
   */


  /**
   * @member SuperMap.ComputeWeightMatrixParameters.prototype.isAnalyzeById {Boolean}
   * @description 是否通过节点 ID 指定路径分析的结点，默认为 false，即通过坐标点指定。
   */


  _createClass(ComputeWeightMatrixParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.isAnalyzeById = null;
      me.nodes = null;
      if (me.parameter) {
        me.parameter.destroy();
        me.parameter = null;
      }
    }
  }]);

  return ComputeWeightMatrixParameters;
}();

exports.default = ComputeWeightMatrixParameters;

_SuperMap2.default.ComputeWeightMatrixParameters = ComputeWeightMatrixParameters;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _BufferAnalystParameters = __webpack_require__(66);

var _BufferAnalystParameters2 = _interopRequireDefault(_BufferAnalystParameters);

var _DataReturnOption = __webpack_require__(24);

var _DataReturnOption2 = _interopRequireDefault(_DataReturnOption);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DatasetBufferAnalystParameters
 * @classdesc  数据集缓冲区分析参数类
 * @param options - {Object} 可选参数。如：</br>
 *        dataset - {string} 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。</br>
 *        filterQueryParameter - {SuperMap.FilterParameter} 设置数据集中几何对象的过滤条件。只有满足此条件的几何对象才参与缓冲区分析。</br>
 *        resultSetting - {SuperMap.DataReturnOption} 结果返回设置类。</br>
 *        isAttributeRetained - {boolean} 是否保留进行缓冲区分析的对象的字段属性，默认为 true。当 isUnion 字段为 false 时该字段有效。</br>
 *        isUnion - {boolean} 是否将缓冲区与源记录集中的对象合并后返回。对于面对象而言，要求源数据集中的面对象不相交。默认为 false。</br>
 *        bufferSetting - {SuperMap.BufferSetting} 设置缓冲区通用参数。</br>
 *
 * @extends SuperMap.BufferAnalystParameters
 */
var DatasetBufferAnalystParameters = function (_BufferAnalystParamet) {
    _inherits(DatasetBufferAnalystParameters, _BufferAnalystParamet);

    /**
     * @member SuperMap.DatasetBufferAnalystParameters.prototype.isAttributeRetained -{boolean}
     * @description 是否保留进行缓冲区分析的对象的字段属性，默认为 true。当 isUnion 字段为 false 时该字段有效。
     */


    /**
     *  @member SuperMap.DatasetBufferAnalystParameters.prototype.filterQueryParameter -{SuperMap.FilterParameter}
     *  @description 设置数据集中几何对象的过滤条件。只有满足此条件的几何对象才参与缓冲区分析。
     */
    function DatasetBufferAnalystParameters(options) {
        _classCallCheck(this, DatasetBufferAnalystParameters);

        var _this = _possibleConstructorReturn(this, (DatasetBufferAnalystParameters.__proto__ || Object.getPrototypeOf(DatasetBufferAnalystParameters)).call(this, options));

        _this.dataset = null;
        _this.filterQueryParameter = null;
        _this.resultSetting = null;
        _this.isAttributeRetained = true;
        _this.isUnion = false;
        _this.CLASS_NAME = "SuperMap.DatasetBufferAnalystParameters";

        var me = _this;
        me.filterQueryParameter = new _FilterParameter2.default();
        me.resultSetting = new _DataReturnOption2.default();
        if (!options) {
            return _possibleConstructorReturn(_this);
        }
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.DatasetBufferAnalystParameters.prototype.isUnion -{boolean}
     * @description 是否将缓冲区与源记录集中的对象合并后返回。对于面对象而言，要求源数据集中的面对象不相交。默认为 false。
     */


    /**
     * @member SuperMap.DatasetBufferAnalystParameters.prototype.resultSetting -{SuperMap.DataReturnOption}
     * @description 结果返回设置类。
     */

    /**
     * @member SuperMap.DatasetBufferAnalystParameters.prototype.dataset -{string}
     * @description 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
     */


    _createClass(DatasetBufferAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(DatasetBufferAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(DatasetBufferAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.dataset = null;
            if (me.filterQueryParameter) {
                me.filterQueryParameter.destroy();
                me.filterQueryParameter = null;
            }
            if (me.resultSetting) {
                me.resultSetting.destroy();
                me.resultSetting = null;
            }
            me.isAttributeRetained = null;
            me.isUnion = null;
        }
        /**
         * @function SuperMap.DatasetBufferAnalystParameters.toObject
         * @param datasetBufferAnalystParameters -{Object} 数据集缓冲区分析参数
         * @param tempObj - {Object} 目标对象
         * @description 生成数据集缓冲区分析对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(datasetBufferAnalystParameters, tempObj) {
            for (var name in datasetBufferAnalystParameters) {
                if (name === "bufferSetting") {
                    datasetBufferAnalystParameters.bufferSetting.radiusUnit = datasetBufferAnalystParameters.bufferSetting.radiusUnit.toUpperCase();
                    tempObj.bufferAnalystParameter = datasetBufferAnalystParameters.bufferSetting;
                } else if (name === "resultSetting") {
                    tempObj.dataReturnOption = datasetBufferAnalystParameters.resultSetting;
                } else if (name === "dataset") {} else {
                    tempObj[name] = datasetBufferAnalystParameters[name];
                }
            }
        }
    }]);

    return DatasetBufferAnalystParameters;
}(_BufferAnalystParameters2.default);

exports.default = DatasetBufferAnalystParameters;


_SuperMap2.default.DatasetBufferAnalystParameters = DatasetBufferAnalystParameters;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.DatasetInfo
 * @classdesc 数据集信息类。
 * @description 数据集一般为存储在一起的相关数据的集合；根据数据类型的不同，分为矢量数据集、栅格数据集(griddataset)和
 *              影像数据集(image dataset)，以及为了处理特定问题而设计的数据集，如拓扑数据集，网络数据集等。
 *              数据集是 GIS 数据组织的最小单位。其中矢量数据集是由同种类型空间要素组成的集合，
 *              所以也可以称为要素集。根据要素的空间特征的不同，矢量数据集又分为点数据集，
 *              线数据集，面数据集等，各矢量数据集是空间特征和性质相同的数据组织起来的集合。
 *              目前版本支持的数据集主要有点数据集，线数据集，面数据集，文本数据集，复合数据集（CAD数据集）、
 *              网络数据集，栅格数据集(grid dataset)和影像数据集(image dataset)。
 * @param options - {Object} 可选参数。如：<br>
 *        bounds - {SuperMap.Bounds} 数据集范围，该字段只读。<br>
 *        dataSourceName - {string} 数据源名称，该字段只读。<br>
 *        description - {string} 数据集的描述信息。<br>
 *        encodeType - {string} 数据集存储时的压缩编码方式，该字段只读。<br>
 *        isReadOnly - {boolean} 数据集是否为只读。<br>
 *        name - {string} 数据集名称，该字段必须且只读。<br>
 *        prjCoordSys - {SuperMap.Projection} 数据集的投影信息。<br>
 *        tableName - {string} 表名，该字段只读。<br>
 *        type - {string} 数据集类型，该字段必设。主要有点数据集，线数据集，面数据集，文本数据集，复合数据集（CAD数据集）、
 *                        网络数据集，栅格数据集(grid dataset)和影像数据集(image dataset)。
 */
var DatasetInfo = function () {

    /**
     * @member SuperMap.DatasetInfo.prototype.tableName -{string}
     * @description 表名，该字段只读。
     */


    /**
     * @member SuperMap.DatasetInfo.prototype.name -{string}
     * @description 数据集名称，该字段必须且只读。
     */


    /**
     * @member SuperMap.DatasetInfo.prototype.encodeType -{string}
     * @description 数据集存储时的压缩编码方式，该字段只读。
     */


    /**
     * @member SuperMap.DatasetInfo.prototype.dataSourceName -{string}
     * @description 数据源名称，该字段只读。
     */
    function DatasetInfo(options) {
        _classCallCheck(this, DatasetInfo);

        this.bounds = null;
        this.dataSourceName = null;
        this.description = null;
        this.encodeType = null;
        this.isReadOnly = null;
        this.name = null;
        this.prjCoordSys = null;
        this.tableName = null;
        this.type = null;
        this.CLASS_NAME = "SuperMap.DatasetInfo";

        options = options || {};
        _SuperMap2.default.Util.extend(this, options);
        var b = this.bounds;
        if (b) {
            this.bounds = new _SuperMap2.default.Bounds(b.leftBottom.x, b.leftBottom.y, b.rightTop.x, b.rightTop.y);
        }
    }

    /**
     * @function SuperMap.DatasetInfo.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */


    /**
     * @member SuperMap.DatasetInfo.prototype.type -{string}
     * @description 数据集类型，该字段必设。主要有点数据集，线数据集，面数据集，文本数据集，复合数据集（CAD数据集）、
     *              网络数据集，栅格数据集(grid dataset)和影像数据集(image dataset)。
     */


    /**
     * @member SuperMap.DatasetInfo.prototype.prjCoordSys -{SuperMap.Projection}
     * @description 数据集的投影信息。
     */


    /**
     * @member SuperMap.DatasetInfo.prototype.isReadOnly -{boolean}
     * @description 数据集是否为只读。
     */


    /**
     * @member SuperMap.DatasetInfo.prototype.description -{string}
     * @description 数据集的描述信息。
     */


    /**
     * @member SuperMap.DatasetInfo.prototype.bounds -{SuperMap.Bounds}
     * @description 数据集范围，该字段只读。
     */


    _createClass(DatasetInfo, [{
        key: "destroy",
        value: function destroy() {
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.DatasetInfo.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: "toServerJSONObject",
        value: function toServerJSONObject() {
            var dataObj = {};
            dataObj = _SuperMap2.default.Util.copyAttributes(dataObj, this);
            if (dataObj.bounds) {
                if (dataObj.bounds.toServerJSONObject) {
                    dataObj.bounds = dataObj.bounds.toServerJSONObject();
                }
            }
            return dataObj;
        }
    }]);

    return DatasetInfo;
}();

exports.default = DatasetInfo;

_SuperMap2.default.DatasetInfo = DatasetInfo;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _DataReturnOption = __webpack_require__(24);

var _DataReturnOption2 = _interopRequireDefault(_DataReturnOption);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

var _OverlayAnalystParameters = __webpack_require__(67);

var _OverlayAnalystParameters2 = _interopRequireDefault(_OverlayAnalystParameters);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DatasetOverlayAnalystParameters
 * @classdesc 数据集叠加分析参数类。
 * @param options - {Object} 可选参数。如：</br>
 *        operateDataset - {string} 叠加分析中操作数据集的名称。必设字段。</br>
 *        operateDatasetFields - {Array<string>} 叠加分析中操作数据集保留在结果数据集中的字段名列表。</br>
 *        operateDatasetFilter - {SuperMap.FilterParameter} 设置操作数据集中空间对象过滤条件。</br>
 *        operateRegions - {Array<Object>} 操作区域。设置了操作区域后，仅对该区域内的对象进行分析。</br>
 *                         面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
 *        sourceDataset - {string} 叠加分析中源数据集的名称。必设字段。</br>
 *        sourceDatasetFields - {Array<string>} 叠加分析中源数据集保留在结果数据集中的字段名列表。</br>
 *        sourceDatasetFilter - {SuperMap.FilterParameter} 设置源数据集中空间对象过滤条件。</br>
 *        tolerance - {Integer} 容限。</br>
 *        operation - {SuperMap.OverlayOperationType} 叠加操作枚举值。</br>
 *        resultSetting - {SuperMap.DataReturnOption} 结果返回设置类。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var DatasetOverlayAnalystParameters = function (_OverlayAnalystParame) {
    _inherits(DatasetOverlayAnalystParameters, _OverlayAnalystParame);

    /**
     * @member SuperMap.DatasetOverlayAnalystParameters.prototype.tolerance -{Integer}
     * @description 容限。
     */


    /**
     * @member SuperMap.DatasetOverlayAnalystParameters.prototype.sourceDatasetFields -{Array<string>}
     * @description 叠加分析中源数据集保留在结果数据集中的字段名列表。
     */


    /**
     * @member SuperMap.DatasetOverlayAnalystParameters.prototype.operateRegions
     * @description 操作面对象集合，表示与这些面对象进行叠加分析。<br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。<br>
     * 与 operateDataset 参数互斥，冲突时以operateDataset 为准。
     */


    /**
     * @member SuperMap.DatasetOverlayAnalystParameters.prototype.operateDatasetFields -{Array<string>}
     * @description 叠加分析中操作数据集保留在结果数据集中的字段名列表。
     */
    function DatasetOverlayAnalystParameters(options) {
        _classCallCheck(this, DatasetOverlayAnalystParameters);

        var _this = _possibleConstructorReturn(this, (DatasetOverlayAnalystParameters.__proto__ || Object.getPrototypeOf(DatasetOverlayAnalystParameters)).call(this, options));

        _this.operateDataset = null;
        _this.operateDatasetFields = null;
        _this.operateDatasetFilter = null;
        _this.operateRegions = null;
        _this.sourceDataset = null;
        _this.sourceDatasetFields = null;
        _this.sourceDatasetFilter = null;
        _this.tolerance = 0;
        _this.resultSetting = null;
        _this.CLASS_NAME = "SuperMap.DatasetOverlayAnalystParameters";

        var me = _this;
        me.operateDatasetFields = [];
        me.operateDatasetFilter = new _FilterParameter2.default();
        me.operateRegions = [];
        me.sourceDatasetFields = [];
        me.sourceDatasetFilter = new _FilterParameter2.default();
        me.resultSetting = new _DataReturnOption2.default();
        if (!options) {
            var _ret;

            return _ret = _this, _possibleConstructorReturn(_this, _ret);
        }
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.DatasetOverlayAnalystParameters.prototype.resultSetting -{SuperMap.DataReturnOption}
     * @description 结果返回设置类。
     */


    /**
     * @member SuperMap.DatasetOverlayAnalystParameters.prototype.filterQueryParameter -{SuperMap.FilterParameter}
     * @description 设置源数据集中空间对象过滤条件。
     */


    /**
     * @member SuperMap.DatasetOverlayAnalystParameters.prototype.sourceDataset -{string}
     * @description 叠加分析中源数据集的名称。必设字段。
     */


    /**
     * @member SuperMap.DatasetOverlayAnalystParameters.prototype.operateDatasetFilter -{SuperMap.FilterParameter}
     * @description 设置操作数据集中空间对象过滤条件。
     */


    /**
     * @member SuperMap.DatasetOverlayAnalystParameters.prototype.operateDataset -{string}
     * @description 叠加分析中操作数据集的名称。
     */


    _createClass(DatasetOverlayAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(DatasetOverlayAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(DatasetOverlayAnalystParameters.prototype), 'destroy', this).call(this);

            var me = this;
            me.operateDataset = null;
            me.operateDatasetFields = null;
            if (me.operateDatasetFilter) {
                me.operateDatasetFilter.destroy();
                me.operateDatasetFilter = null;
            }
            if (me.operateRegions) {
                for (var i = 0, opRegions = me.operateRegions, len = opRegions.length; i < len; i++) {
                    opRegions[i].destroy();
                }
                me.operateRegions = null;
            }
            me.sourceDataset = null;
            me.sourceDatasetFields = null;
            if (me.sourceDatasetFilter) {
                me.sourceDatasetFilter.destroy();
                me.sourceDatasetFilter = null;
            }
            me.tolerance = null;
            if (me.resultSetting) {
                me.resultSetting.destroy();
                me.resultSetting = null;
            }
        }

        /**
         * @function SuperMap.DatasetOverlayAnalystParameters.toObject
         * @param datasetOverlayAnalystParameters -{Object} 数据集分析参数。
         * @param tempObj - {Object} 目标对象。
         * @description 生成数据集分析对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(datasetOverlayAnalystParameters, tempObj) {
            for (var name in datasetOverlayAnalystParameters) {
                if (name === "sourceDataset") {} else if (name === "operateRegions") {
                    tempObj.operateRegions = [];
                    var ors = datasetOverlayAnalystParameters.operateRegions;
                    for (var index in ors) {
                        if (ors.hasOwnProperty(index)) {
                            //icl542
                            tempObj.operateRegions[index] = _ServerGeometry2.default.fromGeometry(ors[index]);
                        }
                    }
                } else if (name === "resultSetting") {
                    tempObj.dataReturnOption = datasetOverlayAnalystParameters.resultSetting;
                } else {
                    tempObj[name] = datasetOverlayAnalystParameters[name];
                }
            }
        }
    }]);

    return DatasetOverlayAnalystParameters;
}(_OverlayAnalystParameters2.default);

exports.default = DatasetOverlayAnalystParameters;


_SuperMap2.default.DatasetOverlayAnalystParameters = DatasetOverlayAnalystParameters;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

var _SurfaceAnalystParameters = __webpack_require__(68);

var _SurfaceAnalystParameters2 = _interopRequireDefault(_SurfaceAnalystParameters);

var _DataReturnOption = __webpack_require__(24);

var _DataReturnOption2 = _interopRequireDefault(_DataReturnOption);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DatasetSurfaceAnalystParameters
 * @classdesc 数据集表面分析参数类。该类对数据集表面分析所用到的参数进行设置。
 * @param options - {Object} 可选参数。如:</br>
 *        dataset - {string} 要用来做数据集表面分析的数据源中数据集的名称。</br>
 *        filterQueryParameter - {SuperMap.FilterParameter} 获取或设置查询过滤条件参数。</br>
 *        zValueFieldName - {string} 获取或设置用于提取操作的字段名称。</br>
 *        extractParameter - {SuperMap.SurfaceAnalystParametersSetting} 表面分析参数设置类。获取或设置表面分析参数。</br>
 *        resolution - {Integer} 获取或设置指定中间结果（栅格数据集）的分辨率。</br>
 *        resultSetting - {SuperMap.DataReturnOption} 结果返回设置类。</br>
 *        surfaceAnalystMethod - {SuperMap.SurfaceAnalystMethod} 获取或设置表面分析的提取方法，提取等值线和提取等值面。</br>
 * @extends SuperMap.SurfaceAnalystParameters
 */
var DatasetSurfaceAnalystParameters = function (_SurfaceAnalystParame) {
    _inherits(DatasetSurfaceAnalystParameters, _SurfaceAnalystParame);

    /**
     *  @member SuperMap.DatasetSurfaceAnalystParameters.prototype.filterQueryParameter -{SuperMap.FilterParameter}
     *  @description 获取或设置查询过滤条件参数。
     */
    function DatasetSurfaceAnalystParameters(options) {
        _classCallCheck(this, DatasetSurfaceAnalystParameters);

        var _this = _possibleConstructorReturn(this, (DatasetSurfaceAnalystParameters.__proto__ || Object.getPrototypeOf(DatasetSurfaceAnalystParameters)).call(this, options));

        _this.dataset = null;
        _this.filterQueryParameter = null;
        _this.zValueFieldName = null;
        _this.CLASS_NAME = "SuperMap.DatasetSurfaceAnalystParameters";

        var me = _this;
        me.filterQueryParameter = new _FilterParameter2.default();
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.DatasetSurfaceAnalystParameters.prototype.zValueFieldName -{string}
     * @description 获取或设置用于提取操作的字段名称。
     * 提取等值线时，将使用该字段中的值，对点记录集中的点数据进行插值分析，得到栅格数据集（中间结果），接着从栅格数据集提取等值线。
     */

    /**
     * @member SuperMap.DatasetSurfaceAnalystParameters.prototype.dataset -{string}
     * @description 要用来做数据集表面分析的数据源中数据集的名称。
     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：Country@World。必设字段。
     */


    _createClass(DatasetSurfaceAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(DatasetSurfaceAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(DatasetSurfaceAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.dataset = null;
            if (me.filterQueryParameter) {
                me.filterQueryParameter.destroy();
                me.filterQueryParameter = null;
            }
            me.zValueFieldName = null;
        }

        /**
         * @function SuperMap.DatasetSurfaceAnalystParameters.toObject
         * @param datasetSurfaceAnalystParameters -{Object} 数据集表面分析参数
         * @param tempObj - {Object} 目标对象
         * @description 生成数数据集表面分析对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(datasetSurfaceAnalystParameters, tempObj) {
            for (var name in datasetSurfaceAnalystParameters) {
                if (name === "filterQueryParameter") {
                    tempObj.filterQueryParameter = datasetSurfaceAnalystParameters.filterQueryParameter;
                }
                if (name === "extractParameter") {
                    if (datasetSurfaceAnalystParameters.extractParameter.clipRegion instanceof _SuperMap2.default.Geometry && datasetSurfaceAnalystParameters.extractParameter.clipRegion.components) {
                        datasetSurfaceAnalystParameters.extractParameter.clipRegion = _ServerGeometry2.default.fromGeometry(datasetSurfaceAnalystParameters.extractParameter.clipRegion);
                    }
                    tempObj.extractParameter = datasetSurfaceAnalystParameters.extractParameter;
                } else if (name === "dataset") {} else if (name === "surfaceAnalystMethod") {} else {
                    tempObj[name] = datasetSurfaceAnalystParameters[name];
                }
            }
        }
    }]);

    return DatasetSurfaceAnalystParameters;
}(_SurfaceAnalystParameters2.default);

exports.default = DatasetSurfaceAnalystParameters;


_SuperMap2.default.DatasetSurfaceAnalystParameters = DatasetSurfaceAnalystParameters;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ThiessenAnalystParameters = __webpack_require__(54);

var _ThiessenAnalystParameters2 = _interopRequireDefault(_ThiessenAnalystParameters);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DatasetThiessenAnalystParameters
 * @classdesc 数据集泰森多边形分析参数类
 * @param options - {Object} 可选参数。如:</br>
 *        filterQueryParameter - {SuperMap.FilterParameter} 对待分析数据集中的点进行过滤，不设置时默认为null，即对数据集中的所有点进行分析。
 * @extends SuperMap.ThiessenAnalystParameters
 */
var DatasetThiessenAnalystParameters = function (_ThiessenAnalystParam) {
    _inherits(DatasetThiessenAnalystParameters, _ThiessenAnalystParam);

    /**
     * @member SuperMap.DatasetThiessenAnalystParameters.prototype.filterQueryParameter -{SuperMap.FilterParameter}
     * @description 过滤条件，对待分析数据集中的点进行过滤，不设置时默认为null，即对数据集中的所有点进行分析。
     * @example
     * (start code)
     * filterQueryParameter的使用方法如：
     *  filterQueryParameter = new SuperMap.FilterParameter({
     *   name: "Countries@World",
     *   attributeFilter: "SmID>100"
     *  });
     * (end)
     */
    function DatasetThiessenAnalystParameters(options) {
        _classCallCheck(this, DatasetThiessenAnalystParameters);

        var _this = _possibleConstructorReturn(this, (DatasetThiessenAnalystParameters.__proto__ || Object.getPrototypeOf(DatasetThiessenAnalystParameters)).call(this, options));

        _this.filterQueryParameter = null;
        _this.dataset = null;
        _this.CLASS_NAME = "SuperMap.DatasetThiessenAnalystParameters";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     *@inheritDoc
     */


    /**
     * @member SuperMap.DatasetThiessenAnalystParameters.prototype.dataset -{string}
     * @description 数据集名称待分析的数据集名称，请使用‘datasetName@datasourceName’格式来表示。
     */


    _createClass(DatasetThiessenAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(DatasetThiessenAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(DatasetThiessenAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.filterQueryParameter) {
                me.filterQueryParameter.destroy();
                me.filterQueryParameter = null;
            }
        }

        /**
         * @function SuperMap.DatasetThiessenAnalystParameters.toObject
         * @param datasetThiessenAnalystParameters -{Object} 泰森多边形分析服务参数。
         * @param tempObj - {Object} 目标对象。
         * @description 生成泰森多边形分析服务对象。
         */

    }], [{
        key: 'toObject',
        value: function toObject(datasetThiessenAnalystParameters, tempObj) {
            for (var name in datasetThiessenAnalystParameters) {
                if (name === "clipRegion") {
                    tempObj.clipRegion = _ServerGeometry2.default.fromGeometry(datasetThiessenAnalystParameters.clipRegion);
                } else {
                    tempObj[name] = datasetThiessenAnalystParameters[name];
                }
            }
        }
    }]);

    return DatasetThiessenAnalystParameters;
}(_ThiessenAnalystParameters2.default);

exports.default = DatasetThiessenAnalystParameters;


_SuperMap2.default.DatasetThiessenAnalystParameters = DatasetThiessenAnalystParameters;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.DatasourceConnectionInfo
 * @classdesc
 * 数据源连接信息类。
 * 该类包括了进行数据源连接的所有信息，如所要连接的服务器名称、数据库名称、用户名以及密码等。
 * 当保存为工作空间时， 工作空间中的数据源的连接信息都将存储到工作空间文件中。对于不同类型的
 * 数据源，其连接信息有所区别。所以在使 用该类所包含的成员时，请注意该成员所适用的数据源类型。
 * 对于从数据源对象中返回的数据连接信息对象，只有 connect 方法可以被修改，其 他内容是不可以被修改的。
 * 对于用户创建的数据源连接信息对象，其内容都可以修改。
 * @param options - {Object} 参数。如:</br>
 * alias - {string} 数据源别名。</br>
 * connect - {boolean} 数据源是否自动连接数据。</br>
 * dataBase - {string} 数据源连接的数据库名。</br>
 * driver - {string} 使用 ODBC(Open Database Connectivity，开放数据库互连)的数据库的驱动程序名。</br>
 * engineType - {EngineType} 数据源连接的引擎类型。</br>
 * exclusive - {boolean} 是否以独占方式打开数据源。</br>
 * OpenLinkTable - {boolean} 是否把数据库中的其他非 SuperMap 数据表作为 LinkTable 打开。</br>
 * password - {string} 登录数据源连接的数据库或文件的密码。</br>
 * readOnly - {boolean} 是否以只读方式打开数据源。</br>
 * server - {string} 数据库服务器名或 SDB 文件名。</br>
 * user - {string} 登录数据库的用户名。</br>
 */
var DatasourceConnectionInfo = function () {

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.server -{string}
     * @description 数据库服务器名、文件名或服务地址。
     * 1.对于SDB和UDB文件，为其文件的绝对路径。注意：当绝对路径的长度超过UTF-8编码格式的260字节长度，该数据源无法打开。
     * 2.对于Oracle数据库，其服务器名为其TNS服务名称。
     * 3.对于SQL Server数据库，其服务器名为其系统的DSN(Database Source Name)名称。
     * 4.对于PostgreSQL数据库，其服务器名为“IP:端口号”，默认的端口号是 5432。
     * 5.对于DB2数据库，已经进行了编目，所以不需要进行服务器的设置。
     * 6.对于 Kingbase 数据库，其服务器名为其 IP 地址。
     * 7.对于GoogleMaps数据源，其服务器地址，默认设置为“http://maps.google.com”，且不可更改。
     * 8.对于SuperMapCould数据源，为其服务地址。
     * 9.对于MAPWORLD数据源，为其服务地址，默认设置为“http://www.tianditu.cn”，且不可更改。
     * 10.对于OGC和REST数据源，为其服务地址。
     */


    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.password -{string}
     * @description 登录数据源连接的数据库或文件的密码。
     */


    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.exclusive -{boolean}
     * @description 是否以独占方式打开数据源。
     */


    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.driver -{string}
     * @description 使用 ODBC(Open Database Connectivity，开放数据库互连)的数据库的驱动程序名。
     * 其中，对于SQL Server 数据库与 iServer 发布的 WMTS 服务，此为必设参数。
     * 对于SQL Server 数据库，它使用 ODBC 连接，所设置的驱动程序名为 "SQL Server" 或 "SQL Native Client"；
     * 对于 iServer 发布的 WMTS 服务，设置的驱动名称为 "WMTS"。
     */


    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.connect -{boolean}
     * @description 数据源是否自动连接数据。
     */
    function DatasourceConnectionInfo(options) {
        _classCallCheck(this, DatasourceConnectionInfo);

        this.alias = null;
        this.connect = null;
        this.dataBase = null;
        this.driver = null;
        this.engineType = null;
        this.exclusive = null;
        this.OpenLinkTable = null;
        this.password = null;
        this.readOnly = null;
        this.server = null;
        this.user = null;
        this.CLASS_NAME = "SuperMap.DatasourceConnectionInfo";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.DatasourceConnectionInfo.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.user -{string}
     * @description 登录数据库的用户名。
     */


    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.readOnly -{boolean}
     * @description 是否以只读方式打开数据源。
     */


    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.OpenLinkTable -{boolean}
     * @description 是否把数据库中的其他非 SuperMap 数据表作为 LinkTable打开。
     */


    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.engineType -{EngineType}
     * @description 数据源连接的引擎类型。
     */


    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.dataBase -{string}
     * @description 数据源连接的数据库名。
     */

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.alias -{string}
     * @description 数据源别名。
     */


    _createClass(DatasourceConnectionInfo, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.alias = null;
            me.connect = null;
            me.dataBase = null;
            me.driver = null;
            me.engineType = null;
            me.exclusive = null;
            me.OpenLinkTable = null;
            me.password = null;
            me.readOnly = null;
            me.server = null;
            me.user = null;
        }
    }]);

    return DatasourceConnectionInfo;
}();

exports.default = DatasourceConnectionInfo;

_SuperMap2.default.DatasourceConnectionInfo = DatasourceConnectionInfo;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.DensityKernelAnalystParameters
 * @classdesc 核密度分析参数类
 * @param options - {Object} 可选参数。如:</br>
 *        dataset - {string} 要用来做核密度分析数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：BaseMap_P@Jingjin。必设字段。</br>
 *        bounds - {SuperMap.Bounds} 核密度分析的范围，用于确定结果栅格数据集的范围。如果缺省，则默认为原数据集的范围。</br>
 *                                   Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchRadius - {number}栅格邻域内用于计算密度的查找半径，单位与当前数据集相同。默认值为当前数据集的长宽中的最大值除30。</br>
 *        fieldName - {string} 用于进行核密度分析的测量值的字段名称，核密度分析不支持文本类型的字段，必设字段。</br>
 *        resultGridDatasetResolution - {number}密度分析结果栅格数据的分辨率，单位与当前数据集相同。默认值为当前数据集的长宽中的最小值除500。</br>
 *        targetDatasource - {string} 指定的存储结果数据集的数据源，默认为当前分析的数据集所在的数据源。</br>
 *        resultGridName - {number}指定结果数据集名称，必设字段。</br>
 *        deleteExistResultDataset - {boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。</br>
 */
var DensityKernelAnalystParameters = function () {

    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.resultGridName -{string}
     * @description 指定结果数据集名称，必设字段。
     */


    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.searchRadius -{number}
     * @description 栅格邻域内用于计算密度的查找半径，单位与当前数据集相同。默认值为当前数据集的长宽中的最大值除30。
     */


    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.fieldName -{string}
     * @description 用于进行核密度分析的测量值的字段名称，核密度分析不支持文本类型的字段，必设字段。
     */


    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.dataset -{string}
     * @description 要用来做核密度分析数据源中数据集的名称。
     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：Railway@Changchun。必设字段。
     * 注：核密度分析支持点数据集和线数据集。
     */
    function DensityKernelAnalystParameters(options) {
        _classCallCheck(this, DensityKernelAnalystParameters);

        this.dataset = null;
        this.bounds = null;
        this.fieldName = null;
        this.resultGridDatasetResolution = null;
        this.searchRadius = null;
        this.targetDatasource = null;
        this.resultGridName = null;
        this.deleteExistResultDataset = false;
        this.CLASS_NAME = "SuperMap.DensityKernelAnalystParameters";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.DensityKernelAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.deleteExistResultDataset -{boolean}
     * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
     */


    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.targetDatasource -{string}
     * @description 指定的存储结果数据集的数据源，默认为当前分析的数据集所在的数据源。
     */


    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.resultGridDatasetResolution -{number}
     * @description 密度分析结果栅格数据的分辨率，单位与当前数据集相同。默认值为当前数据集的长宽中的最小值除500。
     */


    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.bounds
     * @description 核密度分析的范围，用于确定结果栅格数据集的范围。</br>
     * Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
     * 如果缺省，则默认为原数据集的范围。
     */


    _createClass(DensityKernelAnalystParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.dataset = null;
            me.bounds = null;
            me.fieldName = null;
            me.resultGridDatasetResolution = null;
            me.searchRadius = null;

            me.targetDatasource = null;
            me.resultGridName = null;
            me.deleteExistResultDataset = null;
        }

        /**
         * @function SuperMap.DensityKernelAnalystParameters.toObject
         * @param densityKernelAnalystParameters -{Object} 核密度分析参数。
         * @param tempObj - {Object} 目标对象
         * @description 生成核密度分析对象
         */

    }], [{
        key: "toObject",
        value: function toObject(densityKernelAnalystParameters, tempObj) {
            for (var name in densityKernelAnalystParameters) {
                if (name !== "dataset") {
                    tempObj[name] = densityKernelAnalystParameters[name];
                }
            }
        }
    }]);

    return DensityKernelAnalystParameters;
}();

exports.default = DensityKernelAnalystParameters;


_SuperMap2.default.DensityKernelAnalystParameters = DensityKernelAnalystParameters;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.EditFeaturesParameters
 * @classdesc 数据服务中数据集添加、修改、删除参数类。
 * @param options - {Object} 可選参数。如:</br>
 *        features - {Array<Object>} 当前需要创建或者是修改的要素集。</br>
 *                                   feature类型可以是：SuperMap.Feature.Vector|GeoJSON|ol.feature。</br>
 *        returnContent - {boolean} 是返回创建要素的ID数组还是返回featureResult资源的URI。</br>
 *        editType - {SuperMap.EditType} POST动作类型(ADD、UPDATE、DELETE)，默认为 SuperMap.EditType.ADD。</br>
 *        IDs - {Array<string|Integer>}删除要素时的要素的ID数组。</br>
 */
var EditFeaturesParameters = function () {

  /**
   * @member SuperMap.EditFeaturesParameters.prototype.returnContent -{boolean}
   * @description 要素添加时，isUseBatch 不传或传为 false 的情况下有效。
   *true 表示直接返回新创建的要素的 ID 数组;false 表示返回创建的 featureResult 资源的 URI。默认不传时为 false。
   */


  /**
   * @member SuperMap.EditFeaturesParameters.prototype.dataSetName -{EditType}
   * @description 要素集更新类型(add、update、delete)，默认为 SuperMap.EditType.ADD.
   */


  /**
   * @member SuperMap.EditFeaturesParameters.prototype.dataSetName -{string}
   * @description 当前需要创建或者是修改的要素的数据集。
   */
  function EditFeaturesParameters(options) {
    _classCallCheck(this, EditFeaturesParameters);

    this.dataSourceName = null;
    this.dataSetName = null;
    this.features = null;
    this.editType = _REST.EditType.ADD;
    this.IDs = null;
    this.returnContent = false;
    this.isUseBatch = false;
    this.CLASS_NAME = "SuperMap.EditFeaturesParameters";

    if (!options) {
      return;
    }
    _SuperMap2.default.Util.extend(this, options);
  }

  /**
   * @function SuperMap.EditFeaturesParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  /**
   * @member SuperMap.EditFeaturesParameters.prototype.isUseBatch -{boolean}
   * @description 是否使用批量添加要素功能，要素添加时有效。批量添加能够提高要素编辑效率。true 表示批量添加；false 表示不使用批量添加。默认不传时为 false。
   */


  /**
   * @member SuperMap.EditFeaturesParameters.prototype.dataSetName -{Array<string>}|{Array<Integer>}
   * @description 执行删除时要素集ID集合。
   */


  /**
   * @member SuperMap.EditFeaturesParameters.prototype.features -{Array<Object>}
   * @description 当前需要创建或者是修改的要素集。</br>
   * feature类型可以是：SuperMap.Feature.Vector|GeoJSON|ol.feature。
   */


  /**
   * @member SuperMap.EditFeaturesParameters.prototype.dataSourceName -{string}
   * @description 当前需要创建或者是修改的要素的数据源
   */


  _createClass(EditFeaturesParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.dataSourceName = null;
      me.dataSetName = null;
      me.features = null;
      me.editType = null;
      me.IDs = null;
      me.returnContent = null;
    }

    /**
     * @function SuperMap.EditFeaturesParameters.prototype.toJsonParameters
     * @description 将 <EditFeaturesParameters> 对象参数转换为 json 字符串。
     * @param params - {SuperMap.EditFeaturesParameters} 地物编辑参数。
     * return {string} 转化后的 json字符串。
     */

  }], [{
    key: 'toJsonParameters',
    value: function toJsonParameters(params) {
      var geometry,
          feature,
          len,
          features,
          editType = params.editType;

      if (editType === _SuperMap2.default.EditType.DELETE) {
        if (params.IDs === null) return;

        features = { ids: params.IDs };
      } else {
        if (params.features === null) return;

        len = params.features.length;
        features = [];
        for (var i = 0; i < len; i++) {
          feature = params.features[i];
          feature.geometry = _ServerGeometry2.default.fromGeometry(feature.geometry);
          features.push(feature);
        }
      }

      return _SuperMap2.default.Util.toJSON(features);
    }
  }]);

  return EditFeaturesParameters;
}();

exports.default = EditFeaturesParameters;


_SuperMap2.default.EditFeaturesParameters = EditFeaturesParameters;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FacilityAnalyst3DParameters = __webpack_require__(25);

var _FacilityAnalyst3DParameters2 = _interopRequireDefault(_FacilityAnalyst3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystSinks3DParameters
 * @classdesc 最近设施分析参数类(汇查找资源)<br>
 *               最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。<br>
 *               设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。<br>
 *               例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。<br>
 *               最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如：<br>
 *         edgeID - {number}指定的弧段ID。<br>
 *         nodeID - {Integer} 指定的结点ID。<br>
 *         weightName -{string} 指定的权值字段信息对象的名称。<br>
 *         isUncertainDirectionValid -{boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；<br>
 *                                              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找
 */
var FacilityAnalystSinks3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystSinks3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystSinks3DParameters(options) {
        _classCallCheck(this, FacilityAnalystSinks3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystSinks3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystSinks3DParameters)).call(this, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystSinks3DParameters";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystSinks3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystSinks3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystSinks3DParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return FacilityAnalystSinks3DParameters;
}(_FacilityAnalyst3DParameters2.default);

exports.default = FacilityAnalystSinks3DParameters;

_SuperMap2.default.FacilityAnalystSinks3DParameters = FacilityAnalystSinks3DParameters;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FacilityAnalyst3DParameters = __webpack_require__(25);

var _FacilityAnalyst3DParameters2 = _interopRequireDefault(_FacilityAnalyst3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystSources3DParameters
 * @classdesc 最近设施分析参数类(源查找资源)<br>
 *               最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。<br>
 *               设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。<br>
 *               例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。<br>
 *               最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如：<br>
 *         edgeID - {number}指定的弧段ID。<br>
 *         nodeID - {Integer} 指定的结点ID。<br>
 *         weightName -{string} 指定的权值字段信息对象的名称。<br>
 *         isUncertainDirectionValid -{boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；<br>
 *                                              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找
 */
var FacilityAnalystSources3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystSources3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystSources3DParameters(options) {
        _classCallCheck(this, FacilityAnalystSources3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystSources3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystSources3DParameters)).call(this, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystSources3DParameters";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystSources3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystSources3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystSources3DParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return FacilityAnalystSources3DParameters;
}(_FacilityAnalyst3DParameters2.default);

exports.default = FacilityAnalystSources3DParameters;


_SuperMap2.default.FacilityAnalystSources3DParameters = FacilityAnalystSources3DParameters;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FacilityAnalystStreamParameters
 * @description 上游/下游关键设施查找资源参数类。
 * @param options - {Object} 可选参数。如：
 *        sourceNodeIDs - {Array<number>} 指定的设施点ID数组，可以为空。
 *        edgeID - {number}指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。
 *        nodeID - {number}指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。
 *        isUncertainDirectionValid - {boolean} 指定不确定流向是否有效；默认false，无效。
 *        queryType - {number}分析类型，只能是 0 (上游关键设施查询) 或者是 1（下游关键设施查询）
 */
var FacilityAnalystStreamParameters = function () {

    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.isUncertainDirectionValid -{boolean}
     * @description 指定不确定流向是否有效，默认为false。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；<br>
     *               指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
     */


    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.edgeID -{number}
     * @description 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。
     */
    function FacilityAnalystStreamParameters(options) {
        _classCallCheck(this, FacilityAnalystStreamParameters);

        this.sourceNodeIDs = null;
        this.edgeID = null;
        this.nodeID = null;
        this.isUncertainDirectionValid = false;
        this.queryType = null;
        this.CLASS_NAME = "SuperMap.FacilityAnalystStreamParameters";

        var me = this;
        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(me, options);
    }

    /**
     * @function SuperMap.FacilityAnalystStreamParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.queryType -{number}
     * @description 分析类型，只能是 0 (上游关键设施查询) 或者是 1（下游关键设施查询）。
     */


    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.nodeID -{number}
     * @description 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。
     */


    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.sourceNodeIDs -{Array<number>}
     * @description 指定的设施点ID数组,可以为空。
     */


    _createClass(FacilityAnalystStreamParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.edgeID = null;
            me.nodeID = null;
            me.weightName = null;
            me.isUncertainDirectionValid = null;
            me.type = null;
        }
    }]);

    return FacilityAnalystStreamParameters;
}();

exports.default = FacilityAnalystStreamParameters;


_SuperMap2.default.FacilityAnalystStreamParameters = FacilityAnalystStreamParameters;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FacilityAnalyst3DParameters = __webpack_require__(25);

var _FacilityAnalyst3DParameters2 = _interopRequireDefault(_FacilityAnalyst3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystTracedown3DParameters
 * @classdesc 下游追踪资源参数类
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如：<br>
 *        edgeID - {number}指定的弧段ID。<br>
 *        nodeID - {Integer} 指定的结点ID。<br>
 *        weightName -{string} 指定的权值字段信息对象的名称。<br>
 *        isUncertainDirectionValid -{boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；<br>
 *                                              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。

 */
var FacilityAnalystTracedown3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystTracedown3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystTracedown3DParameters(options) {
        _classCallCheck(this, FacilityAnalystTracedown3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystTracedown3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystTracedown3DParameters)).call(this, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystTracedown3DParameters";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystTracedown3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystTracedown3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystTracedown3DParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return FacilityAnalystTracedown3DParameters;
}(_FacilityAnalyst3DParameters2.default);

exports.default = FacilityAnalystTracedown3DParameters;


_SuperMap2.default.FacilityAnalystTracedown3DParameters = FacilityAnalystTracedown3DParameters;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FacilityAnalyst3DParameters = __webpack_require__(25);

var _FacilityAnalyst3DParameters2 = _interopRequireDefault(_FacilityAnalyst3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystTraceup3DParameters
 * @classdesc 上游追踪资源参数类
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如：<br>
 *         edgeID - {number}指定的弧段ID。<br>
 *         nodeID - {Integer} 指定的结点ID。<br>
 *         weightName -{string} 指定的权值字段信息对象的名称。<br>
 *         isUncertainDirectionValid -{boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；<br>
 *                                              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 */
var FacilityAnalystTraceup3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystTraceup3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystTraceup3DParameters(options) {
        _classCallCheck(this, FacilityAnalystTraceup3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystTraceup3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystTraceup3DParameters)).call(this, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystTraceup3DParameters";
        return _this;
    }

    /**
     * @inheritDoc
     */


    _createClass(FacilityAnalystTraceup3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystTraceup3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystTraceup3DParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return FacilityAnalystTraceup3DParameters;
}(_FacilityAnalyst3DParameters2.default);

exports.default = FacilityAnalystTraceup3DParameters;


_SuperMap2.default.FacilityAnalystTraceup3DParameters = FacilityAnalystTraceup3DParameters;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FacilityAnalyst3DParameters = __webpack_require__(25);

var _FacilityAnalyst3DParameters2 = _interopRequireDefault(_FacilityAnalyst3DParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystUpstream3DParameters
 * @classdesc 上游关键设施查找资源参数类
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如：<br>
 *        edgeID - {number}指定的弧段ID。<br>
 *        nodeID - {Integer} 指定的结点ID。<br>
 *        weightName -{string} 指定的权值字段信息对象的名称。<br>
 *        isUncertainDirectionValid -{boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 *                                              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。<br>
 *        sourceNodeIDs - {Array<number>} 指定的设施点ID数组
 */
var FacilityAnalystUpstream3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystUpstream3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystUpstream3DParameters(options) {
        _classCallCheck(this, FacilityAnalystUpstream3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystUpstream3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystUpstream3DParameters)).call(this, options));

        _this.sourceNodeIDs = null;
        _this.CLASS_NAME = "SuperMap.FacilityAnalystUpstream3DParameters";

        options = options || {};
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.FacilityAnalystUpstream3DParameters.prototype.sourceNodeIDs -{Array<number>}
     * @description 指定的设施点ID数组
     */


    _createClass(FacilityAnalystUpstream3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystUpstream3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystUpstream3DParameters.prototype), 'destroy', this).call(this);
            this.sourceNodeIDs = null;
        }
    }]);

    return FacilityAnalystUpstream3DParameters;
}(_FacilityAnalyst3DParameters2.default);

exports.default = FacilityAnalystUpstream3DParameters;


_SuperMap2.default.FacilityAnalystUpstream3DParameters = FacilityAnalystUpstream3DParameters;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FieldParameters
 * @classdesc 字段信息查询参数类。
 * @param options - {Object} 参数。如：<br>
 *        datasource - {string} 数据源名称。<br>
 *        dataset -{string} 数据集名称。
 */
var FieldParameters = function () {
    /**
     * @member SuperMap.FieldParameters.prototype.datasource -{string}
     * @description 要查询的数据集所在的数据源名称。
     */
    function FieldParameters(options) {
        _classCallCheck(this, FieldParameters);

        this.datasource = null;
        this.dataset = null;
        this.CLASS_NAME = "SuperMap.FieldParameters";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.FieldParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     *  @member SuperMap.FieldParameters.prototype.dataset -{string}
     *  @description 要查询的数据集名称。
     */


    _createClass(FieldParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.datasource = null;
            me.dataset = null;
        }
    }]);

    return FieldParameters;
}();

exports.default = FieldParameters;


_SuperMap2.default.FieldParameters = FieldParameters;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FieldParameters2 = __webpack_require__(187);

var _FieldParameters3 = _interopRequireDefault(_FieldParameters2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FieldStatisticsParameters
 * @classdesc 字段统计信息查询参数类。
 * @param options - {Object} 参数。如：<br>
 *         datasource - {string} 数据源名称。<br>
 *        dataset -{string} 数据集名称。
 *        fieldName - {string} 字段名。<br>
 *        statisticMode -{String<SuperMap.StatisticMode>}|{Array<String<SuperMap.StatisticMode>>} 字段统计方法类型。
 * @extends SuperMap.FieldParameters
 */
var FieldStatisticsParameters = function (_FieldParameters) {
    _inherits(FieldStatisticsParameters, _FieldParameters);

    /**
     * @member SuperMap.FieldStatisticsParameters.prototype.fieldName -{string}
     * @description 字段名
     */
    function FieldStatisticsParameters(options) {
        _classCallCheck(this, FieldStatisticsParameters);

        var _this = _possibleConstructorReturn(this, (FieldStatisticsParameters.__proto__ || Object.getPrototypeOf(FieldStatisticsParameters)).call(this, options));

        _this.fieldName = null;
        _this.statisticMode = null;
        _this.CLASS_NAME = "SuperMap.FieldStatisticsParameters";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.FieldStatisticsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.FieldStatisticsParameters.prototype.statisticMode -{string<SuperMap.StatisticMode>}|{Array<string{SuperMap.StatisticMode}>}
     * @description 字段统计方法类型
     */


    _createClass(FieldStatisticsParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.fieldName = null;
            me.statisticMode = null;
        }
    }]);

    return FieldStatisticsParameters;
}(_FieldParameters3.default);

exports.default = FieldStatisticsParameters;


_SuperMap2.default.FieldStatisticsParameters = FieldStatisticsParameters;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _TransportationAnalystParameter = __webpack_require__(17);

var _TransportationAnalystParameter2 = _interopRequireDefault(_TransportationAnalystParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindClosestFacilitiesParameters
 * @classdesc 最近设施分析参数类。
 * @param options - {Object} 可选参数。</br>
 *         event - {Object/Integer} 事件点，一般为需要获得服务设施服务的事件位置，必设字段。</br>
 *                  点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *         expectFacilityCount - {Integer} 要查找的设施点数量。默认值为1。</br>
 *         facilities - {Array<Object>|Array<number>} 设施点集合，一般为提供服务的服务设施位置，必设字段。</br>
 *                       点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *         fromEvent - {boolean} 是否从事件点到设施点进行查找。</br>
 *         isAnalyzeById - {boolean} 事件点和设施点是否通过节点 ID 号来指定，默认为 false，即通过坐标点指定事件点和设施点。</br>
 *         maxWeight - {number}查找半径。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。默认值为0，表示查找全网络。</br>
 *         parameter - {SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。</br>
 */
var FindClosestFacilitiesParameters = function () {

    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.maxWeight -{number}
     * @description 查找半径。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。默认值为0，表示查找全网络。</br>
     *              例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。
     *              那么需要将网络分析参数中 parameter.weightFieldName 设置为表示时间的字段，然后设置查找范围的半径值为10。
     */


    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.fromEvent -{boolean}
     * @description 是否从事件点到设施点进行查找。</br>
     *              最近设施分析主要是通过设施点和事件点之间最优的路线来分析在一定范围内哪个或哪些设施与事件点有最优路线的关系。</br>
     *              这个行走线路是通过网络图层进行网络分析算法计算出来的两点间的最优路线。
     *              由于存在从 A 点到 B 点与从 B 点到 A 点的耗费不一样的情况，因此起止点不同可能会得到不同的最优路线。
     *              因此在进行最近设施分析之前，需要设置获取的最优路线的方向，即是以事件点作为起点到最近设施点的方向分析，还是以最近设施点为起点到事件点的方向分析。
     *              如果需要以事件点作为起点到设施点方向进行查找，设置该字段值为 true；默认为 false，表示从设施点到事件点进行查找。
     */


    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.expectFacilityCount -{number}
     * @description 要查找的设施点数量。默认值为1。
     */
    function FindClosestFacilitiesParameters(options) {
        _classCallCheck(this, FindClosestFacilitiesParameters);

        this.event = null;
        this.expectFacilityCount = 1;
        this.facilities = null;
        this.fromEvent = false;
        this.isAnalyzeById = false;
        this.maxWeight = 0;
        this.parameter = null;
        this.CLASS_NAME = "SuperMap.FindClosestFacilitiesParameters";

        var me = this;
        me.parameter = new _TransportationAnalystParameter2.default();
        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.FindClosestFacilitiesParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.parameter {SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。</br>
     *              通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。</br>
     *              它为 SuperMap.TransportationAnalystParameter 类型，虽然为可选参数，但是如果不设置其中的 resultSetting 字段，则返回结果空间信息等都为空。
     */


    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.isAnalyzeById -{boolean}
     * @description 事件点和设施点是否通过节点 ID 号来指定，默认为 false，即通过坐标点指定事件点和设施点。
     */


    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.facilities -{Array<Object>|Array<number>}
     * @description 设施点集合，一般为提供服务的服务设施位置，必设字段。</br>
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
     *              可以通过两种方式赋予设施点：当该类中字段 isAnalyzeById = true 时，应输入设施点 ID 号；当 isAnalyzeById = false 时，应输入设施点坐标。
     */


    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.event -{Object}
     * @description 事件点，一般为需要获得服务设施服务的事件位置，必设字段。</br>
     *              点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
     *              可以通过两种方式赋予事件点：当该类中字段 isAnalyzeById = true 时，应输入事件点 ID 号；当 isAnalyzeById = false 时，应输入事件点坐标。</br>
     */


    _createClass(FindClosestFacilitiesParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.event = null;
            me.expectFacilityCount = null;
            me.facilities = null;
            me.fromEvent = null;
            me.isAnalyzeById = null;
            me.maxWeight = null;
            if (me.parameter) {
                me.parameter.destroy();
                me.parameter = null;
            }
        }
    }]);

    return FindClosestFacilitiesParameters;
}();

exports.default = FindClosestFacilitiesParameters;


_SuperMap2.default.FindClosestFacilitiesParameters = FindClosestFacilitiesParameters;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SupplyCenter = __webpack_require__(239);

var _SupplyCenter2 = _interopRequireDefault(_SupplyCenter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindLocationParameters
 * @classdesc 选址分区分析参数类。
 * @param options - {Object} 可选参数。如：<br>
 *        expectedSupplyCenterCount - {Integer} 期望用于最终设施选址的资源供给中心数量，必设字段。<br>
 *        isFromCenter - {boolean} 是否从中心点开始分配资源。默认为 false。<br>
 *        supplyCenters - {Array<SupplyCenter>} 资源供给中心集合，必设字段。<br>
 *        turnWeightField - {string} 转向权值字段的名称。<br>
 *        weightName - {string} 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，必设字段。
 */
var FindLocationParameters = function () {

    /**
     * @member SuperMap.FindLocationParameters.prototype.turnWeightField -{string}
     * @description 转向权值字段的名称。
     */


    /**
     * @member SuperMap.FindLocationParameters.prototype.isFromCenter -{boolean}
     * @description 是否从中心点开始分配资源。默认为 false。<br>
     *              由于网路数据中的弧段具有正反阻力，即弧段的正向阻力值与其反向阻力值可能不同，
     *              因此，在进行分析时，从资源供给中心开始分配资源到需求点与从需求点向资源供给中心分配这两种分配形式下，所得的分析结果会不同。
     */
    function FindLocationParameters(options) {
        _classCallCheck(this, FindLocationParameters);

        this.expectedSupplyCenterCount = null;
        this.isFromCenter = false;
        this.supplyCenters = null;
        this.turnWeightField = null;
        this.weightName = null;
        this.CLASS_NAME = "SuperMap.FindLocationParameters";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.FindLocationParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.FindLocationParameters.prototype.weightName -{string}
     * @description 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，必设字段。
     */


    /**
     * @member SuperMap.FindLocationParameters.prototype.supplyCenters -{Array<SuperMap.SupplyCenter>}
     * @description 资源供给中心集合，必设字段。<br>
     *              资源供给中心是提供资源和服务的设施，对应于网络结点，
     *              资源供给中心的相关信息包括资源量、最大阻力值、资源供给中心类型，资源供给中心在网络中所处结点的 ID 等，以便在进行选址分区分析时使用。
     */


    /**
     * @member SuperMap.FindLocationParameters.prototype.expectedSupplyCenterCount -{number}
     * @description 期望用于最终设施选址的资源供给中心数量，必设字段。<br>
     *              当输入值为0时，最终设施选址的资源供给中心数量默认为覆盖分析区域内的所需最少的供给中心数。
     */


    _createClass(FindLocationParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.expectedSupplyCenterCount = null;
            me.isFromCenter = null;
            me.turnWeightField = null;
            me.weightName = null;
            if (me.supplyCenters) {
                for (var i = 0, supplyCenters = me.supplyCenters, len = supplyCenters.length; i < len; i++) {
                    supplyCenters[i].destroy();
                }
                me.supplyCenters = null;
            }
        }
    }]);

    return FindLocationParameters;
}();

exports.default = FindLocationParameters;


_SuperMap2.default.FindLocationParameters = FindLocationParameters;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _TransportationAnalystParameter = __webpack_require__(17);

var _TransportationAnalystParameter2 = _interopRequireDefault(_TransportationAnalystParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindMTSPPathsParameters
 * @classdesc 多旅行商分析参数类
 * @param options - {Object} 可选参数。如：<br>
 *        centers - {Array<Object>|Array<number>} 配送中心集合，必设字段。<br>
 *                                  点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        hasLeastTotalCost - {boolean} 配送模式是否为总花费最小方案。默认为 false。<br>
 *        isAnalyzeById - {boolean} 是否通过节点 ID 号来指定配送中心点和配送目的点，默认为 false，即通过坐标点指定。<br>
 *        nodes - {Array<{SuperMap.Point}|number>} 配送目标集合，必设字段。<br>
 *                                  点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        parameter - {SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。
 */
var FindMTSPPathsParameters = function () {

    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.nodes -{Array<Object>|Array<number>}
     * @description 配送目标集合，必设字段。<br>
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
     *              当 SuperMap.FindMTSPPathsParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；<br>
     *              当 SuperMap.FindMTSPPathsParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
     */


    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.hasLeastTotalCost -{boolean}
     * @description 配送模式是否为总花费最小方案。默认为 false。<br>
     *              若为 true，则按照总花费最小的模式进行配送，此时可能会出现某几个配送中心点配送的花费较多而其他配送中心点的花费很少的情况。<br>
     *              若为 false，则为局部最优，此方案会控制每个配送中心点的花费，使各个中心点花费相对平均，此时总花费不一定最小。
     */
    function FindMTSPPathsParameters(options) {
        _classCallCheck(this, FindMTSPPathsParameters);

        this.centers = null;
        this.hasLeastTotalCost = false;
        this.isAnalyzeById = false;
        this.nodes = null;
        this.parameter = null;
        this.CLASS_NAME = "SuperMap.FindMTSPPathsParameters";

        var me = this;
        me.parameter = new _TransportationAnalystParameter2.default();
        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.FindMTSPPathsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.parameter -{SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。<br>
     *              通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。<br>
     *              SuperMap.TransportationAnalystParameter 类型，它虽然为可选参数，但是如果不设置其中的 resultSetting 字段，则返回结果空间信息等都为空。
     */


    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.isAnalyzeById -{boolean}
     * @description 是否通过节点 ID 号来指定配送中心点和配送目的点，默认为 false，即通过坐标点指定。
     */


    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.centers -{Array<Object>|Array<number>}
     * @description 配送中心集合，必设字段。<br>
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
     *              当 SuperMap.FindMTSPPathsParameters.isAnalyzeById = false 时，centers 应为点的坐标数组；<br>
     *              当 SuperMap.FindMTSPPathsParameters.isAnalyzeById = true 时，centers 应为点的 ID 数组。
     */


    _createClass(FindMTSPPathsParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.centers = null;
            me.hasLeastTotalCost = null;
            me.isAnalyzeById = null;
            me.nodes = null;
            me.maxWeight = null;
            if (me.parameter) {
                me.parameter.destroy();
                me.parameter = null;
            }
        }
    }]);

    return FindMTSPPathsParameters;
}();

exports.default = FindMTSPPathsParameters;


_SuperMap2.default.FindMTSPPathsParameters = FindMTSPPathsParameters;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _TransportationAnalystParameter = __webpack_require__(17);

var _TransportationAnalystParameter2 = _interopRequireDefault(_TransportationAnalystParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindPathParameters
 * @classdesc 最佳路径分析参数类<br>
 *              最佳路径是在网络数据集中指定一些结点，按照顺序访问结点从而求解起止点之间阻抗最小的路径。<br>
 *              例如如果要顺序访问1、2、3、4四个结点，则需要分别找到1、2结点间的最佳路径 R1—2，2、3间的最佳路径 R2—3和3、4结点间的最佳路径 R3—4，<br>
 *              顺序访问1、2、3、4四个结点的最佳路径就是 R= R1—2 + R2—3 + R3—4。<br>
 *              阻抗就是指从一点到另一点的耗费，在实际应用中我们可以将距离、时间、花费等作为阻抗条件。<br>
 *              阻抗最小也就可以理解为从一点到另一点距离最短、时间最少、花费最低等。当两点间距离最短时为最短路径，它是最佳路径问题的一个特例。<br>
 *              阻抗值通过 SuperMap.TransportationAnalystParameter.weightFieldName 设置。<br>
 *              计算最佳路径除了受阻抗影响外，还受转向字段的影响。转向值通过 SuperMap.TransportationAnalystParameter.turnWeightField 设置。<br>
 *
 * @param options - {Object} 可选参数。如：<br>
 *        isAnalyzeById - {boolean} 是否通过节点 ID 指定路径分析的结点。<br>
 *        hasLeastEdgeCount - {boolean} 是否按照弧段数最少的进行最佳路径分析。<br>
 *        nodes - {Array} 最佳路径分析经过的结点或设施点数组，必设字段。该字段至少包含两个点。<br>
 *                        点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        parameter - {SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。
 */
var FindPathParameters = function () {

    /**
     * @member SuperMap.FindPathParameters.prototype.nodes -{Array<Object>|Array<number>}
     * @description 最佳路径分析经过的结点或设施点数组，必设字段。该字段至少包含两个点。<br>
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
     *              当 SuperMap.FindPathParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；<br>
     *              当 SuperMap.FindPathParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
     */


    /**
     * @member SuperMap.FindPathParameters.prototype.isAnalyzeById -{boolean}
     * @description 是否通过节点 ID 指定路径分析的结点，默认为 false。<br>
     *              指定路径分析经过的结点或设施点有两种方式：输入结点 ID 号或直接输入点坐标。<br>
     *              当该字段为 true 时，表示通过结点 ID 指定途经点，即 SuperMap.FindPathParameters.nodes = [ID1,ID2,...]；<br>
     *              反之表示通过结点坐标指定途经点，即 SuperMap.FindPathParameters.nodes = [{x1,y1},{x2,y2},...] 。
     */
    function FindPathParameters(options) {
        _classCallCheck(this, FindPathParameters);

        this.isAnalyzeById = false;
        this.hasLeastEdgeCount = null;
        this.nodes = null;
        this.parameter = null;
        this.CLASS_NAME = "SuperMap.FindPathParameters";

        var me = this;
        me.parameter = new _TransportationAnalystParameter2.default();
        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.FindPathParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.FindPathParameters.prototype.parameter -{SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。
     */


    /**
     * @member SuperMap.FindPathParameters.prototype.hasLeastEdgeCount -{boolean}
     * @description 是否按照弧段数最少的进行最佳路径分析。<br>
     *               true 表示按照弧段数最少进行分析，返回弧段数最少的路径中一个阻抗最小的最佳路径；<br>
     *               false表示直接返回阻抗最小的路径，而不考虑弧段的多少。
     */


    _createClass(FindPathParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.isAnalyzeById = null;
            me.hasLeastEdgeCount = null;
            me.nodes = null;
            if (me.parameter) {
                me.parameter.destroy();
                me.parameter = null;
            }
        }
    }]);

    return FindPathParameters;
}();

exports.default = FindPathParameters;


_SuperMap2.default.FindPathParameters = FindPathParameters;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _TransportationAnalystParameter = __webpack_require__(17);

var _TransportationAnalystParameter2 = _interopRequireDefault(_TransportationAnalystParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindServiceAreasParameters
 * @classdesc 服务区分析参数类.<br>
 *              服务区分析是以指定服务站点为中心，在一定服务范围内查找网络上服务站点能够提供服务的区域范围。<br>
 *              例如：计算某快餐店能够在30分钟内送达快餐的区域。<br>
 * @param options - {Object} 可选参数。<br>
 *        isAnalyzeById - {boolean} 是否通过节点 ID 指定路径分析的结点。<br>
 *        isCenterMutuallyExclusive - {boolean} 是否中心点互斥。<br>
 *        centers - {Array} 服务站点数组，必设字段。<br>
 *                          点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        isFromCenter - {boolean} 是否从中心点开始分析。<br>
 *        weights - {Array} 每个服务站点提供服务的阻力半径，超过这个阻力半径的区域不予考虑，其单位与阻力字段一致，必设字段。<br>
 *        parameter - {SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。
 */
var FindServiceAreasParameters = function () {

    /**
     * APIProperty: weights
     * @member SuperMap.FindServiceAreasParameters.prototype.weights -{Array<number>}
     * @description 每个服务站点提供服务的阻力半径，即超过这个阻力半径的区域不予考虑，其单位与阻力字段一致，必设字段。<br>
     *               该字段为一个数组，数组长度跟服务中心个数一致，按照索引顺序与站点一一对应，每个元素表示了在对每个服务中心进行服务区分析时，所用的服务半径。
     */


    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.centers -{Array<Object>|Array<number>}
     * @description 服务站点数组，必设字段。<br>
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
     *              当该类的 iSAnalyzeById = true 时，通过结点 ID 号指定服务站点；<br>
     *              当 iSAnalyzeById = false 时，通过点坐标指定服务站点。
     */


    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.isAnalyzeById -{boolean}
     * @description 是否通过节点 ID 指定路径分析的结点，默认为 false。<br>
     *               指定路径分析经过的结点或设施点有两种方式：输入结点 ID 号或直接输入点坐标。<br>
     *               当该字段为 true 时，表示通过结点 ID 指定途经点，即 SuperMap.FindServiceAreasParameters.centers = [ID1,ID2,...]；<br>
     *               反之表示通过结点坐标指定途经点，即 SuperMap.FindServiceAreasParameters.centers = [{x1,y1},{x2,y2},...]。
     */
    function FindServiceAreasParameters(options) {
        _classCallCheck(this, FindServiceAreasParameters);

        this.isAnalyzeById = false;
        this.isCenterMutuallyExclusive = false;
        this.centers = null;
        this.isFromCenter = false;
        this.weights = null;
        this.parameter = null;
        this.CLASS_NAME = "SuperMap.FindServiceAreasParameters";

        var me = this;
        me.parameter = new _TransportationAnalystParameter2.default();
        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.FindServiceAreasParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.parameter -{SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。
     */


    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.isFromCenter -{boolean}
     * @description 是否从中心点开始分析。默认为 false。<br>
     *               从中心点开始分析和不从中心点开始分析，体现了服务中心和需要该服务的需求地的关系模式。<br>
     *               从中心点开始分析，是一个服务中心向服务需求地提供服务；<br>
     *               而不从中心点开始分析，是一个服务需求地主动到服务中心获得服务。
     */


    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.isCenterMutuallyExclusive -{boolean}
     * @description 是否中心点互斥，即按照中心点的距离进行判断是否要进行互斥处理，默认为 false。<br>
     *               若分析出的服务区有重叠的部分，则通过设置该参数进行互斥处理。
     */


    _createClass(FindServiceAreasParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.isAnalyzeById = null;
            me.isCenterMutuallyExclusive = null;
            me.centers = null;
            me.isFromCenter = null;
            me.weights = null;
            if (me.parameter) {
                me.parameter.destroy();
                me.parameter = null;
            }
        }
    }]);

    return FindServiceAreasParameters;
}();

exports.default = FindServiceAreasParameters;


_SuperMap2.default.FindServiceAreasParameters = FindServiceAreasParameters;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _TransportationAnalystParameter = __webpack_require__(17);

var _TransportationAnalystParameter2 = _interopRequireDefault(_TransportationAnalystParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindTSPPathsParameters
 * @classdesc 旅行商分析参数类<br>
 *              旅行商分析是路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
 *              旅行商分析也可以指定到达的终点，这时查找从起点能够遍历所有途经点最后到达终点，且花费最小的路径。<br>
 *              旅行商分析和最佳路径分析都是在网络中寻找遍历所有站点的最经济的路径，区别是在遍历网络所有站点的过程中对结点访问顺序不同<br>
 *              最佳路径分析必须按照指定顺序对站点进行访问，而旅行商分析是无序的路径分析。<br>
 * @param options - {Object} 可选参数。如：<br>
 *        endNodeAssigned - {boolean} 是否指定终止点，将指定的途经点的最后一个点作为终止点。<br>
 *                                      true 表示指定终止点，则旅行商必须最后一个访问终止点。默认为 false。<br>
 *        isAnalyzeById - {boolean} 是否通过节点 ID 号来指定配送中心点和配送目的点，默认为 false，即通过坐标点指定。<br>
 *        nodes - {Array<Object>|Array<number>} 配送目标集合，必设字段。<br>
 *                          点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        parameter - {SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。<br>
 */
var FindTSPPathsParameters = function () {

    /**
     * @member SuperMap.FindTSPPathsParameters.prototype.nodes -{Array<Object>|Array<number>}
     * @description 旅行商分析途经点数组，必设字段。<br>
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
     *              当 SuperMap.FindTSPPathsParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；<br>
     *              当 SuperMap.FindTSPPathsParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
     */

    /**
     * @member SuperMap.FindTSPPathsParameters.prototype.endNodeAssigned -{boolean}
     * @description 是否指定终止点，将指定的途经点的最后一个点作为终止点。<br>
     *               true 表示指定终止点，则旅行商必须最后一个访问终止点。默认为 false。
     */
    function FindTSPPathsParameters(options) {
        _classCallCheck(this, FindTSPPathsParameters);

        this.endNodeAssigned = false;
        this.isAnalyzeById = false;
        this.nodes = null;
        this.parameter = null;
        this.CLASS_NAME = "SuperMap.FindTSPPathsParameters";

        var me = this;
        me.parameter = new _TransportationAnalystParameter2.default();
        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.FindTSPPathsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.FindTSPPathsParameters.prototype.parameter -{SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。通过本类可以设置障碍边、障碍点、<br>
     *              权值字段信息的名称标识、转向权值字段等信息。<br>
     *              SuperMap.TransportationAnalystParameter 类型，它虽然为可选参数，但是如果不设置其中的 resultSetting
     *              字段，则返回结果空间信息等都为空。
     */


    /**
     * @member SuperMap.FindTSPPathsParameters.prototype.isAnalyzeById -{boolean}
     * @description 是否通过节点 ID 号来指定途经点，默认为 false，即通过坐标点指定。
     */


    _createClass(FindTSPPathsParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.endNodeAssigned = null;
            me.isAnalyzeById = null;
            me.nodes = null;
            if (me.parameter) {
                me.parameter.destroy();
                me.parameter = null;
            }
        }
    }]);

    return FindTSPPathsParameters;
}();

exports.default = FindTSPPathsParameters;


_SuperMap2.default.FindTSPPathsParameters = FindTSPPathsParameters;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _DataReturnOption = __webpack_require__(24);

var _DataReturnOption2 = _interopRequireDefault(_DataReturnOption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GenerateSpatialDataParameters
 * @classdesc 动态分段操作参数类。通过该类可以为动态分段提供参数信息。
 * @param options - {Object} 可选参数。如:</br>
 *        routeTable - {string} 路由数据集。</br>
 *        routeIDField - {string} 路由数据集的标识字段。</br>
 *        eventTable - {string} 用于生成空间数据的事件表名。</br>
 *        eventRouteIDField - {string} 用于生成空间数据的事件表的路由标识字段。</br>
 *        measureField - {string} 用于生成空间数据的事件表的刻度字段，只有当事件为点事件的时候该属性才有意义</br>
 *        measureStartField - {string} 用于生成空间数据的事件表的起始刻度字段，只有当事件为线事件的时候该属性才有意义。</br>
 *        measureEndField - {string} 用于生成空间数据的事件表的终止刻度字段，只有当事件为线事件的时候该属性才有意义。</br>
 *        measureOffsetField - {string} 刻度偏移量字段。</br>
 *        errorInfoField - {string} 错误信息字段，直接写入原事件表，用于描述事件未能生成对应的点或线时的错误信息。</br>
 *        retainedFields - {Array<string>} 欲保留到结果空间数据中的字段集合（系统字段除外）。</br>
 *        dataReturnOption - {SuperMap.DataReturnOption} 设置数据返回的最大记录。</br>
 */
var GenerateSpatialDataParameters = function () {

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.retainedFields -{Array<string>}
     * @description 欲保留到结果空间数据中的字段集合（系统字段除外）。
     * 生成空间数据时，无论是否指定保留字段，路由 ID 字段、刻度偏移量字段、刻度值字段（点事件为刻度字段，线事件是起始和终止刻度字段）都会保留到结果空间数据中；
     * 如果没有指定 retainedFields 参数或者retainedFields 参数数组长度为0，则返回所有用户字段。
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.measureOffsetField -{string}
     * @description 刻度偏移量字段。
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.measureStartField -{string}
     * @description 用于生成空间数据的事件表的起始刻度字段，只有当事件为线事件的时候该属性才有意义。
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.eventRouteIDField -{string}
     * @description 用于生成空间数据的事件表的路由标识字段。
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.routeIDField -{string}
     * @description 路由数据集的标识字段。
     */
    function GenerateSpatialDataParameters(options) {
        _classCallCheck(this, GenerateSpatialDataParameters);

        this.routeTable = null;
        this.routeIDField = null;
        this.eventTable = null;
        this.eventRouteIDField = null;
        this.measureField = null;
        this.measureStartField = null;
        this.measureEndField = null;
        this.measureOffsetField = null;
        this.errorInfoField = null;
        this.retainedFields = null;
        this.dataReturnOption = null;
        this.CLASS_NAME = "SuperMap.GenerateSpatialDataParameters";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.GenerateSpatialDataParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.dataReturnOption -{SuperMap.DataReturnOption}
     * @description 设置数据返回的选项。
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.errorInfoField -{string}
     * @description 错误信息字段，直接写入原事件表，用于描述事件未能生成对应的点或线时的错误信息。
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.measureEndField -{string}
     * @description 用于生成空间数据的事件表的终止刻度字段，只有当事件为线事件的时候该属性才有意义。
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.measureField -{string}
     * @description 用于生成空间数据的事件表的刻度字段，只有当事件为点事件的时候该属性才有意义
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.eventTable -{string}
     * @description 用于生成空间数据的事件表名。
     */


    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.routeTable -{string}
     * @description 路由数据集。
     */


    _createClass(GenerateSpatialDataParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.routeTable) {
                me.routeTable = null;
            }
            me.routeIDField = null;
            me.eventTable = null;
            me.eventRouteIDField = null;
            me.measureField = null;
            me.measureStartField = null;
            me.measureEndField = null;
            me.measureOffsetField = null;
            me.errorInfoField = null;
            if (me.dataReturnOption) {
                me.dataReturnOption.destroy();
                me.dataReturnOption = null;
            }
        }
    }]);

    return GenerateSpatialDataParameters;
}();

exports.default = GenerateSpatialDataParameters;


_SuperMap2.default.GenerateSpatialDataParameters = GenerateSpatialDataParameters;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GeoCodingParameter
 * @classdesc 地理正向匹配参数类。
 * @param options - {Object} 参数。
 */
var GeoCodingParameter = function () {

    /**
     * @member SuperMap.GeoCodingParameter.prototype.prjCoordSys -{string}
     * @description  查询结果的坐标系。
     */


    /**
     * @member SuperMap.GeoCodingParameter.prototype.toIndex -{number}
     * @description 设置返回对象的结束索引值。
     */


    /**
     * @member SuperMap.GeoCodingParameter.prototype.address -{string}
     * @description 地点关键词。
     */
    function GeoCodingParameter(options) {
        _classCallCheck(this, GeoCodingParameter);

        this.address = null;
        this.fromIndex = null;
        this.toIndex = null;
        this.filters = null;
        this.prjCoordSys = null;
        this.maxReturn = null;

        if (!options) {
            return;
        }
        if (options.filters) {
            var strs = [];
            var fields = options.filters.split(',');
            fields.map(function (field) {
                strs.push("\"" + field + "\"");
            });
            options.filters = strs;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.GeoCodingParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.GeoCodingParameter.prototype.maxReturn -{string}
     * @description 最大返回结果数。
     */


    /**
     * @member SuperMap.GeoCodingParameter.prototype.filters -{Array}
     * @description 过滤字段，限定查询区域。
     */


    /**
     * @member SuperMap.GeoCodingParameter.prototype.fromIndex -{number}
     * @description 设置返回对象的起始索引值。
     */


    _createClass(GeoCodingParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.address = null;
            this.fromIndex = null;
            this.toIndex = null;
            this.filters = null;
            this.prjCoordSys = null;
            this.maxReturn = null;
        }
    }]);

    return GeoCodingParameter;
}();

exports.default = GeoCodingParameter;

_SuperMap2.default.GeoCodingParameter = GeoCodingParameter;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GeoDecodingParameter
 * @classdesc 地理反向匹配参数类。
 * @param options - {Object} 参数。如：<br>
 *        x - {number}查询位置的横坐标。<br>
 *        y - {number}查询位置的纵坐标。<br>
 *        fromIndex - {number}设置返回对象的起始索引值。<br>
 *        filters -{Array} 过滤字段，限定查询区域。<br>
 *        prjCoordSys -{string} 查询结果的坐标系。<br>
 *        maxReturn -{number}最大返回结果数。<br>
 *        geoDecodingRadius -{number}查询半径。
 */
var GeoDecodingParameter = function () {

    /**
     *  @member SuperMap.GeoDecodingParameter.prototype.maxReturn -{number}
     *  @description 最大返回结果数。
     */


    /**
     * @member SuperMap.GeoDecodingParameter.prototype.filters -{Array}
     * @description 过滤字段，限定查询区域。
     */

    /**
     * @member SuperMap.GeoDecodingParameter.prototype.fromIndex - {number}
     * @description  设置返回对象的起始索引值。
     */

    /**
     * @member SuperMap.GeoDecodingParameter.prototype.x - {number}
     * @description 查询位置的横坐标。
     */
    function GeoDecodingParameter(options) {
        _classCallCheck(this, GeoDecodingParameter);

        this.x = null;
        this.y = null;
        this.fromIndex = null;
        this.toIndex = null;
        this.filters = null;
        this.prjCoordSys = null;
        this.maxReturn = null;
        this.geoDecodingRadius = null;

        if (!options) {
            return;
        }
        if (options.filters) {
            var strs = [];
            var fields = options.filters.split(',');
            fields.map(function (field) {
                strs.push("\"" + field + "\"");
            });
            options.filters = strs;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.GeoDecodingParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.GeoDecodingParameter.prototype.geoDecodingRadius -{number}
     * @description 查询半径。
     */


    /**
     * @member SuperMap.GeoDecodingParameter.prototype.prjCoordSys -{string}
     * @description 查询结果的坐标系。
     */


    /**
     * @member SuperMap.GeoDecodingParameter.prototype.toIndex - {number}
     * @description 设置返回对象的结束索引值。
     */


    /**
     * @member SuperMap.GeoDecodingParameter.prototype.y - {number}
     * @description 查询位置的纵坐标。
     */


    _createClass(GeoDecodingParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.x = null;
            this.y = null;
            this.fromIndex = null;
            this.toIndex = null;
            this.filters = null;
            this.prjCoordSys = null;
            this.maxReturn = null;
            this.geoDecodingRadius = null;
        }
    }]);

    return GeoDecodingParameter;
}();

exports.default = GeoDecodingParameter;


_SuperMap2.default.GeoDecodingParameter = GeoDecodingParameter;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GeoRelationAnalystParameters
 * @classdesc
 * 空间关系分析服务参数类。
 * 使用该类可以为空间关系分析服务提供所需的参数信息。
 * @param options - {Object} 可选参数。如:</br>
 *        sourceFilter - {SuperMap.FilterParameter} 空间关系分析中的参考数据集查询参数。仅 name, ids,attributeFilter 和 fields 字段有效。</br>
 *        referenceFilter - {SuperMap.FilterParameter} 空间关系分析中的参考数据集查询参数。仅 name, ids,attributeFilter 和 fields 字段有效。</br>
 *        spatialRelationType - {SuperMap.SpatialRelationType} 指定的空间关系类型。</br>
 *        isBorderInside - {boolean} 边界处理方式，即位于面边线上的点是否被面包含。此参数仅用于空间关系为包含或被包含的情况。</br>
 *        returnFeature - {boolean} 是否返回Feature信息。</br>
 *        returnGeoRelatedOnly - {boolean} 仅返回满足指定空间关系的空间对象，默认为 True。</br>
 *        startRecord - {Integer} 分析结果起始记录位置，默认为0。</br>
 *        expectCount - {Integer} 空间关系分析期望返回结果记录数，默认为500条，如果实际不足500条结果则返回所有分析结果。</br>
 */
var GeoRelationAnalystParameters = function () {

    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.returnGeoRelatedOnly -{Integer}
     * @description 分析结果起始记录位置，默认为0。
     */


    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.returnFeature -{boolean}
     * @description 是否返回Feature信息。
     */


    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.spatialRelationType -{SuperMap.SpatialRelationType}
     * @description 指定的空间关系类型。
     */


    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.sourceFilter -{SuperMap.FilterParameter}
     * @description 空间关系分析中的源数据集查询参数。仅 ids、attributeFilter 和 fields 字段有效。
     */
    function GeoRelationAnalystParameters(options) {
        _classCallCheck(this, GeoRelationAnalystParameters);

        this.dataset = null;
        this.sourceFilter = null;
        this.referenceFilter = null;
        this.spatialRelationType = null;
        this.isBorderInside = null;
        this.returnFeature = null;
        this.returnGeoRelatedOnly = null;
        this.startRecord = 0;
        this.expectCount = 500;
        this.CLASS_NAME = "SuperMap.GeoRelationAnalystParameters";

        var me = this;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
    }

    /**
     * @function SuperMap.GeoRelationAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.expectCount -{Integer}
     * @description 空间关系分析期望返回结果记录数，默认为500条，如果实际不足500条结果则返回所有分析结果。
     */


    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.returnGeoRelatedOnly -{boolean}
     * @description 是否仅返回满足指定空间关系的空间对象，默认为 True。
     */


    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.isBorderInside -{boolean}
     * @description 边界处理方式，即位于面边线上的点是否被面包含。此参数仅用于空间关系为包含或被包含的情况。
     */


    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.referenceFilter -{SuperMap.FilterParameter}
     * @description空间关系分析中的参考数据集查询参数。仅 name, ids, attributeFilter和 fields 字段有效。
     */

    /**
     *  @member SuperMap.GeoRelationAnalystParameters.prototype.dataset -{string}
     *  @description 源数据集名称。
     */


    _createClass(GeoRelationAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.sourceFilter) {
                me.sourceFilter.destroy();
            }
            me.sourceFilter = null;

            if (me.referenceFilter) {
                me.referenceFilter.destroy();
            }
            me.referenceFilter = null;

            me.dataset = null;
            me.spatialRelationType = null;
            me.isBorderInside = null;
            me.returnFeature = null;
            me.returnGeoRelatedOnly = null;
            me.startRecord = null;
            me.expectCount = null;
        }
    }]);

    return GeoRelationAnalystParameters;
}();

exports.default = GeoRelationAnalystParameters;


_SuperMap2.default.GeoRelationAnalystParameters = GeoRelationAnalystParameters;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _BufferAnalystParameters = __webpack_require__(66);

var _BufferAnalystParameters2 = _interopRequireDefault(_BufferAnalystParameters);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeometryBufferAnalystParameters
 * @classdesc 几何对象缓冲区分析参数类
 * 对指定的某个几何对象做缓冲区分析。通过该类可以指定要做缓冲区分析的几何对象、缓冲区参数等。
 * @param options - {Object} 可选参数。如:</br>
 *        sourceGeometry - {Object} 要做缓冲区分析的几何对象。必设字段。</br>
 *              点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *              线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *              面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        bufferSetting - {SuperMap.BufferSetting} 设置缓冲区通用参数。
 * @extends SuperMap.BufferAnalystParameters
 */
var GeometryBufferAnalystParameters = function (_BufferAnalystParamet) {
    _inherits(GeometryBufferAnalystParameters, _BufferAnalystParamet);

    function GeometryBufferAnalystParameters(options) {
        _classCallCheck(this, GeometryBufferAnalystParameters);

        var _this = _possibleConstructorReturn(this, (GeometryBufferAnalystParameters.__proto__ || Object.getPrototypeOf(GeometryBufferAnalystParameters)).call(this, options));

        _this.sourceGeometry = null;
        _this.CLASS_NAME = " SuperMap.GeometryBufferAnalystParameters";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.GeometryBufferAnalystParameters.prototype.sourceGeometry
     * @description 要做缓冲区分析的几何对象。必设字段。。</br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
     */


    _createClass(GeometryBufferAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeometryBufferAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(GeometryBufferAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.sourceGeometry) {
                me.sourceGeometry.destroy();
                me.sourceGeometry = null;
            }
        }

        /**
         * @function SuperMap.GeometryBufferAnalystParameters.toObject
         * @param geometryBufferAnalystParameters -{Object} 几何对象缓冲区分析参数
         * @param tempObj - {Object} 目标对象
         * @description 生成几何对象缓冲区分析对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(geometryBufferAnalystParameters, tempObj) {
            for (var name in geometryBufferAnalystParameters) {
                if (name === "bufferSetting") {
                    var tempBufferSetting = {};
                    for (var key in geometryBufferAnalystParameters.bufferSetting) {
                        tempBufferSetting[key] = geometryBufferAnalystParameters.bufferSetting[key];
                    }
                    delete tempBufferSetting.radiusUnit;
                    tempObj.analystParameter = tempBufferSetting;
                } else if (name === "sourceGeometry") {
                    tempObj.sourceGeometry = _ServerGeometry2.default.fromGeometry(geometryBufferAnalystParameters.sourceGeometry);
                } else {
                    tempObj[name] = geometryBufferAnalystParameters[name];
                }
            }
        }
    }]);

    return GeometryBufferAnalystParameters;
}(_BufferAnalystParameters2.default);

exports.default = GeometryBufferAnalystParameters;


_SuperMap2.default.GeometryBufferAnalystParameters = GeometryBufferAnalystParameters;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _OverlayAnalystParameters = __webpack_require__(67);

var _OverlayAnalystParameters2 = _interopRequireDefault(_OverlayAnalystParameters);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeometryOverlayAnalystParameters
 * @classdesc
 * 几何对象叠加分析参数类
 * 对指定的某两个几何对象做叠加分析。通过该类可以指定要做叠加分析的几何对象、叠加操作类型。
 * @param options - {Object} 可选参数。如:</br>
 *        operateGeometry - {SuperMap.Geometry} 叠加分析的操作几何对象。必设字段。</br>
 *                      点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *                      线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *                      面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        sourceGeometry - {SuperMap.Geometry} 叠加分析的源几何对象。必设字段。</br>
 *                      点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *                      线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *                      面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        operation - {SuperMap.OverlayOperationType} 叠加操作枚举值。</br>
 * @extends SuperMap.OverlayAnalystParameters
 */
var GeometryOverlayAnalystParameters = function (_OverlayAnalystParame) {
    _inherits(GeometryOverlayAnalystParameters, _OverlayAnalystParame);

    /**
     * @member SuperMap.GeometryOverlayAnalystParameters.prototype.operateGeometry
     * @description 叠加分析的操作几何对象。必设字段。</br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
     */
    function GeometryOverlayAnalystParameters(options) {
        _classCallCheck(this, GeometryOverlayAnalystParameters);

        var _this = _possibleConstructorReturn(this, (GeometryOverlayAnalystParameters.__proto__ || Object.getPrototypeOf(GeometryOverlayAnalystParameters)).call(this, options));

        _this.operateGeometry = null;
        _this.sourceGeometry = null;
        _this.CLASS_NAME = "SuperMap.GeometryOverlayAnalystParameters";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.GeometryOverlayAnalystParameters.prototype.sourceGeometry
     * @description 叠加分析的源几何对象。必设字段。</br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。
     */


    _createClass(GeometryOverlayAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeometryOverlayAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(GeometryOverlayAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.sourceGeometry) {
                me.sourceGeometry.destroy();
                me.sourceGeometry = null;
            }

            if (me.operateGeometry) {
                me.operateGeometry.destroy();
                me.operateGeometry = null;
            }
        }

        /**
         * @function SuperMap.GeometryOverlayAnalystParameters.toObject
         * @param geometryOverlayAnalystParameters -{Object} 几何对象叠加分析参数。
         * @param tempObj - {Object} 目标对象
         * @description 生成几何对象叠加分析对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(geometryOverlayAnalystParameters, tempObj) {
            for (var name in geometryOverlayAnalystParameters) {
                if (name === "sourceGeometry") {
                    tempObj.sourceGeometry = _ServerGeometry2.default.fromGeometry(geometryOverlayAnalystParameters.sourceGeometry);
                } else if (name === "operateGeometry") {
                    tempObj.operateGeometry = _ServerGeometry2.default.fromGeometry(geometryOverlayAnalystParameters.operateGeometry);
                } else {
                    tempObj[name] = geometryOverlayAnalystParameters[name];
                }
            }
        }
    }]);

    return GeometryOverlayAnalystParameters;
}(_OverlayAnalystParameters2.default);

exports.default = GeometryOverlayAnalystParameters;


_SuperMap2.default.GeometryOverlayAnalystParameters = GeometryOverlayAnalystParameters;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _SurfaceAnalystParameters = __webpack_require__(68);

var _SurfaceAnalystParameters2 = _interopRequireDefault(_SurfaceAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeometrySurfaceAnalystParameters
 * @classdesc
 * 几何对象表面分析参数类。
 * 该类对几何对象表面分析所用到的参数进行设置。
 * @param options - {Object} 可选参数。如:</br>
 *        points - {Array<SuperMap.Geometry.Point>} 表面分析的坐标点数组。</br>
 *                  点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *        zValues - {Array<number>} 表面分析的坐标点的 Z 值数组。</br>
 *        resolution - {number}获取或设置指定中间结果（栅格数据集）的分辨率。</br>
 *        resultSetting - {SuperMap.DataReturnOption} 结果返回设置类。</br>
 *        extractParameter - {SuperMap.SurfaceAnalystParametersSetting} 获取或设置表面分析参数。</br>
 *        surfaceAnalystMethod - {SuperMap.SurfaceAnalystMethod} 获取或设置表面分析的提取方法，提取等值线和提取等值面。</br>
 * @extends SuperMap.SurfaceAnalystParameters
 */
var GeometrySurfaceAnalystParameters = function (_SurfaceAnalystParame) {
    _inherits(GeometrySurfaceAnalystParameters, _SurfaceAnalystParame);

    /**
     * @member SuperMap.GeometrySurfaceAnalystParameters.prototype.points
     * @description 获取或设置用于表面分析的坐标点数组。</br>
     * 点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     */
    function GeometrySurfaceAnalystParameters(options) {
        _classCallCheck(this, GeometrySurfaceAnalystParameters);

        var _this = _possibleConstructorReturn(this, (GeometrySurfaceAnalystParameters.__proto__ || Object.getPrototypeOf(GeometrySurfaceAnalystParameters)).call(this, options));

        _this.points = null;
        _this.zValues = null;
        _this.CLASS_NAME = "SuperMap.GeometrySurfaceAnalystParameters";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.GeometrySurfaceAnalystParameters.prototype.zValues -{Array<number>}
     * @description 获取或设置用于提取操作的值。提取等值线时，将使用该数组中的值，
     * 对几何对象中的坐标点数组进行插值分析，得到栅格数据集（中间结果），接着从栅格数据集提取等值线。
     */


    _createClass(GeometrySurfaceAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeometrySurfaceAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(GeometrySurfaceAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.points) {
                for (var i = 0, points = me.points, len = points.length; i < len; i++) {
                    points[i].destroy();
                }
                me.points = null;
            }
            me.zValues = null;
        }
    }]);

    return GeometrySurfaceAnalystParameters;
}(_SurfaceAnalystParameters2.default);

exports.default = GeometrySurfaceAnalystParameters;


_SuperMap2.default.GeometrySurfaceAnalystParameters = GeometrySurfaceAnalystParameters;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ThiessenAnalystParameters = __webpack_require__(54);

var _ThiessenAnalystParameters2 = _interopRequireDefault(_ThiessenAnalystParameters);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeometryThiessenAnalystParameters
 * @constructs SuperMap.GeometryThiessenAnalystParameters
 * @classdesc
 * 几何对象泰森多边形分析参数类
 * 对指定的某个几何对象做泰森多边形分析。通过该类可以指定要做泰森多边形分析的几何对象、返回数据集名称等。
 * @param options - {Object} 可选参数。如:</br>
 *        points - {Array<Point>}|{Array} 使用点数组进行分析时使用的几何对象。</br>
 *                 点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 * @extends SuperMap.ThiessenAnalystParameters
 */

var GeometryThiessenAnalystParameters = function (_ThiessenAnalystParam) {
    _inherits(GeometryThiessenAnalystParameters, _ThiessenAnalystParam);

    function GeometryThiessenAnalystParameters(options) {
        _classCallCheck(this, GeometryThiessenAnalystParameters);

        var _this = _possibleConstructorReturn(this, (GeometryThiessenAnalystParameters.__proto__ || Object.getPrototypeOf(GeometryThiessenAnalystParameters)).call(this, options));

        _this.points = null;
        _this.CLASS_NAME = "SuperMap.GeometryThiessenAnalystParameters";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */

    /**
     * @member SuperMap.GeometryThiessenAnalystParameters.prototype.points -{Array<Object>}|{Array}
     * @description 使用点数组进行分析时使用的几何对象。</br>
     * 点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     */


    _createClass(GeometryThiessenAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeometryThiessenAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(GeometryThiessenAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.points) {
                for (var i = me.points.length - 1; i >= 0; i--) {
                    me.points[i].destroy();
                }
                me.points = null;
            }
        }

        /**
         * @function SuperMap.GeometryThiessenAnalystParameters.toObject
         * @param geometryThiessenAnalystParameters -{Object} 几何对象泰森多边形分析参数。
         * @param tempObj - {Object} 目标对象
         * @description 生成几何对象泰森多边形分析对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(geometryThiessenAnalystParameters, tempObj) {
            for (var name in geometryThiessenAnalystParameters) {
                if (name === "clipRegion") {
                    tempObj.clipRegion = _ServerGeometry2.default.fromGeometry(geometryThiessenAnalystParameters.clipRegion);
                } else {
                    tempObj[name] = geometryThiessenAnalystParameters[name];
                }
            }
        }
    }]);

    return GeometryThiessenAnalystParameters;
}(_ThiessenAnalystParameters2.default);

exports.default = GeometryThiessenAnalystParameters;


_SuperMap2.default.GeometryThiessenAnalystParameters = GeometryThiessenAnalystParameters;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

var _GetFeaturesParametersBase = __webpack_require__(26);

var _GetFeaturesParametersBase2 = _interopRequireDefault(_GetFeaturesParametersBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByBoundsParameters
 * @classdesc 数据集范围查询参数类,该类用于设置数据集范围查询的相关参数。
 * @param options - {Object} 参数。如：<br>
 *        bounds - {Object} 用于查询的范围对象。</br>
 *                  Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        attributeFilter - {string} 范围查询属性过滤条件。</br>
 *        fields - {Array<string>} 设置查询结果返回字段。默认返回所有字段。</br>
 *        spatialQueryMode - {SuperMap.SpatialQueryMode} 空间查询模式常量,必设参数。</br>
 *        queryParameter - {SuperMap.FilterParameter} 查询过滤条件参数。</br>
 *        datasetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {boolean} 是否直接返回查询结果。</br>
 *        fromIndex - {Integer} 查询结果的最小索引号。</br>
 *        toIndex - {Integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */

var GetFeaturesByBoundsParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesByBoundsParameters, _GetFeaturesParameter);

    /**
     * @member SuperMap.GetFeaturesByBoundsParameters.prototype.spatialQueryMode -{SuperMap.SpatialQueryMode}
     * @description 空间查询模式常量，必设参数，默认为CONTAIN。
     */


    /**
     * @member SuperMap.GetFeaturesByBoundsParameters.prototype.fields -{Array<string>}
     * @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
     */

    /**
     * @member SuperMap.GetFeaturesByBoundsParameters.prototype.getFeatureMode -{string}
     * @description 数据集查询模式。
     * 范围查询有"BOUNDS"，"BOUNDS_ATTRIBUTEFILTER"两种,当用户设置attributeFilter时会自动切换到BOUNDS_ATTRIBUTEFILTER访问服务。
     */
    function GetFeaturesByBoundsParameters(options) {
        _classCallCheck(this, GetFeaturesByBoundsParameters);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByBoundsParameters.__proto__ || Object.getPrototypeOf(GetFeaturesByBoundsParameters)).call(this, options));

        _this.getFeatureMode = null;
        _this.bounds = null;
        _this.fields = null;
        _this.attributeFilter = null;
        _this.spatialQueryMode = _REST.SpatialQueryMode.CONTAIN;
        _this.CLASS_NAME = "SuperMap.GetFeaturesByBoundsParameters";

        _this.getFeatureMode = GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS;
        if (!options) {
            return _possibleConstructorReturn(_this);
        }
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.GetFeaturesByBoundsParameters.prototype.attributeFilter -{string}
     * @description 范围查询属性过滤条件。
     */


    /**
     * @member SuperMap.GetFeaturesByBoundsParameters.prototype.bounds
     * @description 用于查询的范围对象。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent
     *
     */


    _createClass(GetFeaturesByBoundsParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByBoundsParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByBoundsParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.bounds) {
                me.bounds.destroy();
                me.bounds = null;
            }
            if (me.fields) {
                while (me.fields.length > 0) {
                    me.fields.pop();
                }
                me.fields = null;
            }
            me.attributeFilter = null;
            me.spatialQueryMode = null;
            me.getFeatureMode = null;
        }

        /**
         * @function: SuperMap.GetFeaturesByBoundsParameters.toJsonParameters
         * @description 将<SuperMap.GetFeaturesByBoundsParameters>对象参数转换为json字符串。
         * @param params - {SuperMap.GetFeaturesByBoundsParameters} 范围查询参数。
         * @return  {string} 转化后的 json字符串。
         *
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var filterParameter, bounds, parasByBounds;

            bounds = {
                "leftBottom": { "x": params.bounds.left, "y": params.bounds.bottom },
                "rightTop": { "x": params.bounds.right, "y": params.bounds.top }
            };
            parasByBounds = {
                datasetNames: params.datasetNames,
                getFeatureMode: GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS,
                bounds: bounds,
                spatialQueryMode: params.spatialQueryMode
            };
            if (params.fields) {
                filterParameter = new _FilterParameter2.default();
                filterParameter.name = params.datasetNames;
                filterParameter.fields = params.fields;
                parasByBounds.queryParameter = filterParameter;
            }
            if (params.attributeFilter) {
                parasByBounds.attributeFilter = params.attributeFilter;
                parasByBounds.getFeatureMode = GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS_ATTRIBUTEFILTER;
            }
            if (params.maxFeatures && !isNaN(params.maxFeatures)) {
                parasByBounds.maxFeatures = params.maxFeatures;
            }

            return _SuperMap2.default.Util.toJSON(parasByBounds);
        }
    }]);

    return GetFeaturesByBoundsParameters;
}(_GetFeaturesParametersBase2.default);

GetFeaturesByBoundsParameters.getFeatureMode = {
    "BOUNDS": "BOUNDS",
    "BOUNDS_ATTRIBUTEFILTER": "BOUNDS_ATTRIBUTEFILTER"
};
exports.default = GetFeaturesByBoundsParameters;


_SuperMap2.default.GetFeaturesByBoundsParameters = GetFeaturesByBoundsParameters;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _GetFeaturesParametersBase = __webpack_require__(26);

var _GetFeaturesParametersBase2 = _interopRequireDefault(_GetFeaturesParametersBase);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByBufferParameters
 * @classdesc 数据服务中数据集缓冲区查询参数类。
 * @param options - {Object} 可選参数。如:</br>
 *        bufferDistance - {number}buffer 距离，单位与所查询图层对应的数据集单位相同。</br>
 *        attributeFilter - {string} 属性查询条件。 </br>
 *        fields - {Array<string>} 设置查询结果返回字段。默认返回所有字段。</br>
 *        geometry - {Object} 空间查询条件。</br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *                  线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *                  面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        dataSetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {boolean} 是否直接返回查询结果。</br>
 *        fromIndex - {Integer} 查询结果的最小索引号。</br>
 *        toIndex - {Integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var GetFeaturesByBufferParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesByBufferParameters, _GetFeaturesParameter);

    /**
     * @member SuperMap.GetFeaturesByBufferParameters.prototype.geometry
     * @description 空间查询条件。</br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
     */


    /**
     * @member SuperMap.GetFeaturesByBufferParameters.prototype.bufferDistance - {number}
     * @description buffer距离,单位与所查询图层对应的数据集单位相同。
     */
    function GetFeaturesByBufferParameters(options) {
        _classCallCheck(this, GetFeaturesByBufferParameters);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByBufferParameters.__proto__ || Object.getPrototypeOf(GetFeaturesByBufferParameters)).call(this, options));

        _this.bufferDistance = null;
        _this.attributeFilter = null;
        _this.geometry = null;
        _this.fields = null;
        _this.CLASS_NAME = "SuperMap.GetFeaturesByBufferParameters";

        if (!options) {
            return _possibleConstructorReturn(_this);
        }
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.GetFeaturesByBufferParameters.prototype.fields -{Array<string>}
     * @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
     */


    /**
     * @member SuperMap.GetFeaturesByBufferParameters.prototype.queryParameter - {string}
     * @description 属性查询条件。
     */


    _createClass(GetFeaturesByBufferParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByBufferParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByBufferParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.bufferDistance = null;
            me.attributeFilter = null;
            if (me.fields) {
                while (me.fields.length > 0) {
                    me.fields.pop();
                }
                me.fields = null;
            }
            if (me.geometry) {
                me.geometry.destroy();
                me.geometry = null;
            }
        }

        /**
         * @function SuperMap.GetFeaturesByBufferParameters.toJsonParameters
         * @description 对象参数转换为json字符串。
         * @param params -{SuperMap.GetFeaturesByBufferParameters} SQL查询参数。
         * @return {string} 转化后的 json字符串。
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var filterParameter, paramsBySql, geometry;
            geometry = _ServerGeometry2.default.fromGeometry(params.geometry);
            paramsBySql = {
                datasetNames: params.datasetNames,
                getFeatureMode: "BUFFER",
                bufferDistance: params.bufferDistance,
                geometry: geometry
            };
            if (params.fields) {
                filterParameter = new _FilterParameter2.default();
                filterParameter.name = params.datasetNames;
                filterParameter.fields = params.fields;
                paramsBySql.queryParameter = filterParameter;
            }
            if (params.attributeFilter) {
                paramsBySql.attributeFilter = params.attributeFilter;
                paramsBySql.getFeatureMode = "BUFFER_ATTRIBUTEFILTER";
            }
            if (params.maxFeatures && !isNaN(params.maxFeatures)) {
                paramsBySql.maxFeatures = params.maxFeatures;
            }
            return _SuperMap2.default.Util.toJSON(paramsBySql);
        }
    }]);

    return GetFeaturesByBufferParameters;
}(_GetFeaturesParametersBase2.default);

exports.default = GetFeaturesByBufferParameters;


_SuperMap2.default.GetFeaturesByBufferParameters = GetFeaturesByBufferParameters;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

var _GetFeaturesParametersBase = __webpack_require__(26);

var _GetFeaturesParametersBase2 = _interopRequireDefault(_GetFeaturesParametersBase);

var _ServerGeometry = __webpack_require__(7);

var _ServerGeometry2 = _interopRequireDefault(_ServerGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByGeometryParameters
 * @classdesc 数据集几何查询参数类。该类用于设置数据集几何查询的相关参数。
 * @param options - {Object} 可選参数。如:</br>
 *        geometry - {Object} 用于查询的几何对象。</br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *                  线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *                  面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        attributeFilter - {string} 几何查询属性过滤条件。</br>
 *        fields - {Array<string>} 设置查询结果返回字段。默认返回所有字段。</br>
 *        spatialQueryMode - {SuperMap.SpatialQueryMode} 空间查询模式常量,必设参数。</br>
 *        queryParameter - {SuperMap.FilterParameter} 查询过滤条件参数。</br>
 *        datasetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {boolean} 是否直接返回查询结果。</br>
 *        fromIndex - {Integer} 查询结果的最小索引号。</br>
 *        toIndex - {Integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var GetFeaturesByGeometryParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesByGeometryParameters, _GetFeaturesParameter);

    /**
     * @member SuperMap.GetFeaturesByGeometryParameters.prototype.attributeFilter -{string}
     *  @description 几何查询属性过滤条件。
     */


    /**
     * @member SuperMap.GetFeaturesByGeometryParameters.prototype.geometry
     * @description 用于查询的几何对象。</br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
     */
    function GetFeaturesByGeometryParameters(options) {
        _classCallCheck(this, GetFeaturesByGeometryParameters);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByGeometryParameters.__proto__ || Object.getPrototypeOf(GetFeaturesByGeometryParameters)).call(this, options));

        _this.getFeatureMode = "SPATIAL";
        _this.geometry = null;
        _this.fields = null;
        _this.attributeFilter = null;
        _this.spatialQueryMode = _REST.SpatialQueryMode.CONTAIN;
        _this.CLASS_NAME = "SuperMap.GetFeaturesByGeometryParameters";

        if (!options) {
            return _possibleConstructorReturn(_this);
        }
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesByGeometryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.GetFeaturesByGeometryParameters.prototype.spatialQueryMode -{SuperMap.SpatialQueryMode}
     * @description 空间查询模式常量，必设参数，默认为CONTAIN。
     */


    /**
     * @member SuperMap.GetFeaturesByGeometryParameters.prototype.fields {Array<string>}
     * @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
     */


    /**
     * @member SuperMap.GetFeaturesByGeometryParameters.prototype.getFeatureMode
     * @description 数据集查询模式。
     * 几何查询有"SPATIAL"，"SPATIAL_ATTRIBUTEFILTER"两种,当用户设置attributeFilter时会自动切换到SPATIAL_ATTRIBUTEFILTER访问服务。
     */


    _createClass(GetFeaturesByGeometryParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByGeometryParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByGeometryParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.geometry) {
                me.geometry.destroy();
                me.geometry = null;
            }
            if (me.fields) {
                while (me.fields.length > 0) {
                    me.fields.pop();
                }
                me.fields = null;
            }
            me.attributeFilter = null;
            me.spatialQueryMode = null;
            me.getFeatureMode = null;
        }

        /**
         * @function SuperMap.GetFeaturesByGeometryParameters.toJsonParameters
         * @description 将<SuperMap.GetFeaturesByGeometryParameters>对象参数转换为json字符串。
         * @param params - {SuperMap.GetFeaturesByGeometryParameters} 几何查询参数。
         * @return {string} 转化后的 json字符串。
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var filterParameter, geometry, parasByGeometry;

            geometry = _ServerGeometry2.default.fromGeometry(params.geometry);
            parasByGeometry = {
                datasetNames: params.datasetNames,
                getFeatureMode: "SPATIAL",
                geometry: geometry,
                spatialQueryMode: params.spatialQueryMode
            };
            if (params.fields) {
                filterParameter = new _FilterParameter2.default();
                filterParameter.name = params.datasetNames;
                filterParameter.fields = params.fields;
                parasByGeometry.queryParameter = filterParameter;
            }
            if (params.attributeFilter) {
                parasByGeometry.attributeFilter = params.attributeFilter;
                parasByGeometry.getFeatureMode = "SPATIAL_ATTRIBUTEFILTER";
            }
            if (params.maxFeatures && !isNaN(params.maxFeatures)) {
                parasByGeometry.maxFeatures = params.maxFeatures;
            }

            return _SuperMap2.default.Util.toJSON(parasByGeometry);
        }
    }]);

    return GetFeaturesByGeometryParameters;
}(_GetFeaturesParametersBase2.default);

exports.default = GetFeaturesByGeometryParameters;


_SuperMap2.default.GetFeaturesByGeometryParameters = GetFeaturesByGeometryParameters;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

var _GetFeaturesParametersBase = __webpack_require__(26);

var _GetFeaturesParametersBase2 = _interopRequireDefault(_GetFeaturesParametersBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByIDsParameters
 * @classdesc ID 查询参数类。
 * @param options - {Object} 可选参数。如:</br>
 *        IDs - {Array<Integer>} 所要查询指定的元素ID信息。</br>
 *        fields - {Array<String>} 设置查询结果返回字段。默认返回所有字段。</br>
 *        dataSetNames - {Array<String>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {boolean} 是否直接返回查询结果。</br>
 *        fromIndex - {Integer} 查询结果的最小索引号。</br>
 *        toIndex - {Integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var GetFeaturesByIDsParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesByIDsParameters, _GetFeaturesParameter);

    /**
     * @member SuperMap.GetFeaturesByIDsParameters.prototype.IDs -{Array<Integer>}
     * @description 所要查询指定的元素ID信息。
     */
    function GetFeaturesByIDsParameters(options) {
        _classCallCheck(this, GetFeaturesByIDsParameters);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByIDsParameters.__proto__ || Object.getPrototypeOf(GetFeaturesByIDsParameters)).call(this, options));

        _this.getFeatureMode = "ID";
        _this.IDs = null;
        _this.fields = null;
        _this.CLASS_NAME = "SuperMap.GetFeaturesByIDsParameters";

        if (!options) {
            return _possibleConstructorReturn(_this);
        }
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     *  @member SuperMap.GetFeaturesByIDsParameters.prototype.fields -{Array<String>}
     *  @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
     */

    /**
     * @member SuperMap.GetFeaturesByIDsParameters.prototype.getFeatureMode -{string}
     * @description 数据集查询模式。
     */


    _createClass(GetFeaturesByIDsParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByIDsParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByIDsParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.IDs = null;
            me.getFeatureMode = null;
            if (me.fields) {
                while (me.fields.length > 0) {
                    me.fields.pop();
                }
                me.fields = null;
            }
        }

        /**
         * @function SuperMap.GetFeaturesByIDsParameters.toJsonParameters
         * @description 将<SuperMap.GetFeaturesByIDsParameters>对象参数转换为json字符串。
         * @param params - {SuperMap.GetFeaturesByIDsParameters} IDs查询参数。
         * @return {string} 转化后的 json字符串。
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var parasByIDs, filterParameter;

            parasByIDs = {
                datasetNames: params.datasetNames,
                getFeatureMode: "ID",
                ids: params.IDs
            };
            if (params.fields) {
                filterParameter = new _FilterParameter2.default();
                filterParameter.name = params.datasetNames;
                filterParameter.fields = params.fields;
                parasByIDs.queryParameter = filterParameter;
            }
            return _SuperMap2.default.Util.toJSON(parasByIDs);
        }
    }]);

    return GetFeaturesByIDsParameters;
}(_GetFeaturesParametersBase2.default);

exports.default = GetFeaturesByIDsParameters;


_SuperMap2.default.GetFeaturesByIDsParameters = GetFeaturesByIDsParameters;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _FilterParameter = __webpack_require__(10);

var _FilterParameter2 = _interopRequireDefault(_FilterParameter);

var _GetFeaturesParametersBase = __webpack_require__(26);

var _GetFeaturesParametersBase2 = _interopRequireDefault(_GetFeaturesParametersBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesBySQLParameters
 * @classdesc 数据服务中数据集SQL查询参数类。
 * @param options - {Object} 可選参数。如:</br>
 *        queryParameter - {SuperMap.FilterParameter} 查询过滤条件参数。</br>
 *         datasetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *         returnContent - {boolean} 是否直接返回查询结果。</br>
 *         fromIndex - {Integer} 查询结果的最小索引号。</br>
 *         toIndex - {Integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var GetFeaturesBySQLParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesBySQLParameters, _GetFeaturesParameter);

    /**
     * @function SuperMap.GetFeaturesBySQLParameters.prototype.getFeatureMode -{string}
     * @description 数据集查询模式。
     */
    function GetFeaturesBySQLParameters(options) {
        _classCallCheck(this, GetFeaturesBySQLParameters);

        var _this = _possibleConstructorReturn(this, (GetFeaturesBySQLParameters.__proto__ || Object.getPrototypeOf(GetFeaturesBySQLParameters)).call(this, options));

        _this.getFeatureMode = "SQL";
        _this.queryParameter = null;
        _this.CLASS_NAME = "SuperMap.GetFeaturesBySQLParameters";

        if (!options) {
            return _possibleConstructorReturn(_this);
        }
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @function SuperMap.GetFeaturesBySQLParameters.prototype.queryParameter -{SuperMap.FilterParameter}
     * @description 查询过滤条件参数类。
     */


    _createClass(GetFeaturesBySQLParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesBySQLParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesBySQLParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.getFeatureMode = null;
            if (me.queryParameter) {
                me.queryParameter.destroy();
                me.queryParameter = null;
            }
        }

        /**
         * @function SuperMap.GetFeaturesBySQLParameters.prototype.toJsonParameters
         * @description  将<SuperMap.GetFeaturesBySQLParameters>对象参数转换为json字符串。
         * @param params - {SuperMap.GetFeaturesBySQLParameters} SQL查询参数。
         * @return {string} 转化后的 json字符串。
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var paramsBySql = {
                datasetNames: params.datasetNames,
                getFeatureMode: "SQL",
                queryParameter: params.queryParameter
            };
            if (params.maxFeatures && !isNaN(params.maxFeatures)) {
                paramsBySql.maxFeatures = params.maxFeatures;
            }
            return _SuperMap2.default.Util.toJSON(paramsBySql);
        }
    }]);

    return GetFeaturesBySQLParameters;
}(_GetFeaturesParametersBase2.default);

exports.default = GetFeaturesBySQLParameters;


_SuperMap2.default.GetFeaturesBySQLParameters = GetFeaturesBySQLParameters;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GetGridCellInfosParameters
 * @classdesc 数据服务栅格查询参数类。
 * @param options - {Object} 可选参数。如:</br>
 *        datasetName - {string} 数据集名称。</br>
 *        dataSourceName - {string} 数据源名称</br>
 *        X - {Integer} 要查询的地理位置X轴。</br>
 *        Y - {Integer} 要查询的地理位置Y轴。
 */
var GetGridCellInfosParameters = function () {

  /**
   * @member SuperMap.GetGridCellInfosParameters.prototype.X -{number}
   * @description 要查询的地理位置X轴
   */

  /**
   * @member SuperMap.GetGridCellInfosParameters.prototype.datasetName -{string}
   * @description 数据集名称。
   */
  function GetGridCellInfosParameters(options) {
    _classCallCheck(this, GetGridCellInfosParameters);

    this.datasetName = null;
    this.dataSourceName = null;
    this.X = null;
    this.Y = null;
    this.CLASS_NAME = "SuperMap.GetGridCellInfosParameters";

    if (!options) {
      return;
    }
    _SuperMap2.default.Util.extend(this, options);
  }

  /**
   * @function SuperMap.GetGridCellInfosParameters.prototype.destroy
   * @description 释放资源，将引用的资源属性置空。
   */


  /**
   * @member SuperMap.GetGridCellInfosParameters.prototype.Y -{number}
   * @description 要查询的地理位置Y轴
   */


  /**
   * @member SuperMap.GetGridCellInfosParameters.prototype.dataSourceName -{string}
   * @description  数据源名称。
   */


  _createClass(GetGridCellInfosParameters, [{
    key: "destroy",
    value: function destroy() {
      var me = this;
      me.datasetName = null;
      me.dataSourceName = null;
      me.X = null;
      me.Y = null;
    }
  }]);

  return GetGridCellInfosParameters;
}();

exports.default = GetGridCellInfosParameters;


_SuperMap2.default.GetGridCellInfosParameters = GetGridCellInfosParameters;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _UGCSubLayer2 = __webpack_require__(40);

var _UGCSubLayer3 = _interopRequireDefault(_UGCSubLayer2);

var _ServerColor = __webpack_require__(12);

var _ServerColor2 = _interopRequireDefault(_ServerColor);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

var _ColorDictionary = __webpack_require__(171);

var _ColorDictionary2 = _interopRequireDefault(_ColorDictionary);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Grid
 * @classdesc UGC 栅格图层类。
 * @extends SuperMap.UGCSubLayer
 * @param options - {Object} 可选参数参数。如：<br>
 *        colorDictionary - {Array<Object>} 颜色对照表对象。<br>
 *        brightness - {Integer} Grid 图层的亮度。<br>
 *        colorGradientType - {boolean} 文本压盖时是否显示压盖的文本对象。<br>
 *        colors - {SuperMap.ServerColor} 颜色表对象。<br>
 *        contrast - {Integer} Grid 图层的对比度。<br>
 *        gridType - {SuperMap.GridType} 格网类型。<br>
 *        horizontalSpacing - {number}格网水平间隔大小。<br>
 *        sizeFixed - {boolean} 格网是否固定大小，如果不固定大小，则格网随着地图缩放。<br>
 *        solidStyle - {SuperMap.ServerStyle} 格网实线的样式。<br>
 *        specialColor - {SuperMap.ServerColor} 栅格数据集无值数据的颜色。<br>
 *        specialValue - {number}图层的特殊值。<br>
 *        specialValueTransparent - {boolean} 图层的特殊值（specialValue）所处区域是否透明。<br>
 *        verticalSpacing - {number}格网垂直间隔大小。
 */
var Grid = function (_UGCSubLayer) {
    _inherits(Grid, _UGCSubLayer);

    /**
     * @member SuperMap.Grid.prototype.specialValueTransparent -{boolean}
     * @description 图层的特殊值（specialValue）所处区域是否透明。
     */


    /**
     * @member SuperMap.Grid.prototype.specialColor -{SuperMap.ServerColor}
     * @description 栅格数据集无值数据的颜色。
     */


    /**
     * @member SuperMap.Grid.prototype.sizeFixed -{boolean}
     * @description 格网是否固定大小，如果不固定大小，则格网随着地图缩放。
     */


    /**
     * @member SuperMap.Grid.prototype.gridType -{SuperMap.GridType}
     * @description 格网类型。
     */


    /**
     * @member SuperMap.Grid.prototype.contrast -{Integer}
     * @description Grid 图层的对比度。
     */


    /**
     * @member SuperMap.Grid.prototype.colorGradientType -{SuperMap.ColorGradientType}
     * @description 渐变颜色枚举值
     */


    /**
     * @member SuperMap.Grid.prototype.colorDictionarys -{Array<SuperMap.ColorDictionary>}
     * @description 颜色对照表对象。
     */
    function Grid(options) {
        _classCallCheck(this, Grid);

        options = options || {};

        var _this = _possibleConstructorReturn(this, (Grid.__proto__ || Object.getPrototypeOf(Grid)).call(this, options));

        _this.colorDictionarys = null;
        _this.brightness = null;
        _this.colorGradientType = null;
        _this.colors = null;
        _this.contrast = null;
        _this.dashStyle = null;
        _this.gridType = null;
        _this.horizontalSpacing = null;
        _this.sizeFixed = null;
        _this.solidStyle = null;
        _this.specialColor = null;
        _this.specialValue = null;
        _this.specialValueTransparent = null;
        _this.verticalSpacing = null;
        _this.CLASS_NAME = "SuperMap.Grid";
        return _this;
    }

    /**
     * @function SuperMap.Grid.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */


    /**
     * @member SuperMap.Grid.prototype.verticalSpacing
     * @description {number} 格网垂直间隔大小。
     */


    /**
     * @member SuperMap.Grid.prototype.specialValue -{number}
     * @description 图层的特殊值。
     */


    /**
     * @member SuperMap.Grid.prototype.solidStyle -{SuperMap.ServerStyle}
     * @description 格网实线的样式。
     */


    /**
     * @member SuperMap.Grid.prototype.horizontalSpacing -{number}
     * @description 格网水平间隔大小。
     */


    /**
     * @member SuperMap.Grid.prototype.dashStyle -{SuperMap.ServerStyle}
     * @description 栅格数据集特殊值数据的颜色。
     */


    /**
     * @member SuperMap.Grid.prototype.colors -{SuperMap.ServerColor}
     * @description 颜色表对象。
     */


    /**
     * @member SuperMap.Grid.prototype.brightness -{Integer}
     * @description Grid 图层的亮度。
     */


    _createClass(Grid, [{
        key: 'destroy',
        value: function destroy() {
            _get(Grid.prototype.__proto__ || Object.getPrototypeOf(Grid.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.Grid.prototype.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }, {
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(Grid.prototype.__proto__ || Object.getPrototypeOf(Grid.prototype), 'fromJson', this).call(this, jsonObject);
            if (this.specialColor) {
                this.specialColor = new _ServerColor2.default(this.specialColor.red, this.specialColor.green, this.specialColor.blue);
            }
            if (this.colors) {
                var colors = [],
                    color;
                for (var i in this.colors) {
                    color = this.colors[i];
                    colors.push(new _ServerColor2.default(color.red, color.green, color.blue));
                }
                this.colors = colors;
            }
            if (this.dashStyle) {
                this.dashStyle = new _ServerStyle2.default(this.dashStyle);
            }
            if (this.solidStyle) {
                this.solidStyle = new _ServerStyle2.default(this.solidStyle);
            }
            if (this.colorDictionary) {
                var colorDics = [],
                    colorDic;
                for (var key in this.colorDictionary) {
                    colorDic = this.colorDictionary[key];
                    colorDics.push(new _ColorDictionary2.default({ elevation: key, color: colorDic }));
                }
                this.colorDictionarys = colorDics;
            }
            delete this.colorDictionary;
        }

        /**
         * @function SuperMap.Grid.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var jsonObject = _get(Grid.prototype.__proto__ || Object.getPrototypeOf(Grid.prototype), 'toServerJSONObject', this).call(this);

            if (jsonObject.dashStyle) {
                if (jsonObject.dashStyle.toServerJSONObject) {
                    jsonObject.dashStyle = jsonObject.dashStyle.toServerJSONObject();
                }
            }
            if (jsonObject.solidStyle) {
                if (jsonObject.solidStyle.toServerJSONObject) {
                    jsonObject.solidStyle = jsonObject.solidStyle.toServerJSONObject();
                }
            }
            return jsonObject;
        }
    }]);

    return Grid;
}(_UGCSubLayer3.default);

exports.default = Grid;


_SuperMap2.default.Grid = Grid;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _UGCSubLayer2 = __webpack_require__(40);

var _UGCSubLayer3 = _interopRequireDefault(_UGCSubLayer2);

var _ServerColor = __webpack_require__(12);

var _ServerColor2 = _interopRequireDefault(_ServerColor);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Image
 * @classdesc UGC 影像图层类。
 * @extends SuperMap.UGCSubLayer
 * @param options - {Object} 可选参数。如：<br>
 *        colorSpaceType - {SuperMap.ColorSpaceType} 返回影像图层的色彩显示模式。<br>
 *        brightness - {Integer} 影像图层的亮度。<br>
 *        displayBandIndexes - {Array<Integer>} 返回当前影像图层显示的波段索引。<br>
 *        contrast - {Integer} 影像图层的对比度。<br>
 *        transparent - {boolean} 是否背景透明。<br>
 *        transparentColor - {SuperMap.ServerColor} 返回背景透明色。<br>
 *        transparentColorTolerance - {Integer} 背景透明色容限。
 */
var UGCImage = function (_UGCSubLayer) {
    _inherits(UGCImage, _UGCSubLayer);

    /*
     * @function SuperMap.Image.prototype.constructor
     * @description UGC 影像图层类构造函数。
     * @param options - {Object} 可选参数。如：<br>
     *        colorSpaceType - {SuperMap.ColorSpaceType} 返回影像图层的色彩显示模式。<br>
     *        brightness - {Integer} 影像图层的亮度。<br>
     *        displayBandIndexes - {Array<Integer>} 返回当前影像图层显示的波段索引。<br>
     *        contrast - {Integer} 影像图层的对比度。<br>
     *        transparent - {boolean} 是否背景透明。<br>
     *        transparentColor - {SuperMap.ServerColor} 返回背景透明色。<br>
     *        transparentColorTolerance - {Integer} 背景透明色容限。
     */


    /**
     * @member SuperMap.Image.prototype.transparentColor -{SuperMap.ServerColor}
     * @description 返回背景透明色。
     */


    /**
     * @member SuperMap.Image.prototype.displayBandIndexes {Array<Integer>}
     * @description 返回当前影像图层显示的波段索引。
     */


    /**
     * @member SuperMap.Image.prototype.colorSpaceType -{SuperMap.ColorSpaceType}
     * @description 返回影像图层的色彩显示模式。
     */
    function UGCImage(options) {
        _classCallCheck(this, UGCImage);

        options = options || {};

        var _this = _possibleConstructorReturn(this, (UGCImage.__proto__ || Object.getPrototypeOf(UGCImage)).call(this, options));

        _this.brightness = null;
        _this.colorSpaceType = null;
        _this.contrast = null;
        _this.displayBandIndexes = null;
        _this.transparent = null;
        _this.transparentColor = null;
        _this.transparentColorTolerance = null;
        _this.CLASS_NAME = "SuperMap.Image";
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.Image.prototype.transparentColorTolerance -{Integer}
     * @description 背景透明色容限。
     */


    /**
     * @member SuperMap.Image.prototype.transparent -{boolean}
     * @description 是否背景透明。
     */


    /**
     * @member SuperMap.Image.prototype.contrast -{Integer}
     * @description 影像图层的对比度。
     */


    /**
     * @member SuperMap.Image.prototype.brightness -{Integer}
     * @description 影像图层的亮度。
     */


    _createClass(UGCImage, [{
        key: 'destroy',
        value: function destroy() {
            _get(UGCImage.prototype.__proto__ || Object.getPrototypeOf(UGCImage.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.Image.prototype.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }, {
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(UGCImage.prototype.__proto__ || Object.getPrototypeOf(UGCImage.prototype), 'fromJson', this).call(this, jsonObject);
            if (this.transparentColor) {
                this.transparentColor = new _ServerColor2.default(this.transparentColor.red, this.transparentColor.green, this.transparentColor.blue);
            }
        }

        /**
         * @function SuperMap.Image.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            return _get(UGCImage.prototype.__proto__ || Object.getPrototypeOf(UGCImage.prototype), 'toServerJSONObject', this).call(this);
        }
    }]);

    return UGCImage;
}(_UGCSubLayer3.default);

exports.default = UGCImage;


_SuperMap2.default.Image = UGCImage;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _InterpolationAnalystParameters = __webpack_require__(28);

var _InterpolationAnalystParameters2 = _interopRequireDefault(_InterpolationAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationDensityAnalystParameters
 * @classdesc 点密度差值分析参数类
 * @param options - {Object} 可选参数。如:</br>
 *        bounds - {SuperMap.Bounds} 插值分析的范围，用于确定结果栅格数据集的范围。</br>
 *                 Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchRadius - {number}查找半径，即参与运算点的查找范围，与点数据集单位相同，默认值为0。</br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型( SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        zValueScale - {number}用于进行插值分析值的缩放比率，默认值为1。</br>
 *        resolution - {number}插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
 *        filterQueryParameter - {SuperMap.FilterParameter} 属性过滤条件。</br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称。必设参数</br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。必设参数</br>
 *        pixelFormat - {string} 指定结果栅格数据集存储的像素格式。</br>
 *        dataset - {string} 用来做插值分析的数据源中数据集的名称，该名称用形如"数据集名称@数据源别名"形式来表示。当插值分析类型( SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        inputPoints - {Array <SuperMap.Geometry.Point>} 用于做插值分析的离散点集合。当插值分析类型（ SuperMap.InterpolationAnalystType）为 geometry 时，必设参数。</br>
 *                      点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 * @extends SuperMap.InterpolationAnalystParameters
 * @example 例如：
 * (start code)
 * var myInterpolationDensityAnalystParameters = new SuperMap.InterpolationDensityAnalystParameters({
     *      dataset: "SamplesP@Interpolation",
     *      searchRadius: "100000",
     *      pixelFormat: "BIT16",
     *      zValueFieldName: "AVG_TMP",
     *      resolution: 3000,
     *      filterQueryParameter: {
     *          attributeFilter: ""
     *      },
     *      outputDatasetName: "myDensity"
     * });
 * (end)
 */
var InterpolationDensityAnalystParameters = function (_InterpolationAnalyst) {
    _inherits(InterpolationDensityAnalystParameters, _InterpolationAnalyst);

    function InterpolationDensityAnalystParameters(options) {
        _classCallCheck(this, InterpolationDensityAnalystParameters);

        var _this = _possibleConstructorReturn(this, (InterpolationDensityAnalystParameters.__proto__ || Object.getPrototypeOf(InterpolationDensityAnalystParameters)).call(this, options));

        _this.CLASS_NAME = "SuperMap.InterpolationDensityAnalystParameters";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.InterpolationDensityAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(InterpolationDensityAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(InterpolationDensityAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(InterpolationDensityAnalystParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return InterpolationDensityAnalystParameters;
}(_InterpolationAnalystParameters2.default);

exports.default = InterpolationDensityAnalystParameters;


_SuperMap2.default.InterpolationDensityAnalystParameters = InterpolationDensityAnalystParameters;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _InterpolationAnalystParameters = __webpack_require__(28);

var _InterpolationAnalystParameters2 = _interopRequireDefault(_InterpolationAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationIDWAnalystParameters
 * @classdesc 反距离加权插值（IDW）分析参数类
 * @param options - {Object} 可选参数。如:</br>
 *        power - {number}距离权重计算的幂次。</br>
 *        bounds - {SuperMap.Bounds} 插值分析的范围，用于确定结果栅格数据集的范围。</br>
 *                  Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchMode - {string} 插值运算时，查找参与运算点的方式，支持固定点数查找、定长查找。必设参数</br>
 *        expectedCount - {number}【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数，默认值为12。</br>
 *        searchRadius - {number}【定长查找】方式下，设置查找半径，即参与运算点的查找范围，与点数据集单位相同，默认值为0。</br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        zValueScale - {number}用于进行插值分析值的缩放比率，默认为1。</br>
 *        resolution - {number}插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
 *        filterQueryParameter - {SuperMap.FilterParameter} 属性过滤条件。</br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称。必设参数</br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。必设参数</br>
 *        pixelFormat - {string} 指定结果栅格数据集存储的像素格式。</br>
 *        dataset - {string} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        inputPoints - {Array <Object} 用于做插值分析的离散点集合。当插值分析类型（SuperMap.InterpolationAnalystType）为 geometry 时，必设参数。</br>
 *                      点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 * @extends SuperMap.InterpolationAnalystParameters
 * @example 例如：
 * (start code)
 * var myInterpolationIDWAnalystParameters = new SuperMap.InterpolationIDWAnalystParameters({
     *      dataset:"SamplesP@Interpolation",
     *      power: 2,
     *      searchMode: "KDTREE_FIXED_COUNT",
     *      expectedCount: 12,
     *      pixelFormat: "BIT16",
     *      zValueFieldName: "AVG_TMP",
     *      resolution: 3000,
     *      filterQueryParameter: {
     *          attributeFilter: ""
     *      },
     *      outputDatasetName: "myIDW"
     * });
 * (end)
 *
 */
var InterpolationIDWAnalystParameters = function (_InterpolationAnalyst) {
    _inherits(InterpolationIDWAnalystParameters, _InterpolationAnalyst);

    /**
     * @member SuperMap.InterpolationIDWAnalystParameters.prototype.searchMode -{SuperMap.SearchMode}
     * @description 插值运算时，查找参与运算点的方式，支持固定点数查找、定长查找。必设参数
     * 具体如下：
     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
     */
    function InterpolationIDWAnalystParameters(options) {
        _classCallCheck(this, InterpolationIDWAnalystParameters);

        var _this = _possibleConstructorReturn(this, (InterpolationIDWAnalystParameters.__proto__ || Object.getPrototypeOf(InterpolationIDWAnalystParameters)).call(this, options));

        _this.power = 2;
        _this.searchMode = null;
        _this.expectedCount = 12;
        _this.CLASS_NAME = "SuperMap.InterpolationIDWAnalystParameters";

        var me = _this;
        me.power = 2;
        me.searchMode = null;
        me.expectedCount = 12;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.InterpolationIDWAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.InterpolationIDWAnalystParameters.prototype.expectedCount -{number}
     * @description 【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数，默认值为12。
     */


    /**
     * @member SuperMap.InterpolationIDWAnalystParameters.prototype.power -{number}
     * @description 距离权重计算的幂次，默认值为2。
     * 该值决定了权值下降的速度，幂次越大，随距离的增大权值下降越快，距离预测点越远的点的权值也越小。
     * 理论上，参数值必须大于0，但是0.5到3之间时运算结果更合理，因此推荐值为0.5~3。
     */


    _createClass(InterpolationIDWAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(InterpolationIDWAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(InterpolationIDWAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.power = null;
            me.searchMode = null;
            me.expectedCount = null;
        }
    }]);

    return InterpolationIDWAnalystParameters;
}(_InterpolationAnalystParameters2.default);

exports.default = InterpolationIDWAnalystParameters;


_SuperMap2.default.InterpolationIDWAnalystParameters = InterpolationIDWAnalystParameters;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

var _ThiessenAnalystParameters = __webpack_require__(54);

var _ThiessenAnalystParameters2 = _interopRequireDefault(_ThiessenAnalystParameters);

var _InterpolationAnalystParameters = __webpack_require__(28);

var _InterpolationAnalystParameters2 = _interopRequireDefault(_InterpolationAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationKrigingAnalystParameters
 * @classdesc克吕金插值分析参数类。通过该类可以设置克吕金插值分析所需的参数。
 * 克吕金（Kriging）法为地统计学上一种空间数据内插处理方法，主要的目的是利用各数据点间变异数（variance）的大小来推求某一未知点与各已知点的权重关系，
 * 再由各数据点的值和其与未知点的权重关系推求未知点的值。Kriging 法最大的特色不仅是提供一个最小估计误差的预测值，并且可明确的指出误差值的大小。
 * 一般而言，许多地质参数，如地形面，本身即具有连续性，故在一段距离内的任两点必有空间上的关系。反之，在一不规则面上的两点若相距甚远，
 * 则在统计意义上可视为互为独立 (stastically indepedent)。这种随距离而改变的空间上连续性，可用半变异图 (semivariogram) 来表现。
 * 因此，若想由已知的散乱点来推求某一未知点的值，则可利用半变异图推求各已知点与未知点的空间关系，即以下四个参数。
 * 然后，由此空间参数推求半变异数，由各数据点间的半变异数可推求未知点与已知点间的权重关系，进而推求出未知点的值。
 *
 * · 块金值（nugget）：当采样点间距为0时，理论上半变异函数值为0，但时间上两采样点非常接近时半变异函数值并不为0，即产生了上图所示的块金效应，
 * 对应的半变异函数值为块金值。块金值可能由于测量误差或者空间变异产生。
 *
 * · 基台值（sill）：随着采样点间距的不断增大，半变异函数的值趋向一个稳定的常数，该常数成为基台值。到达基台值后，半变异函数的值不再随采样点间距而改变，
 *   即大于此间距的采样点不再具有空间相关性。
 *
 * · 偏基台值：基台值与块金值的差值。
 *
 * · 自相关阈值（range）：也称变程，是半变异函数值达到基台值时，采样点的间距。超过自相关阈值的采样点不再具有空间相关性，将不对预测结果产生影响。
 *
 * 由上述可知，半变异函数是克吕金插值的关键，因此选择合适的半变异函数模型非常重要，SuperMap提供了以下三种半变异函数模型：
 *
 * · 指数型（EXPONENTIAL）：适用于空间相关关系随样本间距的增加成指数递减的情况，其空间自相关关系在样本间距的无穷远处完全消失。
 *
 * · 球型（SPHERICAL）：适用于空间自相关关系随样本间距的增加而逐渐减少，直到超出一定的距离时空间自相关关系消失的情况。
 *
 * · 高斯型（GAUSSIAN）：适用于半变异函数值渐进地逼近基台值的情况。
 *
 * 半变异函数中，有一个关键参数即插值的字段值的期望（平均值），由于对于此参数的不同处理方法而衍生出了不同的Kriging方法。SuperMap的差值功能基于以下三种常用Kriging算法：
 *
 * １.　简单克吕金（Simple Kriging）：该方法假定用于插值的字段值的期望（平均值）已知的某一常数。
 *
 * ２.　普通克吕金（Kriging）：该方法假定用于插值的字段值的期望（平均值）未知且恒定。它利用一定的数学函数，通过对给定的空间点进行拟合来估算单元格的值，
 *      生成格网数据集。它不仅可以生成一个表面，还可以给出预测结果的精度或者确定性的度量。因此，此方法计算精度较高，常用于地学领域。
 *
 * ３.　泛克吕金（Universal Kriging）：该方法假定用于插值的字段值的期望（平均值）是未知的变量。在样点数据中存在某种主导趋势且该趋势可以通过某一个确定
 *      的函数或者多项式进行拟合的情况下，适用泛克吕金插值法。
 *
 * 克吕金法的优点是以空间统计学作为其坚实的理论基础，物理含义明确；不但能估计测定参数的空间变异分布，而且还可以估算参数的方差分布。克吕金法的缺点是计算步骤较烦琐，
 * 计算量大，且变异函数有时需要根据经验人为选定。
 * @param options - {Object} 可选参数。如:</br>
 *        type - {string} 克吕金插值的类型。必设参数。</br>
 *        mean - {number}【简单克吕金】类型下,插值字段的平均值。</br>
 *        angle - {number}克吕金算法中旋转角度值，默认值为0。</br>
 *        nugget - {number}克吕金算法中块金效应值，默认值为0。</br>
 *        range - {number}克吕金算法中自相关阈值，单位与原数据集单位相同，默认值为0。</br>
 *        sill - {number}克吕金算法中基台值，默认值为0。</br>
 *        variogramMode - {string} 克吕金插值时的半变函数类型，默认为球型（SPHERICAL）。</br>
 *        exponent - {string} 【泛克吕金】类型下，用于插值的样点数据中趋势面方程的阶数，可选值为exp1、exp2，默认值为exp1。</br>
 *        bounds - {SuperMap.Bounds} 插值分析的范围，用于确定结果栅格数据集的范围。</br>
 *                  Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchMode - {string} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找，必设参数。</br>
 *        expectedCount - {number}【固定点数查找】方式下，设置待查找的点数，默认值为12；【定长查找】方式下，设置查找的最小点数，默认值为12。</br>
 *        searchRadius - {number}【定长查找】方式下，设置参与运算点的查找范围，默认值为0。</br>
 *        maxPointCountForInterpolation - {number}【块查找】方式下，设置最多参与插值的点数，默认值为200。</br>
 *        maxPointCountInNode - {number}【块查找】方式下，设置单个块内最多参与运算点数，默认值为50。</br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        zValueScale - {number}用于进行插值分析值的缩放比率，默认值为1。</br>
 *        resolution - {number}插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
 *        filterQueryParameter - {SuperMap.FilterParameter} 属性过滤条件。</br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称，必设参数。</br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。必设参数</br>
 *        pixelFormat - {string} 指定结果栅格数据集存储的像素格式。</br>
 *        dataset - {string} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。</br>
 * 当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        inputPoints - {Array <Object} 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时，必设参数。</br>
 *                       点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 * @extends SuperMap.InterpolationAnalystParameters
 * @example 例如：
 * (start code)
 * var myInterpolationKrigingAnalystParameters = new SuperMap.InterpolationKrigingAnalystParameters({
     *     dataset:"SamplesP@Interpolation",
     *     type: "KRIGING",
     *     angle: 0,
     *     mean: 5,
     *     nugget: 30,
     *     range: 50,
     *     sill: 300,
     *     variogramMode: "EXPONENTIAL",
     *     searchMode: "QUADTREE",
     *     maxPointCountForInterpolation: 20,
     *     maxPointCountInNode: 5,
     *     pixelFormat: "BIT16",
     *     zValueFieldName: "AVG_TMP",
     *     resolution: 30000,
     *     filterQueryParameter: {
     *         attributeFilter: ""
     *     },
     *     outputDatasetName: "myKriging"
     * });
 * (end)
 *
 */
var InterpolationKrigingAnalystParameters = function (_InterpolationAnalyst) {
    _inherits(InterpolationKrigingAnalystParameters, _InterpolationAnalyst);

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.maxPointCountForInterpolation -{number}
     * @description 【块查找】方式下，最多参与插值的点数。默认值为200。
     * 仅用于普通克吕金插值，简单克吕金和泛克吕金不支持块查找。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.searchMode -{SuperMap.SearchMode}
     * @description 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数
     * 简单克吕金和泛克吕金不支持块查找。
     * 具体如下：
     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
     * {QUADTREE} 使用 QUADTREE 方式查找参与内插分析的点（块查找）。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.variogramMode -{SuperMap.VariogramMode}
     * @description 克吕金插值时的半变函数类型.
     * 默认值为 SuperMap.VariogramMode.SPHERICAL。
     * 用户所选择的半变函数类型会影响未知点的预测，特别是曲线在原点处的不同形状有重要意义。
     * 曲线在原点处越陡，则较近领域对该预测值的影响就越大，因此输出表面就会越不光滑。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.range -{number}
     * @description 克吕金算法中自相关阈值，单位与原数据集单位相同。默认值为0。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.angle -{number}
     * @description 克吕金算法中旋转角度值。默认值为0。
     * 此角度值指示了每个查找邻域相对于水平方向逆时针旋转的角度。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.type -{SuperMap.InterpolationAlgorithmType}
     * @description 克吕金插值的类型。必设参数
     * 具体如下：
     * {KRIGING} 普通克吕金插值法
     * {SimpleKriging} 简单克吕金插值法
     * {UniversalKriging} 泛克吕金插值法
     */
    function InterpolationKrigingAnalystParameters(options) {
        _classCallCheck(this, InterpolationKrigingAnalystParameters);

        var _this = _possibleConstructorReturn(this, (InterpolationKrigingAnalystParameters.__proto__ || Object.getPrototypeOf(InterpolationKrigingAnalystParameters)).call(this, options));

        _this.type = null;
        _this.mean = null;
        _this.angle = 0;
        _this.nugget = 0;
        _this.range = 0;
        _this.sill = 0;
        _this.variogramMode = _REST.VariogramMode.SPHERICAL;
        _this.exponent = _REST.Exponent.EXP1;
        _this.searchMode = null;
        _this.expectedCount = 12;
        _this.maxPointCountForInterpolation = 200;
        _this.maxPointCountInNode = 50;
        _this.CLASS_NAME = "SuperMap.InterpolationKrigingAnalystParameters";

        var me = _this;
        me.type = null;
        me.mean = null;
        me.angle = 0;
        me.nugget = 0;
        me.range = 0;
        me.sill = 0;
        me.variogramMode = "SPHERICAL";
        me.exponent = "EXP1";
        me.searchMode = null;
        me.expectedCount = 12;
        me.maxPointCountForInterpolation = 200;
        me.maxPointCountInNode = 50;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.InterpolationKrigingAnalystParameters.prototype.destroy
     *
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.maxPointCountForInterpolation -{number}
     * @description 【块查找】方式下，设置单个块内最多参与运算点数。默认值为50。
     * 仅用于普通克吕金插值，简单克吕金和泛克吕金不支持块查找。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.expectedCount -{number}
     * @description【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数，默认值为12。
     * 【定长查找】方式下，设置查找的最小点数，默认值为12
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.exponent -{SuperMap.Exponent}
     * @description 【泛克吕金】类型下，用于插值的样点数据中趋势面方程的阶数。
     * 默认值为 SuperMap.Exponent.EXP1。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.sill -{number}
     * @description 克吕金算法中基台值。默认值为0。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.nugget -{number}
     * @description 克吕金算法中块金效应值。默认值为0。
     */


    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.mean -{number}
     * @description【简单克吕金】方式下，插值字段的平均值。
     * 即采样点插值字段值总和除以采样点数目。
     */


    _createClass(InterpolationKrigingAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(InterpolationKrigingAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(InterpolationKrigingAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.type = null;
            me.mean = null;
            me.angle = null;
            me.nugget = null;
            me.range = null;
            me.sill = null;
            me.variogramMode = null;
            me.exponent = null;
            me.searchMode = null;
            me.expectedCount = null;
            me.maxPointCountForInterpolation = null;
            me.maxPointCountInNode = null;
        }
    }]);

    return InterpolationKrigingAnalystParameters;
}(_InterpolationAnalystParameters2.default);

exports.default = InterpolationKrigingAnalystParameters;


_SuperMap2.default.InterpolationKrigingAnalystParameters = InterpolationKrigingAnalystParameters;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _InterpolationAnalystParameters = __webpack_require__(28);

var _InterpolationAnalystParameters2 = _interopRequireDefault(_InterpolationAnalystParameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationRBFAnalystParameters
 * @classdesc 样条插值（径向基函数插值法）分析参数类
 * @extends SuperMap.InterpolationAnalystParameters
 * @param options - {Object} 可选参数。如</br>
 *        smooth - {number}光滑系数，该值表示插值函数曲线与点的逼近程度，值域为 0到1，默认值为0.1。</br>
 *        tension - {number}张力系数，用于调整结果栅格数据表面的特性，默认为40。</br>
 *        bounds - {SuperMap.Bounds} 插值分析的范围，用于确定结果栅格数据集的范围。</br>
 *        searchMode - {string} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数。</br>
 *        expectedCount - {number}【固定点数查找】方式下，设置参与差值运算的点数，默认值为12。</br>
 *        searchRadius - {number}【定长查找】方式下，设置参与运算点的查找范围，默认值为0。</br>
 *        maxPointCountForInterpolation - {number}【块查找】方式下，设置最多参与插值的点数。默认为200。</br>
 *        maxPointCountInNode - {number}【块查找】方式下，设置单个块内最多参与运算点数。默认为50。</br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        zValueScale - {number}用于进行插值分析值的缩放比率，默认值为1。</br>
 *        resolution - {number}插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
 *        filterQueryParameter - {SuperMap.FilterParameter} 属性过滤条件。</br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称。必设参数。</br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。必设参数。</br>
 *        pixelFormat - {string} 指定结果栅格数据集存储的像素格式。</br>
 *        dataset - {string} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        inputPoints - {Array <SuperMap.Geometry.Point} 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时，必设参数。</br>
 * @example 例如：
 * (start code)
 * var myInterpolationRBFAnalystParameters = new SuperMap.InterpolationRBFAnalystParameters({
     *     dataset:"SamplesP@Interpolation",
     *     smooth: 0.1,
     *     tension: 40,
     *     searchMode: "QUADTREE",
     *     maxPointCountForInterpolation: 20,
     *     maxPointCountInNode: 5,
     *     pixelFormat: "BIT16",
     *     zValueFieldName: "AVG_TMP",
     *     resolution: 3000,
     *     filterQueryParameter: {
     *         attributeFilter: ""
     *     },
     *     outputDatasetName: "myRBF"
     * });
 * (end)
 *
 */
var InterpolationRBFAnalystParameters = function (_InterpolationAnalyst) {
    _inherits(InterpolationRBFAnalystParameters, _InterpolationAnalyst);

    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.maxPointCountForInterpolation -{number}
     * @description 【块查找】方式下，最多参与插值的点数。默认值为200。
     */


    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.searchMode -{SuperMap.SearchMode}
     * @description 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数
     * 具体如下：
     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
     * {QUADTREE} 使用 QUADTREE 方式查找参与内插分析的点（块查找）。
     */


    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.smooth -{number}
     * @description 光滑系数，值域为 0到1，默认值为0.1，常用取值如0、0.001、0.01、0.1、和0.5。
     * 该值表示插值函数曲线与点的逼近程度，此数值越大，函数曲线与点的偏差越大，反之越小。
     */
    function InterpolationRBFAnalystParameters(options) {
        _classCallCheck(this, InterpolationRBFAnalystParameters);

        var _this = _possibleConstructorReturn(this, (InterpolationRBFAnalystParameters.__proto__ || Object.getPrototypeOf(InterpolationRBFAnalystParameters)).call(this, options));

        _this.smooth = 0.1;
        _this.tension = 40;
        _this.searchMode = null;
        _this.expectedCount = 12;
        _this.maxPointCountForInterpolation = 200;
        _this.maxPointCountInNode = 50;
        _this.CLASS_NAME = "SuperMap.InterpolationRBFAnalystParameters";

        var me = _this;
        me.smooth = 0.1;
        me.tension = 40;
        me.searchMode = null;
        me.expectedCount = 12;
        me.maxPointCountForInterpolation = 200;
        me.maxPointCountInNode = 50;
        if (options) {
            _SuperMap2.default.Util.extend(me, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.InterpolationRBFAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.maxPointCountInNode -{number}
     * @description【块查找】方式下，单个块内最多参与运算点数。默认值为50。
     */


    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.expectedCount -{number}
     * @description【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数。默认值为12。
     */


    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.tension -{number}
     * @description 张力系数，默认为40，常用取值如0、1、5和10。
     * 用于调整结果栅格数据表面的特性，张力越大，插值时每个点对计算结果影响越小，反之越大。
     */


    _createClass(InterpolationRBFAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(InterpolationRBFAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(InterpolationRBFAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.smooth = null;
            me.tension = null;
            me.searchMode = null;
            me.expectedCount = null;
            me.maxPointCountForInterpolation = null;
            me.maxPointCountInNode = null;
        }
        /**
         * @function SuperMap.InterpolationRBFAnalystParameters.toObject
         * @param datasetInterpolationRBFAnalystParameters -{SuperMap.InterpolationRBFAnalystParameters} 样条插值（径向基函数插值法）分析参数
         * @param tempObj - {Object} 目标对象
         * @description 生成样条插值（径向基函数插值法）分析对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(datasetInterpolationRBFAnalystParameters, tempObj) {
            for (var name in datasetInterpolationRBFAnalystParameters) {
                tempObj[name] = datasetInterpolationRBFAnalystParameters[name];
            }
        }
    }]);

    return InterpolationRBFAnalystParameters;
}(_InterpolationAnalystParameters2.default);

exports.default = InterpolationRBFAnalystParameters;


_SuperMap2.default.InterpolationRBFAnalystParameters = InterpolationRBFAnalystParameters;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.KernelDensityJobParameter
 * @classdesc 密度分析任务参数类
 * @param options - {Object} 可选参数。如：<br>
 *        datasetName -{string} 数据集名。 <br>
 *        query -{SuperMap.Bounds} 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。 <br>
 *        resolution -{number}分辨率。 <br>
 *        method -{number}分析方法。 <br>
 *        meshType -{number}分析类型。 <br>
 *        fields -{string} 权重索引。 <br>
 *        radius -{number}分析的影响半径。
 */
var KernelDensityJobParameter = function () {

  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.radiusUnit -{SuperMap.AnalystSizeUnit}
   * @description 搜索半径单位。
   */


  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.radius -{number}
   * @description 分析的影响半径。
   */


  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.meshType -{number}
   * @description 分析类型。
   */


  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.resolution -{number}
   * @description 网格大小。
   */


  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.datasetName -{string}
   * @description 数据集名。
   */
  function KernelDensityJobParameter(options) {
    _classCallCheck(this, KernelDensityJobParameter);

    this.datasetName = "";
    this.query = "";
    this.resolution = 80;
    this.method = 0;
    this.meshType = 0;
    this.fields = "";
    this.radius = 300;
    this.meshSizeUnit = _REST.AnalystSizeUnit.METER;
    this.radiusUnit = _REST.AnalystSizeUnit.METER;
    this.areaUnit = _REST.AnalystAreaUnit.SQUAREMILE;

    if (!options) {
      return;
    }
    _SuperMap2.default.Util.extend(this, options);
  }

  /**
   * @function SuperMap.KernelDensityJobParameter.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.areaUnit -{SuperMap.AnalystAreaUnit}
   * @description 面积单位。
   */


  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.meshSizeUnit -{SuperMap.AnalystSizeUnit}
   * @description 网格大小单位。
   */


  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.fields -{string}
   * @description 权重索引。
   */


  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.method -{number}
   * @description 分析方法。
   */


  /**
   * @member SuperMap.KernelDensityJobParameter.prototype.query -{SuperMap.Bounds}
   * @description 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。 <br>
   */


  _createClass(KernelDensityJobParameter, [{
    key: 'destroy',
    value: function destroy() {
      this.datasetName = null;
      this.query = null;
      this.resolution = null;
      this.method = null;
      this.radius = null;
      this.meshType = null;
      this.fields = null;
      this.meshSizeUnit = null;
      this.radiusUnit = null;
      this.areaUnit = null;
    }

    /**
     * @function SuperMap.KernelDensityJobParameter.toObject
     * @param kernelDensityJobParameter -{Object} 密度分析任务参数。
     * @param tempObj - {Object} 目标对象
     * @description 生成密度分析任务对象
     */

  }], [{
    key: 'toObject',
    value: function toObject(kernelDensityJobParameter, tempObj) {
      for (var name in kernelDensityJobParameter) {
        if (name === "datasetName") {
          tempObj['input'] = tempObj['input'] || {};
          tempObj['input'][name] = kernelDensityJobParameter[name];
          continue;
        }
        tempObj['analyst'] = tempObj['analyst'] || {};
        if (name === 'query') {
          tempObj['analyst'][name] = kernelDensityJobParameter[name].toBBOX();
        } else {
          tempObj['analyst'][name] = kernelDensityJobParameter[name];
        }
      }
    }
  }]);

  return KernelDensityJobParameter;
}();

exports.default = KernelDensityJobParameter;


_SuperMap2.default.KernelDensityJobParameter = KernelDensityJobParameter;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _LabelMatrixCell2 = __webpack_require__(49);

var _LabelMatrixCell3 = _interopRequireDefault(_LabelMatrixCell2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.LabelImageCell
 * @classdesc 图片类型的矩阵标签元素类。
 * @description 该类继承自 SuperMap.LabelMatrixCell类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
 *              矩阵标签专题图是标签专题图（ThemeLabel）的一种，其中矩阵标签中的填充元素又可分为图片类型（SuperMap.LabelImageCell）、
 *              符号类型（SuperMap.LabelSymbolCell）、专题图类型（SuperMap.LabelThemeCell）三种，该类是这三种类型的矩阵标签元素其中的一种，
 *              用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应） 、大小等。
 *              用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 SuperMap.ThemeLabel.matrixCells 属性即可。matrixCells 属是一个二维数组，
 *              每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
 * @extends SuperMap.LabelMatrixCell
 * @param options - {Object} 可选参数。如：<br>
 *        height - {number}设置图片的高度，单位为毫米。<br>
 *        pathField - {string} 设置矩阵标签元素所使用图片的路径。<br>
 *        rotation - {number}图片的旋转角度。逆时针方向为正方向，单位为度，精确到0.1度。默认值为0.0。<br>
 *        width - {number}设置图片的宽度，单位为毫米。<br>
 *        sizeFixed - {boolean} 是否固定图片的大小。默认值为 false，即图片将随地图缩放。
 */
var LabelImageCell = function (_LabelMatrixCell) {
    _inherits(LabelImageCell, _LabelMatrixCell);

    /**
     * @member SuperMap.LabelImageCell.prototype.sizeFixed -{boolean}
     * @description 是否固定图片的大小。默认值为 false，即图片将随地图缩放。
     */


    /**
     * @member SuperMap.LabelImageCell.prototype.rotation -{number}
     * @description 图片的旋转角度。逆时针方向为正方向，单位为度，精确到0.1度。默认值为0.0。
     */


    /**
     * @member SuperMap.LabelImageCell.prototype.height -{number}
     * @description 设置图片的高度，单位为毫米。
     */
    function LabelImageCell(options) {
        _classCallCheck(this, LabelImageCell);

        var _this = _possibleConstructorReturn(this, (LabelImageCell.__proto__ || Object.getPrototypeOf(LabelImageCell)).call(this, options));

        _this.height = 0;
        _this.pathField = null;
        _this.rotation = 0.0;
        _this.width = 0;
        _this.sizeFixed = false;
        _this.type = "IMAGE";
        _this.CLASS_NAME = "SuperMap.LabelImageCell";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.LabelImageCell.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.LabelImageCell.prototype.type -{boolean}
     * @description 制作矩阵专题图时是必须的。
     */


    /**
     * @member SuperMap.LabelImageCell.prototype.width -{number}
     * @description 设置图片的宽度，单位为毫米。
     */


    /**
     * @member SuperMap.LabelImageCell.prototype.pathField -{string}
     * @description 设置矩阵标签元素所使用的图片路径对应的字段名。
     */


    _createClass(LabelImageCell, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.height = null;
            me.pathField = null;
            me.rotation = null;
            me.width = null;
            me.sizeFixed = null;
        }
    }]);

    return LabelImageCell;
}(_LabelMatrixCell3.default);

exports.default = LabelImageCell;


_SuperMap2.default.LabelImageCell = LabelImageCell;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerTextStyle = __webpack_require__(16);

var _ServerTextStyle2 = _interopRequireDefault(_ServerTextStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.LabelMixedTextStyle
 * @classdesc 标签文本复合风格类。
 * @description 该类主要用于对标签专题图中标签的文本内容进行风格设置。通过该类用户可以使标签的文字显示不同的风格，
 *              比如文本 “喜马拉雅山”，通过本类可以将前三个字用红色显示，后两个字用蓝色显示。
 *              对同一文本设置不同的风格实质上是对文本的字符进行分段，同一分段内的字符具有相同的显示风格。
 *              对字符分段有两种方式，一种是利用分隔符对文本进行分段；另一种是根据分段索引值进行分段。<br>
 *              1. 利用分隔符对文本进行分段: 比如文本 “5&109” 被分隔符 “&” 分为“5”和“109”两部分，
 *                 在显示时，“5” 和分隔符 “&” 使用同一个风格，字符串 “109” 使用相同的风格。<br>
 *              2. 利用分段索引值进行分段: 文本中字符的索引值是以0开始的整数，比如文本“珠穆朗玛峰”，
 *                 第一个字符（“珠”）的索引值为0，第二个字符（“穆”）的索引值为1，以此类推；当设置分段索引值为1，3，4，9时，
 *                 字符分段范围相应的就是(-∞，1)，[1，3)，[3，4)，[4，9)，[9，+∞)，可以看出索引号为0的字符（即“珠” ）在第一个分段内，
 *                 索引号为1，2的字符（即“穆”、“朗”）位于第二个分段内，索引号为3的字符（“玛”）在第三个分段内，索引号为4的字符（“峰”）在第四个分段内，其余分段中没有字符。
 * @param options - {Object} 可选参数。如：<br>
 *        defaultStyle - {SuperMap.ServerTextStyle} 默认的文本复合风格。<br>
 *        separator - {string} 文本的分隔符。<br>
 *        separatorEnabled - Boolean} 文本的分隔符是否有效。<br>
 *        splitIndexes - {Array<number>} 分段索引值，分段索引值用来对文本中的字符进行分段。<br>
 *        styles - {Array<SuperMap.ServerTextStyle>} 文本样式集合。
 */
var LabelMixedTextStyle = function () {

    /**
     * @member SuperMap.LabelMixedTextStyle.prototype.splitIndexes -{Array<number>}
     * @description 分段索引值，分段索引值用来对文本中的字符进行分段。
     *              文本中字符的索引值是以0开始的整数，比如文本“珠穆朗玛峰”，第一个字符（“珠”）的索引值为0，第二个字符（“穆”）的索引值为1，
     *              以此类推；当设置分段索引值数组为[1，3，4，9]时，字符分段范围相应的就是(-∞，1)，[1，3)，[3，4)，[4，9)，[9，+∞)，
     *              可以看出索引号为0的字符（即“珠” ）在第一个分段内，索引号为1，2的字符（即“穆”、“朗”）位于第二个分段内，
     *              索引号为3的字符（“玛”）在第三个分段内，索引号为4的字符（“峰”）在第四个分段内，其余分段中没有字符。
     */


    /**
     * @member SuperMap.LabelMixedTextStyle.prototype.separator -{string}
     * @description 文本的分隔符，分隔符的风格与前一个字符的风格一样。文本的分隔符是一个将文本分割开的符号，
     *              比如文本 “5_109” 被 “_” 隔符为 “5” 和 “109” 两部分，假设有风格数组：style1、style2。
     *              在显示时，“5” 和分隔符 “_” 使用 Style1 风格渲染，字符串 “109” 使用 Style2 的风格。
     */
    function LabelMixedTextStyle(options) {
        _classCallCheck(this, LabelMixedTextStyle);

        this.defaultStyle = null;
        this.separator = null;
        this.separatorEnabled = false;
        this.splitIndexes = null;
        this.styles = null;
        this.CLASS_NAME = "SuperMap.LabelMixedTextStyle";

        var me = this;
        me.defaultStyle = new _ServerTextStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.LabelMixedTextStyle.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.LabelMixedTextStyle.prototype.styles -{Array<SuperMap.ServerTextStyle>}
     * @description 文本样式集合。文本样式集合中的样式根据索引与不同分段一一对应，
     *              如果有分段没有风格对应则使用 defaultStyle。
     */


    /**
     * @member SuperMap.LabelMixedTextStyle.prototype.separatorEnabled -{boolean}
     * @description 文本的分隔符是否有效。分隔符有效时利用分隔符对文本进行分段；无效时根据文本中字符的位置进行分段。
     *              分段后，同一分段内的字符具有相同的显示风格。默认为 false。
     */


    /**
     * @member SuperMap.LabelMixedTextStyle.prototype.defaultStyle -{SuperMap.ServerTextStyle}
     * @description 默认的文本复合风格，即 SuperMap.ServerTextStyle 各字段的默认值。
     */


    _createClass(LabelMixedTextStyle, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.defaultStyle) {
                me.defaultStyle.destroy();
                me.defaultStyle = null;
            }
            me.separator = null;
            me.separatorEnabled = null;
            if (me.splitIndexes) {
                me.splitIndexes = null;
            }
            if (me.styles) {
                for (var i = 0, styles = me.styles, len = styles.length; i < len; i++) {
                    styles[i].destroy();
                }
                me.styles = null;
            }
        }

        /**
         * @function SuperMap.LabelMixedTextStyle.fromObj
         * @description 从传入对象获取标签文本复合风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.LabelMixedTextStyle}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new LabelMixedTextStyle();
            var stys = obj.styles;
            _SuperMap2.default.Util.copy(res, obj);
            res.defaultStyle = new _ServerTextStyle2.default(obj.defaultStyle);
            if (stys) {
                res.styles = [];
                for (var i = 0, len = stys.length; i < len; i++) {
                    res.styles.push(new _ServerTextStyle2.default(stys[i]));
                }
            }
            return res;
        }
    }]);

    return LabelMixedTextStyle;
}();

exports.default = LabelMixedTextStyle;


_SuperMap2.default.LabelMixedTextStyle = LabelMixedTextStyle;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

var _LabelMatrixCell2 = __webpack_require__(49);

var _LabelMatrixCell3 = _interopRequireDefault(_LabelMatrixCell2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.LabelSymbolCell
 * @classdesc 符号类型的矩阵标签元素类。
 * @description 该类继承自 SuperMap.LabelMatrixCell类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
 *              矩阵标签专题图是标签专题图（SuperMap.ThemeLabel）的一种，其中矩阵标签中的填充元素又可分为图片类型（SuperMap.LabelImageCell）、
 *              符号类型（SuperMap.LabelSymbolCell）、专题图类型（SuperMap.LabelThemeCell）三种，该类是这三种类型的矩阵标签元素其中的一种，
 *              用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应） 、大小等。
 *              用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 SuperMap.ThemeLabel.matrixCells 属性即可。matrixCells 属是一个二维数组，
 *              每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
 * @extends SuperMap.LabelMatrixCell
 * @param options - {Object} 可选参数。如：<br>
 *        style - {SuperMap.ServerStyle} 获取或设置符号样式—— SuperMap.ServerStyle 对象。<br>
 *        symbolIDField - {string} 符号 ID 或符号 ID 所对应的字段名称。
 */
var LabelSymbolCell = function (_LabelMatrixCell) {
    _inherits(LabelSymbolCell, _LabelMatrixCell);

    /**
     * @member SuperMap.LabelSymbolCell.prototype.symbolIDField -{string}
     * @description 获取或设置符号 ID 或符号 ID 所对应的字段名称，必设属性。
     */
    function LabelSymbolCell(options) {
        _classCallCheck(this, LabelSymbolCell);

        var _this = _possibleConstructorReturn(this, (LabelSymbolCell.__proto__ || Object.getPrototypeOf(LabelSymbolCell)).call(this, options));

        _this.style = null;
        _this.symbolIDField = null;
        _this.type = "SYMBOL";
        _this.CLASS_NAME = "SuperMap.LabelSymbolCell";

        var me = _this;
        me.style = new _ServerStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.LabelSymbolCell.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.LabelSymbolCell.prototype.type -{string}
     * @description 制作矩阵专题图时是必须的。
     */


    /**
     * @member SuperMap.LabelSymbolCell.prototype.style -{SuperMap.ServerStyle}
     * @description 获取或设置符号样式—— SuperMap.ServerStyle 对象，包括符号大小（SuperMap.ServerStyle.markerSize）
     *              和符号旋转（SuperMap.ServerStyle.markerAngle）角度，其中用于设置符号 ID 的属性（SuperMap.ServerStyle.markerSymbolID）在此处不起作用。
     */


    _createClass(LabelSymbolCell, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
            me.symbolIDField = null;
        }
    }]);

    return LabelSymbolCell;
}(_LabelMatrixCell3.default);

exports.default = LabelSymbolCell;


_SuperMap2.default.LabelSymbolCell = LabelSymbolCell;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ThemeLabel = __webpack_require__(52);

var _ThemeLabel2 = _interopRequireDefault(_ThemeLabel);

var _LabelMatrixCell2 = __webpack_require__(49);

var _LabelMatrixCell3 = _interopRequireDefault(_LabelMatrixCell2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.LabelThemeCell
 * @classdesc 专题图类型的矩阵标签元素类。
 * @description 该类继承自 SuperMap.LabelMatrixCell类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
 *              矩阵标签专题图是标签专题图（SuperMap.ThemeLabel）的一种，其中矩阵标签中的填充元素又可分为图片类型（SuperMap.LabelImageCell）、
 *              符号类型（SuperMap.LabelSymbolCell）、专题图类型（SuperMap.LabelThemeCell）三种，该类是这三种类型的矩阵标签元素其中的一种，
 *              用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应） 、大小等。
 *              用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 SuperMap.ThemeLabel.matrixCells 属性即可。matrixCells 属是一个二维数组，
 *              每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
 * @extends SuperMap.LabelMatrixCell
 * @param options - {Object} 可选参数。如：<br>
 *        themeLabel - {SuperMap.ThemeLabel} 使用专题图对象作为矩阵标签的一个元素。
 */
var LabelThemeCell = function (_LabelMatrixCell) {
    _inherits(LabelThemeCell, _LabelMatrixCell);

    /**
     * @member SuperMap.LabelThemeCell.prototype.themeLabel -{SuperMap.ThemeLabel}
     * @description 使用专题图对象作为矩阵标签的一个元素。
     */
    function LabelThemeCell(options) {
        _classCallCheck(this, LabelThemeCell);

        var _this = _possibleConstructorReturn(this, (LabelThemeCell.__proto__ || Object.getPrototypeOf(LabelThemeCell)).call(this, options));

        _this.themeLabel = null;
        _this.type = "THEME";
        _this.CLASS_NAME = " SuperMap.LabelThemeCell";

        var me = _this;
        me.themeLabel = new _ThemeLabel2.default();
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.LabelThemeCell.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.LabelThemeCell.prototype.type -{string}
     * @description 制作矩阵专题图时是必须的。
     */


    _createClass(LabelThemeCell, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.themeLabel) {
                me.themeLabel.destroy();
                me.themeLabel = null;
            }
        }
    }]);

    return LabelThemeCell;
}(_LabelMatrixCell3.default);

exports.default = LabelThemeCell;


_SuperMap2.default.LabelThemeCell = LabelThemeCell;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.LayerStatus
 * @classdesc 子图层显示参数类。
 * @description 该类存储了各个子图层的名字和是否可见的状态。
 * @param options - {Object} 可选参数。如：<br>
 *        layerName - {string} 获取或设置图层名称。<br>
 *        isVisible - {boolean} 获取或设置图层是否可见，true 表示可见。<br>
 *        displayFilter - {string} 图层显示 SQL 过滤条件。
 */
var LayerStatus = function () {

    /**
     * @member SuperMap.LayerStatus.prototype.displayFilter -{string}
     * @description 图层显示 SQL 过滤条件，如 layerStatus.displayFilter = "smid < 10"，表示仅显示 smid 值小于 10 的对象。
     */


    /**
     * @member SuperMap.LayerStatus.prototype.layerName -{string}
     * @description 获取或设置图层名称。必设属性。
     */
    function LayerStatus(options) {
        _classCallCheck(this, LayerStatus);

        this.layerName = null;
        this.isVisible = null;
        this.displayFilter = null;
        this.fieldValuesDisplayFilter = null;
        this.CLASS_NAME = "SuperMap.LayerStatus";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.LayerStatus.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.LayerStatus.prototype.fieldValuesDisplayFilter -{Object}
     * @description 图层要素的显示和隐藏的过滤属性，其带有三个属性，分别是:values、fieldName、fieldValuesDisplayMode,他们的作用如下：<br>
     *              values：{Array<number>} - 就是要过滤的值；<br>
     *              fieldName：{string} - 要过滤的字段名称 只支持数字类型的字段；<br>
     *              fieldValuesDisplayMode：{string} 目前有两个DISPLAY/DISABLE。当为DISPLAY时，表示只显示以上设置的相应属性值的要素，否则表示不显示以上设置的相应属性值的要素
     */


    /**
     * @member SuperMap.LayerStatus.prototype.isVisible -{boolean}
     * @description 获取或设置图层是否可见，true 表示可见。必设属性。
     */


    _createClass(LayerStatus, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.layerName = null;
            me.isVisible = null;
            me.displayFilter = null;
        }

        /**
         * @function SuperMap.LayerStatus.prototype.toJSON
         * @description 生成对应的json。
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            var json = '{';
            json += '"type":"UGC",';
            var v = [];
            if (this.layerName) {
                v.push('"name":"' + this.layerName + '"');
                v.push('"visible":' + this.isVisible);
            }

            if (this.displayFilter) {
                v.push('"displayFilter":"' + this.displayFilter + '"');
            }

            if (this.minScale || this.minScale == 0) {
                v.push('"minScale":' + this.minScale);
            }

            if (this.maxScale || this.maxScale == 0) {
                v.push('"maxScale":' + this.maxScale);
            }

            if (this.fieldValuesDisplayFilter) {
                v.push('"fieldValuesDisplayFilter":' + _SuperMap2.default.Util.toJSON(this.fieldValuesDisplayFilter));
            }

            json += v;
            json += '}';

            return json;
        }
    }]);

    return LayerStatus;
}();

exports.default = LayerStatus;


_SuperMap2.default.LayerStatus = LayerStatus;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _DatasourceConnectionInfo = __webpack_require__(178);

var _DatasourceConnectionInfo2 = _interopRequireDefault(_DatasourceConnectionInfo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** * @class SuperMap.LinkItem * @constructs SuperMap.LinkItem * @classdesc 关联信息类。 * @description 该类用于矢量数据集与外部表的关联。 外部表是另一个数据集（其中纯属性数据集中没有空间几何信息）中的 DBMS 表, *              矢量数据集与外部表可以属于不同的数据源，但数据源类型目前只支持SQL Server和Oracle类型。使用LinkItem时， *              空间数据和属性数据必须满足关联条件，即主空间数据集与外部属性表之间存在关联字段。SuperMap.LinkItem *              只支持左连接，UDB、PostgreSQL 和 DB2 数据源不支持 SuperMap.LinkItem;另外，用于建立关联关系的两个表可以不在同一个数据源下。<br> *              (注意：1. 使用 SuperMap.LinkItem 的约束条件为：空间数据和属性数据必须有关联条件，即主空间数据集与外部属性表之间存在关联字段；<br> *                    2. 使用外关联表制作专题图时，所关联的字段必须设置表名，例如，如果所关联的字段为BaseMap_R数据集的SmID，就要写成BaseMap_R.SMID。) * @param options - {Object} 参数。 *        datasourceConnectionInfo - {SuperMap.DatasourceConnectionInfo} 关联的外部数据源信息。</br> *        foreignKeys - {Array<string>} 主空间数据集的外键。</br> *        foreignTable - {string} 关联的外部属性表的名称。</br> *        linkFields - {Array<string>} 欲保留的外部属性表的字段。</br> *        linkFilter - {string} 与外部属性表的连接条件。</br> *        name - {string} 此关联信息对象的名称。</br> *        primaryKeys - {Array<string>} 需要关联的外部属性表的主键。</br> * @example 下面以SQL查询说明linkitem的使用方法： * (start code) *  function queryBySQL() { *      // 设置关联的外部数据库信息,alias表示数据库别名 *      var dc = new SuperMap.DatasourceConnectionInfo({ *          dataBase: "RelQuery", *          server: "192.168.168.39", *          user: "sa", *          password: "map", *          driver: "SQL Server", *          connect: true, *          OpenLinkTable: false, *          alias: "RelQuery", *          engineType: EngineType.SQLPLUS, *          readOnly: false, *          exclusive: false *      }); *     // 设置关联信息 *      var linkItem = new SuperMap.LinkItem({ *          datasourceConnectionInfo: dc, *          foreignKeys: ["name"], *          foreignTable: "Pop_2011", *          linkFields: ["SmID as Pid","pop"], *          name: "link", *          primatryKeys: ["name"], *      }); *      // 设置查询参数，在查询参数中添加linkItem关联条件信息 *      var queryParam, queryBySQLParams, queryBySQLService; *      queryParam = new SuperMap.FilterParameter({ *          name: "Province@RelQuery", *          fields: ["SmID","name"], *          attributeFilter: "SmID<7", *          linkItems: [linkItem] *       }), *      queryBySQLParams = new SuperMap.QueryBySQLParameters({ *           queryParams: [queryParam] *              }), *      queryBySQLService = new SuperMap.QueryBySQLService(url, {     *          eventListeners: {     *              "processCompleted": processCompleted,     *              "processFailed": processFailed     *              }     *      });     *      queryBySQLService.processAsync(queryBySQLParams);     *  } *  function processCompleted(queryEventArgs) {//todo} *  function processFailed(e) {//todo} * (end) * */
var LinkItem = function () {

  /**     * @member SuperMap.LinkItem.prototype.name -{string}     * @description 此关联信息对象的名称。     */


  /**     * @member SuperMap.LinkItem.prototype.linkFields - {Array<string>}     * @description 欲保留的外部属性表的字段。如果不设置字段或者设置的字段在外部属性表中不存在的话则不返     * 回任何外部属性表的属性信息。如果欲保留的外部表字段与主表字段存在同名，则还需要指定一个不存在字段名作为外部表的字段别名。     */


  /**     * @member SuperMap.LinkItem.prototype.foreignKeys -{Array<string>}     * @description 主空间数据集的外键。     */
  function LinkItem(options) {
    _classCallCheck(this, LinkItem);

    this.datasourceConnectionInfo = null;
    this.foreignKeys = null;
    this.foreignTable = null;
    this.linkFields = null;
    this.linkFilter = null;
    this.name = null;
    this.primaryKeys = null;
    this.CLASS_NAME = "SuperMap.LinkItem";

    if (options) {
      _SuperMap2.default.Util.extend(this, options);
    }
  }

  /**     * @function SuperMap.LinkItem.prototype.destroy     * @description 释放资源，将引用资源的属性置空。     */


  /**     * @member SuperMap.LinkItem.prototype.primaryKeys -{Array<string>}     * @description 需要关联的外部属性表的主键。     */


  /**     * @member SuperMap.LinkItem.prototype.linkFilter -{string}     * @description 与外部属性表的连接条件。     */


  /**     * @member SuperMap.LinkItem.prototype.foreignTable - {string}     * @description 关联的外部属性表的名称，目前仅支持 Supermap 管理的表，即另一个矢量数据集所对应的 DBMS 表。     */


  /**     * @member SuperMap.LinkItem.prototype.datasourceConnectionInfo -{SuperMap.DatasourceConnectionInfo}     * @description 关联的外部数据源信息 。     */


  _createClass(LinkItem, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      if (me.datasourceConnectionInfo) {
        me.datasourceConnectionInfo.destroy();
        me.datasourceConnectionInfo = null;
      }
      me.foreignKeys = null;
      me.foreignTable = null;
      me.linkFields = null;
      me.linkFilter = null;
      me.name = null;
      me.primaryKeys = null;
    }
  }]);

  return LinkItem;
}();

exports.default = LinkItem;

_SuperMap2.default.LinkItem = LinkItem;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.MathExpressionAnalysisParameters
 * @classdesc 栅格代数运算参数类
 * @param options - {Object} 可选参数。如：</br>
 *        dataset - {string} 要用来做栅格代数运算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：BaseMap_P@Jingjin。必设字段。</br>
 *        extractRegion - {SuperMap.Geometry.Ploygon} 栅格代数运算的范围，指定数据集中参与栅格代数运算的区域。</br>
 *                         面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
 *                         如果缺省，则计算全部区域，如果参与运算的数据集范围不一致，将使用所有数据集的范围的交集作为计算区域 。</br>
 *        expression - {string} 指定的栅格运算表达式。如：[DatasourceAlias1.Raster1]*2-10；必设字段。</br>
 *        isZip - {boolean} 是否对结果数据集进行压缩处理。默认为 false，表示不压缩。</br>
 *        ignoreNoValue - {boolean} 是否忽略无值栅格数据。true </br>表示忽略无值数据，即无值栅格不参与运算。默认为 false。
 *        targetDatasource - {string} 指定存储结果数据集的数据源，必设字段。</br>
 *        resultGridName - {number}指定结果数据集名称，必设字段。</br>
 *        deleteExistResultDataset - {boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。</br>
 */
var MathExpressionAnalysisParameters = function () {

    /**
     * @member SuperMap.MathExpressionAnalysisParameters.prototype.resultGridName -{string}
     * @description 指定结果数据集名称，必设字段。
     */


    /**
     * @member SuperMap.MathExpressionAnalysisParameters.prototype.ignoreNoValue -{boolean}
     * @description 是否忽略无值栅格数据，默认为false。
     */


    /**
     * @member SuperMap.MathExpressionAnalysisParameters.prototype.expression -{string}
     * @description 指定的栅格运算表达式。如："[DatasourceAlias1.Raster1]*2-10"；必设字段。
     */


    /**
     * @member SuperMap.MathExpressionAnalysisParameters.prototype.dataset -{string}
     * @description 要用来做栅格代数运算数据源中数据集的名称。
     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。必设字段。
     *
     */
    function MathExpressionAnalysisParameters(options) {
        _classCallCheck(this, MathExpressionAnalysisParameters);

        this.dataset = null;
        this.extractRegion = null;
        this.expression = null;
        this.isZip = false;
        this.ignoreNoValue = false;
        this.targetDatasource = null;
        this.resultGridName = null;
        this.deleteExistResultDataset = false;
        this.CLASS_NAME = "SuperMap.MathExpressionAnalysisParameters";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.MathExpressionAnalysisParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.MathExpressionAnalysisParameters.prototype.deleteExistResultDataset -{boolean}
     * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
     */


    /**
     * @member SuperMap.MathExpressionAnalysisParameters.prototype.targetDatasource -{string}
     * @description 指定存储结果数据集的数据源，必设字段。
     */


    /**
     * @member SuperMap.MathExpressionAnalysisParameters.prototype.isZip -{boolean}
     * @description 是否对结果数据集进行压缩处理。默认为false，表示不压缩。
     */


    /**
     * @member SuperMap.MathExpressionAnalysisParameters.prototype.extractRegion
     * @description 栅格代数运算的范围，指定数据集中参与栅格代数运算的区域。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
     * 如果缺省，则计算全部区域，如果参与运算的数据集范围不一致，将使用所有数据集的范围的交集作为计算区域 。
     */


    _createClass(MathExpressionAnalysisParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.dataset = null;
            me.bounds = null;
            me.expression = null;
            me.isZip = true;
            me.ignoreNoValue = true;
            me.targetDatasource = null;
            me.resultGridName = null;
            me.deleteExistResultDataset = null;
        }

        /**
         * @function SuperMap.MathExpressionAnalysisParameters.toObject
         * @param mathExpressionAnalysisParameters -{Object} 栅格代数运算参数
         * @param tempObj - {Object} 目标对象
         * @description 生成栅格代数运算对象
         */

    }], [{
        key: "toObject",
        value: function toObject(mathExpressionAnalysisParameters, tempObj) {
            for (var name in mathExpressionAnalysisParameters) {
                if (name !== "dataset") {
                    tempObj[name] = mathExpressionAnalysisParameters[name];
                }

                if (name === "extractRegion") {
                    if (mathExpressionAnalysisParameters[name]) {
                        var bs = mathExpressionAnalysisParameters[name].components[0].components;
                        var region = {},
                            points = [],
                            type = "REGION";

                        var len = bs.length;
                        for (var i = 0; i < len - 1; i++) {
                            var poi = {};
                            poi["x"] = bs[i].x;
                            poi["y"] = bs[i].y;
                            points.push(poi);
                        }
                        ;

                        region["points"] = points;
                        region["type"] = type;

                        tempObj[name] = region;
                    }
                }
            }
        }
    }]);

    return MathExpressionAnalysisParameters;
}();

exports.default = MathExpressionAnalysisParameters;


_SuperMap2.default.MathExpressionAnalysisParameters = MathExpressionAnalysisParameters;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.MeasureParameters
 * @classdesc 量算参数类。
 * @param geometry - {Object} 要量算的几何对象。<br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
 *                  线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
 *                  面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。<br>
 * @param options - {Object} 可选参数。如：<br>
 *         unit - {Unit} 量算单位。<br>
 *         prjCoordSys -{string} 用来指定该量算操作所使用的投影,该项默认值为空。<br>
 *         distanceMode -{string} 用来指定量算的方式为按球面长度'Geodesic'或者平面长度'Planar'来计算，默认为'Geodesic'。
 */
var MeasureParameters = function () {

    /**
     * @member SuperMap.MeasureParameters.prototype.prjCoordSys -{string}
     * @description 用来指定该量算操作所使用的投影,该项默认值为空。
     */


    /**
     * @member SuperMap.MeasureParameters.prototype.geometry -{Object}
     * @description 要量算的几何对象（{Line} 或 {Polygon}），必设属性。<br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
     */
    function MeasureParameters(geometry, options) {
        _classCallCheck(this, MeasureParameters);

        this.geometry = null;
        this.unit = _REST.Unit.METER;
        this.prjCoordSys = null;
        this.distanceMode = null;
        this.CLASS_NAME = "SuperMap.MeasureParameters";

        if (!geometry) {
            return;
        }
        this.geometry = geometry;
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.MeasureParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.MeasureParameters.prototype.distanceMode -{string}
     * @description 用来指定量算的方式为按球面长度'Geodesic'或者平面长度'Planar'来计算，默认为'Geodesic'。
     * @example
     * var param = new SuperMap.MeasureParameters(getmetry,{distanceMode:'Planar'});
     */


    /**
     * @member SuperMap.MeasureParameters.prototype.unit -{Unit}
     * @description 量算单位。默认单位：米，即量算结果以米为单位。
     */


    _createClass(MeasureParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.geometry = null;
            me.unit = null;
            me.prjCoordSys = null;
        }
    }]);

    return MeasureParameters;
}();

exports.default = MeasureParameters;


_SuperMap2.default.MeasureParameters = MeasureParameters;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Point2 = __webpack_require__(11);

var _Point3 = _interopRequireDefault(_Point2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.PointWithMeasure
 * @classdesc 路由点类。路由点是指具有线性度量值(Measure)的二维地理坐标点。
 * @param options - {Object} 可选参数。如:</br>.
 *        measure - {number}度量值，即路由对象属性值 M。</br>
 *        x - {number}获取当前点对象在地理坐标系下的 X 坐标值。</br>
 *        y - {number}获取当前点对象在地理坐标系下的 Y 坐标值。</br>
 * @extends SuperMap.Geometry.Point
 */
var PointWithMeasure = function (_Point) {
    _inherits(PointWithMeasure, _Point);

    /**
     * @member SuperMap.PointWithMeasure.prototype.y -{number}
     * @description 获取当前点对象在地理坐标系下的 Y 坐标值。
     */
    function PointWithMeasure(options) {
        _classCallCheck(this, PointWithMeasure);

        var _this = _possibleConstructorReturn(this, (PointWithMeasure.__proto__ || Object.getPrototypeOf(PointWithMeasure)).call(this, options));

        _this.x = null;
        _this.y = null;
        _this.measure = null;
        _this.CLASS_NAME = "SuperMap.PointWithMeasure";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.PointWithMeasure.prototype.equals
     * @description 判断两个路由点对象是否相等。如果两个路由点对象具有相同的坐标以及度量值，则认为是相等的。
     * @param geom - {SuperMap.PointWithMeasure} 需要判断的路由点对象。
     * @return {Boolean} 两个路由点对象是否相等（true为相等，false为不等）。
     */


    /**
     * @member SuperMap.PointWithMeasure.prototype.measure -{number}
     * @description 度量值，即路由对象属性值 M。
     */


    /**
     * @member SuperMap.PointWithMeasure.prototype.x -{number}
     * @description 获取当前点对象在地理坐标系下的 X 坐标值。
     */


    _createClass(PointWithMeasure, [{
        key: 'equals',
        value: function equals(geom) {
            var equals = false;
            if (geom != null) {
                var isValueEquals = this.x === geom.x && this.y === geom.y && this.measure === geom.measure;
                var isNaNValue = isNaN(this.x) && isNaN(this.y) && isNaN(this.measure);
                var isNaNGeometry = isNaN(geom.x) && isNaN(geom.y) && isNaN(geom.measure);
                equals = isValueEquals || isNaNValue && isNaNGeometry;
            }
            return equals;
        }

        /**
         * @function SuperMap.PointWithMeasure.prototype.toJson
         * @description 转换为json对象。
         toJson() {
            var result = "{";
            if (this.measure != null && this.measure != undefined) {
                result += "\"measure\":" + this.measure + ",";
            }
            result += "\"x\":" + this.x + ",";
            result += "\"y\":" + this.y;
            result += "}";
            return result;
        }
           /**
         * @function SuperMap.PointWithMeasure.prototype.destroy
         * @description 释放资源，将引用资源的属性置空。
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.measure = null;
            me.x = null;
            me.y = null;
        }

        /**
         * @function SuperMap.PointWithMeasure.fromJson
         * @description 将 JSON 对象转换为  SuperMap.PointWithMeasure 对象。
         * @param jsonObject - {Object} JSON 对象表示的路由点。
         * @return {SuperMap.PointWithMeasure} 转化后的 PointWithMeasure 对象。
         */

    }], [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }
            return new _SuperMap2.default.PointWithMeasure({
                x: jsonObject.x,
                y: jsonObject.y,
                measure: jsonObject.measure
            });
        }
    }]);

    return PointWithMeasure;
}(_Point3.default);

exports.default = PointWithMeasure;


_SuperMap2.default.PointWithMeasure = PointWithMeasure;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _QueryParameters2 = __webpack_require__(15);

var _QueryParameters3 = _interopRequireDefault(_QueryParameters2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByBoundsParameters
 * @classdesc Bounds 查询参数类。该类用于设置 Bounds 查询的相关参数。
 * @extends SuperMap.QueryParameters
 * @param options - {Object} 可选参数。如：<br>
 *         customParams - {string} 自定义参数，供扩展使用。<br>
 *         prjCoordSys -{Object} 自定义参数，供isueprmap提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br>
 *         expectCount - {number}期望返回结果记录个数。<br>
 *         networkType - {SuperMap.GeometryType} 网络数据集对应的查询类型。<br>
 *         queryOption - {SuperMap.QueryOption} 查询结果类型枚举类。<br>
 *         queryParams -  {Array<SuperMap.FilterParameter>} 查询过滤条件参数数组。<br>
 *         startRecord - {number}查询起始记录号。<br>
 *         holdTime - {number}资源在服务端保存的时间。<br>
 *         returnCustomResult -{boolean} 仅供三维使用。<br>
 *         returnContent - {boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>
 *         bounds - {SuperMap.Bounds} 指定的查询范围。<br>
 *                  Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
 */
var QueryByBoundsParameters = function (_QueryParameters) {
    _inherits(QueryByBoundsParameters, _QueryParameters);

    /**
     * @member SuperMap.QueryByBoundsParameters.prototype.returnContent -{boolean}
     * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>
     *               如果为 true，则直接返回新创建资源，即查询结果的表述。<br>
     *               为 false，则返回的是查询结果资源的 URI。默认为 true。
     */
    function QueryByBoundsParameters(options) {
        _classCallCheck(this, QueryByBoundsParameters);

        var _this = _possibleConstructorReturn(this, (QueryByBoundsParameters.__proto__ || Object.getPrototypeOf(QueryByBoundsParameters)).call(this, options));

        _this.returnContent = true;
        _this.bounds = null;
        _this.CLASS_NAME = "SuperMap.QueryByBoundsParameters";

        if (!options) {
            return _possibleConstructorReturn(_this);
        }
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @function SuperMap.QueryByBoundsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.QueryByBoundsParameters.prototype.bounds
     * @description 指定的查询范围。<br>
     * Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
     */


    _createClass(QueryByBoundsParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryByBoundsParameters.prototype.__proto__ || Object.getPrototypeOf(QueryByBoundsParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
            if (me.bounds) {
                me.bounds = null;
            }
        }
    }]);

    return QueryByBoundsParameters;
}(_QueryParameters3.default);

exports.default = QueryByBoundsParameters;


_SuperMap2.default.QueryByBoundsParameters = QueryByBoundsParameters;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _QueryParameters2 = __webpack_require__(15);

var _QueryParameters3 = _interopRequireDefault(_QueryParameters2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** * @class SuperMap.QueryByDistanceParameters * @classdesc Distance 查询参数类。 *               该类用于设置 Distance 查询的相关参数。 * @extends SuperMap.QueryParameters * @param options - {Object} 可选参数。如：<br> *         customParams - {string} 自定义参数，供扩展使用。<br> *         prjCoordSys -{Object} 自定义参数，供isueprmap提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br> *         expectCount - {number}期望返回结果记录个数。<br> *         networkType - {SuperMap.GeometryType} 网络数据集对应的查询类型。<br> *         queryOption - {SuperMap.QueryOption} 查询结果类型枚举类。<br> *         queryParams -  {Array<SuperMap.FilterParameter>} 查询过滤条件参数数组。<br> *         startRecord - {number}查询起始记录号。<br> *         holdTime - {number}资源在服务端保存的时间。<br> *         returnCustomResult -{boolean} 仅供三维使用。<br> *         distance - {number}查询距离。<br> *         geometry - {Object} 用于查询的几何对象。<br> *                   点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br> *                   线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br> *                   面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。<br> *         isNearest - {boolean} 是否为最近距离查询。<br> *         returnContent - {boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。 */
var QueryByDistanceParameters = function (_QueryParameters) {
  _inherits(QueryByDistanceParameters, _QueryParameters);

  /**     * @member SuperMap.QueryByDistanceParameters.prototype.isNearest -{boolean}     * @description 是否为最近距离查询。<br>     *               建议该属性与 expectCount （继承自 SuperMap.QueryParameters）属性联合使用。<br>     *               当该属性为 true 时，即表示查找最近地物，如果查询结果数大于期望返回的结果记录数（expectCount），<br>     *               则查找结果为查询总记录中距离中心最近的expectCount个地物。<br>     *               当该属性为不为 true 时，如果查询结果数大于期望返回的结果记录数（expectCount），<br>     *               则查找结果为从查询总记录中随机抽取的expectCount个地物。<br>     *               目前查询结果不支持按远近距离排序。     */


  /**     * @member SuperMap.QueryByDistanceParameters.prototype.distance -{number}     * @description 查询距离，默认为0，单位与所查询图层对应的数据集单位相同。     *               当查找最近地物时，该属性无效。     */
  function QueryByDistanceParameters(options) {
    _classCallCheck(this, QueryByDistanceParameters);

    var _this = _possibleConstructorReturn(this, (QueryByDistanceParameters.__proto__ || Object.getPrototypeOf(QueryByDistanceParameters)).call(this, options));

    _this.distance = 0;
    _this.geometry = null;
    _this.isNearest = null;
    _this.returnContent = true;
    _this.CLASS_NAME = "SuperMap.QueryByDistanceParameters";

    if (!options) {
      return _possibleConstructorReturn(_this);
    }
    _SuperMap2.default.Util.extend(_this, options);
    return _this;
  }

  /**     * @function SuperMap.QueryByDistanceParameters.prototype.destroy     * @description 释放资源，将引用资源的属性置空。     */


  /**     * @member SuperMap.QueryByDistanceParameters.prototype.returnContent -{boolean}     * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>     *               如果为 true，则直接返回新创建资源，即查询结果的表述。<br>     *               为 false，则返回的是查询结果资源的 URI。默认为 true。     */


  /**     * @member SuperMap.QueryByDistanceParameters.prototype.geometry     * @description 用于查询的地理对象，必设属性。<br>     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON     */


  _createClass(QueryByDistanceParameters, [{
    key: 'destroy',
    value: function destroy() {
      _get(QueryByDistanceParameters.prototype.__proto__ || Object.getPrototypeOf(QueryByDistanceParameters.prototype), 'destroy', this).call(this);
      var me = this;
      me.returnContent = null;
      me.distance = null;
      me.isNearest = null;
      if (me.geometry) {
        me.geometry.destroy();
        me.geometry = null;
      }
    }
  }]);

  return QueryByDistanceParameters;
}(_QueryParameters3.default);

exports.default = QueryByDistanceParameters;


_SuperMap2.default.QueryByDistanceParameters = QueryByDistanceParameters;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _QueryParameters2 = __webpack_require__(15);

var _QueryParameters3 = _interopRequireDefault(_QueryParameters2);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByGeometryParameters
 * @classdesc Geometry 查询参数类。
 *               该类用于设置 Geometry查询的相关参数。
 * @extends SuperMap.QueryParameters
 * @param options - {Object} 可选参数。如：<br>
 *         customParams - {string} 自定义参数，供扩展使用。<br>
 *         prjCoordSys -{Object} 自定义参数，供isueprmap提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br>
 *         expectCount - {number}期望返回结果记录个数。<br>
 *         networkType - {SuperMap.GeometryType} 网络数据集对应的查询类型。<br>
 *         queryOption - {SuperMap.QueryOption} 查询结果类型枚举类。<br>
 *         queryParams - {Array<SuperMap.FilterParameter>} 查询过滤条件参数数组。<br>
 *         startRecord - {number}查询起始记录号。<br>
 *         holdTime - {number}资源在服务端保存的时间。<br>
 *         returnCustomResult -{boolean} 仅供三维使用。<br>
 *         returnContent - {boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。
 *         geometry - {Object} 用于查询的几何对象。<br>
 *                   点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
 *                   线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
 *                   面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。<br>
 *         spatialQueryMode - {SuperMap.SpatialQueryMode} 空间查询模式。
 */
var QueryByGeometryParameters = function (_QueryParameters) {
    _inherits(QueryByGeometryParameters, _QueryParameters);

    /**
     * @member SuperMap.QueryByGeometryParameters.prototype.geometry
     * @description 用于查询的几何对象。<br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
     */
    function QueryByGeometryParameters(options) {
        _classCallCheck(this, QueryByGeometryParameters);

        var _this = _possibleConstructorReturn(this, (QueryByGeometryParameters.__proto__ || Object.getPrototypeOf(QueryByGeometryParameters)).call(this, options));

        _this.returnContent = true;
        _this.geometry = null;
        _this.spatialQueryMode = _REST.SpatialQueryMode.INTERSECT;
        _this.CLASS_NAME = "SuperMap.QueryByGeometryParameters";

        if (!options) {
            return _possibleConstructorReturn(_this);
        }
        _SuperMap2.default.Util.extend(_this, options);
        return _this;
    }

    /**
     * @function SuperMap.QueryByGeometryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.QueryByGeometryParameters.prototype.spatialQueryMode -{SuperMap.SpatialQueryMode}
     * @description 空间查询模式。
     */


    /**
     * @member SuperMap.QueryByGeometryParameters.prototype.returnContent -{boolean}
     * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>
     *               如果为 true，则直接返回新创建资源，即查询结果的表述。<br>
     *               为 false，则返回的是查询结果资源的 URI。默认为 true。
     */


    _createClass(QueryByGeometryParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryByGeometryParameters.prototype.__proto__ || Object.getPrototypeOf(QueryByGeometryParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
            me.geometry = null;
            me.spatialQueryMode = null;
        }
    }]);

    return QueryByGeometryParameters;
}(_QueryParameters3.default);

exports.default = QueryByGeometryParameters;


_SuperMap2.default.QueryByGeometryParameters = QueryByGeometryParameters;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _QueryParameters2 = __webpack_require__(15);

var _QueryParameters3 = _interopRequireDefault(_QueryParameters2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** * @class SuperMap.QueryBySQLParameters * @classdesc SQL 查询参数类。 *               该类用于设置 SQL 查询的相关参数。 * @extends SuperMap.QueryParameters * @param options - {Object} 可选参数。如：<br> *         customParams - {string} 自定义参数，供扩展使用。<br> *         prjCoordSys -{Object} 自定义参数，供isueprmap提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br> *         expectCount - {number}期望返回结果记录个数。<br> *         networkType - {SuperMap.GeometryType} 网络数据集对应的查询类型。<br> *         queryOption - {SuperMap.QueryOption} 查询结果类型枚举类。<br> *         queryParams -  {Array<SuperMap.FilterParameter>} 查询过滤条件参数数组。<br> *         startRecord - {number}查询起始记录号。<br> *         holdTime - {number}资源在服务端保存的时间。<br> *         returnCustomResult -{boolean} 仅供三维使用。 *         returnContent - {boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。 */
var QueryBySQLParameters = function (_QueryParameters) {
  _inherits(QueryBySQLParameters, _QueryParameters);

  function QueryBySQLParameters(options) {
    _classCallCheck(this, QueryBySQLParameters);

    var _this = _possibleConstructorReturn(this, (QueryBySQLParameters.__proto__ || Object.getPrototypeOf(QueryBySQLParameters)).call(this, options));

    _this.returnContent = true;
    _this.CLASS_NAME = "SuperMap.QueryBySQLParameters";

    if (!options) {
      return _possibleConstructorReturn(_this);
    }
    _SuperMap2.default.Util.extend(_this, options);
    return _this;
  }

  /**     * @function SuperMap.QueryBySQLParameters.prototype.destroy     * @description 释放资源，将引用资源的属性置空。     */


  /**     * @member SuperMap.QueryBySQLParameters.prototype.returnContent -{boolean}     * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>     *               如果为 true，则直接返回新创建资源，即查询结果的表述。<br>     *               为 false，则返回的是查询结果资源的 URI。默认为 true。     */


  _createClass(QueryBySQLParameters, [{
    key: 'destroy',
    value: function destroy() {
      _get(QueryBySQLParameters.prototype.__proto__ || Object.getPrototypeOf(QueryBySQLParameters.prototype), 'destroy', this).call(this);
      var me = this;
      me.returnContent = null;
    }
  }]);

  return QueryBySQLParameters;
}(_QueryParameters3.default);

exports.default = QueryBySQLParameters;


_SuperMap2.default.QueryBySQLParameters = QueryBySQLParameters;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Route = __webpack_require__(50);

var _Route2 = _interopRequireDefault(_Route);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.RouteCalculateMeasureParameters
 * @classdesc 基于路由对象计算指定点M值操作的参数类。通过该类提供参数信息。
 * @param options - {Object} 可选参数。如:</br>
 *        sourceRoute - {Object} 【必选参数】路由对象。该对象可以是用户自己生成或在数据源中查询得到的符合标准的路由对象。</br>
 *        point - {Object} 【必选参数】二维地理坐标点对象，包含x,y坐标值属性的对象。</br>
 *                点坐标对象可以是:SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *        tolerance - {Double} 【可选参数】容限值。</br>
 *        isIgnoreGap - {Double}  【可选参数】是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。</br>
 */
var RouteCalculateMeasureParameters = function () {

    /**
     * @member SuperMap.RouteCalculateMeasureParameters.prototype.tolerance -{Double}
     * @description 【可选参数】容限值。
     */


    /**
     * @member SuperMap.RouteCalculateMeasureParameters.prototype.sourceRoute
     * @description 【必选参数】路由对象。该对象可以是用户自己生成或在数据源中查询得到的符合标准的路由对象；
     * 路由对象可以是：SuperMap.Route|L.Polyline|ol.geom.LineString
     */
    function RouteCalculateMeasureParameters(options) {
        _classCallCheck(this, RouteCalculateMeasureParameters);

        this.sourceRoute = null;
        this.point = null;
        this.tolerance = null;
        this.isIgnoreGap = false;
        this.CLASS_NAME = "SuperMap.RouteCalculateMeasureParameters";

        if (!options) {
            return this;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.RouteCalculateMeasureParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.RouteCalculateMeasureParameters.prototype.isIgnoreGap -{boolean}
     * @description【可选参数】是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。
     */


    /**
     * @member SuperMap.RouteCalculateMeasureParameters.prototype.point
     * @description 【必选参数】二维地理坐标点对象，包含x,y坐标值属性的对象。</br>
     * 点坐标对象可以是:SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     */


    _createClass(RouteCalculateMeasureParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.sourceRoute = null;
            me.point = null;
            if (me.tolerance) {
                me.tolerance = null;
            }
            if (me.isIgnoreGap) {
                me.isIgnoreGap = false;
            }
        }
    }]);

    return RouteCalculateMeasureParameters;
}();

exports.default = RouteCalculateMeasureParameters;


_SuperMap2.default.RouteCalculateMeasureParameters = RouteCalculateMeasureParameters;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Route = __webpack_require__(50);

var _Route2 = _interopRequireDefault(_Route);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.RouteLocatorParameters
 * @classdesc
 * 路由对象定位空间对象的参数类。
 * 参数有两种方式，分别为Geometry和Dataset两种，前者需要指定sourceRoute对象作为参数，后者需要dataset，routeIDField，routeID三个参数
 * 如果用户两种参数均设置，优先选择Dataset方式
 * @param options - {Object} 可选参数。如:</br>
 *        sourceRoute -  {SuperMap.Route} 【必选参数】路由对象。路由对象可以是：SuperMap.Route|L.Polyline|ol.geom.LineString。</br>
 *        type -  {string} 【必选参数】类型：点 or 线。</br>
 *        measure - {Double} 【必选参数】定位点的M值。只当路由对象定位点时有意义。</br>
 *        offset - {Double} 定位点偏移量。只当路由对象定位点时有意义，默认为0。</br>
 *        isIgnoreGap - {boolean} 是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。</br>
 *        startMeasure - {Double} 定位线的起始M值。只当路由对象定位线时有意义。</br>
 *        endMeasure -  {Double} 定位线的终止M值。只当路由对象定位线时有意义。</br>
 */
var RouteLocatorParameters = function () {

    /**
     *  @member SuperMap.RouteLocatorParameters.prototype.startMeasure -{Double}
     *  @description 定位线的起始M值。只当路由对象定位线时有意义。
     */


    /**
     * @member SuperMap.RouteLocatorParameters.prototype.offset -{Double}
     * @description 定位点偏移量。只当路由对象定位点时有意义，默认为0。
     */


    /**
     * @member SuperMap.RouteLocatorParameters.prototype.type -{string}
     * @description 【必选参数】类型：点 or 线。
     * 可选值为:
     * LINE :根据起始 M 值及终止 M 值定位线对象。
     * POINT : 根据 M 值定位点对象。
     */


    /**
     * @member SuperMap.RouteLocatorParameters.prototype.routeIDField -{string}
     * @description  路由对象所在的字段名称。
     *
     */

    /**
     * @member SuperMap.RouteLocatorParameters.prototype.sourceRoute
     * @description 路由对象。路由对象可以是：SuperMap.Route|L.Polyline|ol.geom.LineString
     */
    function RouteLocatorParameters(options) {
        _classCallCheck(this, RouteLocatorParameters);

        this.sourceRoute = null;
        this.dataset = null;
        this.routeIDField = null;
        this.routeID = null;
        this.type = null;
        this.measure = null;
        this.offset = 0;
        this.isIgnoreGap = false;
        this.startMeasure = null;
        this.endMeasure = null;
        this.CLASS_NAME = "SuperMap.RouteLocatorParameters";

        if (!options) {
            return this;
        }
        var routeFromClient = options.sourceRoute;
        var routeHandle = {};
        if (routeFromClient && routeFromClient instanceof _SuperMap2.default.Geometry && routeFromClient.components) {
            routeHandle.type = routeFromClient.type;
            routeHandle.parts = routeFromClient.parts;
            var parts = [];
            for (var i = 0, len = routeFromClient.components.length; i < len; i++) {
                parts = parts.concat(routeFromClient.components[i].components);
            }
            routeHandle.points = parts;
            options.sourceRoute = routeHandle;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.RouteLocatorParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     *  @member SuperMap.RouteLocatorParameters.prototype.endMeasure -{Double}
     *  @description 定位线的终止M值。只当路由对象定位线时有意义。
     */


    /**
     * @member SuperMap.RouteLocatorParameters.prototype.isIgnoreGap -{boolean}
     * @description 是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。
     */


    /**
     * @member SuperMap.RouteLocatorParameters.prototype.measure -{Double}
     * @description 必选参数,定位点的M值。只当路由对象定位点时有意义。
     */


    /**
     * @member SuperMap.RouteLocatorParameters.prototype.routeID -{Interger}
     * @description 路由对象标识 。
     *
     */


    /**
     * @member SuperMap.RouteLocatorParameters.prototype.dataset -{string}
     * @description 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
     */


    _createClass(RouteLocatorParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.sourceRoute = null;
            me.type = null;
            me.measure = null;
            me.offset = 0;
            me.isIgnoreGap = false;
            me.startMeasure = null;
            me.endMeasure = null;
            me.dataset = null;
            me.routeID = null;
            me.routeIDField = null;
        }
    }]);

    return RouteLocatorParameters;
}();

exports.default = RouteLocatorParameters;


_SuperMap2.default.RouteLocatorParameters = RouteLocatorParameters;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ThemeLabel = __webpack_require__(52);

var _ThemeLabel2 = _interopRequireDefault(_ThemeLabel);

var _ThemeUnique = __webpack_require__(73);

var _ThemeUnique2 = _interopRequireDefault(_ThemeUnique);

var _ThemeGraph = __webpack_require__(71);

var _ThemeGraph2 = _interopRequireDefault(_ThemeGraph);

var _ThemeDotDensity = __webpack_require__(69);

var _ThemeDotDensity2 = _interopRequireDefault(_ThemeDotDensity);

var _ThemeGraduatedSymbol = __webpack_require__(70);

var _ThemeGraduatedSymbol2 = _interopRequireDefault(_ThemeGraduatedSymbol);

var _ThemeRange = __webpack_require__(72);

var _ThemeRange2 = _interopRequireDefault(_ThemeRange);

var _UGCSubLayer2 = __webpack_require__(40);

var _UGCSubLayer3 = _interopRequireDefault(_UGCSubLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ServerTheme
 * @classdesc UGC 专题图图层类。
 * @extends SuperMap.UGCSubLayer
 * @param theme - {SuperMap.Theme} 专题图对象。
 * @param themeElementPosition - {SuperMap.LonLat} 专题图元素位置。
 */
var ServerTheme = function (_UGCSubLayer) {
    _inherits(ServerTheme, _UGCSubLayer);

    /*
     * @class SuperMap.ServerTheme
     * @description UGC 专题图图层类类构造函数。
     * @param theme - {SuperMap.Theme} 专题图对象。
     * @param themeElementPosition - {SuperMap.LonLat} 专题图元素位置。
     */


    /**
     * @member SuperMap.ServerTheme.prototype.theme -{SuperMap.Theme}
     * @description 专题图对象。
     */
    function ServerTheme(options) {
        _classCallCheck(this, ServerTheme);

        options = options || {};

        var _this = _possibleConstructorReturn(this, (ServerTheme.__proto__ || Object.getPrototypeOf(ServerTheme)).call(this, options));

        _this.theme = null;
        _this.themeElementPosition = null;
        _this.CLASS_NAME = "SuperMap.ServerTheme";
        return _this;
    }

    /**
     * @inheritdoc
     */


    /**
     * @member SuperMap.ServerTheme.prototype.themeElementPosition -{SuperMap.LonLat}
     * @description 专题图元素位置。
     */


    _createClass(ServerTheme, [{
        key: 'destroy',
        value: function destroy() {
            _get(ServerTheme.prototype.__proto__ || Object.getPrototypeOf(ServerTheme.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.ServerTheme.prototype.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }, {
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(ServerTheme.prototype.__proto__ || Object.getPrototypeOf(ServerTheme.prototype), 'fromJson', this).call(this, jsonObject);
            var themeObj = this.theme;
            var themeT = themeObj && themeObj.type;
            switch (themeT) {
                case 'LABEL':
                    this.theme = _ThemeLabel2.default.fromObj(themeObj);
                    break;
                case 'UNIQUE':
                    this.theme = _ThemeUnique2.default.fromObj(themeObj);
                    break;
                case 'GRAPH':
                    this.theme = _ThemeGraph2.default.fromObj(themeObj);
                    break;
                case 'DOTDENSITY':
                    this.theme = _ThemeDotDensity2.default.fromObj(themeObj);
                    break;
                case 'GRADUATEDSYMBOL':
                    this.theme = _ThemeGraduatedSymbol2.default.fromObj(themeObj);
                    break;
                case 'RANGE':
                    this.theme = _ThemeRange2.default.fromObj(themeObj);
                    break;
                default:
                    break;
            }
            if (this.themeElementPosition) {
                //待测试
                this.themeElementPosition = new _SuperMap2.default.LonLat(this.themeElementPosition.x, this.themeElementPosition.y);
            }
        }

        /**
         * @function  SuperMap.ServerTheme.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            //普通属性直接赋值
            var jsonObject = _get(ServerTheme.prototype.__proto__ || Object.getPrototypeOf(ServerTheme.prototype), 'toServerJSONObject', this).call(this);

            if (jsonObject.themeElementPosition) {
                if (jsonObject.themeElementPosition.toServerJSONObject) {
                    jsonObject.themeElementPosition = jsonObject.themeElementPosition.toServerJSONObject();
                }
            }
            if (jsonObject.theme) {
                if (jsonObject.theme.toServerJSONObject) {
                    jsonObject.theme = jsonObject.theme.toServerJSONObject();
                }
            }
            return jsonObject;
        }
    }]);

    return ServerTheme;
}(_UGCSubLayer3.default);

exports.default = ServerTheme;


_SuperMap2.default.ServerTheme = ServerTheme;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SetLayerInfoParameters
 * @classdesc 设置图层信息参数类.
 * @param options -{Object} 可选参数。如：<br>
 *         tempLayerID -{string} 临时图层的资源ID。<br>
 *         layerName -{string} 图层资源名。<br>
 *         resourceID -{string} 资源ID。<br>
 *         layerInfo -{string} 要更新的图层信息。
 */
var SetLayerInfoParameters = function () {

    /**
     * @member SuperMap.SetLayerInfoParameters.prototype.resourceID -{string}
     * @description 资源ID，
     */


    /**
     * @member SuperMap.SetLayerInfoParameters.prototype.tempLayerID -{string}
     * @description 临时图层的资源ID
     */
    function SetLayerInfoParameters(options) {
        _classCallCheck(this, SetLayerInfoParameters);

        this.tempLayerID = null;
        this.layerName = null;
        this.resourceID = null;
        this.layerInfo = null;
        this.CLASS_NAME = "SuperMap.SetLayerInfoParameters";

        options = options || {};
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.SetLayerInfoParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.SetLayerInfoParameters.prototype.layerInfo -{string}
     * @description 要更新的图层信息
     */


    /**
     * @member SuperMap.SetLayerInfoParameters.prototype.layerName -{string}
     * @description 图层资源名
     */


    _createClass(SetLayerInfoParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.tempLayerID = null;
            me.layerName = null;
            me.resourceID = null;
            me.layerInfo = null;
        }
    }]);

    return SetLayerInfoParameters;
}();

exports.default = SetLayerInfoParameters;


_SuperMap2.default.SetLayerInfoParameters = SetLayerInfoParameters;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _LayerStatus = __webpack_require__(220);

var _LayerStatus2 = _interopRequireDefault(_LayerStatus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SetLayerStatusParameters
 * @classdesc 子图层显示控制参数类,该类存储了各子图层是否可见的状态。<br>
 *               注意在 SuperMap iClient 系列产品中所说的图层与 SuperMap Deskpro 的地图对应，子图层与 SuperMap Deskpro 的图层对应。
 * @param options - {Object} 可选参数。如：<br>
 *        layerStatusList - {Array<SuperMap.LayerStatus>} 获取或设置图层可见状态（SuperMap.LayerStatus）集合，必设属性。
 *                         集合中的每个 SuperMap.LayerStatus 对象代表一个子图层的可视状态。<br>
 *        holdTime - {string} 获取或设置资源在服务端保存的时间。<br>
 *        resourceID - {string} 获取或设置资源服务 ID。
 */
var SetLayerStatusParameters = function () {

    /**
     * @member SuperMap.SetLayerStatusParameters.prototype.holdTime -{number}
     * @description 获取或设置资源在服务端保存的时间。 默认为 15 分钟。
     */
    function SetLayerStatusParameters(options) {
        _classCallCheck(this, SetLayerStatusParameters);

        this.layerStatusList = null;
        this.holdTime = 15;
        this.resourceID = null;
        this.CLASS_NAME = "SuperMap.SetLayerStatusParameters";

        var me = this;
        me.layerStatusList = [];
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.SetLayerStatusParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.SetLayerStatusParameters.prototype.resourceID -{string}
     * @description 获取或设置资源服务 ID 。非必设参数，如果设置该参数则会在指定的 TempLayer 进行图层的显示控制；<br>
     *                如果不设置该参数，则会首先创建一个 TempLayer ，然后在新创建的 TempLayer 进行图层的显示控制。
     */


    /**
     * @member SuperMap.SetLayerStatusParameters.prototype.layerStatusList -{Array<SuperMap.LayerStatus>}
     * @description 获取或设置图层可见状态（SuperMap.LayerStatus）集合，必设属性。<br>
     *                集合中的每个 SuperMap.LayerStatus 对象代表一个子图层的可视状态。
     */


    _createClass(SetLayerStatusParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.layerStatusList = null;
            me.holdTime = null;
            me.resourceID = null;
        }

        /**
         * @function SuperMap.SetLayerStatusParameters.prototype.toJSON
         * @description 生成json。
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            var json = '{';
            json += '"layers":[';
            var v = [];
            for (var i = 0, len = this.layerStatusList.length; i < len; i++) {
                v.push(this.layerStatusList[i].toJSON());
            }

            json += v;
            json += ']';
            json += '}';

            return json;
        }
    }]);

    return SetLayerStatusParameters;
}();

exports.default = SetLayerStatusParameters;


_SuperMap2.default.SetLayerStatusParameters = SetLayerStatusParameters;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SetLayersInfoParameters
 * @classdesc 设置图层信息参数类
 * @param options -{Object} 可选参数。如：<br>
 *        isTempLayers -{boolean} 是否是临时图层。<br>
 *        resourceID -{string} 资源ID。<br>
 *        layerInfo -{string} 要更新的图层信息。
 */
var SetLayersInfoParameters = function () {
    /**
     * @member SuperMap.SetLayersInfoParameters.prototype.resourceID -{string}
     * @description 资源ID，
     */
    function SetLayersInfoParameters(options) {
        _classCallCheck(this, SetLayersInfoParameters);

        this.isTempLayers = null;
        this.resourceID = null;
        this.layerInfo = null;
        this.CLASS_NAME = "SuperMap.SetLayersInfoParameters";

        options = options || {};
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.SetLayersInfoParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.SetLayersInfoParameters.prototype.layerInfo -{string}
     * @description 要更新的图层信息。
     */


    /**
     * @member SuperMap.SetLayersInfoParameters.prototype.isTempLayers -{boolean}
     * @description 是否是临时图层。
     */


    _createClass(SetLayersInfoParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.isTempLayers = null;
            me.resourceID = null;
            me.layerInfo = null;
        }
    }]);

    return SetLayersInfoParameters;
}();

exports.default = SetLayersInfoParameters;


_SuperMap2.default.SetLayersInfoParameters = SetLayersInfoParameters;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SingleObjectQueryJobsParameter
 * @classdesc 单对象空间查询分析任务参数类
 * @param options - {Object} 必填参数。<br>
 *         datasetName -{string} 数据集名。 <br>
 *         datasetQuery -{string} 查询对象所在的数据集名称。 <br>
 *         mode -{SuperMap.SpatialQueryMode} 空间查询模式 。 <br>
 */
var SingleObjectQueryJobsParameter = function () {

    /**
     * @member SuperMap.SingleObjectQueryJobsParameter.prototype.datasetQuery -{string}
     * @description 查询对象所在的数据集名称。
     */
    function SingleObjectQueryJobsParameter(options) {
        _classCallCheck(this, SingleObjectQueryJobsParameter);

        this.datasetName = "";
        this.datasetQuery = "";
        this.mode = _REST.SpatialQueryMode.CONTAIN;

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.SingleObjectQueryJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.SingleObjectQueryJobsParameter.prototype.mode -{SuperMap.SpatialQueryMode}
     * @description 空间查询模式 。
     */


    /**
     * @member SuperMap.SingleObjectQueryJobsParameter.prototype.datasetName -{string}
     * @description 数据集名。
     */


    _createClass(SingleObjectQueryJobsParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.datasetQuery = null;
            this.mode = null;
        }
        /**
         * @function SuperMap.SingleObjectQueryJobsParameter.toObject
         * @param singleObjectQueryJobsParameter -{Object} 单对象空间查询分析任务参数
         * @param tempObj - {Object} 目标对象
         * @description 生成单对象空间查询分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(singleObjectQueryJobsParameter, tempObj) {
            for (var name in singleObjectQueryJobsParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = singleObjectQueryJobsParameter[name];
                    continue;
                }
                tempObj['analyst'] = tempObj['analyst'] || {};
                tempObj['analyst'][name] = singleObjectQueryJobsParameter[name];
            }
        }
    }]);

    return SingleObjectQueryJobsParameter;
}();

exports.default = SingleObjectQueryJobsParameter;


_SuperMap2.default.SingleObjectQueryJobsParameter = SingleObjectQueryJobsParameter;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.StopQueryParameters
 * @classdesc 站点查询参数类。
 * @param options - {Object} 可选参数。
 */
var StopQueryParameters = function () {
    /**
     *  @member SuperMap.StopQueryParameters.prototype.keyWord -{string}
     *  @description 站点名称关键字。
     */
    function StopQueryParameters(options) {
        _classCallCheck(this, StopQueryParameters);

        this.keyWord = null;
        this.returnPosition = false;
        this.CLASS_NAME = "SuperMap.StopQueryParameters";

        options = options || {};
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.StopQueryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.StopQueryParameters.prototype.returnPosition -{boolean}
     * @description 是否返回站点坐标信息。
     */


    _createClass(StopQueryParameters, [{
        key: "destroy",
        value: function destroy() {
            _SuperMap2.default.Util.reset(this);
        }
    }]);

    return StopQueryParameters;
}();

exports.default = StopQueryParameters;


_SuperMap2.default.StopQueryParameters = StopQueryParameters;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SummaryMeshJobParameter
 * @classdesc 点聚合分析任务参数类
 * @param options - {Object} 可选参数。如：<br>
 *        datasetName -{string} 数据集名。<br>
 *        query -{Object} 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。<br>
 *        resolution -{number}分辨率。<br>
 *        statisticModes -{string} 分析模式。<br>
 *        meshType -{number}分析类型。<br>
 *        fields -{number}权重索引。<br>
 *        type -{string} 聚合类型。
 */
var SummaryMeshJobParameter = function () {

    /**
     * @member SuperMap.SummaryMeshJobParameter.prototype.fields -{number}
     * @description 权重字段。
     */


    /**
     * @member SuperMap.SummaryMeshJobParameter.prototype.meshType -{number}
     * @description  网格面类型(聚合类型为网格面聚合时使用的参数),取值：0或1。
     */


    /**
     * @member SuperMap.SummaryMeshJobParameter.prototype.query -{Object}
     * @description 分析范围(聚合类型为网格面聚合时使用的参数)。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。<br>
     */


    /**
     * @member SuperMap.SummaryMeshJobParameter.prototype.datasetName -{string}
     * @description 数据集名。
     */
    function SummaryMeshJobParameter(options) {
        _classCallCheck(this, SummaryMeshJobParameter);

        this.datasetName = "";
        this.regionDataset = "";
        this.query = "";
        this.resolution = 100;
        this.meshType = 0;
        this.statisticModes = "";
        this.fields = "";
        this.type = _REST.SummaryType.SUMMARYMESH;

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.SummaryMeshJobParameter.prototype.type -{SuperMap.SummaryType}
     * @description 聚合类型。
     */


    /**
     * @member SuperMap.SummaryMeshJobParameter.prototype.statisticModes -{SuperMap.StatisticAnalystMode}
     * @description 统计模式。
     */


    /**
     * @member SuperMap.SummaryMeshJobParameter.prototype.resolution -{number}
     * @description 分辨率(聚合类型为网格面聚合时使用的参数)。
     */


    /**
     * @member SuperMap.SummaryMeshJobParameter.prototype.regionDataset -{string}
     * @description 聚合面数据集(聚合类型为多边形聚合时使用的参数)。
     */


    _createClass(SummaryMeshJobParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.query = null;
            this.resolution = null;
            this.statisticModes = null;
            this.meshType = null;
            this.fields = null;
            this.regionDataset = null;
            this.type = null;
        }

        /**
         * @function SuperMap.SummaryMeshJobParameter.toObject
         * @param summaryMeshJobParameter - {Object} 点聚合分析任务参数。
         * @param tempObj - {Object} 目标对象。
         * @description 生成点聚合分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(summaryMeshJobParameter, tempObj) {
            for (var name in summaryMeshJobParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = summaryMeshJobParameter[name];
                    continue;
                }
                if (name === "type") {
                    tempObj['type'] = summaryMeshJobParameter[name];
                    continue;
                }
                if (summaryMeshJobParameter.type === 'SUMMARYMESH' && name !== 'regionDataset' || summaryMeshJobParameter.type === 'SUMMARYREGION' && !contains(['meshType', 'resolution', 'query'], name)) {
                    tempObj['analyst'] = tempObj['analyst'] || {};
                    if (name === 'query') {
                        tempObj['analyst'][name] = summaryMeshJobParameter[name].toBBOX();
                    } else {
                        tempObj['analyst'][name] = summaryMeshJobParameter[name];
                    }
                }
            }

            function contains(arr, obj) {
                var i = arr.length;
                while (i--) {
                    if (arr[i] === obj) {
                        return true;
                    }
                }
                return false;
            }
        }
    }]);

    return SummaryMeshJobParameter;
}();

exports.default = SummaryMeshJobParameter;


_SuperMap2.default.SummaryMeshJobParameter = SummaryMeshJobParameter;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SummaryRegionJobParameter
 * @classdesc 区域汇总分析任务参数类
 * @param options - {Object} 可选参数。如：<br>
 *         datasetName -{string} 数据集名。 <br>
 *         sumShape -{boolean} 是否统计长度或面积。 <br>
 *         query -{SuperMap.Bounds} 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。 <br>
 *         standardSummaryFields -{boolean} 以标准属字段统计。 <br>
 *         standardFields -{string} 以标准属字段统计的字段名称。 <br>
 *         standardStatisticModes -{string} 以标准属字段统计的统计模式。 <br>
 *         weightedSummaryFields -{boolean} 以权重字段统计。 <br>
 *         weightedFields -{string} 以权重字段统计的字段名称。 <br>
 *         weightedStatisticModes -{string} 以权重字段统计的统计模式。 <br>
 *         resolution -{number}网格大小。 <br>
 *         meshType -{number}网格面汇总类型。 <br>
 *         meshSizeUnit -{string} 网格大小单位。 <br>
 *         type -{string} 汇总类型。 <br>
 */
var SummaryRegionJobParameter = function () {

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.meshSizeUnit -{SuperMap.AnalystSizeUnit}
     * @description 网格大小单位。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.meshType -{number}
     * @description 网格面汇总类型。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.weightedFields -{string}
     * @description 以权重字段统计的字段名称。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.standardStatisticModes -{SuperMap.StatisticAnalystMode}
     * @description 以标准属字段统计的统计模式。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.standardSummaryFields -{boolean}
     * @description 以标准属字段统计。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.sumShape -{boolean}
     * @description 是否统计长度或面积。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.datasetName -{string}
     * @description 数据集名。
     */
    function SummaryRegionJobParameter(options) {
        _classCallCheck(this, SummaryRegionJobParameter);

        this.datasetName = "";
        this.regionDataset = "";
        this.sumShape = true;
        this.query = "";
        this.standardSummaryFields = false;
        this.standardFields = "";
        this.standardStatisticModes = "";
        this.weightedSummaryFields = false;
        this.weightedFields = "";
        this.weightedStatisticModes = "";
        this.meshType = 0;
        this.resolution = 100;
        this.meshSizeUnit = _REST.AnalystSizeUnit.METER;
        this.type = _REST.SummaryType.SUMMARYMESH;

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.SummaryRegionJobParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.type -{SuperMap.SummaryType}
     * @description 汇总类型。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.resolution -{number}
     * @description 网格大小。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.weightedStatisticModes -{SuperMap.StatisticAnalystMode}
     * @description 以权重字段统计的统计模式。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.weightedSummaryFields -{boolean}
     * @description 以权重字段统计。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.standardFields -{string}
     * @description 以标准属字段统计的字段名称。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.query
     * @description 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
     */


    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.regionDataset -{string}
     * @description 汇总数据源（多边形汇总时用到的参数）。
     */


    _createClass(SummaryRegionJobParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.sumShape = null;
            this.query = null;
            this.standardSummaryFields = null;
            this.standardFields = null;
            this.standardStatisticModes = null;
            this.weightedSummaryFields = null;
            this.weightedFields = null;
            this.weightedStatisticModes = null;
            this.meshType = null;
            this.resolution = null;
            this.meshSizeUnit = null;
            this.type = null;
        }

        /**
         * @function SuperMap.SummaryRegionJobParameter.toObject
         * @param summaryRegionJobParameter -{Object} 矢量裁剪分析任务参数。
         * @param tempObj - {Object} 目标对象。
         * @description 生成区域汇总分析服务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(summaryRegionJobParameter, tempObj) {
            for (var name in summaryRegionJobParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = summaryRegionJobParameter[name];
                    continue;
                }
                if (name === "type") {
                    tempObj['type'] = summaryRegionJobParameter[name];
                    continue;
                }
                if (summaryRegionJobParameter.type === "SUMMARYREGION" || summaryRegionJobParameter.type === "SUMMARYMESH" && name !== "regionDataset") {
                    tempObj['analyst'] = tempObj['analyst'] || {};
                    if (name === 'query') {
                        tempObj['analyst'][name] = summaryRegionJobParameter[name].toBBOX();
                    } else {
                        tempObj['analyst'][name] = summaryRegionJobParameter[name];
                    }
                }
            }
        }
    }]);

    return SummaryRegionJobParameter;
}();

exports.default = SummaryRegionJobParameter;


_SuperMap2.default.SummaryRegionJobParameter = SummaryRegionJobParameter;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SupplyCenter
 * @classdesc 资源供给中心类。在资源分配和选址分区分析两个功能中使用。
 * @param options - {Object} 可选参数。如：<br>
 *        maxWeight - {number}资源供给中心的最大耗费值，必设参数。<br>
 *        nodeID - {Integer} 资源供给中心点的结点 ID 号，必设参数。资源供给中心必须是结点。<br>
 *        resourceValue - {number}资源供给中心能提供的最大服务量或商品数量，必设参数。<br>
 *        type - {SuperMap.SupplyCenterType} 资源供给中心点的类型常量。
 */
var SupplyCenter = function () {

    /**
     * @member SuperMap.SupplyCenter.prototype.resourceValue -{number}
     * @description 资源供给中心能提供的最大服务量或商品数量，必设参数。例如资源中心为学校，资源中心资源量表示该学校能够接纳多少学生。
     */


    /**
     * @member SuperMap.SupplyCenter.prototype.maxWeight -{number}
     * @description 资源供给中心的最大耗费值，必设参数。中心点最大阻值设置越小，表示中心点所提供的资源可影响范围越大。
     *              最大阻力值是用来限制需求点到中心点的花费。
     *              如果需求点（弧段或结点）到此中心的花费大于最大阻力值，则该需求点不属于该资源供给中心提供资源的范围。
     */
    function SupplyCenter(options) {
        _classCallCheck(this, SupplyCenter);

        this.maxWeight = null;
        this.nodeID = null;
        this.resourceValue = null;
        this.type = null;
        this.CLASS_NAME = "SuperMap.SupplyCenter";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.SupplyCenter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.SupplyCenter.prototype.type -{SuperMap.SupplyCenterType}
     * @description 资源供给中心点的类型常量。资源供给中心点的类型包括非中心，固定中心和可选中心。
     *              固定中心用于资源分配分析；固定中心和可选中心用于选址分析；非中心在两种网络分析时都不予考虑。
     */


    /**
     * @member SuperMap.SupplyCenter.prototype.nodeID -{Integer}
     * @description 资源供给中心点的结点 ID 号，必设参数。资源供给中心必须是结点。
     */


    _createClass(SupplyCenter, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.maxWeight = null;
            me.nodeID = null;
            me.resourceValue = null;
            me.type = null;
        }

        /**
         * @function SuperMap.SupplyCenter.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }], [{
        key: "fromJson",
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }
            return new SupplyCenter({
                maxWeight: jsonObject.maxWeight,
                nodeID: jsonObject.nodeID,
                resourceValue: jsonObject.resourceValue,
                type: jsonObject.type
            });
        }
    }]);

    return SupplyCenter;
}();

exports.default = SupplyCenter;


_SuperMap2.default.SupplyCenter = SupplyCenter;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SurfaceAnalystParametersSetting
 * @classdesc
 * 表面分析参数设置类。
 * 通过该类可以设置表面分析提取等值线、提取等值面的一些参数，包括基准值、等值距、光滑度、光滑方法等。
 * @param options - {Object} 可选参数。如:</br>
 *        clipRegion - {SuperMap.Geometry} 获取或设置裁剪面对象，如果不需要对操作结果进行裁剪，可以使用null值取代该参数。</br>
 *                      面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
 *        datumValue - {number}获取或设置表面分析中提取等值线、提取等值面的基准值。</br>
 *        expectedZValues - {Array<number>} 获取或设置期望分析结果的 Z 值集合。</br>
 *        interval - {number}获取或设置等值距。等值距是两条等值线之间的间隔值。</br>
 *        resampleTolerance - {number}获取或设置重采样容限。</br>
 *        smoothMethod - {SuperMap.SmoothMethod} 获取或设置光滑处理所使用的方法。</br>
 *        smoothness - {number}获取或设置表面分析中等值线或等值面的边界线的光滑度。</br>
 */
var SurfaceAnalystParametersSetting = function () {

    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.smoothMethod -{SuperMap.SmoothMethod}
     * @description 获取或设置光滑处理所使用的方法。
     */


    /**
     *  @member SuperMap.SurfaceAnalystParametersSetting.prototype.interval -{number}
     *  @description 获取或设置等值距。等值距是两条等值线之间的间隔值。
     */


    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.datumValue -{number}
     * @description 获取或设置表面分析中提取等值线、提取等值面的基准值。
     * 基准值是作为一个生成等值线的初始起算值，并不一定是最小等值线的值。 例如，高程范围为 220 -1550 的 DEM 栅格数据，
     * 如果设基准值为0， 等值距为50，则提取等值线时，以基准值0为起点，等值距50为间隔提取等值线，
     * 因为给定高程的最小值是220，所以，在给定范围内提取等值线的最小高程是250。
     * 提取等值线的结果是：最小等值线值为250，最大等值线值为1550。
     */
    function SurfaceAnalystParametersSetting(options) {
        _classCallCheck(this, SurfaceAnalystParametersSetting);

        this.clipRegion = null;
        this.datumValue = 0;
        this.expectedZValues = null;
        this.interval = 0;
        this.resampleTolerance = 0;
        this.smoothMethod = _REST.SmoothMethod.BSPLINE;
        this.smoothness = 0;
        this.CLASS_NAME = "SuperMap.SurfaceAnalystParametersSetting";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.SurfaceAnalystParametersSetting.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.smoothness -{number}
     * @description 获取或设置表面分析中等值线或等值面的边界线的光滑度。
     * 以为0-5为例，光滑度为0表示不进行光滑操作，值越大表示光滑度越高。
     * 随着光滑度的增加，提取的等值线越光滑.当然光滑度越大，
     * 计算所需的时间和占用的内存也就越大。而且，当等值距较小时，
     * 光滑度太高会出现等值线相交的问题。
     */


    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.resampleTolerance -{number}
     * @description 获取或设置重采样容限。
     * 容限值越大，采样结果数据越简化。当分析结果出现交叉时，可通过调整重采样容限为较小的值来处理。
     */

    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.expectedZValues -{Array<number>}
     * @description 获取或设置期望分析结果的 Z 值集合。
     * Z 值集合存储一系列数值，该数值为待提取等值线的值。即仅高程值在Z值集合中的等值线会被提取。
     */


    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.clipRegion
     * @description 获取或设置裁剪面对象，如果不需要对操作结果进行裁剪，可以使用null值取代该参数。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。
     */


    _createClass(SurfaceAnalystParametersSetting, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.clipRegion) {
                me.clipRegion.destroy();
                me.clipRegion = null;
            }

            me.datumValue = null;
            me.expectedZValues = null;
            me.interval = null;
            me.resampleTolerance = null;
            me.smoothMethod = null;
            me.smoothness = null;
        }
    }]);

    return SurfaceAnalystParametersSetting;
}();

exports.default = SurfaceAnalystParametersSetting;

_SuperMap2.default.SurfaceAnalystParametersSetting = SurfaceAnalystParametersSetting;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TerrainCurvatureCalculationParameters
 * @classdesc 地形曲率计算参数类。
 * @param options - {Object} 可选参数。如</br>
 *        dataset - {string} 要用来做地形曲率计算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。必设字段。</br>
 *        zFactor - {number}指定的高程缩放系数。默认值为 1.0，表示不缩放。</br>
 *        averageCurvatureName - {string} 结果数据集：平均曲率数据集的名称，必设字段。</br>
 *        profileCurvatureName - {string} 结果数据集：剖面曲率数据集的名称。</br>
 *        planCurvatureName - {string} 结果数据集：平面曲率数据集的名称。</br>
 *        deleteExistResultDataset - {boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。</br>
 */
var TerrainCurvatureCalculationParameters = function () {

    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.planCurvatureName -{string}
     * @description 结果数据集：平面曲率数据集的名称。
     */


    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.averageCurvatureName -{string}
     * @description 结果数据集：平均曲率数据集的名称，必设字段。
     */


    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.dataset -{string}
     * @description 要用来做地形曲率计算数据源中数据集的名称。
     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。必设字段。
     * 注：地形曲率计算必须为栅格数据集。
     */
    function TerrainCurvatureCalculationParameters(options) {
        _classCallCheck(this, TerrainCurvatureCalculationParameters);

        this.dataset = null;
        this.zFactor = 1.0;
        this.averageCurvatureName = null;
        this.profileCurvatureName = "";
        this.planCurvatureName = "";
        this.deleteExistResultDataset = false;
        this.CLASS_NAME = "SuperMap.TerrainCurvatureCalculationParameters";

        if (!options) {
            return;
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.TerrainCurvatureCalculationParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.deleteExistResultDataset -{boolean}
     * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
     */


    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.profileCurvatureName -{string}
     * @description 结果数据集：剖面曲率数据集的名称。
     */


    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.zFactor -{number}
     * @description 指定的高程缩放系数。默认值为 1.0，表示不缩放。
     * 该值是指在 DEM 栅格数据中，栅格值（Z 坐标，即高程值）相对于 X 和 Y 坐标的单位变换系数。
     * 通常有 X，Y，Z 都参加的计算中，需要将高程值乘以一个高程缩放系数，使得三者单位一致。
     * 例如，X、Y 方向上的单位是米，而 Z 方向的单位是英尺，由于 1 英尺等于 0.3048 米，则需要指定缩放系数为 0.3048。
     */


    _createClass(TerrainCurvatureCalculationParameters, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.dataset = null;
            me.zFactor = 1.0;
            me.averageCurvatureName = null;
            me.profileCurvatureName = null;
            me.planCurvatureName = null;
            me.deleteExistResultDataset = true;
        }
        /**
         * @function SuperMap.TerrainCurvatureCalculationParameters.toObject
         * @param derrainCurvatureCalculationParameters - {Object}  地形曲率计算参数
         * @param tempObj - {Object} 目标对象。
         * @description 生成地形曲率计算对象
         */

    }], [{
        key: "toObject",
        value: function toObject(derrainCurvatureCalculationParameters, tempObj) {
            for (var name in derrainCurvatureCalculationParameters) {
                if (name !== "dataset") {
                    tempObj[name] = derrainCurvatureCalculationParameters[name];
                }
            }
        }
    }]);

    return TerrainCurvatureCalculationParameters;
}();

exports.default = TerrainCurvatureCalculationParameters;


_SuperMap2.default.TerrainCurvatureCalculationParameters = TerrainCurvatureCalculationParameters;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraduatedSymbolStyle
 * @classdesc 等级符号专题图正负零值显示风格类
 * @param options - {Object} 可选参数。如：<br>
 *        negativeDisplayed - {boolean} 是否显示负值。默认为 false。<br>
 *        negativeStyle - {SuperMap.ServerStyle} 负值的等级符号风格。<br>
 *        positiveStyle - {SuperMap.ServerStyle}  正值的等级符号风格。<br>
 *        zeroDisplayed - {boolean} 是否显示0值。默认为 false。<br>
 *        zeroStyle - {SuperMap.ServerStyle} 0值的等级符号风格。
 */
var ThemeGraduatedSymbolStyle = function () {

    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.zeroDisplayed -{boolean}
     * @description 是否显示0值。默认为 false。
     */


    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.negativeStyle -{SuperMap.ServerStyle} 负值的等级符号风格。
     */
    function ThemeGraduatedSymbolStyle(options) {
        _classCallCheck(this, ThemeGraduatedSymbolStyle);

        this.negativeDisplayed = false;
        this.negativeStyle = null;
        this.positiveStyle = null;
        this.zeroDisplayed = false;
        this.zeroStyle = null;
        this.CLASS_NAME = "SuperMap.ThemeGraduatedSymbolStyle";

        var me = this;
        me.negativeStyle = new _ServerStyle2.default();
        me.positiveStyle = new _ServerStyle2.default();
        me.zeroStyle = new _ServerStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeGraduatedSymbolStyle.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.zeroStyle -{SuperMap.ServerStyle}
     * @description 0值的等级符号风格。
     */


    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.positiveStyle -{SuperMap.ServerStyle}
     * @description 正值的等级符号风格。
     */


    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.negativeDisplayed -{boolean}
     * @description 是否显示负值。默认为 false。
     */


    _createClass(ThemeGraduatedSymbolStyle, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.negativeDisplayed = null;
            me.negativeStyle = null;
            me.positiveStyle = null;
            me.zeroDisplayed = null;
            me.zeroStyle = null;
        }

        /**
         * @function SuperMap.ThemeGraduatedSymbolStyle.fromObj
         * @description 从传入对象获取等级符号专题图正负零值显示风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraduatedSymbolStyle}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeGraduatedSymbolStyle();
            _SuperMap2.default.Util.copy(res, obj);
            res.negativeStyle = _ServerStyle2.default.fromJson(obj.negativeStyle);
            res.positiveStyle = _ServerStyle2.default.fromJson(obj.positiveStyle);
            res.zeroStyle = _ServerStyle2.default.fromJson(obj.zeroStyle);
            return res;
        }
    }]);

    return ThemeGraduatedSymbolStyle;
}();

exports.default = ThemeGraduatedSymbolStyle;


_SuperMap2.default.ThemeGraduatedSymbolStyle = ThemeGraduatedSymbolStyle;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerColor = __webpack_require__(12);

var _ServerColor2 = _interopRequireDefault(_ServerColor);

var _ServerTextStyle = __webpack_require__(16);

var _ServerTextStyle2 = _interopRequireDefault(_ServerTextStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraphAxes
 * @classdesc 统计专题图坐标轴样式类。
 * @param  options - {Object} 可选参数。<br>
 *         axesColor - {SuperMap.ServerColor} 坐标轴颜色。<br>
 *         axesDisplayed - {boolean} 是否显示坐标轴。<br>
 *         axesGridDisplayed - {boolean} 是否在统计图坐标轴上显示网格。<br>
 *         axesTextDisplayed - {boolean} 是否显示坐标轴的文本标注。<br>
 *         axesTextStyle - {SuperMap.ServerTextStyle} 统计符号的最大最小尺寸。
 */
var ThemeGraphAxes = function () {

    /**
     * @member SuperMap.ThemeGraphAxes.prototype.axesTextDisplayed -{boolean}
     * @description 是否显示坐标轴的文本标注。默认为 false，即不显示。
     */


    /**
     * @member SuperMap.ThemeGraphAxes.prototype.axesDisplayed -{boolean}
     * @description 是否显示坐标轴。默认为 false，即不显示。<br>
     *              由于饼状图和环状图无坐标轴，故该属性以及所有与坐标轴设置相关的属性都不适用于它们。并且只有当该值为 true 时，其它设置坐标轴的属性才起作用。
     */
    function ThemeGraphAxes(options) {
        _classCallCheck(this, ThemeGraphAxes);

        this.axesColor = null;
        this.axesDisplayed = false;
        this.axesGridDisplayed = false;
        this.axesTextDisplayed = false;
        this.axesTextStyle = null;
        this.CLASS_NAME = "SuperMap.ThemeGraphAxes";

        var me = this;
        me.axesColor = new _ServerColor2.default(0, 0, 0);
        me.axesTextStyle = new _ServerTextStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeGraphAxes.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeGraphAxes.prototype.axesTextStyle -{SuperMap.ServerTextStyle}
     * @description 坐标轴文本风格。当 axesTextDisplayed = true 时有效。
     */


    /**
     * @member SuperMap.ThemeGraphAxes.prototype.axesGridDisplayed -{boolean}
     * @description 是否在统计图坐标轴上显示网格。默认为 false，即不显示。
     */


    /**
     * @member SuperMap.ThemeGraphAxes.prototype.axesColor -{SuperMap.ServerColor}
     * @description 坐标轴颜色，默认为黑色。当 axesDisplayed = true 时有效。
     */


    _createClass(ThemeGraphAxes, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.axesColor) {
                me.axesColor.destroy();
                me.axesColor = null;
            }
            me.axesDisplayed = null;
            me.axesGridDisplayed = null;
            me.axesTextDisplayed = null;
            if (me.axesTextStyle) {
                me.axesTextStyle.destroy();
                me.axesTextStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeGraphAxes.fromObj
         * @description 从传入对象获取统计专题图坐标轴样式类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraphAxes}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeGraphAxes();
            _SuperMap2.default.Util.copy(res, obj);
            res.axesColor = _ServerColor2.default.fromJson(obj.axesColor);
            res.axesTextStyle = _ServerTextStyle2.default.fromObj(obj.axesTextStyle);
            return res;
        }
    }]);

    return ThemeGraphAxes;
}();

exports.default = ThemeGraphAxes;


_SuperMap2.default.ThemeGraphAxes = ThemeGraphAxes;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraphItem
 * @classdesc 统计专题图子项类
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 专题图子项的名称。<br>
 *        graphExpression - {string} 统计专题图的专题变量。<br>
 *        memoryDoubleValues - {Array<number>} 内存数组方式制作专题图时的值数组。<br>
 *        uniformStyle - {SuperMap.ServerStyle} 统计专题图子项的显示风格
 */
var ThemeGraphItem = function () {

    /**
     * @member SuperMap.ThemeGraphItem.prototype.memoryDoubleValues -{Array<number>}
     * @description 内存数组方式制作专题图时的值数组。<br>
     *              内存数组方式制作专题图时，只对 SmID 值在键数组（SuperMap.ThemeGraph.memoryKeys）中的记录制作专题图。<br>
     *              值数组的数值个数必须与键数组中数值的个数一致。 值数组中的值将代替原来的专题值来制作统计专题图。<br>
     *              比如：利用面积字段和周长字段（即有两个统计专题图子项 ）作为专题变量制作统计专题图。
     */


    /**
     * @member SuperMap.ThemeGraphItem.prototype.caption -{string}
     * @description 专题图子项的名称。
     */
    function ThemeGraphItem(options) {
        _classCallCheck(this, ThemeGraphItem);

        this.caption = null;
        this.graphExpression = null;
        this.memoryDoubleValues = null;
        this.uniformStyle = null;
        this.CLASS_NAME = "SuperMap.ThemeGraphItem";

        var me = this;
        me.uniformStyle = new _ServerStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeGraphItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeGraphItem.prototype.uniformStyle -{SuperMap.ServerStyle}
     * @description 统计专题图子项的显示风格。
     *              每一个统计专题图子项都对应一种显示风格。
     */


    /**
     * @member SuperMap.ThemeGraphItem.prototype.graphExpression -{string}
     * @description 统计专题图的专题变量。专题变量可以是一个字段或字段表达式。字段必须为数值型；表达式只能为数值型的字段间的运算。必设字段。
     */


    _createClass(ThemeGraphItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.graphExpression = null;
            me.memoryDoubleValues = null;
            me.uniformStyle = null;
        }

        /**
         * @function SuperMap.ThemeGraphItem.fromObj
         * @description 从传入对象获取统计专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraphItem}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeGraphItem();
            _SuperMap2.default.Util.copy(res, obj);
            res.uniformStyle = _ServerStyle2.default.fromJson(obj.uniformStyle);
            return res;
        }
    }]);

    return ThemeGraphItem;
}();

exports.default = ThemeGraphItem;


_SuperMap2.default.ThemeGraphItem = ThemeGraphItem;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraphSize
 * @classdesc 统计专题图符号尺寸类。
 * @param  options - {Object} 可选参数。如：<br>
 *         maxGraphSize - {number}统计图中显示的最大图表尺寸基准值。<br>
 *         minGraphSize - {number}统计图中显示的最小图表尺寸基准值。
 */
var ThemeGraphSize = function () {

    /**
     * @member SuperMap.ThemeGraphSize.prototype.maxGraphSize -{number}
     * @description 获取或设置统计图中显示的最大图表尺寸基准值，默认为0像素。
     */
    function ThemeGraphSize(options) {
        _classCallCheck(this, ThemeGraphSize);

        this.maxGraphSize = 0;
        this.minGraphSize = 0;
        this.CLASS_NAME = "SuperMap.ThemeGraphSize";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeGraphSize.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeGraphSize.prototype.minGraphSize -{number}
     * @description 获取或设置统计图中显示的最小图表尺寸基准值，默认为0像素。
     */


    _createClass(ThemeGraphSize, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.maxGraphSize = null;
            me.minGraphSize = null;
        }

        /**
         * @function SuperMap.ThemeGraphSize.fromObj
         * @description 从传入对象获统计专题图符号尺寸类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraphSize}
         */

    }], [{
        key: "fromObj",
        value: function fromObj(obj) {
            var res = new ThemeGraphSize();
            _SuperMap2.default.Util.copy(res, obj);
            return res;
        }
    }]);

    return ThemeGraphSize;
}();

exports.default = ThemeGraphSize;


_SuperMap2.default.ThemeGraphSize = ThemeGraphSize;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerTextStyle = __webpack_require__(16);

var _ServerTextStyle2 = _interopRequireDefault(_ServerTextStyle);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraphText
 * @classdesc 统计图文字标注风格类。
 * @param options - {Object} 可选参数。<br>
 *        graphTextDisplayed - {boolean} 是否显示统计图上的文字标注。<br>
 *        graphTextFormat - {SuperMap.ThemeGraphTextFormat} 统计专题图文本显示格式。<br>
 *        graphTextStyle - {SuperMap.ServerTextStyle} 统计图上的文字标注风格。
 */
var ThemeGraphText = function () {

    /**
     * @member SuperMap.ThemeGraphText.prototype.graphTextFormat -{SuperMap.ThemeGraphTextFormat}
     * @description 统计专题图文本显示格式。<br>
     *              文本显示格式包括百分数、真实数值、标题、标题+百分数、标题+真实数值。默认为 SuperMap.ThemeGraphTextFormat.CAPTION。
     */
    function ThemeGraphText(options) {
        _classCallCheck(this, ThemeGraphText);

        this.graphTextDisplayed = false;
        this.graphTextFormat = _REST.ThemeGraphTextFormat.CAPTION;
        this.graphTextStyle = null;
        this.CLASS_NAME = "SuperMap.ThemeGraphText";

        var me = this;
        me.graphTextStyle = new _ServerTextStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeGraphText.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeGraphText.prototype.graphTextStyle -{SuperMap.ServerTextStyle}
     * @description 统计图上的文字标注风格。
     */


    /**
     * @member SuperMap.ThemeGraphText.prototype.graphTextDisplayed -{boolean}
     * @description 是否显示统计图上的文字标注。默认为 false，即不显示。
     */


    _createClass(ThemeGraphText, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.graphTextDisplayed = null;
            me.graphTextFormat = null;
            if (me.graphTextStyle) {
                me.graphTextStyle.destroy();
                me.graphTextStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeGraphText.fromObj
         * @description 从传入对象获取统计图文字标注风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraphText}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeGraphText();
            _SuperMap2.default.Util.copy(res, obj);
            res.graphTextStyle = _ServerTextStyle2.default.fromObj(obj.graphTextStyle);
            return res;
        }
    }]);

    return ThemeGraphText;
}();

exports.default = ThemeGraphText;


_SuperMap2.default.ThemeGraphText = ThemeGraphText;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Theme2 = __webpack_require__(13);

var _Theme3 = _interopRequireDefault(_Theme2);

var _ThemeGridRangeItem = __webpack_require__(248);

var _ThemeGridRangeItem2 = _interopRequireDefault(_ThemeGridRangeItem);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeGridRange
 * @classdesc 栅格分段专题图。<br>
 *              栅格分段专题图，是将所有单元格的值按照某种分段方式分成多个范围段，值在同一个范围段中的单元格使用相同的颜色进行显示。<br>
 *              栅格分段专题图一般用来反映连续分布现象的数量或程度特征。比如某年的全国降水量分布图，将各气象站点的观测值经过内插之后生成的栅格数据进行分段显示。<br>
 *              该类类似于分段专题图类，不同点在于分段专题图的操作对象是矢量数据，而栅格分段专题图的操作对象是栅格数据。<br>
 * @extends SuperMap.Theme
 * @param options - {Object} 参数。<br>
 *        items - {Array<SuperMap.ThemeGridRangeItem>} 栅格分段专题图子项数组。<br>
 *        reverseColor - {boolean} 是否对栅格分段专题图中分段的颜色风格进行反序显示。<br>
 *        rangeMode - {SuperMap.RangeMode} 分段专题图的分段模式。<br>
 *        rangeParameter - {number}分段参数。<br>
 *        colorGradientType - {SuperMap.ColorGradientType} 渐变颜色枚举类。
 */
var ThemeGridRange = function (_Theme) {
    _inherits(ThemeGridRange, _Theme);

    /**
     * @member SuperMap.ThemeGridRange.prototype.colorGradientType -{SuperMap.ColorGradientType}
     * @description 渐变颜色枚举类
     *
     */


    /**
     * @member SuperMap.ThemeGridRange.prototype.rangeMode -{SuperMap.RangeMode}
     * @description 分段专题图的分段模式。<br>
     *              默认值为 SuperMap.RangeMode.EQUALINTERVAL（等距离分段）。<br>
     *              在栅格分段专题图中，作为专题变量的字段或表达式的值按照某种分段方式被分成多个范围段。<br>
     *              目前 SuperMap 提供的分段方式包括：等距离分段法、平方根分段法、标准差分段法、对数分段法、等计数分段法和自定义距离法，<br>
     *              显然这些分段方法根据一定的距离进行分段，因而范围分段专题图所基于的专题变量必须为数值型。
     */
    function ThemeGridRange(options) {
        _classCallCheck(this, ThemeGridRange);

        var _this = _possibleConstructorReturn(this, (ThemeGridRange.__proto__ || Object.getPrototypeOf(ThemeGridRange)).call(this, "GRIDRANGE", options));

        _this.items = null;
        _this.rangeMode = _REST.RangeMode.EQUALINTERVAL;
        _this.rangeParameter = 0;
        _this.colorGradientType = _REST.ColorGradientType.YELLOW_RED;
        _this.reverseColor = false;
        _this.CLASS_NAME = "SuperMap.ThemeGridRange";

        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.ThemeGridRange.prototype.reverseColor -{boolean}
     * @description 是否对栅格分段专题图中分段的颜色风格进行反序显示。
     */


    /**
     * @member SuperMap.ThemeGridRange.prototype.rangeParameter -{number}
     * @description 分段参数。<br>
     *              当分段模式为等距离分段法，平方根分段，对数分段法，计数分段法其中一种模式时，该参数用于设置分段个数，必设；当分段模式为标准差分段法时，<br>
     *              该参数不起作用；当分段模式为自定义距离时，该参数用于设置自定义距离。默认值为 -1。
     */


    /**
     * @member SuperMap.ThemeGridRange.prototype.items -{Array<SuperMap.ThemeGridRangeItem>}
     * @description 栅格分段专题图子项数组。<br>
     *              在栅格分段专题图中，将栅格值按照某种分段模式被分成多个范围段。<br>
     *              本类用来设置每个栅格范围段的分段起始值、终止值、名称和颜色等。每个分段所表示的范围为 [Start,End)。
     */


    _createClass(ThemeGridRange, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeGridRange.prototype.__proto__ || Object.getPrototypeOf(ThemeGridRange.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.items) {
                if (me.items.length > 0) {
                    for (var item in me.items) {
                        me.items[item].destroy();
                        me.items[item] = null;
                    }
                }
                me.items = null;
            }
            me.reverseColor = null;
            me.rangeMode = null;
            me.rangeParameter = null;
            me.colorGradientType = null;
        }

        /**
         * @function SuperMap.ThemeGridRange.fromObj
         * @description 从传入对象获取栅格分段专题图。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGridRange}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeGridRange();
            _SuperMap2.default.Util.copy(res, obj);
            var itemsR = obj.items;
            var len = itemsR ? itemsR.length : 0;
            res.items = [];
            for (var i = 0; i < len; i++) {
                res.items.push(_ThemeGridRangeItem2.default.fromObj(itemsR[i]));
            }
            return res;
        }
    }]);

    return ThemeGridRange;
}(_Theme3.default);

exports.default = ThemeGridRange;


_SuperMap2.default.ThemeGridRange = ThemeGridRange;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerColor = __webpack_require__(12);

var _ServerColor2 = _interopRequireDefault(_ServerColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGridRangeItem
 * @classdesc 栅格分段专题图子项类。<br>
 *            在栅格分段专题图中，将栅格值按照某种分段模式被分成多个范围段。<br>
 *            本类用来设置每个范围段的分段起始值、终止值、名称和颜色等。每个分段所表示的范围为 [Start,End)。<br>
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 栅格分段专题图子项的标题。<br>
 *        color - {SuperMap.ServerColor}栅格分段专题图中每一个分段专题图子项的对应的颜色。<br>
 *        end - {number}栅格分段专题图子项的终止值。<br>
 *        start - {number}栅格分段专题图子项的起始值。<br>
 *        visible - {boolean} 栅格分段专题图子项是否可见。
 */
var ThemeGridRangeItem = function () {

    /**
     * @member SuperMap.ThemeGridRangeItem.prototype.start -{number}
     * @description 栅格分段专题图子项的起始值，即该段专题值范围的最小值，默认值为 0。
     */


    /**
     * @member @member SuperMap.ThemeGridRangeItem.prototype.color -{SuperMap.ServerColor}
     * @description 栅格分段专题图中每一个分段专题图子项的对应的颜色。
     */
    function ThemeGridRangeItem(options) {
        _classCallCheck(this, ThemeGridRangeItem);

        this.caption = null;
        this.color = null;
        this.end = 0;
        this.start = 0;
        this.visible = true;
        this.CLASS_NAME = "SuperMap.ThemeGridRangeItem";

        var me = this;
        me.color = new _ServerColor2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeGridRangeItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeGridRangeItem.prototype.visible -{boolean}
     * @description 栅格分段专题图子项是否可见。默认为 true。
     */


    /**
     * @member SuperMap.ThemeGridRangeItem.prototype.end -{number}
     * @description 栅格分段专题图子项的终止值，即该段专题值范围的最大值，默认值为 0。
     */


    /**
     * @member SuperMap.ThemeGridRangeItem.prototype.caption -{string}
     * @description 栅格分段专题图子项的标题。
     */


    _createClass(ThemeGridRangeItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.end = null;
            me.start = null;
            //需要验证是够存在destroy方法
            if (me.color) {
                me.color.destroy();
                me.color = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeGridRangeItem.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _SuperMap2.default.Util.copyAttributes(obj, this);
            if (obj.color) {
                if (obj.color.toServerJSONObject) {
                    obj.color = obj.color.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeGridRangeItem.fromObj
         * @description 从传入对象获取栅格分段专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGridRangeItem}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeGridRangeItem();
            _SuperMap2.default.Util.copy(res, obj);
            res.color = _ServerColor2.default.fromJson(obj.color);
            return res;
        }
    }]);

    return ThemeGridRangeItem;
}();

exports.default = ThemeGridRangeItem;


_SuperMap2.default.ThemeGridRangeItem = ThemeGridRangeItem;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _Theme2 = __webpack_require__(13);

var _Theme3 = _interopRequireDefault(_Theme2);

var _ServerColor = __webpack_require__(12);

var _ServerColor2 = _interopRequireDefault(_ServerColor);

var _ThemeGridUniqueItem = __webpack_require__(250);

var _ThemeGridUniqueItem2 = _interopRequireDefault(_ThemeGridUniqueItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeGridUnique
 * @classdesc 栅格单值专题图类。<br>
 *              栅格单值专题图，是将单元格值相同的归为一类，为每一类设定一种颜色，从而用来区分不同的类别。<br>
 *              栅格单值专题图适用于离散栅格数据和部分连续栅格数据，对于单元格值各不相同的那些连续栅格数据，使用栅格单值专题图不具有任何意义。<br>
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        items - {Array<SuperMap.ThemeGridUniqueItem>} 栅格单值专题图子项数组。
 *        defaultcolor - {SuperMap.ServerColor} 栅格单值专题图的默认颜色。
 */
var ThemeGridUnique = function (_Theme) {
    _inherits(ThemeGridUnique, _Theme);

    /**
     * @member SuperMap.ThemeGridUnique.prototype.defaultcolor -{SuperMap.ServerColor}
     * @description 栅格单值专题图的默认颜色。
     *              对于那些未在格网单值专题图子项之列的要素使用该颜色显示。
     */
    function ThemeGridUnique(options) {
        _classCallCheck(this, ThemeGridUnique);

        var _this = _possibleConstructorReturn(this, (ThemeGridUnique.__proto__ || Object.getPrototypeOf(ThemeGridUnique)).call(this, "GRIDUNIQUE", options));

        _this.defaultcolor = null;
        _this.items = null;
        _this.CLASS_NAME = "SuperMap.ThemeGridUnique";

        var me = _this;
        me.defaultcolor = new _ServerColor2.default();
        if (options) {
            _SuperMap2.default.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.ThemeGridUnique.prototype.items -{Array<SuperMap.ThemeGridUniqueItem>}
     * @description 栅格单值专题图子项数组。
     *              栅格单值专题图将值相同的单元格归为一类，每一类是一个专题图子项。
     */


    _createClass(ThemeGridUnique, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeGridUnique.prototype.__proto__ || Object.getPrototypeOf(ThemeGridUnique.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.items) {
                if (me.items.length > 0) {
                    for (var item in me.items) {
                        me.items[item].destroy();
                        me.items[item] = null;
                    }
                }
                me.items = null;
            }

            if (me.defaultcolor) {
                me.defaultcolor.destroy();
                me.defaultcolor = null;
            }
        }

        /**
         * @function SuperMap.ThemeGridUnique.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _SuperMap2.default.Util.copyAttributes(obj, this);
            if (obj.defaultcolor) {
                if (obj.defaultcolor.toServerJSONObject) {
                    obj.defaultcolor = obj.defaultcolor.toServerJSONObject();
                }
            }
            if (obj.items) {
                var items = [],
                    len = obj.items.length;
                for (var i = 0; i < len; i++) {
                    items.push(obj.items[i].toServerJSONObject());
                }
                obj.items = items;
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeGridUnique.fromObj
         * @description 从传入对象获取栅格单值专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGridUnique}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeGridUnique();
            var uItems = obj.items;
            var len = uItems ? uItems.length : 0;
            _SuperMap2.default.Util.extend(res, obj);
            res.items = [];
            res.defaultcolor = new _ServerColor2.default.fromJson(obj.defaultcolor);
            for (var i = 0; i < len; i++) {
                res.items.push(new _ThemeGridUniqueItem2.default.fromObj(uItems[i]));
            }
            return res;
        }
    }]);

    return ThemeGridUnique;
}(_Theme3.default);

exports.default = ThemeGridUnique;


_SuperMap2.default.ThemeGridUnique = ThemeGridUnique;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerColor = __webpack_require__(12);

var _ServerColor2 = _interopRequireDefault(_ServerColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGridUniqueItem
 * @classdesc 栅格单值专题图子项类。<br>
 *              栅格单值专题图是将值相同的单元格归为一类，每一类是一个专题图子项。<br>
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 栅格单值专题图子项的名称。<br>
 *        color - {SuperMap.ServerColor} 栅格单值专题图子项的显示颜色。<br>
 *        unique - {number}栅格单值专题图子项的专题值，即单元格的值，值相同的单元格位于一个子项内。<br>
 *        visible - {boolean} 栅格单值专题图子项是否可见。
 */
var ThemeGridUniqueItem = function () {

    /**
     * @member SuperMap.ThemeGridUniqueItem.prototype.unique -{number}
     * @description 栅格单值专题图子项的专题值，即单元格的值，值相同的单元格位于一个子项内。
     */


    /**
     * @member SuperMap.ThemeGridUniqueItem.prototype.caption -{string}
     * @description 栅格单值专题图子项的名称。
     */
    function ThemeGridUniqueItem(options) {
        _classCallCheck(this, ThemeGridUniqueItem);

        this.caption = null;
        this.color = null;
        this.unique = null;
        this.visible = true;
        this.CLASS_NAME = "SuperMap.ThemeGridUniqueItem";

        var me = this;
        me.color = new _ServerColor2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeGridUniqueItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeGridUniqueItem.prototype.visible -{boolean}
     * @description 栅格单值专题图子项是否可见。默认为true。
     */


    /**
     * @member SuperMap.ThemeGridUniqueItem.prototype.color -{SuperMap.ServerColor}
     * @description 栅格单值专题图子项的显示颜色。
     */


    _createClass(ThemeGridUniqueItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.unique = null;

            if (me.color) {
                me.color.destroy();
                me.color = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeGridUniqueItem.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _SuperMap2.default.Util.copyAttributes(obj, this);
            if (obj.color) {
                if (obj.color.toServerJSONObject) {
                    obj.color = obj.color.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeGridUniqueItem.fromObj
         * @description 从传入对象获取栅格单值专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGridUniqueItem}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeGridUniqueItem();
            _SuperMap2.default.Util.copy(res, obj);
            res.color = _ServerColor2.default.fromJson(obj.color);
            return res;
        }
    }]);

    return ThemeGridUniqueItem;
}();

exports.default = ThemeGridUniqueItem;


_SuperMap2.default.ThemeGridUniqueItem = ThemeGridUniqueItem;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelAlongLine
 * @classdesc 标签沿线标注样式类。
 * @param options - {Object} 可选参数。如：<br>
 *        isAlongLine - {boolean} 是否沿线显示文本。<br>
 *        alongLineDirection - {SuperMap.AlongLineDirection} 标签沿线标注方向。<br>
 *        angleFixed - {Boonlean} 当沿线显示文本时，是否将文本角度固定。<br>
 *        repeatedLabelAvoided - {Boonlean} 沿线循环标注时是否避免标签重复标注。<br>
 *        repeatIntervalFixed - {Boonlean} 循环标注间隔是否固定。<br>
 *        labelRepeatInterval - {number}沿线且循环标注时循环标注的间隔。
 */
var ThemeLabelAlongLine = function () {

    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.repeatIntervalFixed -{Boonlean}
     * @description 循环标注间隔是否固定。true 表示使用固定循环标注间隔，即使用逻辑坐标来显示循环标注间隔；
     *              false 表示循环标注间隔随地图的缩放而变化，即使用地理坐标来显示循环标注间隔。默认值为 false。
     */


    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.angleFixed -{Boonlean}
     * @description 当沿线显示文本时，是否将文本角度固定。true 表示按固定文本角度显示文本，false 表示按照沿线角度显示文本。
     *              默认值为 false。如果固定角度，则所有标签均按所设置的文本风格中字体的旋转角度来显示，不考虑沿线标注的方向；
     *              如果不固定角度，在显示标签时会同时考虑字体的旋转角度和沿线标注的方向。
     */


    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.isAlongLine -{boolean}
     * @description 是否沿线显示文本。true 表示沿线显示文本，false 表示正常显示文本，默认为 true。
     */
    function ThemeLabelAlongLine(options) {
        _classCallCheck(this, ThemeLabelAlongLine);

        this.isAlongLine = true;
        this.alongLineDirection = _REST.AlongLineDirection.LB_TO_RT;
        this.angleFixed = false;
        this.repeatedLabelAvoided = false;
        this.repeatIntervalFixed = false;
        this.labelRepeatInterval = 0;
        this.CLASS_NAME = "SuperMap.ThemeLabelAlongLine";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeLabelAlongLine.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.labelRepeatInterval -{number}
     * @description 沿线且循环标注时循环标注的间隔。长度的单位与地图的地理单位一致。只有设定 RepeatedLabelAvoided 为 true
     *              的时候，labelRepeatInterval 属性才有效。默认为0地图单位。
     */


    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.repeatedLabelAvoided -{Boonlean}
     * @description 沿线循环标注时是否避免标签重复标注。
     */


    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.alongLineDirection -{SuperMap.AlongLineDirection}
     * @description 标签沿线标注方向。默认为 SuperMap.AlongLineDirection.LB_TO_RT（从上到下，从左到右放置）。
     */


    _createClass(ThemeLabelAlongLine, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.isAlongLine = null;
            me.alongLineDirection = null;
            me.angleFixed = null;
            me.repeatedLabelAvoided = null;
            me.repeatIntervalFixed = null;
            me.labelRepeatInterval = null;
        }

        /**
         * @function SuperMap.ThemeLabelAlongLine.fromObj
         * @description 从传入对象获取标签沿线标注样式类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabelAlongLine}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var t = new ThemeLabelAlongLine();
            _SuperMap2.default.Util.copy(t, obj);
            return t;
        }
    }]);

    return ThemeLabelAlongLine;
}();

exports.default = ThemeLabelAlongLine;


_SuperMap2.default.ThemeLabelAlongLine = ThemeLabelAlongLine;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelBackground
 * @classdesc 标签背景风格类。通过该类可以设置标签的背景形状和风格。
 * @param options - {Object} 可选参数。如：<br>
 *        labelBackShape - {SuperMap.LabelBackShape} 标签专题图中标签背景风格。<br>
 *        backStyle - {SuperMap.ServerStyle} 标签专题图中标签背景的形状枚举类。
 */
var ThemeLabelBackground = function () {

    /**
     * @member SuperMap.ThemeLabelBackground.prototype.labelBackShape -{SuperMap.LabelBackShape}
     * @description 标签专题图中标签背景风格。当背景形状
     *              labelBackShape 属性设为 NONE（即无背景形状） 时，backStyle 属性无效。
     */
    function ThemeLabelBackground(options) {
        _classCallCheck(this, ThemeLabelBackground);

        this.labelBackShape = _REST.LabelBackShape.NONE;
        this.backStyle = null;
        this.CLASS_NAME = "SuperMap.ThemeLabelBackground";

        var me = this;
        me.backStyle = new _ServerStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeLabelBackground.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeLabelBackground.prototype.backStyle -{SuperMap.ServerStyle}
     * @description 标签专题图中标签背景的形状枚举类。背景类型可
     *              以是矩形、圆角矩形、菱形、椭圆形、三角形和符号等，默认为 SuperMap.LabelBackShape.NONE，
     *              即不使用任何的形状作为标签的背景。
     */


    _createClass(ThemeLabelBackground, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.labelBackShape = null;
            if (me.backStyle) {
                me.backStyle.destroy();
                me.backStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeLabelBackground.fromObj
         * @description 从传入对象获取标签背景风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabelBackground}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var t = new ThemeLabelBackground();
            t.labelBackShape = obj.labelBackShape;
            t.backStyle = _ServerStyle2.default.fromJson(obj.backStyle);

            return t;
        }
    }]);

    return ThemeLabelBackground;
}();

exports.default = ThemeLabelBackground;


_SuperMap2.default.ThemeLabelBackground = ThemeLabelBackground;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerTextStyle = __webpack_require__(16);

var _ServerTextStyle2 = _interopRequireDefault(_ServerTextStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelItem
 * @classdesc 分段标签专题图的子项。<br>
 *              标签专题图用专题值对点、线、面等对象做标注，值得注意的是，分段标签专题图允许用户通过 rangeExpression <br>
 *              字段指定用于分段的数值型字段，同一范围段内的标签具有相同的显示风格，其中每一个范围段就是一个专题图子项，<br>
 *              每一个子项都具有其名称、风格、起始值和终止值。注意：每个分段所表示的范围为 [Start, End)。例如：标签专题图的分段点有两个子项，<br>
 *              他们所代表的分段区间分别为[0,5)，[5,10)。那么需要分别设置 SuperMap.ThemeLabelItem[0].start=0，<br>
 *              SuperMap.ThemeLabelItem[0].end=5，SuperMap.ThemeLabelItem[1].start=5，SuperMap.ThemeLabelItem[1].end=10。
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 专题图子项的名称。<br>
 *        end - {number}标签专题图子项的终止值。<br>
 *        start - {number}标签专题图子项的分段起始值。<br>
 *        visible - {boolean} 标签专题图子项是否可见。<br>
 *        style - {SuperMap.ServerTextStyle} 标签专题图子项文本的显示风格。
 */
var ThemeLabelItem = function () {

    /**
     * @member SuperMap.ThemeLabelItem.prototype.visible -{boolean}
     * @description 标签专题图子项是否可见。如果标签专题图子项可见，则为 true，否则为 false。默认值为 true。
     */


    /**
     * @member SuperMap.ThemeLabelItem.prototype.end -{number}
     * @description 标签专题图子项的终止值。如果该子项是分段中最后一个子项，那么该终止值就是分段的最大值；
     *              如果不是最后一项，该终止值必须与其下一子项的起始值相同，否则系统抛出异常。默认为0。
     */
    function ThemeLabelItem(options) {
        _classCallCheck(this, ThemeLabelItem);

        this.caption = null;
        this.end = 0;
        this.start = 0;
        this.visible = true;
        this.style = null;
        this.CLASS_NAME = "SuperMap.ThemeLabelItem";

        var me = this;
        me.style = new _ServerTextStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeLabelItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeLabelItem.prototype.style -{SuperMap.ServerTextStyle}
     * @description 标签专题图子项文本的显示风格。各种风格的优先级从高到低为：<br>
     *              uniformMixedStyle（标签文本的复合风格），SuperMap.ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
     */


    /**
     * @member SuperMap.ThemeLabelItem.prototype.start -{number}
     * @description 标签专题图子项的分段起始值。如果该子项是分段中第一项，那么该起始值就是分段的最小值；
     *              如果该子项的序号大于等于 1 的时候，该起始值必须与前一子项的终止值相同，否则系统会抛出异常。默认为0。
     */


    /**
     * @member SuperMap.ThemeLabelItem.prototype.caption -{string}
     * @description 标签专题子项的标题。
     */


    _createClass(ThemeLabelItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.end = null;
            me.start = null;
            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeLabelItem.fromObj
         * @description 从传入对象获取分段标签专题图的子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabelItem}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var t = new ThemeLabelItem();
            _SuperMap2.default.Util.copy(t, obj);
            return t;
        }
    }]);

    return ThemeLabelItem;
}();

exports.default = ThemeLabelItem;


_SuperMap2.default.ThemeLabelItem = ThemeLabelItem;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerTextStyle = __webpack_require__(16);

var _ServerTextStyle2 = _interopRequireDefault(_ServerTextStyle);

var _LabelMixedTextStyle = __webpack_require__(217);

var _LabelMixedTextStyle2 = _interopRequireDefault(_LabelMixedTextStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelText
 * @classdesc 标签中文本风格类。
 *              通过该类可以设置标签中的文本字体大小和显示风格。
 * @param options - {Object} 可选参数。如：<br>
 *        maxTextHeight - {number}标签中文本的最大高度。<br>
 *        maxTextWidth - {number}标签中文本的最大宽度。<br>
 *        minTextHeight - {number}标签中文本的最小高度。<br>
 *        minTextWidth - {number}标签中文本的最小宽度。<br>
 *        uniformStyle - {SuperMap.ServerTextStyle} 统一文本风格。<br>
 *        uniformMixedStyle - {SuperMap.LabelMixedTextStyle} 标签专题图统一的文本复合风格。
 */
var ThemeLabelText = function () {

    /**
     * @member SuperMap.ThemeLabelText.prototype.uniformStyle -{SuperMap.ServerTextStyle}
     * @description 统一文本风格。当标签专题图子项的个数大于等于1时，
     *              uniformStyle 不起作用，各标签的风格使用子项中设置的风格。各种风格的优先级从高到低为：uniformMixedStyle（标签文本的复合风格），
     *              SuperMap.ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
     */


    /**
     * @member SuperMap.ThemeLabelText.prototype.minTextHeight -{number}
     * @description 标签中文本的最小高度。当标签文本不固定大小时，即 SuperMap.ServerTextStyle.sizeFixed = false 有效，
     *              当缩小后的文本高度小于最小高度之后就不再缩小。宽度单位为0.1毫米。默认为0毫米。
     */


    /**
     * @member SuperMap.ThemeLabelText.prototype.maxTextHeight -{number}
     * @description 标签中文本的最大高度。当标签文本不固定大小时，即 SuperMap.ServerTextStyle.sizeFixed = false 有效，
     *              当放大后的文本高度超过最大高度之后就不再放大。高度单位为0.1毫米。高度单位为0.1毫米。默认为 0 毫米。
     */
    function ThemeLabelText(options) {
        _classCallCheck(this, ThemeLabelText);

        this.maxTextHeight = 0;
        this.maxTextWidth = 0;
        this.minTextHeight = 0;
        this.minTextWidth = 0;
        this.uniformStyle = null;
        this.uniformMixedStyle = null;
        this.CLASS_NAME = "SuperMap.ThemeLabelText";

        var me = this;
        me.uniformStyle = new _ServerTextStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeLabelText.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     *@member SuperMap.ThemeLabelText.prototype.uniformMixedStyle -{SuperMap.LabelMixedTextStyle}
     *@description  标签专题图统一的文本复合风格。通过该类可以使同一个标
     *              签中的文字使用多种风格显示。各种风格的优先级从高到低为：uniformMixedStyle（标签文本的复合风格），
     *              SuperMap.ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
     */


    /**
     * @member SuperMap.ThemeLabelText.prototype.minTextWidth -{number}
     * @description 标签中文本的最小宽度。当标签文本不固定大小时，即 SuperMap.ServerTextStyle.sizeFixed = false 有效，
     *              当缩小后的文本宽度小于最小宽度之后就不再缩小。宽度单位为0.1毫米。默认为0毫米。
     */


    /**
     * @member SuperMap.ThemeLabelText.prototype.maxTextWidth -{number}
     * @description 标签中文本的最大宽度。当标签文本不固定大小时，即 SuperMap.ServerTextStyle.sizeFixed = false 有效，
     *              当放大后的文本宽度超过最大高度之后就不再放大。宽度单位为0.1毫米。默认为0毫米。
     */


    _createClass(ThemeLabelText, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.maxTextHeight = null;
            me.maxTextWidth = null;
            me.minTextHeight = null;
            me.minTextWidth = null;
            if (me.uniformStyle) {
                me.uniformStyle.destroy();
                me.uniformStyle = null;
            }
            if (me.uniformMixedStyle) {
                me.uniformMixedStyle.destroy();
                me.uniformMixedStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeLabelText.fromObj
         * @description 从传入对象获取标签中文本风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabelText}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeLabelText();
            _SuperMap2.default.Util.copy(res, obj);
            res.uniformStyle = _ServerTextStyle2.default.fromObj(obj.uniformStyle);
            res.uniformMixedStyle = _LabelMixedTextStyle2.default.fromObj(obj.uniformMixedStyle);
            return res;
        }
    }]);

    return ThemeLabelText;
}();

exports.default = ThemeLabelText;


_SuperMap2.default.ThemeLabelText = ThemeLabelText;

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerTextStyle = __webpack_require__(16);

var _ServerTextStyle2 = _interopRequireDefault(_ServerTextStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelUniqueItem
 * @classdesc 单值标签专题图的子项。<br>
 *              标签专题图用专题值对点、线、面等对象做标注，值得注意的是，单值标签专题图允许用户通过 uniqueExpression <br>
 *              字段指定用于单值的字段，同一值的标签具有相同的显示风格，其中每一个值就是一个专题图子项，<br>
 *              每一个子项都具有其名称、风格、指定的单值、X方向偏移量和Y方向偏移量。
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 专题图子项的名称。<br>
 *        unique - {string} 单值专题图子项的值，可以为数字、字符串等。<br>
 *        offsetX - {number}标签在X方向偏移量。<br>
 *        offsetY - {number}标签在Y方向偏移量。<br>
 *        visible - {boolean} 标签专题图子项是否可见。<br>
 *        style - {SuperMap.ServerTextStyle} 标签专题图子项文本的显示风格。
 */
var ThemeLabelUniqueItem = function () {

    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.visible -{boolean}
     * @description 标签专题图子项是否可见。如果标签专题图子项可见，则为 true，否则为 false。默认值为 true。
     */


    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.offsetX -{number}
     * @description 标签在X方向偏移量。
     */


    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.caption -{string}
     * @description 标签专题子项的标题。
     */
    function ThemeLabelUniqueItem(options) {
        _classCallCheck(this, ThemeLabelUniqueItem);

        this.caption = null;
        this.unique = null;
        this.offsetX = 0;
        this.offsetY = 0;
        this.visible = true;
        this.style = null;
        this.CLASS_NAME = "SuperMap.ThemeLabelUniqueItem";

        var me = this;
        me.style = new _ServerTextStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeLabelUniqueItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.style -{SuperMap.ServerTextStyle}
     * @description 标签专题图子项文本的显示风格。各种风格的优先级从高到低为：
     *              uniformMixedStyle（标签文本的复合风格），SuperMap.ThemeLabelUniqueItem.style（单值子项的文本风格），uniformStyle（统一文本风格）。
     */


    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.offsetY -{number}
     * @description 标签在Y方向偏移量。
     */


    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.unique -{string}
     * @description 单值专题图子项的值，可以为数字、字符串等。
     */


    _createClass(ThemeLabelUniqueItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.unique = null;
            me.caption = null;
            me.offsetX = null;
            me.offsetY = null;
            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeLabelUniqueItem.fromObj
         * @description 从传入对象获取单值标签专题图的子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabelUniqueItem}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var t = new ThemeLabelUniqueItem();
            _SuperMap2.default.Util.copy(t, obj);
            return t;
        }
    }]);

    return ThemeLabelUniqueItem;
}();

exports.default = ThemeLabelUniqueItem;


_SuperMap2.default.ThemeLabelUniqueItem = ThemeLabelUniqueItem;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeMemoryData
 * @classdesc 专题图内存数据类。
 * @param srcData - {Array} 原始值数组。
 * @param targetData - {Array} 外部值数组。
 */
var ThemeMemoryData = function () {

    /**
     * @member SuperMap.ThemeMemoryData.prototype.srcData -{Array}
     * @description 原始值数组，该属性值将被 targetData 属性所指定的值替换掉，然后制作专题图，但数据库中的值并不会改变。
     */
    function ThemeMemoryData(srcData, targetData) {
        _classCallCheck(this, ThemeMemoryData);

        this.srcData = null;
        this.targetData = null;
        this.CLASS_NAME = "SuperMap.ThemeMemoryData";

        if (srcData) {
            this.srcData = srcData;
        }
        if (targetData) {
            this.targetData = targetData;
        }
    }

    /**
     * @function SuperMap.ThemeMemoryData.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeMemoryData.prototype.targetData -{Array}
     * @description 外部值数组，即用于制作专题图的内存数据，设定该属性值后，会将 srcData 属性所指定的原始值替换掉制作专题图，但数据库中的值并不会改变。
     */


    _createClass(ThemeMemoryData, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.srcData = null;
            me.targetData = null;
        }

        /**
         * @function SuperMap.ThemeMemoryData.prototype.toJSON
         * @description 将 SuperMap.ThemeMemoryData 对象转化为json字符串。
         * @return {string} 返回转换后的 JSON 字符串。
         */

    }, {
        key: "toJSON",
        value: function toJSON() {
            if (this.srcData && this.targetData) {
                var memoryDataStr = "";
                var count = Math.min(this.srcData.length, this.targetData.length);
                for (var i = 0; i < count; i++) {
                    memoryDataStr += "\'" + this.srcData[i] + "\':\'" + this.targetData[i] + "\',";
                }
                //去除多余的逗号
                if (i > 0) {
                    memoryDataStr = memoryDataStr.substring(0, memoryDataStr.length - 1);
                }
                return "{" + memoryDataStr + "}";
            } else {
                return null;
            }
        }
    }]);

    return ThemeMemoryData;
}();

exports.default = ThemeMemoryData;


_SuperMap2.default.ThemeMemoryData = ThemeMemoryData;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _JoinItem = __webpack_require__(48);

var _JoinItem2 = _interopRequireDefault(_JoinItem);

var _ThemeDotDensity = __webpack_require__(69);

var _ThemeDotDensity2 = _interopRequireDefault(_ThemeDotDensity);

var _ThemeGraduatedSymbol = __webpack_require__(70);

var _ThemeGraduatedSymbol2 = _interopRequireDefault(_ThemeGraduatedSymbol);

var _ThemeGraph = __webpack_require__(71);

var _ThemeGraph2 = _interopRequireDefault(_ThemeGraph);

var _ThemeLabel = __webpack_require__(52);

var _ThemeLabel2 = _interopRequireDefault(_ThemeLabel);

var _ThemeRange = __webpack_require__(72);

var _ThemeRange2 = _interopRequireDefault(_ThemeRange);

var _ThemeUnique = __webpack_require__(73);

var _ThemeUnique2 = _interopRequireDefault(_ThemeUnique);

var _ThemeGridRange = __webpack_require__(247);

var _ThemeGridRange2 = _interopRequireDefault(_ThemeGridRange);

var _ThemeGridUnique = __webpack_require__(249);

var _ThemeGridUnique2 = _interopRequireDefault(_ThemeGridUnique);

var _LabelImageCell = __webpack_require__(216);

var _LabelImageCell2 = _interopRequireDefault(_LabelImageCell);

var _LabelSymbolCell = __webpack_require__(218);

var _LabelSymbolCell2 = _interopRequireDefault(_LabelSymbolCell);

var _LabelThemeCell = __webpack_require__(219);

var _LabelThemeCell2 = _interopRequireDefault(_LabelThemeCell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeParameters
 * @classdesc 专题图参数类。
 *               该类存储了制作专题所需的参数，包括数据源、数据集名称和专题图对象。
 * @param options - {Object} 可选参数。如：<br>
 *        datasetNames - {Array<string>} 要制作专题图的数据集数组，必设。<br>
 *        dataSourceNames - {Array<string>} 要制作专题图的数据集所在的数据源数组，必设。<br>
 *        joinItems - {Array<SuperMap.JoinItem>} 专题图外部表的连接信息 JoinItem 数组。<br>
 *        themes - {Array<SuperMap.Theme>} 专题图对象列表。<br>
 *        displayFilters -{Array<string>} 专题图属性过滤条件。<br>
 *        displayOrderBys -{Array<string>} 专题图对象生成符号叠加次序排序字段。<br>
 *        fieldValuesDisplayFilter -{Object} 图层要素的显示和隐藏的过滤属性，其带有三个属性，分别是:values、fieldName、fieldValuesDisplayMode。
 */
var ThemeParameters = function () {

    /**
     * @member SuperMap.ThemeParameters.prototype.displayOrderBys -{Array<string>}
     * @description 专题图对象生成符号叠加次序排序字段
     */


    /**
     * @member SuperMap.ThemeParameters.prototype.themes -{Array<SuperMap.Theme>}
     * @description 专题图对象列表。
     *               该参数为实例化的各类专题图对象的集合。
     */


    /**
     * @member SuperMap.ThemeParameters.prototype.dataSourceNames -{Array<string>}
     * @description 要制作专题图的数据集所在的数据源数组，必设。
     */
    function ThemeParameters(options) {
        _classCallCheck(this, ThemeParameters);

        this.datasetNames = null;
        this.dataSourceNames = null;
        this.joinItems = null;
        this.themes = null;
        this.displayFilters = null;
        this.displayOrderBys = null;
        this.fieldValuesDisplayFilter = null;
        this.CLASS_NAME = "SuperMap.ThemeParameters";

        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeParameters.prototype.fieldValuesDisplayFilter -{Object}
     * @description 图层要素的显示和隐藏的过滤属性，其带有三个属性，分别是:values、fieldName、fieldValuesDisplayMode,他们的作用如下：<br>
     *               values：{Array<number>} - 就是要过滤的值；<br>
     *               fieldName：{string} - 要过滤的字段名称 只支持数字类型的字段；<br>
     *               fieldValuesDisplayMode：{string} 目前有两个DISPLAY/DISABLE。当为DISPLAY时，表示只显示以上设置的相应属性值的要素，否则表示不显示以上设置的相应属性值的要素
     */


    /**
     * @member SuperMap.ThemeParameters.prototype.displayFilters -{Array<string>}
     * @description 专题图属性过滤条件。
     */


    /**
     * @member SuperMap.ThemeParameters.prototype.joinItems -{Array<SuperMap.JoinItem>}
     * @description 设置与外部表的连接信息 JoinItem 数组。
     *               使用此属性可以制作与外部表连接的专题图。
     */


    /**
     * @member SuperMap.ThemeParameters.prototype.datasetNames -{Array<string>}
     * @description 要制作专题图的数据集数组，必设。
     */


    _createClass(ThemeParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.datasetNames = null;
            me.dataSourceNames = null;
            if (me.joinItems) {
                for (var i = 0, joinItems = me.joinItems, len = joinItems.length; i < len; i++) {
                    joinItems[i].destroy();
                }
                me.joinItems = null;
            }
            if (me.themes) {
                for (var i = 0, themes = me.themes, len = themes.length; i < len; i++) {
                    themes[i].destroy();
                }
                me.themes = null;
            }
        }
    }]);

    return ThemeParameters;
}();

exports.default = ThemeParameters;


_SuperMap2.default.ThemeParameters = ThemeParameters;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeRangeItem
 * @classdesc 范围分段专题图子项类。<br>
 *              在分段专题图中，字段值按照某种分段模式被分成多个范围段，每个范围段即为一个子项，同一范围段的要素属于同一个分段专题图子项。
 *              每个子项都有其分段起始值、终止值、名称和风格等。每个分段所表示的范围为[start, end)。
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 分段专题图子项的标题。<br>
 *        end - {number}分段专题图子项的终止值。<br>
 *        start - {number}分段专题图子项的起始值。<br>
 *        style - {SuperMap.ServerStyle} 分段专题图子项的风格。<br>
 *        visible - {boolean} 分段专题图子项是否可见。
 */
var ThemeRangeItem = function () {

    /**
     * @member SuperMap.ThemeRangeItem.prototype.style -{SuperMap.ServerStyle}
     * @description 分段专题图子项的风格。
     *              每一个分段专题图子项都对应一种显示风格。
     */


    /**
     * @member SuperMap.ThemeRangeItem.prototype.end -{number}
     * @description 分段专题图子项的终止值，即该段专题值范围的最大值，默认值为 0。<br>
     *              如果该子项是分段中最后一个子项，则该终止值应大于分段字段（ThemeRange 类的 rangeExpression 属性）的最大值，若该终止值小于分段字段最大值，
     *              则剩余部分由内部随机定义其颜色；如果不是最后一项，该终止值必须与其下一子项的起始值相同，否则系统抛出异常；
     *              如果设置了范围分段模式和分段数，则会自动计算每段的范围[start, end)，故无需设置[start, end)；当然可以设置，那么结果就会按您设置的值对分段结果进行调整。
     */
    function ThemeRangeItem(options) {
        _classCallCheck(this, ThemeRangeItem);

        this.caption = null;
        this.end = 0;
        this.start = 0;
        this.style = null;
        this.visible = true;
        this.CLASS_NAME = "SuperMap.ThemeRangeItem";

        var me = this;
        me.style = new _ServerStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeRangeItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeRangeItem.prototype.visible -{boolean}
     * @description 分段专题图子项是否可见。默认为 true。
     */


    /**
     * @member SuperMap.ThemeRangeItem.prototype.start -{number}
     * @description 分段专题图子项的起始值，即该段专题值范围的最小值，默认值为 0。<br>
     *              如果该子项是分段中第一个子项，那么该起始值就是分段的最小值；如果子项的序号大于等于1的时候，该起始值必须与前一子项的终止值相同，否则系统会抛出异常。
     *              如果设置了范围分段模式和分段数，则会自动计算每段的范围[start, end)，故无需设置[start, end)；当然可以设置，那么结果就会按您设置的值对分段结果进行调整。
     */


    /**
     * @member SuperMap.ThemeRangeItem.prototype.caption -{string}
     * @description 分段专题图子项的标题。
     */


    _createClass(ThemeRangeItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.end = null;
            me.start = null;

            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeRangeItem.prototypetoServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _SuperMap2.default.Util.copyAttributes(obj, this);
            if (obj.style) {
                if (obj.style.toServerJSONObject) {
                    obj.style = obj.style.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeRangeItem.fromObj
         * @description 从传入对象获取范围分段专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeRangeItem}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) return;
            var res = new ThemeRangeItem();
            _SuperMap2.default.Util.copy(res, obj);
            res.style = _ServerStyle2.default.fromJson(obj.style);
            return res;
        }
    }]);

    return ThemeRangeItem;
}();

exports.default = ThemeRangeItem;


_SuperMap2.default.ThemeRangeItem = ThemeRangeItem;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeUniqueItem
 * @classdesc 单值专题图子项类。<br>
 *              单值专题图是将专题值相同的要素归为一类，为每一类设定一种渲染风格，其中每一类就是一个专题图子项。比如，利用单值专题图制作行政区划图，Name 字段代表
 *              省/直辖市名，该字段用来做专题变量，如果该字段的字段值总共有5种不同值，则该行政区划图有5个专题图子项。
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 单值专题图子项的标题。
 *        style - {SuperMap.ServerStyle} 单值专题图子项的风格。
 *        unique - {string} 单值专题图子项的单值。
 *        visible - {boolean} 单值专题图子项是否可见。
 */
var ThemeUniqueItem = function () {

    /**
     * @member SuperMap.ThemeUniqueItem.prototype.unique -{string}
     * @description 单值专题图子项的值，可以为数字、字符串等。
     */


    /**
     * @member SuperMap.ThemeUniqueItem.prototype.caption -{string}
     * @description 单值专题图子项的标题。
     */
    function ThemeUniqueItem(options) {
        _classCallCheck(this, ThemeUniqueItem);

        this.caption = null;
        this.style = null;
        this.unique = null;
        this.visible = true;
        this.CLASS_NAME = "SuperMap.ThemeUniqueItem";

        var me = this;
        me.style = new _ServerStyle2.default();
        if (options) {
            _SuperMap2.default.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.ThemeUniqueItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.ThemeUniqueItem.prototype.visible -{boolean}
     * @description 单值专题图子项的可见性。默认为 true，表示可见。
     */


    /**
     * @member SuperMap.ThemeUniqueItem.prototype.style -{SuperMap.ServerStyle}
     * @description 单值专题图子项的显示风格。
     */


    _createClass(ThemeUniqueItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.unique = null;

            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeUniqueItem.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _SuperMap2.default.Util.copyAttributes(obj, this);
            if (obj.style) {
                if (obj.style.toServerJSONObject) {
                    obj.style = obj.style.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeUniqueItem.fromObj
         * @description 从传入对象获取单值专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeUniqueItem}
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeUniqueItem();
            _SuperMap2.default.Util.copy(res, obj);
            res.style = _ServerStyle2.default.fromJson(obj.style);
            return res;
        }
    }]);

    return ThemeUniqueItem;
}();

exports.default = ThemeUniqueItem;


_SuperMap2.default.ThemeUniqueItem = ThemeUniqueItem;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TransferLine
 * @classdesc 换乘路线信息类。
 * @param options - {Object} 可选参数。如:</br>
 *        lineID - {string} 乘车路线名称。</br>
 *        lineName - {string} 乘车路线名称。</br>
 *        lineAliasName - {string} 乘车路线别名。</br>
 *        startStopIndex - {number}上车站点在本公交路线中的索引。</br>
 *        startStopName - {string} 上车站点名称。</br>
 *        startStopAliasName - {string} 上车站点别名。</br>
 *        endStopIndex - {number}下车站点在本公交路线中的索引</br>
 *        endStopName - {string} 下车站点名称。</br>
 *        endStopAliasName - {string} 下车站点别名。</br>
 */
var TransferLine = function () {

    /**
     * @memberSuperMap.TransferLine.prototype.endStopName -{string}
     * @description 下车站点名称。
     */


    /**
     * @memberSuperMap.TransferLine.prototype.startStopAliasName -{string}
     * @description 上车站点别名。
     */


    /**
     * @memberSuperMap.TransferLine.prototype.startStopIndex -{number}
     * @description 上车站点在本公交路线中的索引。
     */


    /**
     * @memberSuperMap.TransferLine.prototype.lineName -{string}
     * @description 乘车路线名称。
     */
    function TransferLine(options) {
        _classCallCheck(this, TransferLine);

        this.lineID = null;
        this.lineName = null;
        this.lineAliasName = null;
        this.startStopIndex = null;
        this.startStopName = null;
        this.startStopAliasName = null;
        this.endStopIndex = null;
        this.endStopName = null;
        this.endStopAliasName = null;
        this.CLASS_NAME = "SuperMap.TransferLine";

        options = options || {};
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.TransferLine.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @memberSuperMap.TransferLine.prototype.endStopAliasName -{string}
     * @description 下车站点别名。
     */


    /**
     * @memberSuperMap.TransferLine.prototype.endStopIndex -{number}
     * @description 下车站点在本公交路线中的索引。
     */


    /**
     * @memberSuperMap.TransferLine.prototype.startStopName -{string}
     * @description 上车站点名称。
     */


    /**
     * @memberSuperMap.TransferLine.prototype.lineAliasName -{string}
     * @description 乘车路线别名。
     */

    /**
     * @memberSuperMap.TransferLine.prototype.lineID -{number}
     * @description 乘车路线名称。
     */


    _createClass(TransferLine, [{
        key: 'destroy',
        value: function destroy() {
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.TransferLine.fromJson
         * @description 将返回结果转化为 SuperMap.TransferLine 对象。
         * @param jsonObject - {Object} 新的返回结果。
         * @return {SuperMap.TransferLine} 转化后的 SuperMap.TransferLine 对象。
         */

    }], [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }
            return new TransferLine({
                lineID: jsonObject['lineID'],
                lineName: jsonObject['lineName'],
                lineAliasName: jsonObject['lineAliasName'],
                startStopIndex: jsonObject['startStopIndex'],
                startStopName: jsonObject['startStopName'],
                startStopAliasName: jsonObject['startStopAliasName'],
                endStopIndex: jsonObject['endStopIndex'],
                endStopName: jsonObject['endStopName'],
                endStopAliasName: jsonObject['endStopAliasName']
            });
        }
    }]);

    return TransferLine;
}();

exports.default = TransferLine;


_SuperMap2.default.TransferLine = TransferLine;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _TransferLine = __webpack_require__(260);

var _TransferLine2 = _interopRequireDefault(_TransferLine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TransferPathParameters
 * @classdesc 交通换乘线路查询参数类。
 * @param options - {Object} 参数。如:</br>
 *        transferLines - {Array<SuperMap.TransferLine>} 本换乘分段内可乘车的路线集合。</br>
 *        points - {Array<Integer>} 两种查询方式：按照公交站点的起止ID进行查询和按照起止点的坐标进行查询。</br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
 *
 */
var TransferPathParameters = function () {
    /**
     * @member SuperMap.TransferPathParameters.prototype.transferLines -{Array<SuperMap.TransferLine>}
     * @description 本换乘分段内可乘车的路线集合，通过交通换乘方案查询得到
     */
    function TransferPathParameters(options) {
        _classCallCheck(this, TransferPathParameters);

        this.transferLines = null;
        this.points = false;
        this.CLASS_NAME = "SuperMap.TransferPathParameters";

        options = options || {};
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.TransferPathParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     *  @member SuperMap.TransferPathParameters.prototype.points -{Array<string>}|{Array<Object>}
     *  @description 点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
     *  两种查询方式：
     *           1. 按照公交站点的起止ID进行查询，则points参数的类型为int[]，形如：[起点ID、终点ID]，公交站点的ID对应服务提供者配置中的站点ID字段；
     *           2. 按照起止点的坐标进行查询，则points参数的类型为Point2D[]，形如：[{"x":44,"y":39},{"x":45,"y":40}]。
     */


    _createClass(TransferPathParameters, [{
        key: 'destroy',
        value: function destroy() {
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.TransferPathParameters.toJson
         * @description 将 <SuperMap.TransferPathParameters> 对象参数转换为 json 字符串。
         * @param params - {SuperMap.TransferPathParameters} 交通换乘参数。
         * @returns {string} 转化后的 json字符串。
         */

    }], [{
        key: 'toJson',
        value: function toJson(params) {
            if (params) {
                return _SuperMap2.default.Util.toJSON(params);
            }
        }
    }]);

    return TransferPathParameters;
}();

exports.default = TransferPathParameters;


_SuperMap2.default.TransferPathParameters = TransferPathParameters;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TransferSolutionParameters
 * @classdesc 交通换乘方案查询参数类。
 * @param options - {Object} 参数。如:</br>
 *        solutionCount - {boolean} 乘车方案的数量。默认为6。</br>
 *        transferTactic - {SuperMap.TransferTactic} 交通换乘策略类型，
 *                      包括时间最短、距离最短、最少换乘、最少步行四种选择。</br>
 *        transferPreference - {SuperMap.TransferPreference} 乘车偏好枚举。</br>
 *        walkingRatio - {Array<number>} 步行与公交的消耗权重比，默认值为 10。</br>
 *        points - {Array<number>} 两种查询方式：按照公交站点的起止ID进行查询和按照起止点的坐标进行查询。</br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
 *        evadeLines - {Array<number>} 避让路线的ID，默认为null。</br>
 *        evadeStops - {Array<number>} 避让站点的ID，默认为null。</br>
 *        priorLines - {Array<number>} 优先路线的ID，默认为null。</br>
 *        priorStops - {Array<number>} 优先站点的ID，默认为null。</br>
 *        travelTime - {string} 出行的时间。</br>
 */
var TransferSolutionParameters = function () {

    /**
     * @member SuperMap.TransferSolutionParameters.prototype.priorStops -{Array<number>}
     * @description 优先站点ID。
     * */


    /**
     * @member SuperMap.TransferSolutionParameters.prototype.evadeStops -{Array<number>}
     * @description 避让站点ID。
     * */


    /**
     *  @member SuperMap.TransferSolutionParameters.prototype.points - {Array<String>}|{Array<Object>}
     *  @description 点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
     *  两种查询方式：
     *           1. 按照公交站点的起止ID进行查询，则points参数的类型为int[]，形如：[起点ID、终点ID]，公交站点的ID对应服务提供者配置中的站点ID字段；
     *           2. 按照起止点的坐标进行查询，则points参数的类型为Point2D[]，形如：[{"x":44,"y":39},{"x":45,"y":40}]。
     */


    /**
     *  @member SuperMap.TransferSolutionParameters.prototype.transferTactic - {SuperMap.TransferTactic}
     *  @description 交通换乘策略类型，包括时间最短、距离最短、最少换乘、最少步行四种选择。默认为SuperMap.TransferTactic.LESS_TIME
     */


    /**
     *  @member SuperMap.TransferSolutionParameters.prototype.solutionCount -{number}
     *  @description 乘车方案的数量。默认为6。
     */
    function TransferSolutionParameters(options) {
        _classCallCheck(this, TransferSolutionParameters);

        this.solutionCount = 6;
        this.transferPreference = _REST.TransferPreference.NONE;
        this.transferTactic = _REST.TransferTactic.LESS_TIME;
        this.walkingRatio = null;
        this.points = false;
        this.evadeLines = null;
        this.evadeStops = null;
        this.priorLines = null;
        this.priorStops = null;
        this.travelTime = null;
        this.CLASS_NAME = "SuperMap.TransferSolutionParameters";

        options = options || {};
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.TransferSolutionParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.TransferSolutionParameters.prototype.travelTime -{string}
     * @description 出行的时间； 格式是："小时:分钟"，如："08:30"。如果设置了该参数，在分析时，则会考虑线路的首末班车时间的限制，即在返回的结果中会提示公交的首末班发车时间。
     */


    /**
     * @member SuperMap.TransferSolutionParameters.prototype.priorLines -{Array<number>}
     * @description 优先路线ID。
     * */


    /**
     * @member SuperMap.TransferSolutionParameters.prototype.evadeLines -{Array<number>}
     * @description 避让路线ID。
     * */


    /**
     *  @member SuperMap.TransferSolutionParameters.prototype.walkingRatio - {number}
     *  @description 步行与公交的消耗权重比，默认值为 10。此值越大，则步行因素对于方案选择的影响越大。例如：</br>
     * 例如现在有两种换乘方案（在仅考虑消耗因素的情况下）：</br>
     * 方案1：坐车10公里，走路1公里；</br>
     * 方案2：坐车15公里，走路0.5公里；</br>
     *      1. 假设权重比为15：
     *          •方案1的总消耗为：10 + 1*15 = 25
     *          •方案2的总消耗为：15 + 0.5*15 = 22.5
     *          此时方案2消耗更低。
     *      2. 假设权重比为2：
     *          •方案1的总消耗为：10+1*2 = 12
     *          •方案2的总消耗为：15+0.5*2 = 17
     *          此时方案1消耗更低。
     */

    /**
     * @member SuperMap.TransferSolutionParameters.prototype.transferPreference -{SuperMap.TransferPreference}
     *  @description 乘车偏好枚举。默认为SuperMap.TransferPreference.NONE
     */


    _createClass(TransferSolutionParameters, [{
        key: 'destroy',
        value: function destroy() {
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.TransferSolutionParameters.toJsonParameters
         * @description 将 <SuperMap.TransferSolutionParameters> 对象参数转换为 json 字符串。
         * @param  params - {SuperMap.TransferSolutionParameters} 交通换乘参数。
         * @return {string} 转化后的 json字符串。
         */

    }], [{
        key: 'toJson',
        value: function toJson(params) {
            if (params) {
                return _SuperMap2.default.Util.toJSON(params);
            }
        }
    }]);

    return TransferSolutionParameters;
}();

exports.default = TransferSolutionParameters;


_SuperMap2.default.TransferSolutionParameters = TransferSolutionParameters;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** * @class SuperMap.TransportationAnalystResultSetting * @classdesc 交通网络分析结果参数类。 *            通过该类设置交通网络分析返回的结果，包括是否返回图片、是否返回弧段空间信息、是否返回结点空间信息等。 * @param options - {Object} 可选参数。如:</br> *        returnEdgeFeatures - {boolean} 是否在分析结果中包含弧段要素集合。</br> *        returnEdgeGeometry - {boolean} 返回的弧段要素集合中是否包含几何对象信息。默认为 false。</br> *        returnEdgeIDs - {boolean} 返回结果中是否包含经过弧段 ID 集合。默认为 false。</br> *        returnNodeFeatures - {boolean} 是否在分析结果中包含结点要素集合。</br> *        returnNodeGeometry - {boolean} 返回的结点要素集合中是否包含几何对象信息。默认为 false。</br> *        returnNodeIDs - {boolean} 返回结果中是否包含经过结点 ID 集合。默认为 false。</br> *        returnPathGuides - {boolean} 返回分析结果中是否包含行驶导引集合。</br> *        returnRoutes - {boolean} 返回分析结果中是否包含路由对象的集合。 */
var TransportationAnalystResultSetting = function () {

  /**     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnPathGuides -{boolean}     * @description 返回分析结果中是否包含行驶导引集合。     */


  /**     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnNodeGeometry -{boolean}     * @description 返回的结点要素集合中是否包含几何对象信息。默认为 false。     */


  /**     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnEdgeIDs -{boolean}     * @description 返回结果中是否包含经过弧段 ID 集合。默认为 false。     */


  /**     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnEdgeFeatures -{boolean}     * @description 是否在分析结果中包含弧段要素集合。弧段要素包括弧段的空间信息和属性信息。     */
  function TransportationAnalystResultSetting(options) {
    _classCallCheck(this, TransportationAnalystResultSetting);

    this.returnEdgeFeatures = false;
    this.returnEdgeGeometry = false;
    this.returnEdgeIDs = false;
    this.returnNodeFeatures = false;
    this.returnNodeGeometry = false;
    this.returnNodeIDs = false;
    this.returnPathGuides = false;
    this.returnRoutes = false;
    this.CLASS_NAME = "SuperMap.TransportationAnalystResultSetting";

    if (!options) {
      return;
    }
    _SuperMap2.default.Util.extend(this, options);
  }

  /**     * @function SuperMap.TransportationAnalystResultSetting.prototype.destroy     * @description 释放资源，将引用资源的属性置空。     */


  /**     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnRoutes -{boolean}     * @description 返回分析结果中是否包含路由对象的集合。     */


  /**     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnNodeIDs -{boolean}     * @description 返回结果中是否包含经过结点 ID 集合。默认为 false。     */


  /**     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnNodeFeatures -{boolean}     * @description 是否在分析结果中包含结点要素集合。     * 结点要素包括结点的空间信息和属性信息。其中返回的结点要素是否包含空间信息可通过 returnNodeGeometry 字段设置。默认为 false。     */


  /**     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnEdgeGeometry -{boolean}     * @description 返回的弧段要素集合中是否包含几何对象信息。默认为 false。     */


  _createClass(TransportationAnalystResultSetting, [{
    key: "destroy",
    value: function destroy() {
      var me = this;
      me.returnEdgeFeatures = null;
      me.returnEdgeGeometry = null;
      me.returnEdgeIDs = null;
      me.returnNodeFeatures = null;
      me.returnNodeGeometry = null;
      me.returnNodeIDs = null;
      me.returnPathGuides = null;
      me.returnRoutes = null;
    }
  }]);

  return TransportationAnalystResultSetting;
}();

exports.default = TransportationAnalystResultSetting;

_SuperMap2.default.TransportationAnalystResultSetting = TransportationAnalystResultSetting;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.UGCLayer
 * @classdesc UGC 图层类。
 * @param options - {Object} 可选参数。如：<br>
 *        bounds - {SuperMap.Bounds} 图层范围。<br>
 *        caption - {string} 图层的标题。<br>
 *        description - {string} 图层的描述信息。<br>
 *        name - {string} 图层的名称。<br>
 *        queryable - {boolean} 图层中的对象是否可以查询。<br>
 *        subUGCLayers - {boolean} 是否允许图层的符号大小随图缩放。<br>
 *        type - {SuperMap.UGCLayerType} 图层类型。<br>
 *        visible - {boolean} 地图对象在同一范围内时，是否重叠显示，默认为False。
 */
var UGCLayer = function () {

    /**
     * @member SuperMap.UGCLayer.prototype.type -{SuperMap.UGCLayerType}
     * @description 图层类型。
     */


    /**
     * @member SuperMap.UGCLayer.prototype.queryable -{boolean}
     * @description 图层中的对象是否可以查询。
     */


    /**
     * @member SuperMap.UGCLayer.prototype.description -{string}
     * @description 图层的描述信息。
     */


    /**
     * @member SuperMap.UGCLayer.prototype.bounds -{SuperMap.Bounds}
     * @description 图层范围。
     */
    function UGCLayer(options) {
        _classCallCheck(this, UGCLayer);

        this.bounds = null;
        this.caption = null;
        this.description = null;
        this.name = null;
        this.queryable = null;
        this.subLayers = null;
        this.type = null;
        this.visible = null;
        this.CLASS_NAME = "SuperMap.UGCLayer";

        options = options ? options : {};
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.UGCLayer.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.UGCLayer.prototype.visible -{boolean}
     * @description 图层是否可视。
     */


    /**
     * @member SuperMap.UGCLayer.prototype.subLayers -{Array}
     * @description 子图层集。
     */


    /**
     * @member SuperMap.UGCLayer.prototype.name -{string}
     * @description 图层的名称。
     */


    /**
     * @member SuperMap.UGCLayer.prototype.caption -{string}
     * @description 图层的标题。
     */


    _createClass(UGCLayer, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            _SuperMap2.default.Util.reset(me);
        }

        /**
         * @function SuperMap.UGCLayer.prototype.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }, {
        key: "fromJson",
        value: function fromJson(jsonObject) {
            jsonObject = jsonObject ? jsonObject : {};
            _SuperMap2.default.Util.extend(this, jsonObject);
            var b = this.bounds;
            if (b) {
                this.bounds = new _SuperMap2.default.Bounds(b.leftBottom.x, b.leftBottom.y, b.rightTop.x, b.rightTop.y);
            }
        }

        /**
         * @function SuperMap.UGCLayer.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: "toServerJSONObject",
        value: function toServerJSONObject() {
            var jsonObject = {};
            jsonObject = _SuperMap2.default.Util.copyAttributes(jsonObject, this);
            if (jsonObject.bounds) {
                if (jsonObject.bounds.toServerJSONObject) {
                    jsonObject.bounds = jsonObject.bounds.toServerJSONObject();
                }
            }
            return jsonObject;
        }
    }]);

    return UGCLayer;
}();

exports.default = UGCLayer;


_SuperMap2.default.UGCLayer = UGCLayer;

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _UGCLayer2 = __webpack_require__(264);

var _UGCLayer3 = _interopRequireDefault(_UGCLayer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.UGCMapLayer
 * @classdesc UGC 地图图层类。
 * @extends SuperMap.UGCLayer
 * @param options - {Object} 可选参数。如：<br>
 *        completeLineSymbolDisplayed - {boolean} 是否显示完整线型。<br>
 *        maxScale - {number}地图最大比例尺。<br>
 *        minScale - {number}地图最小比例尺。<br>
 *        minVisibleGeometrySize - {number}几何对象的最小可见大小，以像素为单位。<br>
 *        opaqueRate - {Integer} 图层的不透明度。<br>
 *        symbolScalable - {boolean} 是否允许图层的符号大小随图缩放。<br>
 *        symbolScale - {number}图层的符号缩放基准比例尺。<br>
 *        overlapDisplayed - {boolean} 地图对象在同一范围内时，是否重叠显示，默认为False。<br>
 *        overlapDisplayedOptions - {SuperMap.OverlapDisplayedOptions} 地图的压盖过滤显示选项，当
 *                                   overlapDisplayed 为 false 时有效。
 */
var UGCMapLayer = function (_UGCLayer) {
    _inherits(UGCMapLayer, _UGCLayer);

    /*
     * Constructor: SuperMap.UGCMapLayer
     * UGC 地图图层类构造函数。
     */


    /**
     * @member SuperMap.UGCMapLayer.prototype.overlapDisplayed -{boolean}
     * @description 地图对象在同一范围内时，是否重叠显示，默认为False。
     */

    /**
     * @member SuperMap.UGCMapLayer.prototype.symbolScalable -{boolean}
     * @description 是否允许图层的符号大小随图缩放。
     */


    /**
     * @member SuperMap.UGCMapLayer.prototype.minVisibleGeometrySize -{number}
     * @description 几何对象的最小可见大小，以像素为单位。
     */


    /**
     * @member SuperMap.UGCMapLayer.prototype.maxScale -{number}
     * @description 地图最大比例尺。
     */
    function UGCMapLayer(options) {
        _classCallCheck(this, UGCMapLayer);

        options = options || {};

        var _this = _possibleConstructorReturn(this, (UGCMapLayer.__proto__ || Object.getPrototypeOf(UGCMapLayer)).call(this, options));

        _this.completeLineSymbolDisplayed = null;
        _this.maxScale = null;
        _this.minScale = null;
        _this.minVisibleGeometrySize = null;
        _this.opaqueRate = null;
        _this.symbolScalable = null;
        _this.symbolScale = null;
        _this.overlapDisplayed = null;
        _this.overlapDisplayedOptions = null;
        _this.CLASS_NAME = "SuperMap.UGCMapLayer";
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.UGCMapLayer.prototype.overlapDisplayedOptions -{SuperMap.OverlapDisplayedOptions}
     * @description 地图的压盖过滤显示选项，当 overlapDisplayed 为 false 时有效。
     */


    /**
     * @member SuperMap.UGCMapLayer.prototype.symbolScale -{number}
     * @description 图层的符号缩放基准比例尺。
     */


    /**
     * @member SuperMap.UGCMapLayer.prototype.opaqueRate -{Integer}
     * @description 图层的不透明度。
     */


    /**
     * @member SuperMap.UGCMapLayer.prototype.minScale -{number}
     * @description 地图最小比例尺。
     */


    /**
     * @member SuperMap.UGCMapLayer.prototype.completeLineSymbolDisplayed -{boolean}
     * @description 是否显示完整线型。
     */


    _createClass(UGCMapLayer, [{
        key: 'destroy',
        value: function destroy() {
            _get(UGCMapLayer.prototype.__proto__ || Object.getPrototypeOf(UGCMapLayer.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.UGCMapLayer.prototype.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }, {
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(UGCMapLayer.prototype.__proto__ || Object.getPrototypeOf(UGCMapLayer.prototype), 'fromJson', this).call(this, jsonObject);
        }

        /**
         * @function SuperMap.UGCMapLayer.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            return _get(UGCMapLayer.prototype.__proto__ || Object.getPrototypeOf(UGCMapLayer.prototype), 'toServerJSONObject', this).call(this);
        }
    }]);

    return UGCMapLayer;
}(_UGCLayer3.default);

exports.default = UGCMapLayer;


_SuperMap2.default.UGCMapLayer = UGCMapLayer;

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.UpdateEdgeWeightParameters
 * @classdesc 边的耗费权重更新服务参数类。
 * @param options - {Object} 可选参数。如：<br>
 *        edgeId - {string} 所在边的id。<br>
 *        fromNodeId - {string} 起始转向点的id。<br>
 *        toNodeId - {string} 终止转向点的id。<br>
 *        weightField - {string} 边的耗费字段。<br>
 *        edgeWeight - {string} 耗费权重。
 */
var UpdateEdgeWeightParameters = function () {

    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.weightField -{string}
     * @description 边的耗费字段
     */


    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.fromNodeId -{string}
     * @description 起始转向点的id
     */
    function UpdateEdgeWeightParameters(option) {
        _classCallCheck(this, UpdateEdgeWeightParameters);

        this.edgeId = "";
        this.fromNodeId = "";
        this.toNodeId = "";
        this.weightField = "";
        this.edgeWeight = "";
        this.CLASS_NAME = "SuperMap.UpdateEdgeWeightParameters";

        if (!option) return;

        option.edgeId && (this.edgeId = option.edgeId);
        option.fromNodeId && (this.fromNodeId = option.fromNodeId);
        option.toNodeId && (this.toNodeId = option.toNodeId);
        option.weightField && (this.weightField = option.weightField);
        option.edgeWeight && (this.edgeWeight = option.edgeWeight);
    }

    /**
     * @function SuperMap.UpdateEdgeWeightParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.edgeWeight -{string}
     * @description 耗费权重
     */


    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.toNodeId -{string}
     * @description 终止转向点的id
     */


    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.edgeId -{string}
     * @description 所在边的id
     */


    _createClass(UpdateEdgeWeightParameters, [{
        key: "destroy",
        value: function destroy() {
            this.edgeId = null;
            this.fromNodeId = null;
            this.toNodeId = null;
            this.weightField = null;
            this.edgeWeight = null;
        }
    }]);

    return UpdateEdgeWeightParameters;
}();

exports.default = UpdateEdgeWeightParameters;


_SuperMap2.default.UpdateEdgeWeightParameters = UpdateEdgeWeightParameters;

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.UpdateTurnNodeWeightParameters
 * @classdesc 转向耗费权重更新服务参数类
 * @param options - {Object} 可选参数。如：<br>
 *         nodeId - {string} 转向结点的id。<br>
 *        fromEdgeId - {string} 起始边的id。<br>
 *        toEdgeId - {string} 终止边的id。<br>
 *        weightField - {string} 转向结点的耗费字段。<br>
 *        turnNodeWeight - {string} 耗费权重
 */
var UpdateTurnNodeWeightParameters = function () {

    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.weightField -{string}
     * @description 转向结点的耗费字段
     */


    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.fromEdgeId -{string}
     * @description 起始边的id
     */
    function UpdateTurnNodeWeightParameters(option) {
        _classCallCheck(this, UpdateTurnNodeWeightParameters);

        this.nodeId = "";
        this.fromEdgeId = "";
        this.toEdgeId = "";
        this.weightField = "";
        this.turnNodeWeight = "";
        this.CLASS_NAME = "SuperMap.UpdateTurnNodeWeightParameters";

        if (!option) return;

        option.nodeId && (this.nodeId = option.nodeId);
        option.fromEdgeId && (this.fromEdgeId = option.fromEdgeId);
        option.toEdgeId && (this.toEdgeId = option.toEdgeId);
        option.weightField && (this.weightField = option.weightField);
        option.turnNodeWeight && (this.turnNodeWeight = option.turnNodeWeight);
    }

    /**
     * @function SuperMap.UpdateTurnNodeWeightParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.turnNodeWeight -{string}
     * @description 耗费权重
     */


    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.toEdgeId -{string}
     * @description 终止边的id
     */


    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.nodeId -{string}
     * @description 转向结点的id
     */


    _createClass(UpdateTurnNodeWeightParameters, [{
        key: "destroy",
        value: function destroy() {
            this.nodeId = null;
            this.fromEdgeId = null;
            this.toEdgeId = null;
            this.weightField = null;
            this.turnNodeWeight = null;
        }
    }]);

    return UpdateTurnNodeWeightParameters;
}();

exports.default = UpdateTurnNodeWeightParameters;


_SuperMap2.default.UpdateTurnNodeWeightParameters = UpdateTurnNodeWeightParameters;

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _UGCSubLayer2 = __webpack_require__(40);

var _UGCSubLayer3 = _interopRequireDefault(_UGCSubLayer2);

var _ServerStyle = __webpack_require__(8);

var _ServerStyle2 = _interopRequireDefault(_ServerStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Vector
 * @classdesc UGC 矢量图层类。
 * @extends SuperMap.UGCSubLayer
 * @param options - {Object} 可选参数。如：<br>
 *        style - {SuperMap.ServerStyle} 矢量图层的风格。
 */

var Vector = function (_UGCSubLayer) {
    _inherits(Vector, _UGCSubLayer);

    function Vector(options) {
        _classCallCheck(this, Vector);

        options = options || {};

        var _this = _possibleConstructorReturn(this, (Vector.__proto__ || Object.getPrototypeOf(Vector)).call(this, options));

        _this.style = null;
        _this.CLASS_NAME = "SuperMap.Vector";
        return _this;
    }

    /**
     * @inheritDoc
     */


    /**
     * @member SuperMap.Vector.prototype.style -{SuperMap.ServerStyle}
     * @description 矢量图层的风格。
     */


    _createClass(Vector, [{
        key: 'destroy',
        value: function destroy() {
            _get(Vector.prototype.__proto__ || Object.getPrototypeOf(Vector.prototype), 'destroy', this).call(this);
            _SuperMap2.default.Util.reset(this);
        }

        /**
         * @function SuperMap.Vector.prototype.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }, {
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(Vector.prototype.__proto__ || Object.getPrototypeOf(Vector.prototype), 'fromJson', this).call(this, jsonObject);
            var sty = this.style;
            if (sty) {
                this.style = new _ServerStyle2.default(sty);
            }
        }

        /**
         * @function SuperMap.Vector.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var jsonObject = _SuperMap2.default.toServerJSONObject();
            if (jsonObject.style) {
                if (jsonObject.style.toServerJSONObject) {
                    jsonObject.style = jsonObject.style.toServerJSONObject();
                }
            }
            return jsonObject;
        }
    }]);

    return Vector;
}(_UGCSubLayer3.default);

exports.default = Vector;


_SuperMap2.default.Vector = Vector;

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.VectorClipJobsParameter
 * @classdesc 矢量裁剪分析任务参数类
 * @param options - {Object} 必填参数。<br>
 *         datasetName -{string} 数据集名。 <br>
 *         datasetOverlay -{string} 裁剪对象数据集。 <br>
 *         mode -{SuperMap.SpatialQueryMode} 裁剪分析模式 。 <br>
 */
var VectorClipJobsParameter = function () {

    /**
     * @member SuperMap.VectorClipJobsParameter.prototype.datasetOverlay -{string}
     * @description 裁剪对象数据集。
     */
    function VectorClipJobsParameter(options) {
        _classCallCheck(this, VectorClipJobsParameter);

        this.datasetName = "";
        this.datasetOverlay = "";
        this.mode = _REST.ClipAnalystMode.CLIP;
        this.CLASS_NAME = "SuperMap.VectorClipJobsParameter";

        options = options || {};
        if (options.mode && typeof options.mode === "string") {
            options.mode = options.mode.toLowerCase();
        }
        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.VectorClipJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    /**
     * @member SuperMap.VectorClipJobsParameter.prototype.mode -{SuperMap.ClipAnalystMode}
     * @description 裁剪分析模式 。
     */


    /**
     * @member SuperMap.VectorClipJobsParameter.prototype.datasetName -{string}
     * @description 数据集名。
     */


    _createClass(VectorClipJobsParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.datasetOverlay = null;
            this.mode = null;
        }
        /**
         * @function SuperMap.VectorClipJobsParameter.toObject
         * @param vectorClipJobsParameter -{Object} 区域汇总分析服务参数
         * @param tempObj - {Object} 目标对象。
         * @description 矢量裁剪分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(vectorClipJobsParameter, tempObj) {
            for (var name in vectorClipJobsParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = vectorClipJobsParameter[name];
                    continue;
                }
                tempObj['analyst'] = tempObj['analyst'] || {};
                tempObj['analyst'][name] = vectorClipJobsParameter[name];
            }
        }
    }]);

    return VectorClipJobsParameter;
}();

exports.default = VectorClipJobsParameter;


_SuperMap2.default.VectorClipJobsParameter = VectorClipJobsParameter;

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.KeyServiceParameter
 * @classdesc key申请参数
 * @param options - {Object} 参数。如：<br>
 *        name - {string} 申请服务名称。<br>
 *        serviceIds - {number}服务ID。<br>
 *        clientType - {ClientType} 服务端类型。<br>
 *        limitation - {number}有效期
 */
var KeyServiceParameter = function () {
    function KeyServiceParameter(options) {
        _classCallCheck(this, KeyServiceParameter);

        this.name = null;
        this.serviceIds = null;
        this.clientType = _REST.ClientType.SERVER;
        this.limitation = null;
        this.CLASS_NAME = "SuperMap.KeyServiceParameter";

        _SuperMap2.default.Util.extend(this, options);
    }

    /**
     * @function SuperMap.KeyServiceParameter.prototype.toJSON
     * @description 转换成JSON对象
     * @return {Object} 参数的JSON对象
     */


    _createClass(KeyServiceParameter, [{
        key: 'toJSON',
        value: function toJSON() {
            return {
                name: this.name,
                serviceIds: this.serviceIds,
                clientType: this.clientType,
                limitation: this.limitation
            };
        }
    }]);

    return KeyServiceParameter;
}();

exports.default = KeyServiceParameter;


_SuperMap2.default.KeyServiceParameter = KeyServiceParameter;

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _ServerInfo = __webpack_require__(272);

var _ServerInfo2 = _interopRequireDefault(_ServerInfo);

var _TokenServiceParameter = __webpack_require__(273);

var _TokenServiceParameter2 = _interopRequireDefault(_TokenServiceParameter);

var _KeyServiceParameter = __webpack_require__(270);

var _KeyServiceParameter2 = _interopRequireDefault(_KeyServiceParameter);

var _FetchRequest = __webpack_require__(41);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class SuperMap.SecurityManager
 * @classdesc
 *  安全管理中心
 *  提供iServer,iPortal,Online统一权限认证管理
 *  使用说明：
 *  创建任何一个服务之前调用SuperMap.SecurityManager.registerToken或
 *  SuperMap.SecurityManager.registerKey注册凭据。
 *  发送请求时根据url或者服务id获取相应的key或者token并自动添加到服务地址中
 */
_SuperMap2.default.SecurityManager = {

    INNER_WINDOW_WIDTH: 600,
    INNER_WINDOW_HEIGHT: 600,
    /**
     * @function SuperMap.SecurityManager.prototype.generateToken
     * @description 从服务器获取一个token,在此之前要注册服务器信息
     * @param url {string}-服务器域名+端口，如：http://localhost:8092
     * @param tokenParam -{SuperMap.TokenServiceParameter} token申请参数
     * @return {Promise}
     */
    generateToken: function generateToken(url, tokenParam) {
        var serverInfo = this.servers[url];
        if (!serverInfo) {
            return;
        }
        return _FetchRequest.FetchRequest.post(serverInfo.tokenServiceUrl, JSON.stringify(tokenParam.toJSON())).then(function (response) {
            return response.text();
        });
    },

    /**
     * @function SuperMap.SecurityManager.prototype.registerServers
     * @description 注册安全服务器相关信息
     * @param serverInfos -{SuperMap.ServerInfo} 服务器信息
     */
    registerServers: function registerServers(serverInfos) {
        this.servers = this.servers || {};
        if (!_SuperMap2.default.Util.isArray(serverInfos)) {
            serverInfos = [serverInfos];
        }
        for (var i = 0; i < serverInfos.length; i++) {
            var serverInfo = serverInfos[i];
            this.servers[serverInfo.server] = serverInfo;
        }
    },

    /**
     * @function SuperMap.SecurityManager.prototype.registerToken
     * @description 服务请求都会自动带上这个token
     * @param url {string} -服务器域名+端口：如http://localhost:8090
     * @param token -{string}
     */
    registerToken: function registerToken(url, token) {
        this.tokens = this.tokens || {};
        if (!url || !token) {
            return;
        }
        var domain = this._getTokenStorageKey(url);
        this.tokens[domain] = token;
    },

    /**
     * @function SuperMap.SecurityManager.prototype.registerKey
     * @description 注册key,ids为数组(存在一个key对应多个服务)
     * @param ids -{Array} 可以是服务id数组或者url地址数组或者webAPI类型数组
     * @param key -{string}
     */
    registerKey: function registerKey(ids, key) {
        this.keys = this.keys || {};
        if (!ids || ids.length < 1 || !key) {
            return;
        }

        ids = _SuperMap2.default.Util.isArray(ids) ? ids : [ids];
        for (var i = 0; i < ids.length; i++) {
            var id = this._getUrlRestString(ids[0]) || ids[0];
            this.keys[id] = key;
        }
    },

    /**
     * @function SuperMap.SecurityManager.prototype.getServerInfo
     * @description 获取服务信息
     * @param url {string}-服务器域名+端口，如：http://localhost:8092
     */
    getServerInfo: function getServerInfo(url) {
        this.servers = this.servers || {};
        return this.servers[url];
    },

    /**
     * @function SuperMap.SecurityManager.prototype.getToken
     * @description token按照域名存储
     * @param url -{string}-服务器域名+端口，如：http://localhost:8092
     */
    getToken: function getToken(url) {
        if (!url) {
            return;
        }
        this.tokens = this.tokens || {};
        var domain = this._getTokenStorageKey(url);
        return this.tokens[domain];
    },

    getKey: function getKey(id) {
        this.keys = this.keys || {};
        var key = this._getUrlRestString(id) || id;
        return this.keys[key];
    },

    /**
     * @function SuperMap.SecurityManager.prototype.loginOnline
     * @description Online登录验证
     * @param callbackLocation -{string} 跳转位置
     * @param newTab -{boolean}是否新窗口打开
     */
    loginOnline: function loginOnline(callbackLocation, newTab) {
        var loginUrl = _SuperMap2.default.SecurityManager.SSO + "/login?service=" + callbackLocation;
        this._open(loginUrl, newTab);
    },

    /**
     * @function SuperMap.SecurityManager.prototype.loginPortal
     * @description iPortal登录验证
     * @param url -{string} 网站地址
     * @param newTab -{boolean}是否新窗口打开
     */
    loginPortal: function loginPortal(url, newTab) {
        var end = url.substr(url.length - 1, 1);
        url += end === "/" ? "web/login" : "/web/login";
        this._open(url, newTab);
    },

    /**
     * @function SuperMap.SecurityManager.prototype.loginManager
     * @description iManager登录验证
     * @param url -{String} iManager地址。<br>
     *                      地址参数为iManager首页地址，如： http://localhost:8390/imanager<br>
     * @param loginInfoParams -{Object} iManager 登录参数<br>
     *        userName -{String} 用户名<br>
     *        password-{String} 密码
     * @param options -{Object} <br>
     *        isNewTab -{boolean} 不同域时是否在新窗口打开登录页面
     * @return {Promise}
     */
    loginManager: function loginManager(url, loginInfoParams, options) {
        if (!_SuperMap2.default.Util.isInTheSameDomain(url)) {
            var isNewTab = options ? options.isNewTab : true;
            this._open(url, isNewTab);
            return;
        }
        var end = url.substr(url.length - 1, 1);
        var requestUrl = end === "/" ? url + "icloud/security/tokens.json" : url + "/icloud/security/tokens.json";
        var params = loginInfoParams || {};
        var loginInfo = {
            username: params.userName && params.userName.toString(),
            password: params.password && params.password.toString()
        };
        loginInfo = JSON.stringify(loginInfo);
        var requestOptions = {
            headers: {
                'Accept': '*/*',
                'Content-Type': 'application/json'
            }
        };
        var me = this;
        return _FetchRequest.FetchRequest.post(requestUrl, loginInfo, requestOptions).then(function (response) {
            response.text().then(function (result) {
                me.imanagerToken = result;
                return result;
            });
        });
    },

    /**
     * @function SuperMap.SecurityManager.prototype.destroyAllCredentials
     * @description 清空全部验证信息
     */
    destroyAllCredentials: function destroyAllCredentials() {
        this.keys = null;
        this.tokens = null;
        this.servers = null;
    },
    /**
     * @function SuperMap.SecurityManager.prototype.destroyToken
     * @description 清空令牌信息
     */
    destroyToken: function destroyToken(url) {
        if (!url) {
            return;
        }
        var domain = this._getTokenStorageKey(url);
        this.tokens = this.tokens || {};
        if (this.tokens[domain]) {
            delete this.tokens[domain];
        }
    },
    /**
     * @function SuperMap.SecurityManager.prototype.destroyToken
     * @description 清空服务授权码
     */
    destroyKey: function destroyKey(id) {
        if (!id) {
            return;
        }
        this.keys = this.keys || {};
        var key = this._getUrlRestString(id) || id;
        if (this.keys[key]) {
            delete this.keys[key];
        }
    },

    _open: function _open(url, newTab) {
        newTab = newTab != null ? newTab : true;
        var offsetX = window.screen.availWidth / 2 - this.INNER_WINDOW_WIDTH / 2;
        var offsetY = window.screen.availHeight / 2 - this.INNER_WINDOW_HEIGHT / 2;
        var options = "height=" + this.INNER_WINDOW_HEIGHT + ", width=" + this.INNER_WINDOW_WIDTH + ",top=" + offsetY + ", left=" + offsetX + ",toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no";
        if (newTab) {
            window.open(url, 'login');
        } else {
            window.open(url, 'login', options);
        }
    },

    _getTokenStorageKey: function _getTokenStorageKey(url) {
        var patten = /(.*?):\/\/([^\/]+)/i;
        var result = url.match(patten);
        if (!result) {
            return url;
        }
        return result[0];
    },

    _getUrlRestString: function _getUrlRestString(url) {
        if (!url) {
            return url;
        }
        var patten = /http:\/\/(.*\/rest)/i;
        var result = url.match(patten);
        if (!result) {
            return url;
        }
        return result[0];
    }

};
_SuperMap2.default.SecurityManager.SSO = "https://sso.supermap.com";
_SuperMap2.default.SecurityManager.ONLINE = "http://www.supermapol.com";

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ServerInfo
 * @classdesc 服务器信息(安全相关)，包含服务器类型，服务地址，token服务地址等
 * @param type - {string} 服务器类型
 * @param options - {Object} 服务器信息相关可选参数。如：<br>
 *        server - {string} 服务器地址,如：http://supermapiserver:8090/iserver<br>
 *        tokenServiceUrl - {string} 非必填，如：http://supermapiserver:8090/iserver/services/security/tokens.json
 *        keyServiceUrl - {string} 非必填，如：http://supermapiserver:8092/web/mycontent/keys/register.json
 */
var ServerInfo =

/**
 * @member SuperMap.ServerInfo.prototype.tokenServiceUrl -{string}
 * @description 非必填，如：http://supermapiserver:8090/iserver/services/security/tokens.json
 */

/**
 * @member SuperMap.ServerInfo.prototype.type -{SuperMap.ServerType}
 * @description 服务器类型
 */
function ServerInfo(type, options) {
    _classCallCheck(this, ServerInfo);

    this.type = null;
    this.server = null;
    this.tokenServiceUrl = null;
    this.keyServiceUrl = null;
    this.CLASS_NAME = "SuperMap.ServerInfo";

    this.type = type || _REST.ServerType.ISERVER;
    _SuperMap2.default.Util.extend(this, options);
    if (!this.server) {
        console.error('server url require is not  undefined');
    }
    var patten = /http:\/\/([^\/]+)/i;
    this.server = this.server.match(patten)[0];

    var tokenServiceSuffix = "/services/security/tokens.json";
    if (this.type === _REST.ServerType.ISERVER && this.server.indexOf("iserver") < 0) {
        tokenServiceSuffix = "/iserver" + tokenServiceSuffix;
    }

    if (!this.tokenServiceUrl) {
        this.tokenServiceUrl = this.server + tokenServiceSuffix;
    }

    if (!this.keyServiceUrl) {
        if (this.type === _REST.ServerType.IPORTAL) {
            this.keyServiceUrl = this.server + "/web/mycontent/keys/register.json";
        } else if (this.type === _REST.ServerType.ONLINE) {
            this.keyServiceUrl = this.server + "/web/mycontent/keys.json";
        }
    }
}

/**
 * @member SuperMap.ServerInfo.prototype.keyServiceUrl -{string}
 * @description 非必填。如：http://supermapiserver:8092/web/mycontent/keys/register.json
 */


/**
 * @member SuperMap.ServerInfo.prototype.server -{string}
 * @description 必填，服务器地址
 */
;

exports.default = ServerInfo;


_SuperMap2.default.ServerInfo = ServerInfo;

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SuperMap2 = _interopRequireDefault(_SuperMap);

var _REST = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TokenServiceParameter
 * @classdesc token申请参数
 * @param options - {Object} 参数。
 */
var TokenServiceParameter = function () {
  /**
   * @member SuperMap.TokenServiceParameter.prototype.referer -{string}
   * @description clientType=Referer 时，必选。如果按照指定 URL 的方式申请令牌，则传递相应的 URL。
   */


  /**
   * @member SuperMap.TokenServiceParameter.prototype.clientType -{string}
   * @description token申请的客户端标识类型。
   */

  /**
   * @member SuperMap.TokenServiceParameter.prototype.userName -{string}
   * @description 用户名。
   */
  function TokenServiceParameter(options) {
    _classCallCheck(this, TokenServiceParameter);

    this.userName = null;
    this.password = null;
    this.clientType = _REST.ClientType.NONE;
    this.ip = null;
    this.referer = null;
    this.expiration = 60;
    this.CLASS_NAME = "SuperMap.TokenServiceParameter";

    _SuperMap2.default.Util.extend(this, options);
  }

  /**
   * @function SuperMap.TokenServiceParameter.prototype.toJSON
   * @description 将所有信息转成JSON字符串
   * @return {string} 参数的JSON字符串
   */


  /**
   * @member SuperMap.TokenServiceParameter.prototype.expiration -{number}
   * @description 申请令牌的有效期，从发布令牌的时间开始计算，单位为分钟。
   */


  /**
   * @member SuperMap.TokenServiceParameter.prototype.ip -{string}
   * @description clientType=Referer 时，必选。如果按照指定 URL 的方式申请令牌，则传递相应的 URL。
   */

  /**
   * @member SuperMap.TokenServiceParameter.prototype.password -{string}
   * @description 密码。
   */


  _createClass(TokenServiceParameter, [{
    key: 'toJSON',
    value: function toJSON() {
      return {
        userName: this.userName,
        password: this.password,
        clientType: this.clientType,
        ip: this.ip,
        referer: this.referer,
        expiration: this.expiration
      };
    }
  }]);

  return TokenServiceParameter;
}();

exports.default = TokenServiceParameter;


_SuperMap2.default.TokenServiceParameter = TokenServiceParameter;

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _mapboxGl = __webpack_require__(20);

var _mapboxGl2 = _interopRequireDefault(_mapboxGl);

var _mapv = __webpack_require__(81);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseLayer = _mapv.baiduMapLayer ? _mapv.baiduMapLayer.__proto__ : Function;
/**
 * @private
 * @class mapboxgl.supermap.MapvRenderer
 * @classdesc MapV图层渲染
 * @param map - {string} 地图
 * @param layer -{Object} 图层
 * @param dataSet -{Object} 数据集
 * @param options -{Object} 交互时所需可选参数。
 * @extends BaseLayer
 *
 */

var MapvRenderer = function (_BaseLayer) {
    _inherits(MapvRenderer, _BaseLayer);

    function MapvRenderer(map, layer, dataSet, options) {
        _classCallCheck(this, MapvRenderer);

        if (!BaseLayer) {
            return _possibleConstructorReturn(_this);
        }

        var _this = _possibleConstructorReturn(this, (MapvRenderer.__proto__ || Object.getPrototypeOf(MapvRenderer)).call(this, map, dataSet, options));

        _this.map = map;
        var self = _this;
        options = options || {};

        self.init(options);
        self.argCheck(options);
        _this.canvasLayer = layer;
        _this.clickEvent = _this.clickEvent.bind(_this);
        _this.mousemoveEvent = _this.mousemoveEvent.bind(_this);
        _this.map.on('move', _this.moveEvent.bind(_this));
        _this.map.on('resize', _this.resizeEvent.bind(_this));
        _this.map.on('moveend', _this.moveEndEvent.bind(_this));
        _this.map.on('remove', _this.removeEvent.bind(_this));
        _this.bindEvent();
        return _this;
    }
    /**
     * @function mapboxgl.supermap.prototype.clickEvent
     * @description  点击绑定事件
     * @param e - {Object} 事件
     */


    _createClass(MapvRenderer, [{
        key: 'clickEvent',
        value: function clickEvent(e) {
            var pixel = e.layerPoint;
            _get(MapvRenderer.prototype.__proto__ || Object.getPrototypeOf(MapvRenderer.prototype), 'clickEvent', this).call(this, pixel, e);
        }
        /**
         * @function mapboxgl.supermap.prototype.mousemoveEvent
         * @description  鼠标移动事件
         * @param e - {Object} 事件
         */

    }, {
        key: 'mousemoveEvent',
        value: function mousemoveEvent(e) {
            var pixel = e.layerPoint;
            _get(MapvRenderer.prototype.__proto__ || Object.getPrototypeOf(MapvRenderer.prototype), 'mousemoveEvent', this).call(this, pixel, e);
        }
        /**
         * @function  mapboxgl.supermap.prototype.bindEvent
         * @description 绑定事件
         * @param e - {object} 触发对象
         */

    }, {
        key: 'bindEvent',
        value: function bindEvent(e) {
            var map = this.map;
            if (this.options.methods) {
                if (this.options.methods.click) {
                    map.on('click', this.clickEvent);
                }
                if (this.options.methods.mousemove) {
                    map.on('mousemove', this.mousemoveEvent);
                }
            }
        }

        /**
         * @function mapboxgl.supermap.prototype.unbindEvent
         * @description 解绑事件
         * @param e - {object} 触发对象
         */

    }, {
        key: 'unbindEvent',
        value: function unbindEvent(e) {
            var map = this.map;

            if (this.options.methods) {
                if (this.options.methods.click) {
                    map.off('click', this.clickEvent);
                }
                if (this.options.methods.mousemove) {
                    map.off('mousemove', this.mousemoveEvent);
                }
            }
        }
        /**
         * @function mapboxgl.supermap.prototype.getContext
         * @description 获取信息
         */

    }, {
        key: 'getContext',
        value: function getContext() {
            return this.canvasLayer.canvas.getContext(this.context);
        }

        /**
         * @function mapboxgl.supermap.prototype.updateData
         * @param dataSet - {Object} 数据集
         * @param options - {Object} 数据项配置
         * @description  更新数据
         */

    }, {
        key: 'updateData',
        value: function updateData(dataSet, options) {
            if (dataSet && dataSet.get) {
                this.dataSet.set(dataSet.get());
            }
            this.update({ options: options });
        }
    }, {
        key: '_canvasUpdate',
        value: function _canvasUpdate(time) {
            if (!this.canvasLayer) {
                return;
            }

            var self = this;

            var animationOptions = self.options.animation;

            var context = this.getContext();
            var map = this.map;
            if (self.isEnabledTime()) {
                if (time === undefined) {
                    this.clear(context);
                    return;
                }
                if (this.context === '2d') {
                    context.save();
                    context.globalCompositeOperation = 'destination-out';
                    context.fillStyle = 'rgba(0, 0, 0, .1)';
                    context.fillRect(0, 0, context.canvas.width, context.canvas.height);
                    context.restore();
                }
            } else {
                this.clear(context);
            }

            if (this.context === '2d') {
                for (var key in self.options) {
                    context[key] = self.options[key];
                }
            } else {
                context.clear(context.COLOR_BUFFER_BIT);
            }

            if (self.options.minZoom && map.getZoom() < self.options.minZoom || self.options.maxZoom && map.getZoom() > self.options.maxZoom) {
                return;
            }
            function projectPoint(p) {
                var sin = Math.sin(p[1] * Math.PI / 180),
                    x = p[0] / 360 + 0.5,
                    y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;

                y = y < 0 ? 0 : y > 1 ? 1 : y;

                return [x, y, 0];
            }
            var dataGetOptions = {
                transferCoordinate: function transferCoordinate(coordinate) {
                    var worldPoint = map.transform.locationPoint(new window.mapboxgl.LngLat(coordinate[0], coordinate[1]));
                    return [worldPoint.x, worldPoint.y];
                }
            };

            if (time !== undefined) {
                dataGetOptions.filter = function (item) {
                    var trails = animationOptions.trails || 10;
                    return time && item.time > time - trails && item.time < time;
                };
            }

            var data = self.dataSet.get(dataGetOptions);

            this.processData(data);

            self.options._size = self.options.size;

            var worldPoint = map.project(new window.mapboxgl.LngLat(0, 0));
            this.drawContext(context, new mapv.DataSet(data), self.options, worldPoint);

            self.options.updateCallback && self.options.updateCallback(time);
        }
    }, {
        key: 'init',
        value: function init(options) {

            var self = this;

            self.options = options;

            this.initDataRange(options);

            this.context = self.options.context || '2d';

            if (self.options.zIndex) {
                this.canvasLayer && this.canvasLayer.setZIndex(self.options.zIndex);
            }

            this.initAnimator();
        }
        /**
         * @function mapboxgl.supermap.prototype.addAnimatorEvent
         * @description 添加动画事件
         */

    }, {
        key: 'addAnimatorEvent',
        value: function addAnimatorEvent() {}
        /**
         * @function mapboxgl.supermap.prototype.removeEvent
         * @description 移除事件
         */

    }, {
        key: 'removeEvent',
        value: function removeEvent() {
            this.canvasLayer.mapContainer.removeChild(this.canvasLayer.canvas);
        }
        /**
         * @function mapboxgl.supermap.prototype.moveEvent
         * @description 隐藏事件
         */

    }, {
        key: 'moveEvent',
        value: function moveEvent() {
            this._hide();
        }
        /**
         * @function mapboxgl.supermap.prototype.resizeEvent
         * @description 调整事件
         */

    }, {
        key: 'resizeEvent',
        value: function resizeEvent() {
            var canvas = this.canvasLayer.canvas;
            canvas.style.position = 'absolute';
            canvas.style.top = 0 + "px";
            canvas.style.left = 0 + "px";
            canvas.width = parseInt(this.map.getCanvas().style.width);
            canvas.height = parseInt(this.map.getCanvas().style.height);
            canvas.style.width = this.map.getCanvas().style.width;
            canvas.style.height = this.map.getCanvas().style.height;
        }
        /**
         * @function mapboxgl.supermap.prototype.moveEndEvent
         * @description 移除最后事件
         */

    }, {
        key: 'moveEndEvent',
        value: function moveEndEvent() {
            this._canvasUpdate();
            this._show();
        }
        /**
         * @function mapboxgl.supermap.prototype.clear
         * @param context - {object} 当前环境
         * @description 清除环境
         */

    }, {
        key: 'clear',
        value: function clear(context) {
            context && context.clearRect && context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        }
    }, {
        key: '_hide',
        value: function _hide() {
            this.canvasLayer.canvas.style.display = 'none';
        }
    }, {
        key: '_show',
        value: function _show() {
            this.canvasLayer.canvas.style.display = 'block';
        }
        /**
         * @function mapboxgl.supermap.prototype.draw
         * @description 渲染绘制
         */

    }, {
        key: 'draw',
        value: function draw() {
            this.canvasLayer.draw();
        }
    }]);

    return MapvRenderer;
}(BaseLayer);

exports.default = MapvRenderer;

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

var mgrs = __webpack_require__(60);

function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if(typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point.fromMGRS = function(mgrsStr) {
  return new Point(mgrs.toPoint(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return mgrs.forward([this.x, this.y], accuracy);
};
module.exports = Point;


/***/ }),
/* 276 */
/***/ (function(module, exports) {

module.exports = function(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      t = 'x';
    }
    else if (i === 1) {
      v = yin;
      t = 'y';
    }
    else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
    case 'e':
      point[t] = v;
      break;
    case 'w':
      point[t] = -v;
      break;
    case 'n':
      point[t] = v;
      break;
    case 's':
      point[t] = -v;
      break;
    case 'u':
      if (point[t] !== undefined) {
        point.z = v;
      }
      break;
    case 'd':
      if (point[t] !== undefined) {
        point.z = -v;
      }
      break;
    default:
      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
      return null;
    }
  }
  return point;
};


/***/ }),
/* 277 */
/***/ (function(module, exports) {

var HALF_PI = Math.PI/2;

module.exports = function(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return (-1 * HALF_PI);
    }
    else {
      return HALF_PI;
    }
  }
  //var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
};

/***/ }),
/* 278 */
/***/ (function(module, exports) {

var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;

module.exports = function(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
};

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

var pj_mlfn = __webpack_require__(74);
var EPSLN = 1.0e-10;
var MAX_ITER = 20;
module.exports = function(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;
    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  //..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
};

/***/ }),
/* 280 */
/***/ (function(module, exports) {

module.exports = function(esinp, exp) {
  return (Math.pow((1 - esinp) / (1 + esinp), exp));
};

/***/ }),
/* 281 */
/***/ (function(module, exports) {

exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
exports.potsdam = {
  towgs84: "606.0,23.0,413.0",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
exports.hermannskogel = {
  towgs84: "653.0,-212.0,449.0",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};
exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};
exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};
exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};

/***/ }),
/* 282 */
/***/ (function(module, exports) {

exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};
exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};
exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};
exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};
exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};
exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};
exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};
exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};
exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};
exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};
exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};
exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};

/***/ }),
/* 283 */
/***/ (function(module, exports) {

exports.greenwich = 0.0; //"0dE",
exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
exports.paris = 2.337229166667; //"2d20'14.025\"E",
exports.bogota = -74.080916666667; //"74d04'51.3\"W",
exports.madrid = -3.687938888889; //"3d41'16.58\"W",
exports.rome = 12.452333333333; //"12d27'8.4\"E",
exports.bern = 7.439583333333; //"7d26'22.5\"E",
exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
exports.ferro = -17.666666666667; //"17d40'W",
exports.brussels = 4.367975; //"4d22'4.71\"E",
exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
exports.athens = 23.7163375; //"23d42'58.815\"E",
exports.oslo = 10.722916666667; //"10d43'22.5\"E"

/***/ }),
/* 284 */
/***/ (function(module, exports) {

exports.ft = {to_meter: 0.3048};
exports['us-ft'] = {to_meter: 1200 / 3937};


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var proj = __webpack_require__(55);
var transform = __webpack_require__(79);
var wgs84 = proj('WGS84');

function transformer(from, to, coords) {
  var transformedArray;
  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords);
    if (coords.length === 3) {
      return [transformedArray.x, transformedArray.y, transformedArray.z];
    }
    else {
      return [transformedArray.x, transformedArray.y];
    }
  }
  else {
    return transform(from, to, coords);
  }
}

function checkProj(item) {
  if (item instanceof proj) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return proj(item);
}
function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  }
  else {
    obj = {
      forward: function(coords) {
        return transformer(fromProj, toProj, coords);
      },
      inverse: function(coords) {
        return transformer(toProj, fromProj, coords);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
module.exports = proj4;

/***/ }),
/* 286 */
/***/ (function(module, exports) {

var HALF_PI = Math.PI/2;
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var AD_C = 1.0026000;
var COS_67P5 = 0.38268343236508977;
var datum = function(proj) {
  if (!(this instanceof datum)) {
    return new datum(proj);
  }
  this.datum_type = PJD_WGS84; //default setting
  if (!proj) {
    return;
  }
  if (proj.datumCode && proj.datumCode === 'none') {
    this.datum_type = PJD_NODATUM;
  }

  if (proj.datum_params) {
    this.datum_params = proj.datum_params.map(parseFloat);
    if (this.datum_params[0] !== 0 || this.datum_params[1] !== 0 || this.datum_params[2] !== 0) {
      this.datum_type = PJD_3PARAM;
    }
    if (this.datum_params.length > 3) {
      if (this.datum_params[3] !== 0 || this.datum_params[4] !== 0 || this.datum_params[5] !== 0 || this.datum_params[6] !== 0) {
        this.datum_type = PJD_7PARAM;
        this.datum_params[3] *= SEC_TO_RAD;
        this.datum_params[4] *= SEC_TO_RAD;
        this.datum_params[5] *= SEC_TO_RAD;
        this.datum_params[6] = (this.datum_params[6] / 1000000.0) + 1.0;
      }
    }
  }

  // DGR 2011-03-21 : nadgrids support
  this.datum_type = proj.grids ? PJD_GRIDSHIFT : this.datum_type;

  this.a = proj.a; //datum object also uses these values
  this.b = proj.b;
  this.es = proj.es;
  this.ep2 = proj.ep2;
  if (this.datum_type === PJD_GRIDSHIFT) {
    this.grids = proj.grids;
  }
};
datum.prototype = {


  /****************************************************************/
  // cs_compare_datums()
  //   Returns TRUE if the two datums match, otherwise FALSE.
  compare_datums: function(dest) {
    if (this.datum_type !== dest.datum_type) {
      return false; // false, datums are not equal
    }
    else if (this.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {
      // the tolerence for es is to ensure that GRS80 and WGS84
      // are considered identical
      return false;
    }
    else if (this.datum_type === PJD_3PARAM) {
      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2]);
    }
    else if (this.datum_type === PJD_7PARAM) {
      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2] && this.datum_params[3] === dest.datum_params[3] && this.datum_params[4] === dest.datum_params[4] && this.datum_params[5] === dest.datum_params[5] && this.datum_params[6] === dest.datum_params[6]);
    }
    else if (this.datum_type === PJD_GRIDSHIFT || dest.datum_type === PJD_GRIDSHIFT) {
      //alert("ERROR: Grid shift transformations are not implemented.");
      //return false
      //DGR 2012-07-29 lazy ...
      return this.nadgrids === dest.nadgrids;
    }
    else {
      return true; // datums are equal
    }
  }, // cs_compare_datums()

  /*
   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
   * according to the current ellipsoid parameters.
   *
   *    Latitude  : Geodetic latitude in radians                     (input)
   *    Longitude : Geodetic longitude in radians                    (input)
   *    Height    : Geodetic height, in meters                       (input)
   *    X         : Calculated Geocentric X coordinate, in meters    (output)
   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
   *
   */
  geodetic_to_geocentric: function(p) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0; //Z value not always supplied
    var X; // output
    var Y;
    var Z;

    var Error_Code = 0; //  GEOCENT_NO_ERROR;
    var Rn; /*  Earth radius at location  */
    var Sin_Lat; /*  Math.sin(Latitude)  */
    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
    var Cos_Lat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
      Latitude = -HALF_PI;
    }
    else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
      Latitude = HALF_PI;
    }
    else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
      return null;
    }

    if (Longitude > Math.PI) {
      Longitude -= (2 * Math.PI);
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = this.a / (Math.sqrt(1.0e0 - this.es * Sin2_Lat));
    X = (Rn + Height) * Cos_Lat * Math.cos(Longitude);
    Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude);
    Z = ((Rn * (1 - this.es)) + Height) * Sin_Lat;

    p.x = X;
    p.y = Y;
    p.z = Z;
    return Error_Code;
  }, // cs_geodetic_to_geocentric()


  geocentric_to_geodetic: function(p) {
    /* local defintions and variables */
    /* end-criterium of loop, accuracy of sin(Latitude) */
    var genau = 1e-12;
    var genau2 = (genau * genau);
    var maxiter = 30;

    var P; /* distance between semi-minor axis and location */
    var RR; /* distance between center and location */
    var CT; /* sin of geocentric latitude */
    var ST; /* cos of geocentric latitude */
    var RX;
    var RK;
    var RN; /* Earth radius at location */
    var CPHI0; /* cos of start or old geodetic latitude in iterations */
    var SPHI0; /* sin of start or old geodetic latitude in iterations */
    var CPHI; /* cos of searched geodetic latitude */
    var SPHI; /* sin of searched geodetic latitude */
    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
    var At_Pole; /* indicates location is in polar region */
    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0.0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    At_Pole = false;
    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z * Z);

    /*      special cases for latitude and longitude */
    if (P / this.a < genau) {

      /*  special case, if P=0. (X=0., Y=0.) */
      At_Pole = true;
      Longitude = 0.0;

      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
      if (RR / this.a < genau) {
        Latitude = HALF_PI;
        Height = -this.b;
        return;
      }
    }
    else {
      /*  ellipsoidal (geodetic) longitude
       *  interval: -PI < Longitude <= +PI */
      Longitude = Math.atan2(Y, X);
    }

    /* --------------------------------------------------------------
     * Following iterative algorithm was developped by
     * "Institut for Erdmessung", University of Hannover, July 1988.
     * Internet: www.ife.uni-hannover.de
     * Iterative computation of CPHI,SPHI and Height.
     * Iteration of CPHI and SPHI to 10**-12 radian resp.
     * 2*10**-7 arcsec.
     * --------------------------------------------------------------
     */
    CT = Z / RR;
    ST = P / RR;
    RX = 1.0 / Math.sqrt(1.0 - this.es * (2.0 - this.es) * ST * ST);
    CPHI0 = ST * (1.0 - this.es) * RX;
    SPHI0 = CT * RX;
    iter = 0;

    /* loop to find sin(Latitude) resp. Latitude
     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
    do {
      iter++;
      RN = this.a / Math.sqrt(1.0 - this.es * SPHI0 * SPHI0);

      /*  ellipsoidal (geodetic) height */
      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - this.es * SPHI0 * SPHI0);

      RK = this.es * RN / (RN + Height);
      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
      CPHI = ST * (1.0 - RK) * RX;
      SPHI = CT * RX;
      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
      CPHI0 = CPHI;
      SPHI0 = SPHI;
    }
    while (SDPHI * SDPHI > genau2 && iter < maxiter);

    /*      ellipsoidal (geodetic) latitude */
    Latitude = Math.atan(SPHI / Math.abs(CPHI));

    p.x = Longitude;
    p.y = Latitude;
    p.z = Height;
    return p;
  }, // cs_geocentric_to_geodetic()

  /** Convert_Geocentric_To_Geodetic
   * The method used here is derived from 'An Improved Algorithm for
   * Geocentric to Geodetic Coordinate Conversion', by Ralph Toms, Feb 1996
   */
  geocentric_to_geodetic_noniter: function(p) {
    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    var W; /* distance from Z axis */
    var W2; /* square of distance from Z axis */
    var T0; /* initial estimate of vertical component */
    var T1; /* corrected estimate of vertical component */
    var S0; /* initial estimate of horizontal component */
    var S1; /* corrected estimate of horizontal component */
    var Sin_B0; /* Math.sin(B0), B0 is estimate of Bowring aux variable */
    var Sin3_B0; /* cube of Math.sin(B0) */
    var Cos_B0; /* Math.cos(B0) */
    var Sin_p1; /* Math.sin(phi1), phi1 is estimated latitude */
    var Cos_p1; /* Math.cos(phi1) */
    var Rn; /* Earth radius at location */
    var Sum; /* numerator of Math.cos(phi1) */
    var At_Pole; /* indicates location is in polar region */

    X = parseFloat(X); // cast from string to float
    Y = parseFloat(Y);
    Z = parseFloat(Z);

    At_Pole = false;
    if (X !== 0.0) {
      Longitude = Math.atan2(Y, X);
    }
    else {
      if (Y > 0) {
        Longitude = HALF_PI;
      }
      else if (Y < 0) {
        Longitude = -HALF_PI;
      }
      else {
        At_Pole = true;
        Longitude = 0.0;
        if (Z > 0.0) { /* north pole */
          Latitude = HALF_PI;
        }
        else if (Z < 0.0) { /* south pole */
          Latitude = -HALF_PI;
        }
        else { /* center of earth */
          Latitude = HALF_PI;
          Height = -this.b;
          return;
        }
      }
    }
    W2 = X * X + Y * Y;
    W = Math.sqrt(W2);
    T0 = Z * AD_C;
    S0 = Math.sqrt(T0 * T0 + W2);
    Sin_B0 = T0 / S0;
    Cos_B0 = W / S0;
    Sin3_B0 = Sin_B0 * Sin_B0 * Sin_B0;
    T1 = Z + this.b * this.ep2 * Sin3_B0;
    Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0;
    S1 = Math.sqrt(T1 * T1 + Sum * Sum);
    Sin_p1 = T1 / S1;
    Cos_p1 = Sum / S1;
    Rn = this.a / Math.sqrt(1.0 - this.es * Sin_p1 * Sin_p1);
    if (Cos_p1 >= COS_67P5) {
      Height = W / Cos_p1 - Rn;
    }
    else if (Cos_p1 <= -COS_67P5) {
      Height = W / -Cos_p1 - Rn;
    }
    else {
      Height = Z / Sin_p1 + Rn * (this.es - 1.0);
    }
    if (At_Pole === false) {
      Latitude = Math.atan(Sin_p1 / Cos_p1);
    }

    p.x = Longitude;
    p.y = Latitude;
    p.z = Height;
    return p;
  }, // geocentric_to_geodetic_noniter()

  /****************************************************************/
  // pj_geocentic_to_wgs84( p )
  //  p = point to transform in geocentric coordinates (x,y,z)
  geocentric_to_wgs84: function(p) {

    if (this.datum_type === PJD_3PARAM) {
      // if( x[io] === HUGE_VAL )
      //    continue;
      p.x += this.datum_params[0];
      p.y += this.datum_params[1];
      p.z += this.datum_params[2];

    }
    else if (this.datum_type === PJD_7PARAM) {
      var Dx_BF = this.datum_params[0];
      var Dy_BF = this.datum_params[1];
      var Dz_BF = this.datum_params[2];
      var Rx_BF = this.datum_params[3];
      var Ry_BF = this.datum_params[4];
      var Rz_BF = this.datum_params[5];
      var M_BF = this.datum_params[6];
      // if( x[io] === HUGE_VAL )
      //    continue;
      var x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF;
      var y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF;
      var z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;
      p.x = x_out;
      p.y = y_out;
      p.z = z_out;
    }
  }, // cs_geocentric_to_wgs84

  /****************************************************************/
  // pj_geocentic_from_wgs84()
  //  coordinate system definition,
  //  point to transform in geocentric coordinates (x,y,z)
  geocentric_from_wgs84: function(p) {

    if (this.datum_type === PJD_3PARAM) {
      //if( x[io] === HUGE_VAL )
      //    continue;
      p.x -= this.datum_params[0];
      p.y -= this.datum_params[1];
      p.z -= this.datum_params[2];

    }
    else if (this.datum_type === PJD_7PARAM) {
      var Dx_BF = this.datum_params[0];
      var Dy_BF = this.datum_params[1];
      var Dz_BF = this.datum_params[2];
      var Rx_BF = this.datum_params[3];
      var Ry_BF = this.datum_params[4];
      var Rz_BF = this.datum_params[5];
      var M_BF = this.datum_params[6];
      var x_tmp = (p.x - Dx_BF) / M_BF;
      var y_tmp = (p.y - Dy_BF) / M_BF;
      var z_tmp = (p.z - Dz_BF) / M_BF;
      //if( x[io] === HUGE_VAL )
      //    continue;

      p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp;
      p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp;
      p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp;
    } //cs_geocentric_from_wgs84()
  }
};

/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
module.exports = datum;


/***/ }),
/* 287 */
/***/ (function(module, exports) {

var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_NODATUM = 5; // WGS84 or equivalent
var SRS_WGS84_SEMIMAJOR = 6378137; // only used in grid shift transforms
var SRS_WGS84_ESQUARED = 0.006694379990141316; //DGR: 2012-07-29
module.exports = function(source, dest, point) {
  var wp, i, l;

  function checkParams(fallback) {
    return (fallback === PJD_3PARAM || fallback === PJD_7PARAM);
  }
  // Short cut if the datums are identical.
  if (source.compare_datums(dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }

  //DGR: 2012-07-29 : add nadgrids support (begin)
  var src_a = source.a;
  var src_es = source.es;

  var dst_a = dest.a;
  var dst_es = dest.es;

  var fallback = source.datum_type;
  // If this datum requires grid shifts, then apply it to geodetic coordinates.
  if (fallback === PJD_GRIDSHIFT) {
    if (this.apply_gridshift(source, 0, point) === 0) {
      source.a = SRS_WGS84_SEMIMAJOR;
      source.es = SRS_WGS84_ESQUARED;
    }
    else {
      // try 3 or 7 params transformation or nothing ?
      if (!source.datum_params) {
        source.a = src_a;
        source.es = source.es;
        return point;
      }
      wp = 1;
      for (i = 0, l = source.datum_params.length; i < l; i++) {
        wp *= source.datum_params[i];
      }
      if (wp === 0) {
        source.a = src_a;
        source.es = source.es;
        return point;
      }
      if (source.datum_params.length > 3) {
        fallback = PJD_7PARAM;
      }
      else {
        fallback = PJD_3PARAM;
      }
    }
  }
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest.a = SRS_WGS84_SEMIMAJOR;
    dest.es = SRS_WGS84_ESQUARED;
  }
  // Do we need to go through geocentric coordinates?
  if (source.es !== dest.es || source.a !== dest.a || checkParams(fallback) || checkParams(dest.datum_type)) {
    //DGR: 2012-07-29 : add nadgrids support (end)
    // Convert to geocentric coordinates.
    source.geodetic_to_geocentric(point);
    // CHECK_RETURN;
    // Convert between datums
    if (checkParams(source.datum_type)) {
      source.geocentric_to_wgs84(point);
      // CHECK_RETURN;
    }
    if (checkParams(dest.datum_type)) {
      dest.geocentric_from_wgs84(point);
      // CHECK_RETURN;
    }
    // Convert back to geodetic coordinates
    dest.geocentric_to_geodetic(point);
    // CHECK_RETURN;
  }
  // Apply grid shift to destination if required
  if (dest.datum_type === PJD_GRIDSHIFT) {
    this.apply_gridshift(dest, 1, point);
    // CHECK_RETURN;
  }

  source.a = src_a;
  source.es = src_es;
  dest.a = dst_a;
  dest.es = dst_es;

  return point;
};



/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var Datum = __webpack_require__(281);
var Ellipsoid = __webpack_require__(282);
var extend = __webpack_require__(59);
var datum = __webpack_require__(286);
var EPSLN = 1.0e-10;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
module.exports = function(json) {
  // DGR 2011-03-20 : nagrids -> nadgrids
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = Datum[json.datumCode];
    if (datumDef) {
      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  if (!json.a) { // do we have an ellipsoid?
    var ellipse = Ellipsoid[json.ellps] ? Ellipsoid[json.ellps] : Ellipsoid.WGS84;
    extend(json, ellipse);
  }
  if (json.rf && !json.b) {
    json.b = (1.0 - 1.0 / json.rf) * json.a;
  }
  if (json.rf === 0 || Math.abs(json.a - json.b) < EPSLN) {
    json.sphere = true;
    json.b = json.a;
  }
  json.a2 = json.a * json.a; // used in geocentric
  json.b2 = json.b * json.b; // used in geocentric
  json.es = (json.a2 - json.b2) / json.a2; // e ^ 2
  json.e = Math.sqrt(json.es); // eccentricity
  if (json.R_A) {
    json.a *= 1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6));
    json.a2 = json.a * json.a;
    json.b2 = json.b * json.b;
    json.es = 0;
  }
  json.ep2 = (json.a2 - json.b2) / json.b2; // used in geocentric
  if (!json.k0) {
    json.k0 = 1.0; //default value
  }
  //DGR 2010-11-12: axis
  if (!json.axis) {
    json.axis = "enu";
  }

  if (!json.datum) {
    json.datum = datum(json);
  }
  return json;
};


/***/ }),
/* 289 */
/***/ (function(module, exports) {

module.exports = function(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
};


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var projs = [
  __webpack_require__(78),
  __webpack_require__(316),
  __webpack_require__(315),
  __webpack_require__(314),
  __webpack_require__(313),
  __webpack_require__(310),
  __webpack_require__(304),
  __webpack_require__(302),
  __webpack_require__(296),
  __webpack_require__(303),
  __webpack_require__(294),
  __webpack_require__(301),
  __webpack_require__(297),
  __webpack_require__(298),
  __webpack_require__(311),
  __webpack_require__(309),
  __webpack_require__(307),
  __webpack_require__(312),
  __webpack_require__(308),
  __webpack_require__(299),
  __webpack_require__(317),
  __webpack_require__(295)
];
module.exports = function(proj4){
  projs.forEach(function(proj){
    proj4.Proj.projections.add(proj);
  });
};

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var proj4 = __webpack_require__(285);
proj4.defaultDatum = 'WGS84'; //default datum
proj4.Proj = __webpack_require__(55);
proj4.WGS84 = new proj4.Proj('WGS84');
proj4.Point = __webpack_require__(275);
proj4.toPoint = __webpack_require__(75);
proj4.defs = __webpack_require__(76);
proj4.transform = __webpack_require__(79);
proj4.mgrs = __webpack_require__(60);
proj4.version = __webpack_require__(318).version;
__webpack_require__(290)(proj4);
module.exports = proj4;

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var defs = __webpack_require__(76);
var wkt = __webpack_require__(80);
var projStr = __webpack_require__(77);
function testObj(code){
  return typeof code === 'string';
}
function testDef(code){
  return code in defs;
}
function testWKT(code){
  var codeWords = ['GEOGCS','GEOCCS','PROJCS','LOCAL_CS'];
  return codeWords.reduce(function(a,b){
    return a+1+code.indexOf(b);
  },0);
}
function testProj(code){
  return code[0] === '+';
}
function parse(code){
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return defs[code];
    }
    else if (testWKT(code)) {
      return wkt(code);
    }
    else if (testProj(code)) {
      return projStr(code);
    }
  }else{
    return code;
  }
}

module.exports = parse;

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var projs = [
  __webpack_require__(306),
  __webpack_require__(305)
];
var names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names[n.toLowerCase()] = len;
  });
  return this;
}

exports.add = add;

exports.get = function(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
    return projStore[names[n]];
  }
};
exports.start = function() {
  projs.forEach(add);
};


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var EPSLN = 1.0e-10;
var msfnz = __webpack_require__(19);
var qsfnz = __webpack_require__(58);
var adjust_lon = __webpack_require__(3);
var asinz = __webpack_require__(18);
exports.init = function() {

  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);

  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  }
  else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
};

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/
exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);

  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
};


exports.inverse = function(p) {
  var rh1, qs, con, theta, lon, lat;

  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  }
  else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = adjust_lon(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
};

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/
exports.phi1z = function(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }

  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
};
exports.names = ["Albers_Conic_Equal_Area", "Albers", "aea"];


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(3);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var mlfn = __webpack_require__(35);
var e0fn = __webpack_require__(31);
var e1fn = __webpack_require__(32);
var e2fn = __webpack_require__(33);
var e3fn = __webpack_require__(34);
var gN = __webpack_require__(56);
var asinz = __webpack_require__(18);
var imlfn = __webpack_require__(57);
exports.init = function() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
};

exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    }
    else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c / Math.sin(c);
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    }
    else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }


};

exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > (2 * HALF_PI * this.a)) {
      return;
    }
    z = rh / this.a;

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    }
    else {
      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
      }
      else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;

      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }

};
exports.names = ["Azimuthal_Equidistant", "aeqd"];


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var mlfn = __webpack_require__(35);
var e0fn = __webpack_require__(31);
var e1fn = __webpack_require__(32);
var e2fn = __webpack_require__(33);
var e3fn = __webpack_require__(34);
var gN = __webpack_require__(56);
var adjust_lon = __webpack_require__(3);
var adjust_lat = __webpack_require__(30);
var imlfn = __webpack_require__(57);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
exports.init = function() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
};



/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
exports.forward = function(p) {

  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  }
  else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
};

/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  }
  else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));

    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

  }

  p.x = adjust_lon(lam + this.long0);
  p.y = adjust_lat(phi);
  return p;

};
exports.names = ["Cassini", "Cassini_Soldner", "cass"];

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(3);
var qsfnz = __webpack_require__(58);
var msfnz = __webpack_require__(19);
var iqsfnz = __webpack_require__(277);
/*
  reference:  
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/
exports.init = function() {
  //no-op
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
};


/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  }
  else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
};

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
  }
  else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["cea"];


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(3);
var adjust_lat = __webpack_require__(30);
exports.init = function() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

  this.rc = Math.cos(this.lat_ts);
};


// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p.x = this.x0 + (this.a * dlon * this.rc);
  p.y = this.y0 + (this.a * dlat);
  return p;
};

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
exports.inverse = function(p) {

  var x = p.x;
  var y = p.y;

  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
  return p;
};
exports.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

var e0fn = __webpack_require__(31);
var e1fn = __webpack_require__(32);
var e2fn = __webpack_require__(33);
var e3fn = __webpack_require__(34);
var msfnz = __webpack_require__(19);
var mlfn = __webpack_require__(35);
var adjust_lon = __webpack_require__(3);
var adjust_lat = __webpack_require__(30);
var imlfn = __webpack_require__(57);
var EPSLN = 1.0e-10;
exports.init = function() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);

  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);

  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  }
  else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
};


/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      -----------------*/
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  }
  else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
};

/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }

};
exports.names = ["Equidistant_Conic", "eqdc"];


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var FORTPI = Math.PI/4;
var srat = __webpack_require__(280);
var HALF_PI = Math.PI/2;
var MAX_ITER = 20;
exports.init = function() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
};

exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;

  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
};

exports.inverse = function(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["gauss"];


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(3);
var EPSLN = 1.0e-10;
var asinz = __webpack_require__(18);

/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */
exports.init = function() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
};


/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
exports.forward = function(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = adjust_lon(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  }
  else {

    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project 
    // to infinity, on a bearing 
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that 
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

  }
  p.x = x;
  p.y = y;
  return p;
};


exports.inverse = function(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      -----------------*/
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;

  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);

    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["gnom"];


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(3);
exports.init = function() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
};

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
exports.forward = function(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  /* Transformation */
  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return (p);
};

/* calculate lat/lon from xy */
exports.inverse = function(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x*/
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }

  return (p);
};
exports.names = ["Krovak", "krovak"];


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var HALF_PI = Math.PI/2;
var FORTPI = Math.PI/4;
var EPSLN = 1.0e-10;
var qsfnz = __webpack_require__(58);
var adjust_lon = __webpack_require__(3);
/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

exports.S_POLE = 1;
exports.N_POLE = 2;
exports.EQUIT = 3;
exports.OBLIQ = 4;


/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/
exports.init = function() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  }
  else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  }
  else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;

    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = this.authset(this.es);
    switch (this.mode) {
    case this.N_POLE:
      this.dd = 1;
      break;
    case this.S_POLE:
      this.dd = 1;
      break;
    case this.EQUIT:
      this.rq = Math.sqrt(0.5 * this.qp);
      this.dd = 1 / this.rq;
      this.xmf = 1;
      this.ymf = 0.5 * this.qp;
      break;
    case this.OBLIQ:
      this.rq = Math.sqrt(0.5 * this.qp);
      sinphi = Math.sin(this.lat0);
      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
      this.ymf = (this.xmf = this.rq) / this.dd;
      this.xmf *= this.dd;
      break;
    }
  }
  else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
};

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
exports.forward = function(p) {

  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;

  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.phi0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  }
  else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
    case this.OBLIQ:
      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
      break;
    case this.EQUIT:
      b = 1 + cosb * coslam;
      break;
    case this.N_POLE:
      b = HALF_PI + phi;
      q = this.qp - q;
      break;
    case this.S_POLE:
      b = phi - HALF_PI;
      q = this.qp + q;
      break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
    case this.OBLIQ:
    case this.EQUIT:
      b = Math.sqrt(2 / b);
      if (this.mode === this.OBLIQ) {
        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
      }
      else {
        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
      }
      x = this.xmf * b * cosb * sinlam;
      break;
    case this.N_POLE:
    case this.S_POLE:
      if (q >= 0) {
        x = (b = Math.sqrt(q)) * sinlam;
        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
      }
      else {
        x = y = 0;
      }
      break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
};

/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;

  if (this.sphere) {
    var cosz = 0,
      rh, sinz = 0;

    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
    case this.EQUIT:
      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
      x *= sinz;
      y = cosz * rh;
      break;
    case this.OBLIQ:
      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
      x *= sinz * this.cosph0;
      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
      break;
    case this.N_POLE:
      y = -y;
      phi = HALF_PI - phi;
      break;
    case this.S_POLE:
      phi -= HALF_PI;
      break;
    }
    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
  }
  else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= (sCe = Math.sin(sCe));
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      }
      else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = (x * x + y * y);
      if (!q) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = this.authlat(Math.asin(ab), this.apa);
  }


  p.x = adjust_lon(this.long0 + lam);
  p.y = phi;
  return p;
};

/* determine latitude from authalic latitude */
exports.P00 = 0.33333333333333333333;
exports.P01 = 0.17222222222222222222;
exports.P02 = 0.10257936507936507936;
exports.P10 = 0.06388888888888888888;
exports.P11 = 0.06640211640211640211;
exports.P20 = 0.01641501294219154443;

exports.authset = function(es) {
  var t;
  var APA = [];
  APA[0] = es * this.P00;
  t = es * es;
  APA[0] += t * this.P01;
  APA[1] = t * this.P10;
  t *= es;
  APA[0] += t * this.P02;
  APA[1] += t * this.P11;
  APA[2] = t * this.P20;
  return APA;
};

exports.authlat = function(beta, APA) {
  var t = beta + beta;
  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
};
exports.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var EPSLN = 1.0e-10;
var msfnz = __webpack_require__(19);
var tsfnz = __webpack_require__(43);
var HALF_PI = Math.PI/2;
var sign = __webpack_require__(36);
var adjust_lon = __webpack_require__(3);
var phi2z = __webpack_require__(42);
exports.init = function() {

  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
  //double c_lat;                   /* center latitude                      */
  //double c_lon;                   /* center longitude                     */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);

  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);

  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);

  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  }
  else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
};


// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }

  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  }
  else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

  return p;
};

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
exports.inverse = function(p) {

  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = (this.rh - (p.y - this.y0) / this.k0);
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2((con * x), (con * y));
  }
  if ((rh1 !== 0) || (this.ns > 0)) {
    con = 1 / this.ns;
    ts = Math.pow((rh1 / (this.a * this.f0)), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);

  p.x = lon;
  p.y = lat;
  return p;
};

exports.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];


/***/ }),
/* 305 */
/***/ (function(module, exports) {

exports.init = function() {
  //no-op for longlat
};

function identity(pt) {
  return pt;
}
exports.forward = identity;
exports.inverse = identity;
exports.names = ["longlat", "identity"];


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var msfnz = __webpack_require__(19);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var R2D = 57.29577951308232088;
var adjust_lon = __webpack_require__(3);
var FORTPI = Math.PI/4;
var tsfnz = __webpack_require__(43);
var phi2z = __webpack_require__(42);
exports.init = function() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if(!('x0' in this)){
    this.x0 = 0;
  }
  if(!('y0' in this)){
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    }
    else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      }
      else {
        this.k0 = 1;
      }
    }
  }
};

/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }

  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  }
  else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    }
    else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
};


/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
exports.inverse = function(p) {

  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  }
  else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

  p.x = lon;
  p.y = lat;
  return p;
};

exports.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(3);
/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */


/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/
exports.init = function() {
  //no-op
};


/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

  p.x = x;
  p.y = y;
  return p;
};

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;

  var lon = adjust_lon(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Miller_Cylindrical", "mill"];


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(3);
var EPSLN = 1.0e-10;
exports.init = function() {};

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/
exports.forward = function(p) {

  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/
  for (var i = 0; true; i++) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
};

exports.inverse = function(p) {
  var theta;
  var arg;

  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
  if (lon < (-Math.PI)) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Mollweide", "moll"];


/***/ }),
/* 309 */
/***/ (function(module, exports) {

var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
exports.iterations = 1;

exports.init = function() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;

  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;

  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;

  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
};

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
exports.forward = function(p) {
  var n;
  var lon = p.x;
  var lat = p.y;

  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;

  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = (z_im * this.a) + this.x0;
  p.y = (z_re * this.a) + this.y0;

  return p;
};


/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
exports.inverse = function(p) {
  var n;
  var x = p.x;
  var y = p.y;

  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;

  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;

    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
  var lon = this.long0 + d_lambda;

  p.x = lon;
  p.y = lat;

  return p;
};
exports.names = ["New_Zealand_Map_Grid", "nzmg"];

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

var tsfnz = __webpack_require__(43);
var adjust_lon = __webpack_require__(3);
var phi2z = __webpack_require__(42);
var HALF_PI = Math.PI/2;
var FORTPI = Math.PI/4;
var EPSLN = 1.0e-10;

/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/
exports.init = function() {
  this.no_off = this.no_off || false;
  this.no_rot = this.no_rot || false;

  if (isNaN(this.k0)) {
    this.k0 = 1;
  }
  var sinlat = Math.sin(this.lat0);
  var coslat = Math.cos(this.lat0);
  var con = this.e * sinlat;

  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
  var t0 = tsfnz(this.e, this.lat0, sinlat);
  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
  if (dl * dl < 1) {
    dl = 1;
  }
  var fl;
  var gl;
  if (!isNaN(this.longc)) {
    //Central point and azimuth method

    if (this.lat0 >= 0) {
      fl = dl + Math.sqrt(dl * dl - 1);
    }
    else {
      fl = dl - Math.sqrt(dl * dl - 1);
    }
    this.el = fl * Math.pow(t0, this.bl);
    gl = 0.5 * (fl - 1 / fl);
    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

  }
  else {
    //2 points method
    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
    if (this.lat0 >= 0) {
      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    else {
      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    var hl = Math.pow(t1, this.bl);
    var ll = Math.pow(t2, this.bl);
    fl = this.el / hl;
    gl = 0.5 * (fl - 1 / fl);
    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
    var pl = (ll - hl) / (ll + hl);
    var dlon12 = adjust_lon(this.long1 - this.long2);
    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
    this.long0 = adjust_lon(this.long0);
    var dlon10 = adjust_lon(this.long1 - this.long0);
    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
  }

  if (this.no_off) {
    this.uc = 0;
  }
  else {
    if (this.lat0 >= 0) {
      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
    else {
      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
  }

};


/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon(lon - this.long0);
  var us, vs;
  var con;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    if (lat > 0) {
      con = -1;
    }
    else {
      con = 1;
    }
    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
    us = -1 * con * HALF_PI * this.al / this.bl;
  }
  else {
    var t = tsfnz(this.e, lat, Math.sin(lat));
    var ql = this.el / Math.pow(t, this.bl);
    var sl = 0.5 * (ql - 1 / ql);
    var tl = 0.5 * (ql + 1 / ql);
    var vl = Math.sin(this.bl * (dlon));
    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
      vs = Number.POSITIVE_INFINITY;
    }
    else {
      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
    }
    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
      us = this.al * this.bl * (dlon);
    }
    else {
      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
    }
  }

  if (this.no_rot) {
    p.x = this.x0 + us;
    p.y = this.y0 + vs;
  }
  else {

    us -= this.uc;
    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
  }
  return p;
};

exports.inverse = function(p) {
  var us, vs;
  if (this.no_rot) {
    vs = p.y - this.y0;
    us = p.x - this.x0;
  }
  else {
    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
    us += this.uc;
  }
  var qp = Math.exp(-1 * this.bl * vs / this.al);
  var sp = 0.5 * (qp - 1 / qp);
  var tp = 0.5 * (qp + 1 / qp);
  var vp = Math.sin(this.bl * us / this.al);
  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
  if (Math.abs(up - 1) < EPSLN) {
    p.x = this.long0;
    p.y = HALF_PI;
  }
  else if (Math.abs(up + 1) < EPSLN) {
    p.x = this.long0;
    p.y = -1 * HALF_PI;
  }
  else {
    p.y = phi2z(this.e, ts);
    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
  }
  return p;
};

exports.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var e0fn = __webpack_require__(31);
var e1fn = __webpack_require__(32);
var e2fn = __webpack_require__(33);
var e3fn = __webpack_require__(34);
var adjust_lon = __webpack_require__(3);
var adjust_lat = __webpack_require__(30);
var mlfn = __webpack_require__(35);
var EPSLN = 1.0e-10;
var gN = __webpack_require__(56);
var MAX_ITER = 20;
exports.init = function() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
};


/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    }
    else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  }
  else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    }
    else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }

  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
};


/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    }
    else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
    }
  }
  else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    }
    else {

      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }

      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Polyconic", "poly"];

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(3);
var adjust_lat = __webpack_require__(30);
var pj_enfn = __webpack_require__(278);
var MAX_ITER = 20;
var pj_mlfn = __webpack_require__(74);
var pj_inv_mlfn = __webpack_require__(279);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var asinz = __webpack_require__(18);
exports.init = function() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/


  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  }
  else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }

};

/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/
exports.forward = function(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/
  lon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    }
    else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;

  }
  else {

    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
};

exports.inverse = function(p) {
  var lat, temp, lon, s;

  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    }
    else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  }
  else {
    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    }
    else if ((s - EPSLN) < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Sinusoidal", "sinu"];

/***/ }),
/* 313 */
/***/ (function(module, exports) {

/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme à axe oblique et pour la transformation entre
    des systèmes de référence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */
exports.init = function() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
};


exports.forward = function(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
};

exports.inverse = function(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;

  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

  var lambda = this.lambda0 + I / this.alpha;

  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    }
    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
};

exports.names = ["somerc"];


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var sign = __webpack_require__(36);
var msfnz = __webpack_require__(19);
var tsfnz = __webpack_require__(43);
var phi2z = __webpack_require__(42);
var adjust_lon = __webpack_require__(3);
exports.ssfn_ = function(phit, sinphi, eccen) {
  sinphi *= eccen;
  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
};

exports.init = function() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      }
      else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
};

// Stereographic forward equations--mapping lat,long to x,y
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  }
  else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      //trace(p.toString());
      return p;
    }
    else if (Math.abs(this.sinlat0) < EPSLN) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    }
    else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  //trace(p.toString());
  return p;
};


//* Stereographic inverse equations--mapping x,y to lat/long
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      }
    }
    else {
      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        //trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
    }
    else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      }
      else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  //trace(p.toString());
  return p;

};
exports.names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

var gauss = __webpack_require__(300);
var adjust_lon = __webpack_require__(3);
exports.init = function() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
};

exports.forward = function(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon(p.x - this.long0);
  gauss.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
};

exports.inverse = function(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;
  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  gauss.inverse.apply(this, [p]);
  p.x = adjust_lon(p.x + this.long0);
  return p;
};

exports.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var D2R = 0.01745329251994329577;
var tmerc = __webpack_require__(78);
exports.dependsOn = 'tmerc';
exports.init = function() {
  if (!this.zone) {
    return;
  }
  this.lat0 = 0;
  this.long0 = ((6 * Math.abs(this.zone)) - 183) * D2R;
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;

  tmerc.init.apply(this);
  this.forward = tmerc.forward;
  this.inverse = tmerc.inverse;
};
exports.names = ["Universal Transverse Mercator System", "utm"];


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(3);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var asinz = __webpack_require__(18);
/* Initialize the Van Der Grinten projection
  ----------------------------------------*/
exports.init = function() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
};

exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    }
    else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);

  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  //con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  }
  else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
};

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/
exports.inverse = function(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = ((3 * d) / a1) / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    }
    else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  }
  else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];

/***/ }),
/* 318 */
/***/ (function(module, exports) {

module.exports = {"_from":"proj4@2.3.15","_id":"proj4@2.3.15","_inBundle":false,"_integrity":"sha1-WtBui8owvg/6OJpJ5FZfUfBtCJ4=","_location":"/proj4","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"proj4@2.3.15","name":"proj4","escapedName":"proj4","rawSpec":"2.3.15","saveSpec":null,"fetchSpec":"2.3.15"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/proj4/-/proj4-2.3.15.tgz","_shasum":"5ad06e8bca30be0ffa389a49e4565f51f06d089e","_spec":"proj4@2.3.15","_where":"E:\\codes\\iClient9","author":"","bugs":{"url":"https://github.com/proj4js/proj4js/issues"},"bundleDependencies":false,"contributors":[{"name":"Mike Adair","email":"madair@dmsolutions.ca"},{"name":"Richard Greenwood","email":"rich@greenwoodmap.com"},{"name":"Calvin Metcalf","email":"calvin.metcalf@gmail.com"},{"name":"Richard Marsden","url":"http://www.winwaed.com"},{"name":"T. Mittan"},{"name":"D. Steinwand"},{"name":"S. Nelson"}],"dependencies":{"mgrs":"~0.0.2"},"deprecated":false,"description":"Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.","devDependencies":{"browserify":"~12.0.1","chai":"~1.8.1","curl":"git://github.com/cujojs/curl.git","grunt":"~0.4.2","grunt-browserify":"~4.0.1","grunt-cli":"~0.1.13","grunt-contrib-connect":"~0.6.0","grunt-contrib-jshint":"~0.8.0","grunt-contrib-uglify":"~0.11.1","grunt-mocha-phantomjs":"~0.4.0","istanbul":"~0.2.4","mocha":"~1.17.1","tin":"~0.4.0"},"directories":{"test":"test","doc":"docs"},"homepage":"https://github.com/proj4js/proj4js#readme","jam":{"main":"dist/proj4.js","include":["dist/proj4.js","README.md","AUTHORS","LICENSE.md"]},"license":"MIT","main":"lib/index.js","name":"proj4","repository":{"type":"git","url":"git://github.com/proj4js/proj4js.git"},"scripts":{"test":"./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"},"version":"2.3.15"}

/***/ }),
/* 319 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF4AAAAdCAYAAAAjHtusAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozYWZlOGIwMi01MWE3LTRiZjYtYWVkYS05MGQ2ZTQ4YjZiMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODg0NkFBQUE3RjEzMTFFNzhFRjJFQkY4RjcxQjc1NjIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODg0NkFBQTk3RjEzMTFFNzhFRjJFQkY4RjcxQjc1NjIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4MWI3NzdhNC1lZmEyLTQ1MzUtOGQzNi03MmRjNDkyODMzN2UiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpjYTYzODVjMi1jNDQ1LTExN2EtYTc0ZC1lM2I5MzJlMGE4Y2QiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5q1HM0AAAF/ElEQVR42tSabYhUVRjHZ7W01C1uaCRW4F3oi9SXCUnwQ9gsGUFvOEtQH1bLu5VS9sbYh5KicjYt29qiGQwVg2xWWKgocob91AvC+CWsoJqB3qHMSdTMpZyeU/+Df07n3pk7997Z6cBv99z7nHvOvf/z/pxJNZvNVI/jCKXmv6EquAmVkxPSlvtp2GItr0/96fFQForChJAWDiVYTkMYMu4XBFcYjLOwWS3sNwmn8NGzZ0h4Flv/zwIdchAnh/slCGmmKUNIBzYPaXOUr0vPuEjD71JAPh7l61embzinhV3V8nnCGmGT8LwlzSL8/yUh4Tfjo9T/CgnCIYNKycA2Qq21AcHU/VHE80Idoo3Qs0W6p0UtUnkZvEMDeVcCyqxEafF7hL8Qf0oYsIj+lfC9cH1CwhchWAGCtZO+AooQOkdC1Km1VtCb63StW73uFSzgKFUkNwBbmZGGmqowhvg8ZNpH9oXChcIcYRdeNomgxLkaH+S1SGubAxyIpFv+Zp+0DYjrAS00j/dem2VGEl6FJ4Qa4quEu8j2hTCJ+GJhe4JjfQMf6JCYPPbysMPxBlp0BUKOogEF9Rg9/heNvNKYfM0KsZUZaYxX4STGrzJa+zbhPeFH2DcK10KItcI+pI0rVElwXl1ULaKnIJhDw0oRQpTQc1zcbwRU8ATy4DR6yMlTzwkqMziEWHvubJ4Nk4ZtHdnqwvwY17xq3Z4FjrG+z2Kdrdf2ZSGD+xlLPh6t1R0jP9fI22ZzKI92yvQl7EbmBxI4S7Y+vIAOL87QZqsc5uNnssxZIcfYjXT9snCR7jjobidp+FkxA2v+Cq1QervMDmp4P7Xs3YZtE9kOC3P/By6JGaETl8ElwueYTNTDq4UDsKnd7YfCNbT239LF1udS72xYJt1UWxNfN4IIP4bWuTpEja01JtMFZFsm/AHbtHBlDE6yasA4moYTrUbvdBTXHqUrAH4uSadbyzF+vbBM2IsNkS3MNa5305JxqfA02T4TnkX8XOH1mPw8ruVejpxbI9hZD2Cz1U7LdrrUvjP/WfZinNZhr6V27hP+FPZh9aLvLxVO4DllX0G2OcKnlO/DCblxaz6uXBtmi+8mBaP3/SP8IuEIiTRoPPQm2TaEmEyXo0JU+F0YiPFD0hhOsiE/vqeEVwyTgF8L51OilcIZ2I4Ll5NttvAJPfukUeB2sk0ZPSbKIUUJpCII7+DasWy08uhNNazT0wGHI7mAtB7KqMKm38HhDdAUibTVKGicbB8YAqrJ9DRsp43JdB4qUof1HQrPE6XTQWu3Ce/inVzjXhXpMiTwUYugNVQ+p80jrUsV5EH0POKeuXO9QjhFq5GryNYvfEMCDhsftYVsB9ETtG0V9ZjfhCURhbcJFpfwVZ9jvhxsLHwTYtp2svlWQw3vXL8UnqHVSIG8l8ex+tHhBXgjddgqHEZ8ufAA2aaEnYgrF/KrPXrEmMUqZ9THLW06xhoBaVueQpkug+ewOUphE3Qv2Q5gGamXYa+QbVq4O+DQ5FHyZqrjxNt7UHh9uuRa0F7HjCF8o9PCTOGnscM7g2u1Hl9C9oeEnxC/1ajZg8JLiM9Hj9GHJseMShwL2DO0G5yEWn3Zh1QUods5CPkIoqlwAZxhXMsb6HrcEPBxchhdJ6wj29vCW4hfLOzo8J3rltYX50nXQAATSf/K4DEaGlTLvplsk/QCpoD60EQ7gLYZc8H9wq+I3yncEOEcNhuz6HWf3XEiwU/4Y8YEqVp2P10rt+8REvBGw026i4aDcbL9jF8r8Blmf4fCOzhViiscskygXRdehf3CO4hfigmTBXyQrl8TFtD1IzQX3CbcQrY3hPcRv4z8OmHPXwchVNln2MmE7BX6VwIFi/he6uxvb6JM3m0fdqvx/ATidxg2JeC7VDErAw5NzGfvwRJVheEIQ8Mg/pdwIM+UOmi9Q8ivCsrIy0tF+wVbEcLrd3Pb2XisEb4Tdlhsi4WP4RBbaLGrHfC3PrvMIezy9rTpGm5lz9LOMG15xvFxD/j5gjzjjDbMOzk+9zzt3v5bgAEAibzFeFHVgYkAAAAASUVORK5CYII="

/***/ }),
/* 320 */
/***/ (function(module, exports) {

module.exports = function(){try{return elasticsearch}catch(e){return {}}}();

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(111);
__webpack_require__(112);
__webpack_require__(108);
__webpack_require__(109);
__webpack_require__(110);
__webpack_require__(92);
__webpack_require__(113);
__webpack_require__(99);
__webpack_require__(114);
__webpack_require__(84);
__webpack_require__(85);
__webpack_require__(91);
__webpack_require__(106);
__webpack_require__(107);
__webpack_require__(116);
__webpack_require__(119);
__webpack_require__(121);
__webpack_require__(126);
__webpack_require__(127);
__webpack_require__(135);
__webpack_require__(136);
__webpack_require__(138);
__webpack_require__(117);
__webpack_require__(133);
__webpack_require__(131);
__webpack_require__(134);
__webpack_require__(144);
__webpack_require__(83);
__webpack_require__(115);
__webpack_require__(118);
__webpack_require__(88);
__webpack_require__(123);
__webpack_require__(124);
__webpack_require__(125);
__webpack_require__(122);
__webpack_require__(139);
__webpack_require__(120);
__webpack_require__(87);
__webpack_require__(128);
__webpack_require__(130);
__webpack_require__(129);
__webpack_require__(137);
__webpack_require__(82);
__webpack_require__(145);
__webpack_require__(90);
__webpack_require__(86);
__webpack_require__(89);
__webpack_require__(95);
__webpack_require__(100);
__webpack_require__(101);
__webpack_require__(102);
__webpack_require__(103);
__webpack_require__(104);
__webpack_require__(105);
__webpack_require__(142);
__webpack_require__(143);
__webpack_require__(93);
__webpack_require__(94);
__webpack_require__(96);
__webpack_require__(97);
__webpack_require__(98);
__webpack_require__(132);
__webpack_require__(140);
__webpack_require__(141);
__webpack_require__(147);
__webpack_require__(150);
__webpack_require__(149);
__webpack_require__(148);
module.exports = __webpack_require__(146);


/***/ })
/******/ ]);